use std::cmp::Ordering;
use std::fmt;
use std::fmt::{Display, Write};

use itertools::Itertools;
use rinja::Template;
use rustc_abi::VariantIdx;
use rustc_data_structures::captures::Captures;
use rustc_data_structures::fx::{FxHashMap, FxIndexSet};
use rustc_hir as hir;
use rustc_hir::def::CtorKind;
use rustc_hir::def_id::DefId;
use rustc_index::IndexVec;
use rustc_middle::ty::{self, TyCtxt};
use rustc_span::hygiene::MacroKind;
use rustc_span::symbol::{Symbol, kw, sym};
use tracing::{debug, info};

use super::type_layout::document_type_layout;
use super::{
    AssocItemLink, AssocItemRender, Context, ImplRenderingParameters, RenderMode,
    collect_paths_for_type, document, ensure_trailing_slash, get_filtered_impls_for_reference,
    item_ty_to_section, notable_traits_button, notable_traits_json, render_all_impls,
    render_assoc_item, render_assoc_items, render_attributes_in_code, render_attributes_in_pre,
    render_impl, render_rightside, render_stability_since_raw,
    render_stability_since_raw_with_extra, write_section_heading,
};
use crate::clean;
use crate::config::ModuleSorting;
use crate::formats::Impl;
use crate::formats::item_type::ItemType;
use crate::html::escape::{Escape, EscapeBodyTextWithWbr};
use crate::html::format::{
    Ending, PrintWithSpace, join_with_double_colon, print_abi_with_space,
    print_constness_with_space, print_where_clause, visibility_print_with_space,
};
use crate::html::markdown::{HeadingOffset, MarkdownSummaryLine};
use crate::html::render::{document_full, document_item_info};
use crate::html::url_parts_builder::UrlPartsBuilder;
use crate::joined::Joined as _;

/// Generates a Rinja template struct for rendering items with common methods.
///
/// Usage:
/// ```ignore (illustrative)
/// item_template!(
///     #[template(path = "<template.html>", /* additional values */)]
///     /* additional meta items */
///     struct MyItem<'a, 'cx> {
///         cx: RefCell<&'a mut Context<'cx>>,
///         it: &'a clean::Item,
///         /* additional fields */
///     },
///     methods = [ /* method names (comma separated; refer to macro definition of `item_template_methods!()`) */ ]
/// )
/// ```
///
/// NOTE: ensure that the generic lifetimes (`'a`, `'cx`) and
/// required fields (`cx`, `it`) are identical (in terms of order and definition).
macro_rules! item_template {
    (
        $(#[$meta:meta])*
        struct $name:ident<'a, 'cx> {
            cx: &'a Context<'cx>,
            it: &'a clean::Item,
            $($field_name:ident: $field_ty:ty),*,
        },
        methods = [$($methods:tt),* $(,)?]
    ) => {
        #[derive(Template)]
        $(#[$meta])*
        struct $name<'a, 'cx> {
            cx: &'a Context<'cx>,
            it: &'a clean::Item,
            $($field_name: $field_ty),*
        }

        impl<'a, 'cx: 'a> ItemTemplate<'a, 'cx> for $name<'a, 'cx> {
            fn item_and_cx(&self) -> (&'a clean::Item, &'a Context<'cx>) {
                (&self.it, &self.cx)
            }
        }

        impl<'a, 'cx: 'a> $name<'a, 'cx> {
            item_template_methods!($($methods)*);
        }
    };
}

/// Implement common methods for item template structs generated by `item_template!()`.
///
/// NOTE: this macro is intended to be used only by `item_template!()`.
macro_rules! item_template_methods {
    () => {};
    (document $($rest:tt)*) => {
        fn document<'b>(&'b self) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {
            fmt::from_fn(move |f| {
                let (item, cx) = self.item_and_cx();
                let v = document(cx, item, None, HeadingOffset::H2);
                write!(f, "{v}")
            })
        }
        item_template_methods!($($rest)*);
    };
    (document_type_layout $($rest:tt)*) => {
        fn document_type_layout<'b>(&'b self) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {
            fmt::from_fn(move |f| {
                let (item, cx) = self.item_and_cx();
                let def_id = item.item_id.expect_def_id();
                let v = document_type_layout(cx, def_id);
                write!(f, "{v}")
            })
        }
        item_template_methods!($($rest)*);
    };
    (render_attributes_in_pre $($rest:tt)*) => {
        fn render_attributes_in_pre<'b>(&'b self) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {
            fmt::from_fn(move |f| {
                let (item, cx) = self.item_and_cx();
                let v = render_attributes_in_pre(item, "", cx);
                write!(f, "{v}")
            })
        }
        item_template_methods!($($rest)*);
    };
    (render_assoc_items $($rest:tt)*) => {
        fn render_assoc_items<'b>(&'b self) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {
            fmt::from_fn(move |f| {
                let (item, cx) = self.item_and_cx();
                let def_id = item.item_id.expect_def_id();
                let v = render_assoc_items(cx, item, def_id, AssocItemRender::All);
                write!(f, "{v}")
            })
        }
        item_template_methods!($($rest)*);
    };
    ($method:ident $($rest:tt)*) => {
        compile_error!(concat!("unknown method: ", stringify!($method)));
    };
    ($token:tt $($rest:tt)*) => {
        compile_error!(concat!("unexpected token: ", stringify!($token)));
    };
}

const ITEM_TABLE_OPEN: &str = "<dl class=\"item-table\">";
const REEXPORTS_TABLE_OPEN: &str = "<dl class=\"item-table reexports\">";
const ITEM_TABLE_CLOSE: &str = "</dl>";

// A component in a `use` path, like `string` in std::string::ToString
struct PathComponent {
    path: String,
    name: Symbol,
}

#[derive(Template)]
#[template(path = "print_item.html")]
struct ItemVars<'a> {
    typ: &'a str,
    name: &'a str,
    item_type: &'a str,
    path_components: Vec<PathComponent>,
    stability_since_raw: &'a str,
    src_href: Option<&'a str>,
}

/// Calls `print_where_clause` and returns `true` if a `where` clause was generated.
fn print_where_clause_and_check<'a, 'tcx: 'a>(
    mut w: impl Write,
    gens: &'a clean::Generics,
    cx: &'a Context<'tcx>,
) -> bool {
    write!(w, "{}", print_where_clause(gens, cx, 0, Ending::Newline)).unwrap();
    !gens.where_predicates.is_empty()
}

pub(super) fn print_item<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    item: &'a clean::Item,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    debug_assert!(!item.is_stripped());
    fmt::from_fn(|f| {
        let typ = match item.kind {
            clean::ModuleItem(_) => {
                if item.is_crate() {
                    "Crate "
                } else {
                    "Module "
                }
            }
            clean::FunctionItem(..) | clean::ForeignFunctionItem(..) => "Function ",
            clean::TraitItem(..) => "Trait ",
            clean::StructItem(..) => "Struct ",
            clean::UnionItem(..) => "Union ",
            clean::EnumItem(..) => "Enum ",
            clean::TypeAliasItem(..) => "Type Alias ",
            clean::MacroItem(..) => "Macro ",
            clean::ProcMacroItem(ref mac) => match mac.kind {
                MacroKind::Bang => "Macro ",
                MacroKind::Attr => "Attribute Macro ",
                MacroKind::Derive => "Derive Macro ",
            },
            clean::PrimitiveItem(..) => "Primitive Type ",
            clean::StaticItem(..) | clean::ForeignStaticItem(..) => "Static ",
            clean::ConstantItem(..) => "Constant ",
            clean::ForeignTypeItem => "Foreign Type ",
            clean::KeywordItem => "Keyword ",
            clean::TraitAliasItem(..) => "Trait Alias ",
            _ => {
                // We don't generate pages for any other type.
                unreachable!();
            }
        };
        let mut stability_since_raw = String::new();
        render_stability_since_raw(
            &mut stability_since_raw,
            item.stable_since(cx.tcx()),
            item.const_stability(cx.tcx()),
        );

        // Write source tag
        //
        // When this item is part of a `crate use` in a downstream crate, the
        // source link in the downstream documentation will actually come back to
        // this page, and this link will be auto-clicked. The `id` attribute is
        // used to find the link to auto-click.
        let src_href =
            if cx.info.include_sources && !item.is_primitive() { cx.src_href(item) } else { None };

        let path_components = if item.is_primitive() || item.is_keyword() {
            vec![]
        } else {
            let cur = &cx.current;
            let amt = if item.is_mod() { cur.len() - 1 } else { cur.len() };
            cur.iter()
                .enumerate()
                .take(amt)
                .map(|(i, component)| PathComponent {
                    path: "../".repeat(cur.len() - i - 1),
                    name: *component,
                })
                .collect()
        };

        let item_vars = ItemVars {
            typ,
            name: item.name.as_ref().unwrap().as_str(),
            item_type: &item.type_().to_string(),
            path_components,
            stability_since_raw: &stability_since_raw,
            src_href: src_href.as_deref(),
        };

        item_vars.render_into(f).unwrap();

        match &item.kind {
            clean::ModuleItem(ref m) => item_module(cx, item, &m.items).fmt(f),
            clean::FunctionItem(ref func) | clean::ForeignFunctionItem(ref func, _) => {
                item_function(cx, item, func).fmt(f)
            }
            clean::TraitItem(ref t) => item_trait(cx, item, t).fmt(f),
            clean::StructItem(ref s) => item_struct(cx, item, s).fmt(f),
            clean::UnionItem(ref s) => item_union(cx, item, s).fmt(f),
            clean::EnumItem(ref e) => item_enum(cx, item, e).fmt(f),
            clean::TypeAliasItem(ref t) => item_type_alias(cx, item, t).fmt(f),
            clean::MacroItem(ref m) => item_macro(cx, item, m).fmt(f),
            clean::ProcMacroItem(ref m) => item_proc_macro(cx, item, m).fmt(f),
            clean::PrimitiveItem(_) => item_primitive(cx, item).fmt(f),
            clean::StaticItem(ref i) => item_static(cx, item, i, None).fmt(f),
            clean::ForeignStaticItem(ref i, safety) => {
                item_static(cx, item, i, Some(*safety)).fmt(f)
            }
            clean::ConstantItem(ci) => {
                item_constant(cx, item, &ci.generics, &ci.type_, &ci.kind).fmt(f)
            }
            clean::ForeignTypeItem => item_foreign_type(cx, item).fmt(f),
            clean::KeywordItem => item_keyword(cx, item).fmt(f),
            clean::TraitAliasItem(ref ta) => item_trait_alias(cx, item, ta).fmt(f),
            _ => {
                // We don't generate pages for any other type.
                unreachable!();
            }
        }?;

        // Render notable-traits.js used for all methods in this module.
        let mut types_with_notable_traits = cx.types_with_notable_traits.borrow_mut();
        if !types_with_notable_traits.is_empty() {
            write!(
                f,
                r#"<script type="text/json" id="notable-traits-data">{}</script>"#,
                notable_traits_json(types_with_notable_traits.iter(), cx)
            )?;
            types_with_notable_traits.clear();
        }
        Ok(())
    })
}

/// For large structs, enums, unions, etc, determine whether to hide their fields
fn should_hide_fields(n_fields: usize) -> bool {
    n_fields > 12
}

fn toggle_open<'a>(text: impl Display + 'a) -> impl Display + 'a {
    fmt::from_fn(move |w| {
        write!(
            w,
            "<details class=\"toggle type-contents-toggle\">\
                <summary class=\"hideme\">\
                <span>Show {text}</span>\
                </summary>",
        )
    })
}

fn toggle_close() -> impl fmt::Display {
    "</details>"
}

trait ItemTemplate<'a, 'cx: 'a>: rinja::Template + Display {
    fn item_and_cx(&self) -> (&'a clean::Item, &'a Context<'cx>);
}

fn item_module<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    item: &'a clean::Item,
    items: &'a [clean::Item],
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(|f| {
        write!(f, "{}", document(cx, item, None, HeadingOffset::H2))?;

        let mut not_stripped_items =
            items.iter().filter(|i| !i.is_stripped()).enumerate().collect::<Vec<_>>();

        // the order of item types in the listing
        fn reorder(ty: ItemType) -> u8 {
            match ty {
                ItemType::ExternCrate => 0,
                ItemType::Import => 1,
                ItemType::Primitive => 2,
                ItemType::Module => 3,
                ItemType::Macro => 4,
                ItemType::Struct => 5,
                ItemType::Enum => 6,
                ItemType::Constant => 7,
                ItemType::Static => 8,
                ItemType::Trait => 9,
                ItemType::Function => 10,
                ItemType::TypeAlias => 12,
                ItemType::Union => 13,
                _ => 14 + ty as u8,
            }
        }

        fn cmp(i1: &clean::Item, i2: &clean::Item, tcx: TyCtxt<'_>) -> Ordering {
            let rty1 = reorder(i1.type_());
            let rty2 = reorder(i2.type_());
            if rty1 != rty2 {
                return rty1.cmp(&rty2);
            }
            let is_stable1 =
                i1.stability(tcx).as_ref().map(|s| s.level.is_stable()).unwrap_or(true);
            let is_stable2 =
                i2.stability(tcx).as_ref().map(|s| s.level.is_stable()).unwrap_or(true);
            if is_stable1 != is_stable2 {
                // true is bigger than false in the standard bool ordering,
                // but we actually want stable items to come first
                return is_stable2.cmp(&is_stable1);
            }
            let lhs = i1.name.unwrap_or(kw::Empty);
            let rhs = i2.name.unwrap_or(kw::Empty);
            compare_names(lhs.as_str(), rhs.as_str())
        }

        let tcx = cx.tcx();

        match cx.shared.module_sorting {
            ModuleSorting::Alphabetical => {
                not_stripped_items.sort_by(|(_, i1), (_, i2)| cmp(i1, i2, tcx));
            }
            ModuleSorting::DeclarationOrder => {}
        }
        // This call is to remove re-export duplicates in cases such as:
        //
        // ```
        // pub(crate) mod foo {
        //     pub(crate) mod bar {
        //         pub(crate) trait Double { fn foo(); }
        //     }
        // }
        //
        // pub(crate) use foo::bar::*;
        // pub(crate) use foo::*;
        // ```
        //
        // `Double` will appear twice in the generated docs.
        //
        // FIXME: This code is quite ugly and could be improved. Small issue: DefId
        // can be identical even if the elements are different (mostly in imports).
        // So in case this is an import, we keep everything by adding a "unique id"
        // (which is the position in the vector).
        not_stripped_items.dedup_by_key(|(idx, i)| {
            (
                i.item_id,
                if i.name.is_some() { Some(full_path(cx, i)) } else { None },
                i.type_(),
                if i.is_import() { *idx } else { 0 },
            )
        });

        debug!("{not_stripped_items:?}");
        let mut last_section = None;

        for (_, myitem) in &not_stripped_items {
            let my_section = item_ty_to_section(myitem.type_());
            if Some(my_section) != last_section {
                if last_section.is_some() {
                    f.write_str(ITEM_TABLE_CLOSE)?;
                }
                last_section = Some(my_section);
                let section_id = my_section.id();
                let tag =
                    if section_id == "reexports" { REEXPORTS_TABLE_OPEN } else { ITEM_TABLE_OPEN };

                write_section_heading(my_section.name(), &cx.derive_id(section_id), None, tag)
                    .fmt(f)?;
            }

            match myitem.kind {
                clean::ExternCrateItem { ref src } => {
                    use crate::html::format::anchor;

                    match *src {
                        Some(src) => {
                            write!(
                                f,
                                "<dt><code>{}extern crate {} as {};",
                                visibility_print_with_space(myitem, cx),
                                anchor(myitem.item_id.expect_def_id(), src, cx),
                                EscapeBodyTextWithWbr(myitem.name.unwrap().as_str()),
                            )?;
                        }
                        None => {
                            write!(
                                f,
                                "<dt><code>{}extern crate {};",
                                visibility_print_with_space(myitem, cx),
                                anchor(myitem.item_id.expect_def_id(), myitem.name.unwrap(), cx),
                            )?;
                        }
                    }
                    f.write_str("</code></dt>")?;
                }

                clean::ImportItem(ref import) => {
                    let stab_tags = import.source.did.map_or_else(String::new, |import_def_id| {
                        extra_info_tags(tcx, myitem, item, Some(import_def_id)).to_string()
                    });

                    let id = fmt::from_fn(|f| match import.kind {
                        clean::ImportKind::Simple(s) => {
                            write!(f, " id=\"{}\"", cx.derive_id(format!("reexport.{s}")))
                        }
                        clean::ImportKind::Glob => Ok(()),
                    });
                    write!(
                        f,
                        "<dt{id}>\
                            <code>{vis}{imp}</code>{stab_tags}\
                        </dt>",
                        vis = visibility_print_with_space(myitem, cx),
                        imp = import.print(cx),
                    )?;
                }

                _ => {
                    if myitem.name.is_none() {
                        continue;
                    }

                    let unsafety_flag = match myitem.kind {
                        clean::FunctionItem(_) | clean::ForeignFunctionItem(..)
                            if myitem.fn_header(tcx).unwrap().is_unsafe() =>
                        {
                            "<sup title=\"unsafe function\">⚠</sup>"
                        }
                        clean::ForeignStaticItem(_, hir::Safety::Unsafe) => {
                            "<sup title=\"unsafe static\">⚠</sup>"
                        }
                        _ => "",
                    };

                    let visibility_and_hidden = match myitem.visibility(tcx) {
                        Some(ty::Visibility::Restricted(_)) => {
                            if myitem.is_doc_hidden() {
                                // Don't separate with a space when there are two of them
                                "<span title=\"Restricted Visibility\">&nbsp;🔒</span><span title=\"Hidden item\">👻</span> "
                            } else {
                                "<span title=\"Restricted Visibility\">&nbsp;🔒</span> "
                            }
                        }
                        _ if myitem.is_doc_hidden() => {
                            "<span title=\"Hidden item\">&nbsp;👻</span> "
                        }
                        _ => "",
                    };

                    let docs =
                        MarkdownSummaryLine(&myitem.doc_value(), &myitem.links(cx)).into_string();
                    let (docs_before, docs_after) =
                        if docs.is_empty() { ("", "") } else { ("<dd>", "</dd>") };
                    write!(
                        f,
                        "<dt>\
                            <a class=\"{class}\" href=\"{href}\" title=\"{title}\">{name}</a>\
                            {visibility_and_hidden}\
                            {unsafety_flag}\
                            {stab_tags}\
                        </dt>\
                        {docs_before}{docs}{docs_after}",
                        name = EscapeBodyTextWithWbr(myitem.name.unwrap().as_str()),
                        visibility_and_hidden = visibility_and_hidden,
                        stab_tags = extra_info_tags(tcx, myitem, item, None),
                        class = myitem.type_(),
                        unsafety_flag = unsafety_flag,
                        href = item_path(myitem.type_(), myitem.name.unwrap().as_str()),
                        title = [myitem.type_().to_string(), full_path(cx, myitem)]
                            .iter()
                            .filter_map(|s| if !s.is_empty() { Some(s.as_str()) } else { None })
                            .collect::<Vec<_>>()
                            .join(" "),
                    )?;
                }
            }
        }

        if last_section.is_some() {
            f.write_str(ITEM_TABLE_CLOSE)?;
        }

        Ok(())
    })
}

/// Render the stability, deprecation and portability tags that are displayed in the item's summary
/// at the module level.
fn extra_info_tags<'a, 'tcx: 'a>(
    tcx: TyCtxt<'tcx>,
    item: &'a clean::Item,
    parent: &'a clean::Item,
    import_def_id: Option<DefId>,
) -> impl Display + 'a + Captures<'tcx> {
    fmt::from_fn(move |f| {
        fn tag_html<'a>(class: &'a str, title: &'a str, contents: &'a str) -> impl Display + 'a {
            fmt::from_fn(move |f| {
                write!(
                    f,
                    r#"<wbr><span class="stab {class}" title="{title}">{contents}</span>"#,
                    title = Escape(title),
                )
            })
        }

        // The trailing space after each tag is to space it properly against the rest of the docs.
        let deprecation = import_def_id
            .map_or_else(|| item.deprecation(tcx), |import_did| tcx.lookup_deprecation(import_did));
        if let Some(depr) = deprecation {
            let message = if depr.is_in_effect() { "Deprecated" } else { "Deprecation planned" };
            write!(f, "{}", tag_html("deprecated", "", message))?;
        }

        // The "rustc_private" crates are permanently unstable so it makes no sense
        // to render "unstable" everywhere.
        let stability = import_def_id
            .map_or_else(|| item.stability(tcx), |import_did| tcx.lookup_stability(import_did));
        if stability.is_some_and(|s| s.is_unstable() && s.feature != sym::rustc_private) {
            write!(f, "{}", tag_html("unstable", "", "Experimental"))?;
        }

        let cfg = match (&item.cfg, parent.cfg.as_ref()) {
            (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),
            (cfg, _) => cfg.as_deref().cloned(),
        };

        debug!(
            "Portability name={name:?} {cfg:?} - {parent_cfg:?} = {cfg:?}",
            name = item.name,
            cfg = item.cfg,
            parent_cfg = parent.cfg
        );
        if let Some(ref cfg) = cfg {
            tag_html("portability", &cfg.render_long_plain(), &cfg.render_short_html()).fmt(f)
        } else {
            Ok(())
        }
    })
}

fn item_function<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
    func: &'a clean::Function,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(|f| {
        let tcx = cx.tcx();
        let header = it.fn_header(tcx).expect("printing a function which isn't a function");
        debug!(
            "item_function/const: {:?} {:?} {:?} {:?}",
            it.name,
            &header.constness,
            it.stable_since(tcx),
            it.const_stability(tcx),
        );
        let constness = print_constness_with_space(
            &header.constness,
            it.stable_since(tcx),
            it.const_stability(tcx),
        );
        let safety = header.safety.print_with_space();
        let abi = print_abi_with_space(header.abi).to_string();
        let asyncness = header.asyncness.print_with_space();
        let visibility = visibility_print_with_space(it, cx).to_string();
        let name = it.name.unwrap();

        let generics_len = format!("{:#}", func.generics.print(cx)).len();
        let header_len = "fn ".len()
            + visibility.len()
            + constness.len()
            + asyncness.len()
            + safety.len()
            + abi.len()
            + name.as_str().len()
            + generics_len;

        let notable_traits = notable_traits_button(&func.decl.output, cx);

        wrap_item(format_args!(
            "{attrs}{visibility}{constness}{asyncness}{safety}{abi}fn \
                {name}{generics}{decl}{notable_traits}{where_clause}",
            attrs = render_attributes_in_pre(it, "", cx),
            generics = func.generics.print(cx),
            where_clause = print_where_clause(&func.generics, cx, 0, Ending::Newline),
            decl = func.decl.full_print(header_len, 0, cx),
            notable_traits = notable_traits.unwrap_or_default(),
        ))
        .fmt(f)?;
        document(cx, it, None, HeadingOffset::H2).fmt(f)
    })
}

fn item_trait<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
    t: &'a clean::Trait,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(|f| {
        let tcx = cx.tcx();
        let bounds = bounds(&t.bounds, false, cx);
        let required_types =
            t.items.iter().filter(|m| m.is_required_associated_type()).collect::<Vec<_>>();
        let provided_types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();
        let required_consts =
            t.items.iter().filter(|m| m.is_required_associated_const()).collect::<Vec<_>>();
        let provided_consts =
            t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();
        let required_methods = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();
        let provided_methods = t.items.iter().filter(|m| m.is_method()).collect::<Vec<_>>();
        let count_types = required_types.len() + provided_types.len();
        let count_consts = required_consts.len() + provided_consts.len();
        let count_methods = required_methods.len() + provided_methods.len();
        let must_implement_one_of_functions = tcx.trait_def(t.def_id).must_implement_one_of.clone();

        // Output the trait definition
        wrap_item(fmt::from_fn(|f| {
            write!(
                f,
                "{attrs}{vis}{safety}{is_auto}trait {name}{generics}{bounds}",
                attrs = render_attributes_in_pre(it, "", cx),
                vis = visibility_print_with_space(it, cx),
                safety = t.safety(tcx).print_with_space(),
                is_auto = if t.is_auto(tcx) { "auto " } else { "" },
                name = it.name.unwrap(),
                generics = t.generics.print(cx),
            )?;

            if !t.generics.where_predicates.is_empty() {
                write!(f, "{}", print_where_clause(&t.generics, cx, 0, Ending::Newline))?;
            } else {
                f.write_str(" ")?;
            }

            if t.items.is_empty() {
                f.write_str("{ }")
            } else {
                // FIXME: we should be using a derived_id for the Anchors here
                f.write_str("{\n").unwrap();
                let mut toggle = false;

                // If there are too many associated types, hide _everything_
                if should_hide_fields(count_types) {
                    toggle = true;
                    toggle_open(format_args!(
                        "{} associated items",
                        count_types + count_consts + count_methods
                    ))
                    .fmt(f)?;
                }
                for types in [&required_types, &provided_types] {
                    for t in types {
                        write!(
                            f,
                            "{};\n",
                            render_assoc_item(
                                t,
                                AssocItemLink::Anchor(None),
                                ItemType::Trait,
                                cx,
                                RenderMode::Normal,
                            )
                        )?;
                    }
                }
                // If there are too many associated constants, hide everything after them
                // We also do this if the types + consts is large because otherwise we could
                // render a bunch of types and _then_ a bunch of consts just because both were
                // _just_ under the limit
                if !toggle && should_hide_fields(count_types + count_consts) {
                    toggle = true;
                    toggle_open(format_args!(
                        "{count_consts} associated constant{plural_const} and \
                            {count_methods} method{plural_method}",
                        plural_const = pluralize(count_consts),
                        plural_method = pluralize(count_methods),
                    ))
                    .fmt(f)?;
                }
                if count_types != 0 && (count_consts != 0 || count_methods != 0) {
                    f.write_str("\n")?;
                }
                for consts in [&required_consts, &provided_consts] {
                    for c in consts {
                        writeln!(
                            f,
                            "{};",
                            render_assoc_item(
                                c,
                                AssocItemLink::Anchor(None),
                                ItemType::Trait,
                                cx,
                                RenderMode::Normal,
                            )
                        )?;
                    }
                }
                if !toggle && should_hide_fields(count_methods) {
                    toggle = true;
                    write!(f, "{}", toggle_open(format_args!("{count_methods} methods")))?;
                }
                if count_consts != 0 && count_methods != 0 {
                    f.write_str("\n")?;
                }

                if !required_methods.is_empty() {
                    writeln!(f, "    // Required method{}", pluralize(required_methods.len()))?;
                }
                for (pos, m) in required_methods.iter().enumerate() {
                    writeln!(
                        f,
                        "{};",
                        render_assoc_item(
                            m,
                            AssocItemLink::Anchor(None),
                            ItemType::Trait,
                            cx,
                            RenderMode::Normal,
                        )
                    )?;

                    if pos < required_methods.len() - 1 {
                        f.write_str("<span class=\"item-spacer\"></span>")?;
                    }
                }
                if !required_methods.is_empty() && !provided_methods.is_empty() {
                    f.write_str("\n")?;
                }

                if !provided_methods.is_empty() {
                    writeln!(f, "    // Provided method{}", pluralize(provided_methods.len()))?;
                }
                for (pos, m) in provided_methods.iter().enumerate() {
                    write!(
                        f,
                        "{} {{ ... }}\n",
                        render_assoc_item(
                            m,
                            AssocItemLink::Anchor(None),
                            ItemType::Trait,
                            cx,
                            RenderMode::Normal,
                        )
                    )?;

                    if pos < provided_methods.len() - 1 {
                        f.write_str("<span class=\"item-spacer\"></span>")?;
                    }
                }
                if toggle {
                    write!(f, "{}", toggle_close())?;
                }
                f.write_str("}")
            }
        }))
        .fmt(f)?;

        // Trait documentation
        write!(f, "{}", document(cx, it, None, HeadingOffset::H2))?;

        fn trait_item<'a, 'cx: 'a, 'tcx: 'cx, 'm: 'a, 't: 'a>(
            cx: &'cx Context<'tcx>,
            m: &'m clean::Item,
            t: &'t clean::Item,
        ) -> impl Display + use<'a, 'tcx> {
            fmt::from_fn(|w| {
                let name = m.name.unwrap();
                info!("Documenting {name} on {ty_name:?}", ty_name = t.name);
                let item_type = m.type_();
                let id = cx.derive_id(format!("{item_type}.{name}"));

                let content = document_full(m, cx, HeadingOffset::H5).to_string();

                let toggled = !content.is_empty();
                if toggled {
                    let method_toggle_class =
                        if item_type.is_method() { " method-toggle" } else { "" };
                    write!(w, "<details class=\"toggle{method_toggle_class}\" open><summary>")?;
                }
                write!(
                    w,
                    "<section id=\"{id}\" class=\"method\">\
                        {rightside}
                        <h4 class=\"code-header\">{item}</h4></section>",
                    rightside = render_rightside(cx, m, RenderMode::Normal),
                    item = render_assoc_item(
                        m,
                        AssocItemLink::Anchor(Some(&id)),
                        ItemType::Impl,
                        cx,
                        RenderMode::Normal,
                    )
                )?;
                document_item_info(cx, m, Some(t)).render_into(&mut *w).unwrap();
                if toggled {
                    write!(w, "</summary>{content}</details>")?;
                }
                Ok(())
            })
        }

        if !required_consts.is_empty() {
            write_section_heading(
                "Required Associated Constants",
                "required-associated-consts",
                None,
                "<div class=\"methods\">",
            )
            .fmt(f)?;
            for t in required_consts {
                write!(f, "{}", trait_item(cx, t, it))?;
            }
            f.write_str("</div>")?;
        }
        if !provided_consts.is_empty() {
            write_section_heading(
                "Provided Associated Constants",
                "provided-associated-consts",
                None,
                "<div class=\"methods\">",
            )
            .fmt(f)?;
            for t in provided_consts {
                write!(f, "{}", trait_item(cx, t, it))?;
            }
            f.write_str("</div>")?;
        }

        if !required_types.is_empty() {
            write_section_heading(
                "Required Associated Types",
                "required-associated-types",
                None,
                "<div class=\"methods\">",
            )
            .fmt(f)?;
            for t in required_types {
                write!(f, "{}", trait_item(cx, t, it))?;
            }
            f.write_str("</div>")?;
        }
        if !provided_types.is_empty() {
            write_section_heading(
                "Provided Associated Types",
                "provided-associated-types",
                None,
                "<div class=\"methods\">",
            )
            .fmt(f)?;
            for t in provided_types {
                write!(f, "{}", trait_item(cx, t, it))?;
            }
            f.write_str("</div>")?;
        }

        // Output the documentation for each function individually
        if !required_methods.is_empty() || must_implement_one_of_functions.is_some() {
            write_section_heading(
                "Required Methods",
                "required-methods",
                None,
                "<div class=\"methods\">",
            )
            .fmt(f)?;

            if let Some(list) = must_implement_one_of_functions.as_deref() {
                write!(
                    f,
                    "<div class=\"stab must_implement\">At least one of the `{}` methods is required.</div>",
                    list.iter().join("`, `")
                )?;
            }

            for m in required_methods {
                write!(f, "{}", trait_item(cx, m, it))?;
            }
            f.write_str("</div>")?;
        }
        if !provided_methods.is_empty() {
            write_section_heading(
                "Provided Methods",
                "provided-methods",
                None,
                "<div class=\"methods\">",
            )
            .fmt(f)?;
            for m in provided_methods {
                write!(f, "{}", trait_item(cx, m, it))?;
            }
            f.write_str("</div>")?;
        }

        // If there are methods directly on this trait object, render them here.
        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All).fmt(f)?;

        let mut extern_crates = FxIndexSet::default();

        if !t.is_dyn_compatible(cx.tcx()) {
            write_section_heading(
                "Dyn Compatibility",
                "dyn-compatibility",
                None,
                format_args!(
                    "<div class=\"dyn-compatibility-info\"><p>This trait is <b>not</b> \
                    <a href=\"{base}/reference/items/traits.html#dyn-compatibility\">dyn compatible</a>.</p>\
                    <p><i>In older versions of Rust, dyn compatibility was called \"object safety\", \
                    so this trait is not object safe.</i></p></div>",
                    base = crate::clean::utils::DOC_RUST_LANG_ORG_VERSION
                ),
            )
            .fmt(f)?;
        }

        if let Some(implementors) = cx.shared.cache.implementors.get(&it.item_id.expect_def_id()) {
            // The DefId is for the first Type found with that name. The bool is
            // if any Types with the same name but different DefId have been found.
            let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();
            for implementor in implementors {
                if let Some(did) =
                    implementor.inner_impl().for_.without_borrowed_ref().def_id(&cx.shared.cache)
                    && !did.is_local()
                {
                    extern_crates.insert(did.krate);
                }
                match implementor.inner_impl().for_.without_borrowed_ref() {
                    clean::Type::Path { ref path } if !path.is_assoc_ty() => {
                        let did = path.def_id();
                        let &mut (prev_did, ref mut has_duplicates) =
                            implementor_dups.entry(path.last()).or_insert((did, false));
                        if prev_did != did {
                            *has_duplicates = true;
                        }
                    }
                    _ => {}
                }
            }

            let (local, mut foreign) =
                implementors.iter().partition::<Vec<_>, _>(|i| i.is_on_local_type(cx));

            let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =
                local.iter().partition(|i| i.inner_impl().kind.is_auto());

            synthetic.sort_by_cached_key(|i| ImplString::new(i, cx));
            concrete.sort_by_cached_key(|i| ImplString::new(i, cx));
            foreign.sort_by_cached_key(|i| ImplString::new(i, cx));

            if !foreign.is_empty() {
                write_section_heading(
                    "Implementations on Foreign Types",
                    "foreign-impls",
                    None,
                    "",
                )
                .fmt(f)?;

                for implementor in foreign {
                    let provided_methods = implementor.inner_impl().provided_trait_methods(tcx);
                    let assoc_link =
                        AssocItemLink::GotoSource(implementor.impl_item.item_id, &provided_methods);
                    render_impl(
                        cx,
                        implementor,
                        it,
                        assoc_link,
                        RenderMode::Normal,
                        None,
                        &[],
                        ImplRenderingParameters {
                            show_def_docs: false,
                            show_default_items: false,
                            show_non_assoc_items: true,
                            toggle_open_by_default: false,
                        },
                    )
                    .fmt(f)?;
                }
            }

            write_section_heading(
                "Implementors",
                "implementors",
                None,
                "<div id=\"implementors-list\">",
            )
            .fmt(f)?;
            for implementor in concrete {
                render_implementor(cx, implementor, it, &implementor_dups, &[]).fmt(f)?;
            }
            f.write_str("</div>")?;

            if t.is_auto(tcx) {
                write_section_heading(
                    "Auto implementors",
                    "synthetic-implementors",
                    None,
                    "<div id=\"synthetic-implementors-list\">",
                )
                .fmt(f)?;
                for implementor in synthetic {
                    render_implementor(
                        cx,
                        implementor,
                        it,
                        &implementor_dups,
                        &collect_paths_for_type(
                            implementor.inner_impl().for_.clone(),
                            &cx.shared.cache,
                        ),
                    )
                    .fmt(f)?;
                }
                f.write_str("</div>")?;
            }
        } else {
            // even without any implementations to write in, we still want the heading and list, so the
            // implementors javascript file pulled in below has somewhere to write the impls into
            write_section_heading(
                "Implementors",
                "implementors",
                None,
                "<div id=\"implementors-list\"></div>",
            )
            .fmt(f)?;

            if t.is_auto(tcx) {
                write_section_heading(
                    "Auto implementors",
                    "synthetic-implementors",
                    None,
                    "<div id=\"synthetic-implementors-list\"></div>",
                )
                .fmt(f)?;
            }
        }

        // [RUSTDOCIMPL] trait.impl
        //
        // Include implementors in crates that depend on the current crate.
        //
        // This is complicated by the way rustdoc is invoked, which is basically
        // the same way rustc is invoked: it gets called, one at a time, for each
        // crate. When building the rustdocs for the current crate, rustdoc can
        // see crate metadata for its dependencies, but cannot see metadata for its
        // dependents.
        //
        // To make this work, we generate a "hook" at this stage, and our
        // dependents can "plug in" to it when they build. For simplicity's sake,
        // it's [JSONP]: a JavaScript file with the data we need (and can parse),
        // surrounded by a tiny wrapper that the Rust side ignores, but allows the
        // JavaScript side to include without having to worry about Same Origin
        // Policy. The code for *that* is in `write_shared.rs`.
        //
        // This is further complicated by `#[doc(inline)]`. We want all copies
        // of an inlined trait to reference the same JS file, to address complex
        // dependency graphs like this one (lower crates depend on higher crates):
        //
        // ```text
        //  --------------------------------------------
        //  |            crate A: trait Foo            |
        //  --------------------------------------------
        //      |                               |
        //  --------------------------------    |
        //  | crate B: impl A::Foo for Bar |    |
        //  --------------------------------    |
        //      |                               |
        //  ---------------------------------------------
        //  | crate C: #[doc(inline)] use A::Foo as Baz |
        //  |          impl Baz for Quux                |
        //  ---------------------------------------------
        // ```
        //
        // Basically, we want `C::Baz` and `A::Foo` to show the same set of
        // impls, which is easier if they both treat `/trait.impl/A/trait.Foo.js`
        // as the Single Source of Truth.
        //
        // We also want the `impl Baz for Quux` to be written to
        // `trait.Foo.js`. However, when we generate plain HTML for `C::Baz`,
        // we're going to want to generate plain HTML for `impl Baz for Quux` too,
        // because that'll load faster, and it's better for SEO. And we don't want
        // the same impl to show up twice on the same page.
        //
        // To make this work, the trait.impl/A/trait.Foo.js JS file has a structure kinda
        // like this:
        //
        // ```js
        // JSONP({
        // "B": {"impl A::Foo for Bar"},
        // "C": {"impl Baz for Quux"},
        // });
        // ```
        //
        // First of all, this means we can rebuild a crate, and it'll replace its own
        // data if something changes. That is, `rustdoc` is idempotent. The other
        // advantage is that we can list the crates that get included in the HTML,
        // and ignore them when doing the JavaScript-based part of rendering.
        // So C's HTML will have something like this:
        //
        // ```html
        // <script src="/trait.impl/A/trait.Foo.js"
        //     data-ignore-extern-crates="A,B" async></script>
        // ```
        //
        // And, when the JS runs, anything in data-ignore-extern-crates is known
        // to already be in the HTML, and will be ignored.
        //
        // [JSONP]: https://en.wikipedia.org/wiki/JSONP
        let mut js_src_path: UrlPartsBuilder = std::iter::repeat("..")
            .take(cx.current.len())
            .chain(std::iter::once("trait.impl"))
            .collect();
        if let Some(did) = it.item_id.as_def_id()
            && let get_extern = { || cx.shared.cache.external_paths.get(&did).map(|s| &s.0) }
            && let Some(fqp) = cx.shared.cache.exact_paths.get(&did).or_else(get_extern)
        {
            js_src_path.extend(fqp[..fqp.len() - 1].iter().copied());
            js_src_path.push_fmt(format_args!("{}.{}.js", it.type_(), fqp.last().unwrap()));
        } else {
            js_src_path.extend(cx.current.iter().copied());
            js_src_path.push_fmt(format_args!("{}.{}.js", it.type_(), it.name.unwrap()));
        }
        let extern_crates = extern_crates
            .into_iter()
            .map(|cnum| tcx.crate_name(cnum).to_string())
            .collect::<Vec<_>>()
            .join(",");
        let (extern_before, extern_after) = if extern_crates.is_empty() {
            ("", "")
        } else {
            (" data-ignore-extern-crates=\"", "\"")
        };
        write!(
            f,
            "<script src=\"{src}\"{extern_before}{extern_crates}{extern_after} async></script>",
            src = js_src_path.finish()
        )
    })
}

fn item_trait_alias<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
    t: &'a clean::TraitAlias,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(|f| {
        wrap_item(format_args!(
            "{attrs}trait {name}{generics}{where_b} = {bounds};",
            attrs = render_attributes_in_pre(it, "", cx),
            name = it.name.unwrap(),
            generics = t.generics.print(cx),
            where_b = print_where_clause(&t.generics, cx, 0, Ending::Newline),
            bounds = bounds(&t.bounds, true, cx),
        ))
        .fmt(f)?;

        write!(f, "{}", document(cx, it, None, HeadingOffset::H2))?;
        // Render any items associated directly to this alias, as otherwise they
        // won't be visible anywhere in the docs. It would be nice to also show
        // associated items from the aliased type (see discussion in #32077), but
        // we need #14072 to make sense of the generics.
        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All).fmt(f)
    })
}

fn item_type_alias<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
    t: &'a clean::TypeAlias,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(|w| {
        wrap_item(format_args!(
            "{attrs}{vis}type {name}{generics}{where_clause} = {type_};",
            attrs = render_attributes_in_pre(it, "", cx),
            vis = visibility_print_with_space(it, cx),
            name = it.name.unwrap(),
            generics = t.generics.print(cx),
            where_clause = print_where_clause(&t.generics, cx, 0, Ending::Newline),
            type_ = t.type_.print(cx),
        ))
        .fmt(w)?;

        write!(w, "{}", document(cx, it, None, HeadingOffset::H2))?;

        if let Some(inner_type) = &t.inner_type {
            write!(w, "{}", write_section_heading("Aliased Type", "aliased-type", None, ""))?;

            match inner_type {
                clean::TypeAliasInnerType::Enum { variants, is_non_exhaustive } => {
                    let variants_iter = || variants.iter().filter(|i| !i.is_stripped());
                    let ty = cx.tcx().type_of(it.def_id().unwrap()).instantiate_identity();
                    let enum_def_id = ty.ty_adt_def().unwrap().did();

                    let variants_len = variants.len();
                    let variants_count = variants_iter().count();
                    let has_stripped_entries = variants_len != variants_count;
                    wrap_item(format_args!(
                        "enum {}{}{}",
                        it.name.unwrap(),
                        t.generics.print(cx),
                        render_enum_fields(
                            cx,
                            Some(&t.generics),
                            variants,
                            variants_count,
                            has_stripped_entries,
                            *is_non_exhaustive,
                            enum_def_id,
                        )
                    ))
                    .fmt(w)?;
                    item_variants(cx, it, variants, enum_def_id).fmt(w)?;
                }
                clean::TypeAliasInnerType::Union { fields } => {
                    let fields_count = fields.iter().filter(|i| !i.is_stripped()).count();
                    let has_stripped_fields = fields.len() != fields_count;
                    wrap_item(format_args!(
                        "union {}{}{}",
                        it.name.unwrap(),
                        t.generics.print(cx),
                        render_struct_fields(
                            Some(&t.generics),
                            None,
                            fields,
                            "",
                            true,
                            has_stripped_fields,
                            cx,
                        )
                    ))
                    .fmt(w)?;
                    item_fields(cx, it, fields, None).fmt(w)?;
                }
                clean::TypeAliasInnerType::Struct { ctor_kind, fields } => {
                    let fields_count = fields.iter().filter(|i| !i.is_stripped()).count();
                    let has_stripped_fields = fields.len() != fields_count;
                    wrap_item(format_args!(
                        "struct {}{}{}",
                        it.name.unwrap(),
                        t.generics.print(cx),
                        render_struct_fields(
                            Some(&t.generics),
                            *ctor_kind,
                            fields,
                            "",
                            true,
                            has_stripped_fields,
                            cx,
                        )
                    ))
                    .fmt(w)?;
                    item_fields(cx, it, fields, None).fmt(w)?;
                }
            }
        }

        let def_id = it.item_id.expect_def_id();
        // Render any items associated directly to this alias, as otherwise they
        // won't be visible anywhere in the docs. It would be nice to also show
        // associated items from the aliased type (see discussion in #32077), but
        // we need #14072 to make sense of the generics.
        write!(w, "{}", render_assoc_items(cx, it, def_id, AssocItemRender::All))?;
        write!(w, "{}", document_type_layout(cx, def_id))?;

        // [RUSTDOCIMPL] type.impl
        //
        // Include type definitions from the alias target type.
        //
        // Earlier versions of this code worked by having `render_assoc_items`
        // include this data directly. That generates *O*`(types*impls)` of HTML
        // text, and some real crates have a lot of types and impls.
        //
        // To create the same UX without generating half a gigabyte of HTML for a
        // crate that only contains 20 megabytes of actual documentation[^115718],
        // rustdoc stashes these type-alias-inlined docs in a [JSONP]
        // "database-lite". The file itself is generated in `write_shared.rs`,
        // and hooks into functions provided by `main.js`.
        //
        // The format of `trait.impl` and `type.impl` JS files are superficially
        // similar. Each line, except the JSONP wrapper itself, belongs to a crate,
        // and they are otherwise separate (rustdoc should be idempotent). The
        // "meat" of the file is HTML strings, so the frontend code is very simple.
        // Links are relative to the doc root, though, so the frontend needs to fix
        // that up, and inlined docs can reuse these files.
        //
        // However, there are a few differences, caused by the sophisticated
        // features that type aliases have. Consider this crate graph:
        //
        // ```text
        //  ---------------------------------
        //  | crate A: struct Foo<T>        |
        //  |          type Bar = Foo<i32>  |
        //  |          impl X for Foo<i8>   |
        //  |          impl Y for Foo<i32>  |
        //  ---------------------------------
        //      |
        //  ----------------------------------
        //  | crate B: type Baz = A::Foo<i8> |
        //  |          type Xyy = A::Foo<i8> |
        //  |          impl Z for Xyy        |
        //  ----------------------------------
        // ```
        //
        // The type.impl/A/struct.Foo.js JS file has a structure kinda like this:
        //
        // ```js
        // JSONP({
        // "A": [["impl Y for Foo<i32>", "Y", "A::Bar"]],
        // "B": [["impl X for Foo<i8>", "X", "B::Baz", "B::Xyy"], ["impl Z for Xyy", "Z", "B::Baz"]],
        // });
        // ```
        //
        // When the type.impl file is loaded, only the current crate's docs are
        // actually used. The main reason to bundle them together is that there's
        // enough duplication in them for DEFLATE to remove the redundancy.
        //
        // The contents of a crate are a list of impl blocks, themselves
        // represented as lists. The first item in the sublist is the HTML block,
        // the second item is the name of the trait (which goes in the sidebar),
        // and all others are the names of type aliases that successfully match.
        //
        // This way:
        //
        // - There's no need to generate these files for types that have no aliases
        //   in the current crate. If a dependent crate makes a type alias, it'll
        //   take care of generating its own docs.
        // - There's no need to reimplement parts of the type checker in
        //   JavaScript. The Rust backend does the checking, and includes its
        //   results in the file.
        // - Docs defined directly on the type alias are dropped directly in the
        //   HTML by `render_assoc_items`, and are accessible without JavaScript.
        //   The JSONP file will not list impl items that are known to be part
        //   of the main HTML file already.
        //
        // [JSONP]: https://en.wikipedia.org/wiki/JSONP
        // [^115718]: https://github.com/rust-lang/rust/issues/115718
        let cache = &cx.shared.cache;
        if let Some(target_did) = t.type_.def_id(cache) &&
        let get_extern = { || cache.external_paths.get(&target_did) } &&
        let Some(&(ref target_fqp, target_type)) = cache.paths.get(&target_did).or_else(get_extern) &&
        target_type.is_adt() && // primitives cannot be inlined
        let Some(self_did) = it.item_id.as_def_id() &&
        let get_local = { || cache.paths.get(&self_did).map(|(p, _)| p) } &&
        let Some(self_fqp) = cache.exact_paths.get(&self_did).or_else(get_local)
        {
            let mut js_src_path: UrlPartsBuilder = std::iter::repeat("..")
                .take(cx.current.len())
                .chain(std::iter::once("type.impl"))
                .collect();
            js_src_path.extend(target_fqp[..target_fqp.len() - 1].iter().copied());
            js_src_path.push_fmt(format_args!("{target_type}.{}.js", target_fqp.last().unwrap()));
            let self_path = self_fqp.iter().map(Symbol::as_str).collect::<Vec<&str>>().join("::");
            write!(
                w,
                "<script src=\"{src}\" data-self-path=\"{self_path}\" async></script>",
                src = js_src_path.finish(),
            )?;
        }
        Ok(())
    })
}

fn item_union<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
    s: &'a clean::Union,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    item_template!(
        #[template(path = "item_union.html")]
        struct ItemUnion<'a, 'cx> {
            cx: &'a Context<'cx>,
            it: &'a clean::Item,
            s: &'a clean::Union,
        },
        methods = [document, document_type_layout, render_attributes_in_pre, render_assoc_items]
    );

    impl<'a, 'cx: 'a> ItemUnion<'a, 'cx> {
        fn render_union<'b>(&'b self) -> impl Display + Captures<'a> + 'b + Captures<'cx> {
            fmt::from_fn(move |f| {
                let v = render_union(self.it, Some(&self.s.generics), &self.s.fields, self.cx);
                write!(f, "{v}")
            })
        }

        fn document_field<'b>(
            &'b self,
            field: &'a clean::Item,
        ) -> impl Display + Captures<'a> + 'b + Captures<'cx> {
            fmt::from_fn(move |f| {
                let v = document(self.cx, field, Some(self.it), HeadingOffset::H3);
                write!(f, "{v}")
            })
        }

        fn stability_field(&self, field: &clean::Item) -> Option<String> {
            field.stability_class(self.cx.tcx())
        }

        fn print_ty<'b>(
            &'b self,
            ty: &'a clean::Type,
        ) -> impl Display + Captures<'a> + 'b + Captures<'cx> {
            fmt::from_fn(move |f| {
                let v = ty.print(self.cx);
                write!(f, "{v}")
            })
        }

        fn fields_iter(
            &self,
        ) -> std::iter::Peekable<impl Iterator<Item = (&'a clean::Item, &'a clean::Type)>> {
            self.s
                .fields
                .iter()
                .filter_map(|f| match f.kind {
                    clean::StructFieldItem(ref ty) => Some((f, ty)),
                    _ => None,
                })
                .peekable()
        }
    }

    fmt::from_fn(|f| {
        ItemUnion { cx, it, s }.render_into(f).unwrap();
        Ok(())
    })
}

fn print_tuple_struct_fields<'a, 'cx: 'a>(
    cx: &'a Context<'cx>,
    s: &'a [clean::Item],
) -> impl Display + 'a + Captures<'cx> {
    fmt::from_fn(|f| {
        if !s.is_empty()
            && s.iter().all(|field| {
                matches!(field.kind, clean::StrippedItem(box clean::StructFieldItem(..)))
            })
        {
            return f.write_str("<span class=\"comment\">/* private fields */</span>");
        }

        s.iter()
            .map(|ty| {
                fmt::from_fn(|f| match ty.kind {
                    clean::StrippedItem(box clean::StructFieldItem(_)) => f.write_str("_"),
                    clean::StructFieldItem(ref ty) => write!(f, "{}", ty.print(cx)),
                    _ => unreachable!(),
                })
            })
            .joined(", ", f)
    })
}

fn item_enum<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
    e: &'a clean::Enum,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(|w| {
        let count_variants = e.variants().count();
        wrap_item(format_args!(
            "{}{}enum {}{}{}",
            render_attributes_in_code(it, cx),
            visibility_print_with_space(it, cx),
            it.name.unwrap(),
            e.generics.print(cx),
            render_enum_fields(
                cx,
                Some(&e.generics),
                &e.variants,
                count_variants,
                e.has_stripped_entries(),
                it.is_non_exhaustive(),
                it.def_id().unwrap(),
            )
        ))
        .fmt(w)?;

        write!(w, "{}", document(cx, it, None, HeadingOffset::H2))?;

        if count_variants != 0 {
            item_variants(cx, it, &e.variants, it.def_id().unwrap()).fmt(w)?;
        }
        let def_id = it.item_id.expect_def_id();
        write!(w, "{}", render_assoc_items(cx, it, def_id, AssocItemRender::All))?;
        write!(w, "{}", document_type_layout(cx, def_id))?;
        Ok(())
    })
}

/// It'll return false if any variant is not a C-like variant. Otherwise it'll return true if at
/// least one of them has an explicit discriminant or if the enum has `#[repr(C)]` or an integer
/// `repr`.
fn should_show_enum_discriminant(
    cx: &Context<'_>,
    enum_def_id: DefId,
    variants: &IndexVec<VariantIdx, clean::Item>,
) -> bool {
    let mut has_variants_with_value = false;
    for variant in variants {
        if let clean::VariantItem(ref var) = variant.kind
            && matches!(var.kind, clean::VariantKind::CLike)
        {
            has_variants_with_value |= var.discriminant.is_some();
        } else {
            return false;
        }
    }
    if has_variants_with_value {
        return true;
    }
    let repr = cx.tcx().adt_def(enum_def_id).repr();
    repr.c() || repr.int.is_some()
}

fn display_c_like_variant<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    item: &'a clean::Item,
    variant: &'a clean::Variant,
    index: VariantIdx,
    should_show_enum_discriminant: bool,
    enum_def_id: DefId,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(move |f| {
        let name = item.name.unwrap();
        write!(f, "{name}")?;
        if let Some(value) = &variant.discriminant {
            write!(f, " = {}", value.value(cx.tcx(), true))?;
        } else if should_show_enum_discriminant {
            let adt_def = cx.tcx().adt_def(enum_def_id);
            let discr = adt_def.discriminant_for_variant(cx.tcx(), index);
            if discr.ty.is_signed() {
                write!(f, " = {}", discr.val as i128)?;
            } else {
                write!(f, " = {}", discr.val)?;
            }
        }
        Ok(())
    })
}

fn render_enum_fields<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    g: Option<&'a clean::Generics>,
    variants: &'a IndexVec<VariantIdx, clean::Item>,
    count_variants: usize,
    has_stripped_entries: bool,
    is_non_exhaustive: bool,
    enum_def_id: DefId,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(move |f| {
        let should_show_enum_discriminant =
            should_show_enum_discriminant(cx, enum_def_id, variants);
        if !g.is_some_and(|g| print_where_clause_and_check(&mut *f, g, cx)) {
            // If there was a `where` clause, we add a whitespace.
            f.write_str(" ")?;
        }

        let variants_stripped = has_stripped_entries;
        if count_variants == 0 && !variants_stripped {
            f.write_str("{}")?;
        } else {
            f.write_str("{\n")?;
            let toggle = should_hide_fields(count_variants);
            if toggle {
                write!(f, "{}", toggle_open(format_args!("{count_variants} variants")))?;
            }
            const TAB: &str = "    ";
            for (index, v) in variants.iter_enumerated() {
                if v.is_stripped() {
                    continue;
                }
                f.write_str(TAB).unwrap();
                match v.kind {
                    clean::VariantItem(ref var) => match var.kind {
                        clean::VariantKind::CLike => {
                            display_c_like_variant(
                                cx,
                                v,
                                var,
                                index,
                                should_show_enum_discriminant,
                                enum_def_id,
                            )
                            .fmt(f)?;
                        }
                        clean::VariantKind::Tuple(ref s) => {
                            write!(f, "{}({})", v.name.unwrap(), print_tuple_struct_fields(cx, s))?;
                        }
                        clean::VariantKind::Struct(ref s) => {
                            render_struct(v, None, None, &s.fields, TAB, false, cx).fmt(f)?;
                        }
                    },
                    _ => unreachable!(),
                }
                f.write_str(",\n")?;
            }

            if variants_stripped && !is_non_exhaustive {
                f.write_str("    <span class=\"comment\">// some variants omitted</span>\n")?;
            }
            if toggle {
                write!(f, "{}", toggle_close())?;
            }
            f.write_str("}")?;
        }
        Ok(())
    })
}

fn item_variants<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
    variants: &'a IndexVec<VariantIdx, clean::Item>,
    enum_def_id: DefId,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(move |f| {
        let tcx = cx.tcx();
        write_section_heading(
            &format!("Variants{}", document_non_exhaustive_header(it)),
            "variants",
            Some("variants"),
            format_args!("{}<div class=\"variants\">", document_non_exhaustive(it)),
        )
        .fmt(f)?;

        let should_show_enum_discriminant =
            should_show_enum_discriminant(cx, enum_def_id, variants);
        for (index, variant) in variants.iter_enumerated() {
            if variant.is_stripped() {
                continue;
            }
            let id = cx.derive_id(format!("{}.{}", ItemType::Variant, variant.name.unwrap()));
            write!(
                f,
                "<section id=\"{id}\" class=\"variant\">\
                <a href=\"#{id}\" class=\"anchor\">§</a>",
            )?;
            render_stability_since_raw_with_extra(
                &mut *f,
                variant.stable_since(tcx),
                variant.const_stability(tcx),
                " rightside",
            );
            f.write_str("<h3 class=\"code-header\">")?;
            if let clean::VariantItem(ref var) = variant.kind
                && let clean::VariantKind::CLike = var.kind
            {
                display_c_like_variant(
                    cx,
                    variant,
                    var,
                    index,
                    should_show_enum_discriminant,
                    enum_def_id,
                )
                .fmt(f)?;
            } else {
                write!(f, "{}", variant.name.unwrap())?;
            }

            let clean::VariantItem(variant_data) = &variant.kind else { unreachable!() };

            if let clean::VariantKind::Tuple(ref s) = variant_data.kind {
                write!(f, "({})", print_tuple_struct_fields(cx, s))?;
            }
            f.write_str("</h3></section>")?;

            write!(f, "{}", document(cx, variant, Some(it), HeadingOffset::H4))?;

            let heading_and_fields = match &variant_data.kind {
                clean::VariantKind::Struct(s) => {
                    // If there is no field to display, no need to add the heading.
                    if s.fields.iter().any(|f| !f.is_doc_hidden()) {
                        Some(("Fields", &s.fields))
                    } else {
                        None
                    }
                }
                clean::VariantKind::Tuple(fields) => {
                    // Documentation on tuple variant fields is rare, so to reduce noise we only emit
                    // the section if at least one field is documented.
                    if fields.iter().any(|f| !f.doc_value().is_empty()) {
                        Some(("Tuple Fields", fields))
                    } else {
                        None
                    }
                }
                clean::VariantKind::CLike => None,
            };

            if let Some((heading, fields)) = heading_and_fields {
                let variant_id =
                    cx.derive_id(format!("{}.{}.fields", ItemType::Variant, variant.name.unwrap()));
                write!(
                    f,
                    "<div class=\"sub-variant\" id=\"{variant_id}\">\
                    <h4>{heading}</h4>\
                    {}",
                    document_non_exhaustive(variant)
                )?;
                for field in fields {
                    match field.kind {
                        clean::StrippedItem(box clean::StructFieldItem(_)) => {}
                        clean::StructFieldItem(ref ty) => {
                            let id = cx.derive_id(format!(
                                "variant.{}.field.{}",
                                variant.name.unwrap(),
                                field.name.unwrap()
                            ));
                            write!(
                                f,
                                "<div class=\"sub-variant-field\">\
                                    <span id=\"{id}\" class=\"section-header\">\
                                        <a href=\"#{id}\" class=\"anchor field\">§</a>\
                                        <code>{f}: {t}</code>\
                                    </span>\
                                    {doc}\
                                </div>",
                                f = field.name.unwrap(),
                                t = ty.print(cx),
                                doc = document(cx, field, Some(variant), HeadingOffset::H5)
                            )?;
                        }
                        _ => unreachable!(),
                    }
                }
                f.write_str("</div>")?
            }
        }
        write!(f, "</div>")
    })
}

fn item_macro<'a, 'cx: 'a, 'tcx: 'cx, 'item: 'a, 'm: 'a>(
    cx: &'cx Context<'tcx>,
    it: &'item clean::Item,
    t: &'m clean::Macro,
) -> impl Display + use<'a, 'tcx> {
    fmt::from_fn(|f| {
        wrap_item(fmt::from_fn(|w| {
            // FIXME: Also print `#[doc(hidden)]` for `macro_rules!` if it `is_doc_hidden`.
            if !t.macro_rules {
                write!(w, "{}", visibility_print_with_space(it, cx))?;
            }
            write!(w, "{}", Escape(&t.source))
        }))
        .fmt(f)?;
        write!(f, "{}", document(cx, it, None, HeadingOffset::H2))
    })
}

fn item_proc_macro<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
    m: &'a clean::ProcMacro,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(|f| {
        wrap_item(fmt::from_fn(|f| {
            let name = it.name.expect("proc-macros always have names");
            match m.kind {
                MacroKind::Bang => {
                    write!(f, "{name}!() {{ <span class=\"comment\">/* proc-macro */</span> }}")?
                }
                MacroKind::Attr => write!(f, "#[{name}]")?,
                MacroKind::Derive => {
                    write!(f, "#[derive({name})]")?;
                    if !m.helpers.is_empty() {
                        f.write_str(
                            "\n{\n    \
                            <span class=\"comment\">// Attributes available to this derive:</span>\n"
                        )?;
                        for attr in &m.helpers {
                            writeln!(f, "    #[{attr}]")?;
                        }
                        f.write_str("}\n")?;
                    }
                }
            }
            Ok(())
        }))
        .fmt(f)?;
        write!(f, "{}", document(cx, it, None, HeadingOffset::H2))
    })
}

fn item_primitive<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(|f| {
        let def_id = it.item_id.expect_def_id();
        write!(f, "{}", document(cx, it, None, HeadingOffset::H2)).unwrap();
        if it.name.map(|n| n.as_str() != "reference").unwrap_or(false) {
            write!(f, "{}", render_assoc_items(cx, it, def_id, AssocItemRender::All)).unwrap();
        } else {
            // We handle the "reference" primitive type on its own because we only want to list
            // implementations on generic types.
            let (concrete, synthetic, blanket_impl) =
                get_filtered_impls_for_reference(&cx.shared, it);

            write!(f, "{}", render_all_impls(cx, it, &concrete, &synthetic, &blanket_impl))
                .unwrap();
        }
        Ok(())
    })
}

fn item_constant<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
    generics: &'a clean::Generics,
    ty: &'a clean::Type,
    c: &'a clean::ConstantKind,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(|f| {
        wrap_item(fmt::from_fn(|f| {
            let tcx = cx.tcx();
            write!(f, "{}", render_attributes_in_code(it, cx))?;

            write!(
                f,
                "{vis}const {name}{generics}: {typ}{where_clause}",
                vis = visibility_print_with_space(it, cx),
                name = it.name.unwrap(),
                generics = generics.print(cx),
                typ = ty.print(cx),
                where_clause = print_where_clause(generics, cx, 0, Ending::NoNewline),
            )?;

            // FIXME: The code below now prints
            //            ` = _; // 100i32`
            //        if the expression is
            //            `50 + 50`
            //        which looks just wrong.
            //        Should we print
            //            ` = 100i32;`
            //        instead?

            let value = c.value(tcx);
            let is_literal = c.is_literal(tcx);
            let expr = c.expr(tcx);
            if value.is_some() || is_literal {
                write!(f, " = {expr};", expr = Escape(&expr))?;
            } else {
                f.write_str(";")?;
            }

            if !is_literal && let Some(value) = &value {
                let value_lowercase = value.to_lowercase();
                let expr_lowercase = expr.to_lowercase();

                if value_lowercase != expr_lowercase
                    && value_lowercase.trim_end_matches("i32") != expr_lowercase
                {
                    write!(f, " // {value}", value = Escape(value))?;
                }
            }
            Ok(())
        }))
        .fmt(f)?;

        write!(f, "{}", document(cx, it, None, HeadingOffset::H2))
    })
}

fn item_struct<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
    s: &'a clean::Struct,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(|f| {
        wrap_item(format_args!(
            "{}{}",
            render_attributes_in_code(it, cx),
            render_struct(it, Some(&s.generics), s.ctor_kind, &s.fields, "", true, cx)
        ))
        .fmt(f)?;

        let def_id = it.item_id.expect_def_id();

        write!(
            f,
            "{}{}{}{}",
            document(cx, it, None, HeadingOffset::H2),
            item_fields(cx, it, &s.fields, s.ctor_kind),
            render_assoc_items(cx, it, def_id, AssocItemRender::All),
            document_type_layout(cx, def_id)
        )
    })
}

fn item_fields<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
    fields: &'a [clean::Item],
    ctor_kind: Option<CtorKind>,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(move |f| {
        let mut fields = fields
            .iter()
            .filter_map(|f| match f.kind {
                clean::StructFieldItem(ref ty) => Some((f, ty)),
                _ => None,
            })
            .peekable();
        if let None | Some(CtorKind::Fn) = ctor_kind {
            if fields.peek().is_some() {
                let title = format!(
                    "{}{}",
                    if ctor_kind.is_none() { "Fields" } else { "Tuple Fields" },
                    document_non_exhaustive_header(it),
                );
                write_section_heading(
                    &title,
                    "fields",
                    Some("fields"),
                    document_non_exhaustive(it),
                )
                .fmt(f)?;
                for (index, (field, ty)) in fields.enumerate() {
                    let field_name = field
                        .name
                        .map_or_else(|| index.to_string(), |sym| sym.as_str().to_string());
                    let id =
                        cx.derive_id(format!("{typ}.{field_name}", typ = ItemType::StructField));
                    write!(
                        f,
                        "<span id=\"{id}\" class=\"{item_type} section-header\">\
                            <a href=\"#{id}\" class=\"anchor field\">§</a>\
                            <code>{field_name}: {ty}</code>\
                        </span>\
                        {doc}",
                        item_type = ItemType::StructField,
                        ty = ty.print(cx),
                        doc = document(cx, field, Some(it), HeadingOffset::H3)
                    )?;
                }
            }
        }
        Ok(())
    })
}

fn item_static<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
    s: &'a clean::Static,
    safety: Option<hir::Safety>,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(move |f| {
        wrap_item(format_args!(
            "{attrs}{vis}{safe}static {mutability}{name}: {typ}",
            attrs = render_attributes_in_code(it, cx),
            vis = visibility_print_with_space(it, cx),
            safe = safety.map(|safe| safe.prefix_str()).unwrap_or(""),
            mutability = s.mutability.print_with_space(),
            name = it.name.unwrap(),
            typ = s.type_.print(cx)
        ))
        .fmt(f)?;

        write!(f, "{}", document(cx, it, None, HeadingOffset::H2))
    })
}

fn item_foreign_type<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(|f| {
        wrap_item(fmt::from_fn(|f| {
            write!(
                f,
                "extern {{\n{}    {}type {};\n}}",
                render_attributes_in_code(it, cx),
                visibility_print_with_space(it, cx),
                it.name.unwrap()
            )
        }))
        .fmt(f)?;

        write!(
            f,
            "{}{}",
            document(cx, it, None, HeadingOffset::H2),
            render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All)
        )
    })
}

fn item_keyword<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    it: &'a clean::Item,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(|f| write!(f, "{}", document(cx, it, None, HeadingOffset::H2)))
}

/// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order).
///
/// This code is copied from [`rustfmt`], and should probably be released as a crate at some point.
///
/// [`rustfmt`]:https://github.com/rust-lang/rustfmt/blob/rustfmt-2.0.0-rc.2/src/formatting/reorder.rs#L32
pub(crate) fn compare_names(left: &str, right: &str) -> Ordering {
    let mut left = left.chars().peekable();
    let mut right = right.chars().peekable();

    loop {
        // The strings are equal so far and not inside a number in both sides
        let (l, r) = match (left.next(), right.next()) {
            // Is this the end of both strings?
            (None, None) => return Ordering::Equal,
            // If for one, the shorter one is considered smaller
            (None, Some(_)) => return Ordering::Less,
            (Some(_), None) => return Ordering::Greater,
            (Some(l), Some(r)) => (l, r),
        };
        let next_ordering = match (l.to_digit(10), r.to_digit(10)) {
            // If neither is a digit, just compare them
            (None, None) => Ord::cmp(&l, &r),
            // The one with shorter non-digit run is smaller
            // For `strverscmp` it's smaller iff next char in longer is greater than digits
            (None, Some(_)) => Ordering::Greater,
            (Some(_), None) => Ordering::Less,
            // If both start numbers, we have to compare the numbers
            (Some(l), Some(r)) => {
                if l == 0 || r == 0 {
                    // Fraction mode: compare as if there was leading `0.`
                    let ordering = Ord::cmp(&l, &r);
                    if ordering != Ordering::Equal {
                        return ordering;
                    }
                    loop {
                        // Get next pair
                        let (l, r) = match (left.peek(), right.peek()) {
                            // Is this the end of both strings?
                            (None, None) => return Ordering::Equal,
                            // If for one, the shorter one is considered smaller
                            (None, Some(_)) => return Ordering::Less,
                            (Some(_), None) => return Ordering::Greater,
                            (Some(l), Some(r)) => (l, r),
                        };
                        // Are they digits?
                        match (l.to_digit(10), r.to_digit(10)) {
                            // If out of digits, use the stored ordering due to equal length
                            (None, None) => break Ordering::Equal,
                            // If one is shorter, it's smaller
                            (None, Some(_)) => return Ordering::Less,
                            (Some(_), None) => return Ordering::Greater,
                            // If both are digits, consume them and take into account
                            (Some(l), Some(r)) => {
                                left.next();
                                right.next();
                                let ordering = Ord::cmp(&l, &r);
                                if ordering != Ordering::Equal {
                                    return ordering;
                                }
                            }
                        }
                    }
                } else {
                    // Integer mode
                    let mut same_length_ordering = Ord::cmp(&l, &r);
                    loop {
                        // Get next pair
                        let (l, r) = match (left.peek(), right.peek()) {
                            // Is this the end of both strings?
                            (None, None) => return same_length_ordering,
                            // If for one, the shorter one is considered smaller
                            (None, Some(_)) => return Ordering::Less,
                            (Some(_), None) => return Ordering::Greater,
                            (Some(l), Some(r)) => (l, r),
                        };
                        // Are they digits?
                        match (l.to_digit(10), r.to_digit(10)) {
                            // If out of digits, use the stored ordering due to equal length
                            (None, None) => break same_length_ordering,
                            // If one is shorter, it's smaller
                            (None, Some(_)) => return Ordering::Less,
                            (Some(_), None) => return Ordering::Greater,
                            // If both are digits, consume them and take into account
                            (Some(l), Some(r)) => {
                                left.next();
                                right.next();
                                same_length_ordering = same_length_ordering.then(Ord::cmp(&l, &r));
                            }
                        }
                    }
                }
            }
        };
        if next_ordering != Ordering::Equal {
            return next_ordering;
        }
    }
}

pub(super) fn full_path(cx: &Context<'_>, item: &clean::Item) -> String {
    let mut s = join_with_double_colon(&cx.current);
    s.push_str("::");
    s.push_str(item.name.unwrap().as_str());
    s
}

pub(super) fn item_path(ty: ItemType, name: &str) -> String {
    match ty {
        ItemType::Module => format!("{}index.html", ensure_trailing_slash(name)),
        _ => format!("{ty}.{name}.html"),
    }
}

fn bounds<'a, 'tcx>(
    t_bounds: &'a [clean::GenericBound],
    trait_alias: bool,
    cx: &'a Context<'tcx>,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(move |f| {
        if t_bounds.is_empty() {
            return Ok(());
        }
        let has_lots_of_bounds = t_bounds.len() > 2;
        let inter_str = if has_lots_of_bounds { "\n    + " } else { " + " };
        if !trait_alias {
            if has_lots_of_bounds {
                f.write_str(":\n    ")?;
            } else {
                f.write_str(": ")?;
            }
        }
        t_bounds.iter().map(|p| p.print(cx)).joined(inter_str, f)
    })
}

fn wrap_item<'a>(t: impl Display + 'a) -> impl Display + 'a {
    fmt::from_fn(move |f| write!(f, r#"<pre class="rust item-decl"><code>{t}</code></pre>"#))
}

#[derive(PartialEq, Eq)]
struct ImplString(String);

impl ImplString {
    fn new(i: &Impl, cx: &Context<'_>) -> ImplString {
        ImplString(format!("{}", i.inner_impl().print(false, cx)))
    }
}

impl PartialOrd for ImplString {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(Ord::cmp(self, other))
    }
}

impl Ord for ImplString {
    fn cmp(&self, other: &Self) -> Ordering {
        compare_names(&self.0, &other.0)
    }
}

fn render_implementor<'a, 'tcx>(
    cx: &'a Context<'tcx>,
    implementor: &'a Impl,
    trait_: &'a clean::Item,
    implementor_dups: &'a FxHashMap<Symbol, (DefId, bool)>,
    aliases: &'a [String],
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(|f| {
        // If there's already another implementor that has the same abridged name, use the
        // full path, for example in `std::iter::ExactSizeIterator`
        let use_absolute = match implementor.inner_impl().for_ {
            clean::Type::Path { ref path, .. }
            | clean::BorrowedRef { type_: box clean::Type::Path { ref path, .. }, .. }
                if !path.is_assoc_ty() =>
            {
                implementor_dups[&path.last()].1
            }
            _ => false,
        };
        render_impl(
            cx,
            implementor,
            trait_,
            AssocItemLink::Anchor(None),
            RenderMode::Normal,
            Some(use_absolute),
            aliases,
            ImplRenderingParameters {
                show_def_docs: false,
                show_default_items: false,
                show_non_assoc_items: false,
                toggle_open_by_default: false,
            },
        )
        .fmt(f)
    })
}

fn render_union<'a, 'cx: 'a>(
    it: &'a clean::Item,
    g: Option<&'a clean::Generics>,
    fields: &'a [clean::Item],
    cx: &'a Context<'cx>,
) -> impl Display + 'a + Captures<'cx> {
    fmt::from_fn(move |f| {
        write!(f, "{}union {}", visibility_print_with_space(it, cx), it.name.unwrap(),)?;

        let where_displayed = g
            .map(|g| {
                let mut buf = String::new();
                write!(buf, "{}", g.print(cx)).unwrap();
                let where_displayed = print_where_clause_and_check(&mut buf, g, cx);
                write!(f, "{buf}").unwrap();
                where_displayed
            })
            .unwrap_or(false);

        // If there wasn't a `where` clause, we add a whitespace.
        if !where_displayed {
            f.write_str(" ")?;
        }

        writeln!(f, "{{")?;
        let count_fields =
            fields.iter().filter(|field| matches!(field.kind, clean::StructFieldItem(..))).count();
        let toggle = should_hide_fields(count_fields);
        if toggle {
            write!(f, "{}", toggle_open(format_args!("{count_fields} fields")))?;
        }

        for field in fields {
            if let clean::StructFieldItem(ref ty) = field.kind {
                writeln!(
                    f,
                    "    {}{}: {},",
                    visibility_print_with_space(field, cx),
                    field.name.unwrap(),
                    ty.print(cx)
                )?;
            }
        }

        if it.has_stripped_entries().unwrap() {
            writeln!(f, "    <span class=\"comment\">/* private fields */</span>")?;
        }
        if toggle {
            write!(f, "{}", toggle_close())?;
        }
        f.write_str("}")?;
        Ok(())
    })
}

fn render_struct<'a, 'tcx>(
    it: &'a clean::Item,
    g: Option<&'a clean::Generics>,
    ty: Option<CtorKind>,
    fields: &'a [clean::Item],
    tab: &'a str,
    structhead: bool,
    cx: &'a Context<'tcx>,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(move |f| {
        write!(
            f,
            "{}{}{}",
            visibility_print_with_space(it, cx),
            if structhead { "struct " } else { "" },
            it.name.unwrap()
        )?;
        if let Some(g) = g {
            write!(f, "{}", g.print(cx))?;
        }
        render_struct_fields(
            g,
            ty,
            fields,
            tab,
            structhead,
            it.has_stripped_entries().unwrap_or(false),
            cx,
        )
        .fmt(f)
    })
}

fn render_struct_fields<'a, 'tcx>(
    g: Option<&'a clean::Generics>,
    ty: Option<CtorKind>,
    fields: &'a [clean::Item],
    tab: &'a str,
    structhead: bool,
    has_stripped_entries: bool,
    cx: &'a Context<'tcx>,
) -> impl fmt::Display + 'a + Captures<'tcx> {
    fmt::from_fn(move |w| {
        match ty {
            None => {
                let where_displayed =
                    g.map(|g| print_where_clause_and_check(&mut *w, g, cx)).unwrap_or(false);

                // If there wasn't a `where` clause, we add a whitespace.
                if !where_displayed {
                    w.write_str(" {")?;
                } else {
                    w.write_str("{")?;
                }
                let count_fields =
                    fields.iter().filter(|f| matches!(f.kind, clean::StructFieldItem(..))).count();
                let has_visible_fields = count_fields > 0;
                let toggle = should_hide_fields(count_fields);
                if toggle {
                    write!(w, "{}", toggle_open(format_args!("{count_fields} fields")))?;
                }
                for field in fields {
                    if let clean::StructFieldItem(ref ty) = field.kind {
                        write!(
                            w,
                            "\n{tab}    {vis}{name}: {ty},",
                            vis = visibility_print_with_space(field, cx),
                            name = field.name.unwrap(),
                            ty = ty.print(cx),
                        )?;
                    }
                }

                if has_visible_fields {
                    if has_stripped_entries {
                        write!(
                            w,
                            "\n{tab}    <span class=\"comment\">/* private fields */</span>"
                        )?;
                    }
                    write!(w, "\n{tab}")?;
                } else if has_stripped_entries {
                    write!(w, " <span class=\"comment\">/* private fields */</span> ")?;
                }
                if toggle {
                    write!(w, "{}", toggle_close())?;
                }
                w.write_str("}")?;
            }
            Some(CtorKind::Fn) => {
                w.write_str("(")?;
                if !fields.is_empty()
                    && fields.iter().all(|field| {
                        matches!(field.kind, clean::StrippedItem(box clean::StructFieldItem(..)))
                    })
                {
                    write!(w, "<span class=\"comment\">/* private fields */</span>")?;
                } else {
                    for (i, field) in fields.iter().enumerate() {
                        if i > 0 {
                            w.write_str(", ")?;
                        }
                        match field.kind {
                            clean::StrippedItem(box clean::StructFieldItem(..)) => {
                                write!(w, "_")?;
                            }
                            clean::StructFieldItem(ref ty) => {
                                write!(
                                    w,
                                    "{}{}",
                                    visibility_print_with_space(field, cx),
                                    ty.print(cx)
                                )?;
                            }
                            _ => unreachable!(),
                        }
                    }
                }
                w.write_str(")")?;
                if let Some(g) = g {
                    write!(w, "{}", print_where_clause(g, cx, 0, Ending::NoNewline))?;
                }
                // We only want a ";" when we are displaying a tuple struct, not a variant tuple struct.
                if structhead {
                    w.write_str(";")?;
                }
            }
            Some(CtorKind::Const) => {
                // Needed for PhantomData.
                if let Some(g) = g {
                    write!(w, "{}", print_where_clause(g, cx, 0, Ending::NoNewline))?;
                }
                w.write_str(";")?;
            }
        }

        Ok(())
    })
}

fn document_non_exhaustive_header(item: &clean::Item) -> &str {
    if item.is_non_exhaustive() { " (Non-exhaustive)" } else { "" }
}

fn document_non_exhaustive(item: &clean::Item) -> impl Display + '_ {
    fmt::from_fn(|f| {
        if item.is_non_exhaustive() {
            write!(
                f,
                "<details class=\"toggle non-exhaustive\">\
                    <summary class=\"hideme\"><span>{}</span></summary>\
                    <div class=\"docblock\">",
                {
                    if item.is_struct() {
                        "This struct is marked as non-exhaustive"
                    } else if item.is_enum() {
                        "This enum is marked as non-exhaustive"
                    } else if item.is_variant() {
                        "This variant is marked as non-exhaustive"
                    } else {
                        "This type is marked as non-exhaustive"
                    }
                }
            )?;

            if item.is_struct() {
                f.write_str(
                    "Non-exhaustive structs could have additional fields added in future. \
                    Therefore, non-exhaustive structs cannot be constructed in external crates \
                    using the traditional <code>Struct { .. }</code> syntax; cannot be \
                    matched against without a wildcard <code>..</code>; and \
                    struct update syntax will not work.",
                )?;
            } else if item.is_enum() {
                f.write_str(
                    "Non-exhaustive enums could have additional variants added in future. \
                    Therefore, when matching against variants of non-exhaustive enums, an \
                    extra wildcard arm must be added to account for any future variants.",
                )?;
            } else if item.is_variant() {
                f.write_str(
                    "Non-exhaustive enum variants could have additional fields added in future. \
                    Therefore, non-exhaustive enum variants cannot be constructed in external \
                    crates and cannot be matched against.",
                )?;
            } else {
                f.write_str(
                    "This type will require a wildcard arm in any match statements or constructors.",
                )?;
            }

            f.write_str("</div></details>")?;
        }
        Ok(())
    })
}

fn pluralize(count: usize) -> &'static str {
    if count > 1 { "s" } else { "" }
}
