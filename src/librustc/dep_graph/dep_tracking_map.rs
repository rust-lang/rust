// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use rustc_data_structures::fx::FxHashMap;
use std::cell::RefCell;
use std::hash::Hash;
use std::marker::PhantomData;
use super::{DepNode, DepGraph, DepKind};

/// A DepTrackingMap offers a subset of the `Map` API and ensures that
/// we make calls to `read` and `write` as appropriate. We key the
/// maps with a unique type for brevity.
pub struct DepTrackingMap<M: DepTrackingMapConfig> {
    phantom: PhantomData<M>,
    graph: DepGraph,
    map: RefCell<FxHashMap<M::Key,  (M::Value, DepNode)>>,
}

pub trait DepTrackingMapConfig {
    type Key: Eq + Hash + Clone;
    type Value: Clone;

    /// A DepTrackingMap always creates anonymous DepNodes, but the DepKind of
    /// the nodes generated by a given map can be specified via this constant.
    const DEP_KIND: DepKind;
}

impl<M: DepTrackingMapConfig> DepTrackingMap<M> {
    pub fn new(graph: DepGraph) -> DepTrackingMap<M> {
        DepTrackingMap {
            phantom: PhantomData,
            graph: graph,
            map: RefCell::new(FxHashMap()),
        }
    }

    /// Memoizes an entry in the dep-tracking-map. If the entry is not
    /// already present, then `op` will be executed to compute its value.
    /// The resulting dependency graph looks like this:
    ///
    ///     [op] -> Map(key) -> CurrentTask
    ///
    /// Here, `[op]` represents whatever nodes `op` reads in the
    /// course of execution; `Map(key)` represents the node for this
    /// map; and `CurrentTask` represents the current task when
    /// `memoize` is invoked. The node `Map(key)` is an automatically
    /// generated, "anonymous" node with DepKind as configured in the
    /// map's `DepTrackingMapConfig`.
    pub fn memoize<F>(&self,
                      key: M::Key,
                      op: F)
                      -> M::Value
        where F: FnOnce() -> M::Value
    {
        {
            let map = self.map.borrow();
            if let Some(&(ref result, dep_node)) = map.get(&key) {
                self.graph.read(dep_node);
                return result.clone();
            }
        }

        let (result, dep_node) = self.graph.with_anon_task(M::DEP_KIND, op);

        self.graph.read(dep_node);
        self.map.borrow_mut().insert(key, (result.clone(), dep_node));
        result
    }
}
