    1|       |#![allow(unused_assignments)]
    2|       |// expect-exit-status-101
    3|       |
    4|      4|fn might_fail_assert(one_plus_one: u32) {
    5|      4|    println!("does 1 + 1 = {}?", one_plus_one);
    6|      4|    assert_eq!(1 + 1, one_plus_one, "the argument was wrong");
                                                  ^1
    7|      3|}
    8|       |
    9|      1|fn main() -> Result<(),u8> {
   10|      1|    let mut countdown = 10;
   11|     10|    while countdown > 0 {
   12|     10|        if countdown == 1 {
   13|      0|            might_fail_assert(3);
   14|     10|        } else if countdown < 5 {
   15|      3|            might_fail_assert(2);
   16|      6|        }
   17|      9|        countdown -= 1;
   18|       |    }
   19|      0|    Ok(())
   20|      0|}
   21|       |
   22|       |// Notes:
   23|       |//   1. Compare this program and its coverage results to those of the very similar test
   24|       |//      `panic_unwind.rs`, and similar tests `abort.rs` and `try_error_result.rs`.
   25|       |//   2. This test confirms the coverage generated when a program passes or fails an `assert!()` or
   26|       |//      related `assert_*!()` macro.
   27|       |//   3. Notably, the `assert` macros *do not* generate `TerminatorKind::Assert`. The macros produce
   28|       |//      conditional expressions, `TerminatorKind::SwitchInt` branches, and a possible call to
   29|       |//      `begin_panic_fmt()` (that begins a panic unwind, if the assertion test fails).
   30|       |//   4. `TerminatoKind::Assert` is, however, also present in the MIR generated for this test
   31|       |//      (and in many other coverage tests). The `Assert` terminator is typically generated by the
   32|       |//      Rust compiler to check for runtime failures, such as numeric overflows.

