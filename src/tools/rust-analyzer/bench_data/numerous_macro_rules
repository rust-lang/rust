macro_rules! __ra_macro_fixture0 {($T :  ident )=>( int_module ! ($T , # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]);); ($T :  ident , # [$attr :  meta ])=>( doc_comment ! { concat ! ( "The smallest value that can be represented by this integer type.\nUse [`" ,  stringify ! ($T ),  "::MIN" ,  "`](../../std/primitive." ,  stringify ! ($T ),  ".html#associatedconstant.MIN) instead.\n\n# Examples\n\n```rust\n// deprecated way\nlet min = std::" ,  stringify ! ($T ),  "::MIN;\n\n// intended way\nlet min = " ,  stringify ! ($T ),  "::MIN;\n```\n" ), # [$attr ] pub  const  MIN : $T = $T ::  MIN ; } doc_comment ! { concat ! ( "The largest value that can be represented by this integer type.\nUse [`" ,  stringify ! ($T ),  "::MAX" ,  "`](../../std/primitive." ,  stringify ! ($T ),  ".html#associatedconstant.MAX) instead.\n\n# Examples\n\n```rust\n// deprecated way\nlet max = std::" ,  stringify ! ($T ),  "::MAX;\n\n// intended way\nlet max = " ,  stringify ! ($T ),  "::MAX;\n```\n" ), # [$attr ] pub  const  MAX : $T = $T ::  MAX ; })}
macro_rules! __ra_macro_fixture1 {($($ty :  ty :  add ($addfn :  path ),  mul /  div ($bigty :  ident );)*)=>($(impl  FullOps  for $ty { fn  full_add ( self ,  other : $ty ,  carry :  bool )-> ( bool , $ty ){ let ( v ,  carry1 )=  intrinsics ::  add_with_overflow ( self ,  other );  let ( v ,  carry2 )=  intrinsics ::  add_with_overflow ( v ,  if  carry { 1 } else { 0 }); ( carry1 ||  carry2 ,  v )} fn  full_mul ( self ,  other : $ty ,  carry : $ty )-> ($ty , $ty ){ let  v = ( self  as $bigty )* ( other  as $bigty )+ ( carry  as $bigty ); (( v >> <$ty >::  BITS ) as $ty ,  v  as $ty )} fn  full_mul_add ( self ,  other : $ty ,  other2 : $ty ,  carry : $ty )-> ($ty , $ty ){ let  v = ( self  as $bigty )* ( other  as $bigty )+ ( other2  as $bigty )+ ( carry  as $bigty ); (( v >> <$ty >::  BITS ) as $ty ,  v  as $ty )} fn  full_div_rem ( self ,  other : $ty ,  borrow : $ty )-> ($ty , $ty ){ debug_assert ! ( borrow <  other );  let  lhs = (( borrow  as $bigty )<< <$ty >::  BITS )| ( self  as $bigty );  let  rhs =  other  as $bigty ; (( lhs /  rhs ) as $ty , ( lhs %  rhs ) as $ty )}})* )}
macro_rules! __ra_macro_fixture2 {($name :  ident :  type =$ty :  ty ,  n =$n :  expr )=>{# [ doc =  " Stack-allocated arbitrary-precision (up to certain limit) integer." ]# [ doc =  "" ]# [ doc =  " This is backed by a fixed-size array of given type (\\\"digit\\\")." ]# [ doc =  " While the array is not very large (normally some hundred bytes)," ]# [ doc =  " copying it recklessly may result in the performance hit." ]# [ doc =  " Thus this is intentionally not `Copy`." ]# [ doc =  "" ]# [ doc =  " All operations available to bignums panic in the case of overflows." ]# [ doc =  " The caller is responsible to use large enough bignum types." ] pub  struct $name {# [ doc =  " One plus the offset to the maximum \\\"digit\\\" in use." ]# [ doc =  " This does not decrease, so be aware of the computation order." ]# [ doc =  " `base[size..]` should be zero." ] size :  usize , # [ doc =  " Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`" ]# [ doc =  " where `W` is the number of bits in the digit type." ] base : [$ty ; $n ], } impl $name {# [ doc =  " Makes a bignum from one digit." ] pub  fn  from_small ( v : $ty )-> $name { let  mut  base = [ 0 ; $n ];  base [ 0 ]=  v ; $name { size :  1 ,  base :  base }}# [ doc =  " Makes a bignum from `u64` value." ] pub  fn  from_u64 ( mut  v :  u64 )-> $name { let  mut  base = [ 0 ; $n ];  let  mut  sz =  0 ;  while  v >  0 { base [ sz ]=  v  as $ty ;  v >>= <$ty >::  BITS ;  sz +=  1 ; }$name { size :  sz ,  base :  base }}# [ doc =  " Returns the internal digits as a slice `[a, b, c, ...]` such that the numeric" ]# [ doc =  " value is `a + b * 2^W + c * 2^(2W) + ...` where `W` is the number of bits in" ]# [ doc =  " the digit type." ] pub  fn  digits (&  self )-> & [$ty ]{&  self .  base [..  self .  size ]}# [ doc =  " Returns the `i`-th bit where bit 0 is the least significant one." ]# [ doc =  " In other words, the bit with weight `2^i`." ] pub  fn  get_bit (&  self ,  i :  usize )->  u8 { let  digitbits = <$ty >::  BITS  as  usize ;  let  d =  i /  digitbits ;  let  b =  i %  digitbits ; (( self .  base [ d ]>>  b )&  1 ) as  u8 }# [ doc =  " Returns `true` if the bignum is zero." ] pub  fn  is_zero (&  self )->  bool { self .  digits ().  iter ().  all (|&  v |  v ==  0 )}# [ doc =  " Returns the number of bits necessary to represent this value. Note that zero" ]# [ doc =  " is considered to need 0 bits." ] pub  fn  bit_length (&  self )->  usize { let  digits =  self .  digits ();  let  zeros =  digits .  iter ().  rev ().  take_while (|&&  x |  x ==  0 ).  count ();  let  end =  digits .  len ()-  zeros ;  let  nonzero = &  digits [..  end ];  if  nonzero .  is_empty (){ return  0 ; } let  digitbits = <$ty >::  BITS  as  usize ;  let  mut  i =  nonzero .  len ()*  digitbits -  1 ;  while  self .  get_bit ( i )==  0 { i -=  1 ; } i +  1 }# [ doc =  " Adds `other` to itself and returns its own mutable reference." ] pub  fn  add < 'a > (& 'a  mut  self ,  other : &$name )-> & 'a  mut $name { use  crate ::  cmp ;  use  crate ::  num ::  bignum ::  FullOps ;  let  mut  sz =  cmp ::  max ( self .  size ,  other .  size );  let  mut  carry =  false ;  for ( a ,  b ) in  self .  base [..  sz ].  iter_mut ().  zip (&  other .  base [..  sz ]){ let ( c ,  v )= (*  a ).  full_add (*  b ,  carry ); *  a =  v ;  carry =  c ; } if  carry { self .  base [ sz ]=  1 ;  sz +=  1 ; } self .  size =  sz ;  self } pub  fn  add_small (&  mut  self ,  other : $ty )-> &  mut $name { use  crate ::  num ::  bignum ::  FullOps ;  let ( mut  carry ,  v )=  self .  base [ 0 ].  full_add ( other ,  false );  self .  base [ 0 ]=  v ;  let  mut  i =  1 ;  while  carry { let ( c ,  v )=  self .  base [ i ].  full_add ( 0 ,  carry );  self .  base [ i ]=  v ;  carry =  c ;  i +=  1 ; } if  i >  self .  size { self .  size =  i ; } self }# [ doc =  " Subtracts `other` from itself and returns its own mutable reference." ] pub  fn  sub < 'a > (& 'a  mut  self ,  other : &$name )-> & 'a  mut $name { use  crate ::  cmp ;  use  crate ::  num ::  bignum ::  FullOps ;  let  sz =  cmp ::  max ( self .  size ,  other .  size );  let  mut  noborrow =  true ;  for ( a ,  b ) in  self .  base [..  sz ].  iter_mut ().  zip (&  other .  base [..  sz ]){ let ( c ,  v )= (*  a ).  full_add (!*  b ,  noborrow ); *  a =  v ;  noborrow =  c ; } assert ! ( noborrow );  self .  size =  sz ;  self }# [ doc =  " Multiplies itself by a digit-sized `other` and returns its own" ]# [ doc =  " mutable reference." ] pub  fn  mul_small (&  mut  self ,  other : $ty )-> &  mut $name { use  crate ::  num ::  bignum ::  FullOps ;  let  mut  sz =  self .  size ;  let  mut  carry =  0 ;  for  a  in &  mut  self .  base [..  sz ]{ let ( c ,  v )= (*  a ).  full_mul ( other ,  carry ); *  a =  v ;  carry =  c ; } if  carry >  0 { self .  base [ sz ]=  carry ;  sz +=  1 ; } self .  size =  sz ;  self }# [ doc =  " Multiplies itself by `2^bits` and returns its own mutable reference." ] pub  fn  mul_pow2 (&  mut  self ,  bits :  usize )-> &  mut $name { let  digitbits = <$ty >::  BITS  as  usize ;  let  digits =  bits /  digitbits ;  let  bits =  bits %  digitbits ;  assert ! ( digits < $n );  debug_assert ! ( self .  base [$n -  digits ..].  iter ().  all (|&  v |  v ==  0 ));  debug_assert ! ( bits ==  0 || ( self .  base [$n -  digits -  1 ]>> ( digitbits -  bits ))==  0 );  for  i  in ( 0 ..  self .  size ).  rev (){ self .  base [ i +  digits ]=  self .  base [ i ]; } for  i  in  0 ..  digits { self .  base [ i ]=  0 ; } let  mut  sz =  self .  size +  digits ;  if  bits >  0 { let  last =  sz ;  let  overflow =  self .  base [ last -  1 ]>> ( digitbits -  bits );  if  overflow >  0 { self .  base [ last ]=  overflow ;  sz +=  1 ; } for  i  in ( digits +  1 ..  last ).  rev (){ self .  base [ i ]= ( self .  base [ i ]<<  bits )| ( self .  base [ i -  1 ]>> ( digitbits -  bits )); } self .  base [ digits ]<<=  bits ; } self .  size =  sz ;  self }# [ doc =  " Multiplies itself by `5^e` and returns its own mutable reference." ] pub  fn  mul_pow5 (&  mut  self ,  mut  e :  usize )-> &  mut $name { use  crate ::  mem ;  use  crate ::  num ::  bignum ::  SMALL_POW5 ;  let  table_index =  mem ::  size_of ::<$ty > ().  trailing_zeros () as  usize ;  let ( small_power ,  small_e )=  SMALL_POW5 [ table_index ];  let  small_power =  small_power  as $ty ;  while  e >=  small_e { self .  mul_small ( small_power );  e -=  small_e ; } let  mut  rest_power =  1 ;  for _  in  0 ..  e { rest_power *=  5 ; } self .  mul_small ( rest_power );  self }# [ doc =  " Multiplies itself by a number described by `other[0] + other[1] * 2^W +" ]# [ doc =  " other[2] * 2^(2W) + ...` (where `W` is the number of bits in the digit type)" ]# [ doc =  " and returns its own mutable reference." ] pub  fn  mul_digits < 'a > (& 'a  mut  self ,  other : & [$ty ])-> & 'a  mut $name { fn  mul_inner ( ret : &  mut [$ty ; $n ],  aa : & [$ty ],  bb : & [$ty ])->  usize { use  crate ::  num ::  bignum ::  FullOps ;  let  mut  retsz =  0 ;  for ( i , &  a ) in  aa .  iter ().  enumerate (){ if  a ==  0 { continue ; } let  mut  sz =  bb .  len ();  let  mut  carry =  0 ;  for ( j , &  b ) in  bb .  iter ().  enumerate (){ let ( c ,  v )=  a .  full_mul_add ( b ,  ret [ i +  j ],  carry );  ret [ i +  j ]=  v ;  carry =  c ; } if  carry >  0 { ret [ i +  sz ]=  carry ;  sz +=  1 ; } if  retsz <  i +  sz { retsz =  i +  sz ; }} retsz } let  mut  ret = [ 0 ; $n ];  let  retsz =  if  self .  size <  other .  len (){ mul_inner (&  mut  ret , &  self .  digits (),  other )} else { mul_inner (&  mut  ret ,  other , &  self .  digits ())};  self .  base =  ret ;  self .  size =  retsz ;  self }# [ doc =  " Divides itself by a digit-sized `other` and returns its own" ]# [ doc =  " mutable reference *and* the remainder." ] pub  fn  div_rem_small (&  mut  self ,  other : $ty )-> (&  mut $name , $ty ){ use  crate ::  num ::  bignum ::  FullOps ;  assert ! ( other >  0 );  let  sz =  self .  size ;  let  mut  borrow =  0 ;  for  a  in  self .  base [..  sz ].  iter_mut ().  rev (){ let ( q ,  r )= (*  a ).  full_div_rem ( other ,  borrow ); *  a =  q ;  borrow =  r ; }( self ,  borrow )}# [ doc =  " Divide self by another bignum, overwriting `q` with the quotient and `r` with the" ]# [ doc =  " remainder." ] pub  fn  div_rem (&  self ,  d : &$name ,  q : &  mut $name ,  r : &  mut $name ){ assert ! (!  d .  is_zero ());  let  digitbits = <$ty >::  BITS  as  usize ;  for  digit  in &  mut  q .  base [..]{*  digit =  0 ; } for  digit  in &  mut  r .  base [..]{*  digit =  0 ; } r .  size =  d .  size ;  q .  size =  1 ;  let  mut  q_is_zero =  true ;  let  end =  self .  bit_length ();  for  i  in ( 0 ..  end ).  rev (){ r .  mul_pow2 ( 1 );  r .  base [ 0 ]|=  self .  get_bit ( i ) as $ty ;  if &*  r >=  d { r .  sub ( d );  let  digit_idx =  i /  digitbits ;  let  bit_idx =  i %  digitbits ;  if  q_is_zero { q .  size =  digit_idx +  1 ;  q_is_zero =  false ; } q .  base [ digit_idx ]|=  1 <<  bit_idx ; }} debug_assert ! ( q .  base [ q .  size ..].  iter ().  all (|&  d |  d ==  0 ));  debug_assert ! ( r .  base [ r .  size ..].  iter ().  all (|&  d |  d ==  0 )); }} impl  crate ::  cmp ::  PartialEq  for $name { fn  eq (&  self ,  other : &$name )->  bool { self .  base [..]==  other .  base [..]}} impl  crate ::  cmp ::  Eq  for $name {} impl  crate ::  cmp ::  PartialOrd  for $name { fn  partial_cmp (&  self ,  other : &$name )->  crate ::  option ::  Option <  crate ::  cmp ::  Ordering > { crate ::  option ::  Option ::  Some ( self .  cmp ( other ))}} impl  crate ::  cmp ::  Ord  for $name { fn  cmp (&  self ,  other : &$name )->  crate ::  cmp ::  Ordering { use  crate ::  cmp ::  max ;  let  sz =  max ( self .  size ,  other .  size );  let  lhs =  self .  base [..  sz ].  iter ().  cloned ().  rev ();  let  rhs =  other .  base [..  sz ].  iter ().  cloned ().  rev ();  lhs .  cmp ( rhs )}} impl  crate ::  clone ::  Clone  for $name { fn  clone (&  self )->  Self { Self { size :  self .  size ,  base :  self .  base }}} impl  crate ::  fmt ::  Debug  for $name { fn  fmt (&  self ,  f : &  mut  crate ::  fmt ::  Formatter < '_ >)->  crate ::  fmt ::  Result { let  sz =  if  self .  size <  1 { 1 } else { self .  size };  let  digitlen = <$ty >::  BITS  as  usize /  4 ;  write ! ( f ,  "{:#x}" ,  self .  base [ sz -  1 ])?;  for &  v  in  self .  base [..  sz -  1 ].  iter ().  rev (){ write ! ( f ,  "_{:01$x}" ,  v ,  digitlen )?; } crate ::  result ::  Result ::  Ok (())}}}; }
macro_rules! __ra_macro_fixture3 {($t :  ty )=>{# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  FromStr  for $t { type  Err =  ParseFloatError ; # [ doc =  " Converts a string in base 10 to a float." ]# [ doc =  " Accepts an optional decimal exponent." ]# [ doc =  "" ]# [ doc =  " This function accepts strings such as" ]# [ doc =  "" ]# [ doc =  " * \\\'3.14\\\'" ]# [ doc =  " * \\\'-3.14\\\'" ]# [ doc =  " * \\\'2.5E10\\\', or equivalently, \\\'2.5e10\\\'" ]# [ doc =  " * \\\'2.5E-10\\\'" ]# [ doc =  " * \\\'5.\\\'" ]# [ doc =  " * \\\'.5\\\', or, equivalently, \\\'0.5\\\'" ]# [ doc =  " * \\\'inf\\\', \\\'-inf\\\', \\\'NaN\\\'" ]# [ doc =  "" ]# [ doc =  " Leading and trailing whitespace represent an error." ]# [ doc =  "" ]# [ doc =  " # Grammar" ]# [ doc =  "" ]# [ doc =  " All strings that adhere to the following [EBNF] grammar" ]# [ doc =  " will result in an [`Ok`] being returned:" ]# [ doc =  "" ]# [ doc =  " ```txt" ]# [ doc =  " Float  ::= Sign? ( \\\'inf\\\' | \\\'NaN\\\' | Number )" ]# [ doc =  " Number ::= ( Digit+ |" ]# [ doc =  "              Digit+ \\\'.\\\' Digit* |" ]# [ doc =  "              Digit* \\\'.\\\' Digit+ ) Exp?" ]# [ doc =  " Exp    ::= [eE] Sign? Digit+" ]# [ doc =  " Sign   ::= [+-]" ]# [ doc =  " Digit  ::= [0-9]" ]# [ doc =  " ```" ]# [ doc =  "" ]# [ doc =  " [EBNF]: https://www.w3.org/TR/REC-xml/#sec-notation" ]# [ doc =  "" ]# [ doc =  " # Known bugs" ]# [ doc =  "" ]# [ doc =  " In some situations, some strings that should create a valid float" ]# [ doc =  " instead return an error. See [issue #31407] for details." ]# [ doc =  "" ]# [ doc =  " [issue #31407]: https://github.com/rust-lang/rust/issues/31407" ]# [ doc =  "" ]# [ doc =  " # Arguments" ]# [ doc =  "" ]# [ doc =  " * src - A string" ]# [ doc =  "" ]# [ doc =  " # Return value" ]# [ doc =  "" ]# [ doc =  " `Err(ParseFloatError)` if the string did not represent a valid" ]# [ doc =  " number. Otherwise, `Ok(n)` where `n` is the floating-point" ]# [ doc =  " number represented by `src`." ]# [ inline ] fn  from_str ( src : &  str )->  Result <  Self ,  ParseFloatError > { dec2flt ( src )}}}; }
macro_rules! __ra_macro_fixture4 {($(# [$stability :  meta ]$Ty :  ident ($Int :  ty ); )+ )=>{$(doc_comment ! { concat ! ( "An integer that is known not to equal zero.\n\nThis enables some memory layout optimization.\nFor example, `Option<" ,  stringify ! ($Ty ),  ">` is the same size as `" ,  stringify ! ($Int ),  "`:\n\n```rust\nuse std::mem::size_of;\nassert_eq!(size_of::<Option<core::num::" ,  stringify ! ($Ty ),  ">>(), size_of::<" ,  stringify ! ($Int ),  ">());\n```" ), # [$stability ]# [ derive ( Copy ,  Clone ,  Eq ,  PartialEq ,  Ord ,  PartialOrd ,  Hash )]# [ repr ( transparent )]# [ rustc_layout_scalar_valid_range_start ( 1 )]# [ rustc_nonnull_optimization_guaranteed ] pub  struct $Ty ($Int ); } impl $Ty {# [ doc =  " Creates a non-zero without checking the value." ]# [ doc =  "" ]# [ doc =  " # Safety" ]# [ doc =  "" ]# [ doc =  " The value must not be zero." ]# [$stability ]# [ rustc_const_stable ( feature =  "nonzero" ,  since =  "1.34.0" )]# [ inline ] pub  const  unsafe  fn  new_unchecked ( n : $Int )->  Self { unsafe { Self ( n )}}# [ doc =  " Creates a non-zero if the given value is not zero." ]# [$stability ]# [ rustc_const_stable ( feature =  "const_nonzero_int_methods" ,  since =  "1.47.0" )]# [ inline ] pub  const  fn  new ( n : $Int )->  Option <  Self > { if  n !=  0 { Some ( unsafe { Self ( n )})} else { None }}# [ doc =  " Returns the value as a primitive type." ]# [$stability ]# [ inline ]# [ rustc_const_stable ( feature =  "nonzero" ,  since =  "1.34.0" )] pub  const  fn  get ( self )-> $Int { self .  0 }}# [ stable ( feature =  "from_nonzero" ,  since =  "1.31.0" )] impl  From <$Ty >  for $Int { doc_comment ! { concat ! ( "Converts a `" ,  stringify ! ($Ty ),  "` into an `" ,  stringify ! ($Int ),  "`" ), # [ inline ] fn  from ( nonzero : $Ty )->  Self { nonzero .  0 }}}# [ stable ( feature =  "nonzero_bitor" ,  since =  "1.45.0" )] impl  BitOr  for $Ty { type  Output =  Self ; # [ inline ] fn  bitor ( self ,  rhs :  Self )->  Self ::  Output { unsafe {$Ty ::  new_unchecked ( self .  get ()|  rhs .  get ())}}}# [ stable ( feature =  "nonzero_bitor" ,  since =  "1.45.0" )] impl  BitOr <$Int >  for $Ty { type  Output =  Self ; # [ inline ] fn  bitor ( self ,  rhs : $Int )->  Self ::  Output { unsafe {$Ty ::  new_unchecked ( self .  get ()|  rhs )}}}# [ stable ( feature =  "nonzero_bitor" ,  since =  "1.45.0" )] impl  BitOr <$Ty >  for $Int { type  Output = $Ty ; # [ inline ] fn  bitor ( self ,  rhs : $Ty )->  Self ::  Output { unsafe {$Ty ::  new_unchecked ( self |  rhs .  get ())}}}# [ stable ( feature =  "nonzero_bitor" ,  since =  "1.45.0" )] impl  BitOrAssign  for $Ty {# [ inline ] fn  bitor_assign (&  mut  self ,  rhs :  Self ){*  self = *  self |  rhs ; }}# [ stable ( feature =  "nonzero_bitor" ,  since =  "1.45.0" )] impl  BitOrAssign <$Int >  for $Ty {# [ inline ] fn  bitor_assign (&  mut  self ,  rhs : $Int ){*  self = *  self |  rhs ; }} impl_nonzero_fmt ! {# [$stability ]( Debug ,  Display ,  Binary ,  Octal ,  LowerHex ,  UpperHex ) for $Ty })+ }}
macro_rules! __ra_macro_fixture5 {($($t :  ty )*)=>{$(# [ stable ( feature =  "nonzero_parse" ,  since =  "1.35.0" )] impl  FromStr  for $t { type  Err =  ParseIntError ;  fn  from_str ( src : &  str )->  Result <  Self ,  Self ::  Err > { Self ::  new ( from_str_radix ( src ,  10 )?).  ok_or ( ParseIntError { kind :  IntErrorKind ::  Zero })}})*}}
macro_rules! __ra_macro_fixture6 {($($t :  ident )*)=>($(sh_impl_unsigned ! {$t ,  usize })*)}
macro_rules! __ra_macro_fixture7 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Add  for  Wrapping <$t > { type  Output =  Wrapping <$t >; # [ inline ] fn  add ( self ,  other :  Wrapping <$t >)->  Wrapping <$t > { Wrapping ( self .  0 .  wrapping_add ( other .  0 ))}} forward_ref_binop ! { impl  Add ,  add  for  Wrapping <$t >,  Wrapping <$t >, # [ stable ( feature =  "wrapping_ref" ,  since =  "1.14.0" )]}# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  AddAssign  for  Wrapping <$t > {# [ inline ] fn  add_assign (&  mut  self ,  other :  Wrapping <$t >){*  self = *  self +  other ; }} forward_ref_op_assign ! { impl  AddAssign ,  add_assign  for  Wrapping <$t >,  Wrapping <$t > }# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Sub  for  Wrapping <$t > { type  Output =  Wrapping <$t >; # [ inline ] fn  sub ( self ,  other :  Wrapping <$t >)->  Wrapping <$t > { Wrapping ( self .  0 .  wrapping_sub ( other .  0 ))}} forward_ref_binop ! { impl  Sub ,  sub  for  Wrapping <$t >,  Wrapping <$t >, # [ stable ( feature =  "wrapping_ref" ,  since =  "1.14.0" )]}# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  SubAssign  for  Wrapping <$t > {# [ inline ] fn  sub_assign (&  mut  self ,  other :  Wrapping <$t >){*  self = *  self -  other ; }} forward_ref_op_assign ! { impl  SubAssign ,  sub_assign  for  Wrapping <$t >,  Wrapping <$t > }# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Mul  for  Wrapping <$t > { type  Output =  Wrapping <$t >; # [ inline ] fn  mul ( self ,  other :  Wrapping <$t >)->  Wrapping <$t > { Wrapping ( self .  0 .  wrapping_mul ( other .  0 ))}} forward_ref_binop ! { impl  Mul ,  mul  for  Wrapping <$t >,  Wrapping <$t >, # [ stable ( feature =  "wrapping_ref" ,  since =  "1.14.0" )]}# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  MulAssign  for  Wrapping <$t > {# [ inline ] fn  mul_assign (&  mut  self ,  other :  Wrapping <$t >){*  self = *  self *  other ; }} forward_ref_op_assign ! { impl  MulAssign ,  mul_assign  for  Wrapping <$t >,  Wrapping <$t > }# [ stable ( feature =  "wrapping_div" ,  since =  "1.3.0" )] impl  Div  for  Wrapping <$t > { type  Output =  Wrapping <$t >; # [ inline ] fn  div ( self ,  other :  Wrapping <$t >)->  Wrapping <$t > { Wrapping ( self .  0 .  wrapping_div ( other .  0 ))}} forward_ref_binop ! { impl  Div ,  div  for  Wrapping <$t >,  Wrapping <$t >, # [ stable ( feature =  "wrapping_ref" ,  since =  "1.14.0" )]}# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  DivAssign  for  Wrapping <$t > {# [ inline ] fn  div_assign (&  mut  self ,  other :  Wrapping <$t >){*  self = *  self /  other ; }} forward_ref_op_assign ! { impl  DivAssign ,  div_assign  for  Wrapping <$t >,  Wrapping <$t > }# [ stable ( feature =  "wrapping_impls" ,  since =  "1.7.0" )] impl  Rem  for  Wrapping <$t > { type  Output =  Wrapping <$t >; # [ inline ] fn  rem ( self ,  other :  Wrapping <$t >)->  Wrapping <$t > { Wrapping ( self .  0 .  wrapping_rem ( other .  0 ))}} forward_ref_binop ! { impl  Rem ,  rem  for  Wrapping <$t >,  Wrapping <$t >, # [ stable ( feature =  "wrapping_ref" ,  since =  "1.14.0" )]}# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  RemAssign  for  Wrapping <$t > {# [ inline ] fn  rem_assign (&  mut  self ,  other :  Wrapping <$t >){*  self = *  self %  other ; }} forward_ref_op_assign ! { impl  RemAssign ,  rem_assign  for  Wrapping <$t >,  Wrapping <$t > }# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Not  for  Wrapping <$t > { type  Output =  Wrapping <$t >; # [ inline ] fn  not ( self )->  Wrapping <$t > { Wrapping (!  self .  0 )}} forward_ref_unop ! { impl  Not ,  not  for  Wrapping <$t >, # [ stable ( feature =  "wrapping_ref" ,  since =  "1.14.0" )]}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  BitXor  for  Wrapping <$t > { type  Output =  Wrapping <$t >; # [ inline ] fn  bitxor ( self ,  other :  Wrapping <$t >)->  Wrapping <$t > { Wrapping ( self .  0 ^  other .  0 )}} forward_ref_binop ! { impl  BitXor ,  bitxor  for  Wrapping <$t >,  Wrapping <$t >, # [ stable ( feature =  "wrapping_ref" ,  since =  "1.14.0" )]}# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  BitXorAssign  for  Wrapping <$t > {# [ inline ] fn  bitxor_assign (&  mut  self ,  other :  Wrapping <$t >){*  self = *  self ^  other ; }} forward_ref_op_assign ! { impl  BitXorAssign ,  bitxor_assign  for  Wrapping <$t >,  Wrapping <$t > }# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  BitOr  for  Wrapping <$t > { type  Output =  Wrapping <$t >; # [ inline ] fn  bitor ( self ,  other :  Wrapping <$t >)->  Wrapping <$t > { Wrapping ( self .  0 |  other .  0 )}} forward_ref_binop ! { impl  BitOr ,  bitor  for  Wrapping <$t >,  Wrapping <$t >, # [ stable ( feature =  "wrapping_ref" ,  since =  "1.14.0" )]}# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  BitOrAssign  for  Wrapping <$t > {# [ inline ] fn  bitor_assign (&  mut  self ,  other :  Wrapping <$t >){*  self = *  self |  other ; }} forward_ref_op_assign ! { impl  BitOrAssign ,  bitor_assign  for  Wrapping <$t >,  Wrapping <$t > }# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  BitAnd  for  Wrapping <$t > { type  Output =  Wrapping <$t >; # [ inline ] fn  bitand ( self ,  other :  Wrapping <$t >)->  Wrapping <$t > { Wrapping ( self .  0 &  other .  0 )}} forward_ref_binop ! { impl  BitAnd ,  bitand  for  Wrapping <$t >,  Wrapping <$t >, # [ stable ( feature =  "wrapping_ref" ,  since =  "1.14.0" )]}# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  BitAndAssign  for  Wrapping <$t > {# [ inline ] fn  bitand_assign (&  mut  self ,  other :  Wrapping <$t >){*  self = *  self &  other ; }} forward_ref_op_assign ! { impl  BitAndAssign ,  bitand_assign  for  Wrapping <$t >,  Wrapping <$t > }# [ stable ( feature =  "wrapping_neg" ,  since =  "1.10.0" )] impl  Neg  for  Wrapping <$t > { type  Output =  Self ; # [ inline ] fn  neg ( self )->  Self { Wrapping ( 0 )-  self }} forward_ref_unop ! { impl  Neg ,  neg  for  Wrapping <$t >, # [ stable ( feature =  "wrapping_ref" ,  since =  "1.14.0" )]})*)}
macro_rules! __ra_macro_fixture8 {($($t :  ty )*)=>($(impl  Wrapping <$t > { doc_comment ! { concat ! ( "Returns the smallest value that can be represented by this integer type.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(<Wrapping<" ,  stringify ! ($t ),  ">>::MIN, Wrapping(" ,  stringify ! ($t ),  "::MIN));\n```" ), # [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  MIN :  Self =  Self (<$t >::  MIN ); } doc_comment ! { concat ! ( "Returns the largest value that can be represented by this integer type.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(<Wrapping<" ,  stringify ! ($t ),  ">>::MAX, Wrapping(" ,  stringify ! ($t ),  "::MAX));\n```" ), # [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  MAX :  Self =  Self (<$t >::  MAX ); } doc_comment ! { concat ! ( "Returns the number of ones in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(0b01001100" ,  stringify ! ($t ),  ");\n\nassert_eq!(n.count_ones(), 3);\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  count_ones ( self )->  u32 { self .  0 .  count_ones ()}} doc_comment ! { concat ! ( "Returns the number of zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(Wrapping(!0" ,  stringify ! ($t ),  ").count_zeros(), 0);\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  count_zeros ( self )->  u32 { self .  0 .  count_zeros ()}} doc_comment ! { concat ! ( "Returns the number of trailing zeros in the binary representation\nof `self`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(0b0101000" ,  stringify ! ($t ),  ");\n\nassert_eq!(n.trailing_zeros(), 3);\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  trailing_zeros ( self )->  u32 { self .  0 .  trailing_zeros ()}}# [ doc =  " Shifts the bits to the left by a specified amount, `n`," ]# [ doc =  " wrapping the truncated bits to the end of the resulting" ]# [ doc =  " integer." ]# [ doc =  "" ]# [ doc =  " Please note this isn\\\'t the same operation as the `<<` shifting" ]# [ doc =  " operator!" ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " Basic usage:" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " #![feature(wrapping_int_impl)]" ]# [ doc =  " use std::num::Wrapping;" ]# [ doc =  "" ]# [ doc =  " let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);" ]# [ doc =  " let m: Wrapping<i64> = Wrapping(-0x76543210FEDCBA99);" ]# [ doc =  "" ]# [ doc =  " assert_eq!(n.rotate_left(32), m);" ]# [ doc =  " ```" ]# [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  rotate_left ( self ,  n :  u32 )->  Self { Wrapping ( self .  0 .  rotate_left ( n ))}# [ doc =  " Shifts the bits to the right by a specified amount, `n`," ]# [ doc =  " wrapping the truncated bits to the beginning of the resulting" ]# [ doc =  " integer." ]# [ doc =  "" ]# [ doc =  " Please note this isn\\\'t the same operation as the `>>` shifting" ]# [ doc =  " operator!" ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " Basic usage:" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " #![feature(wrapping_int_impl)]" ]# [ doc =  " use std::num::Wrapping;" ]# [ doc =  "" ]# [ doc =  " let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);" ]# [ doc =  " let m: Wrapping<i64> = Wrapping(-0xFEDCBA987654322);" ]# [ doc =  "" ]# [ doc =  " assert_eq!(n.rotate_right(4), m);" ]# [ doc =  " ```" ]# [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  rotate_right ( self ,  n :  u32 )->  Self { Wrapping ( self .  0 .  rotate_right ( n ))}# [ doc =  " Reverses the byte order of the integer." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " Basic usage:" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " #![feature(wrapping_int_impl)]" ]# [ doc =  " use std::num::Wrapping;" ]# [ doc =  "" ]# [ doc =  " let n: Wrapping<i16> = Wrapping(0b0000000_01010101);" ]# [ doc =  " assert_eq!(n, Wrapping(85));" ]# [ doc =  "" ]# [ doc =  " let m = n.swap_bytes();" ]# [ doc =  "" ]# [ doc =  " assert_eq!(m, Wrapping(0b01010101_00000000));" ]# [ doc =  " assert_eq!(m, Wrapping(21760));" ]# [ doc =  " ```" ]# [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  swap_bytes ( self )->  Self { Wrapping ( self .  0 .  swap_bytes ())}# [ doc =  " Reverses the bit pattern of the integer." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " Please note that this example is shared between integer types." ]# [ doc =  " Which explains why `i16` is used here." ]# [ doc =  "" ]# [ doc =  " Basic usage:" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " use std::num::Wrapping;" ]# [ doc =  "" ]# [ doc =  " let n = Wrapping(0b0000000_01010101i16);" ]# [ doc =  " assert_eq!(n, Wrapping(85));" ]# [ doc =  "" ]# [ doc =  " let m = n.reverse_bits();" ]# [ doc =  "" ]# [ doc =  " assert_eq!(m.0 as u16, 0b10101010_00000000);" ]# [ doc =  " assert_eq!(m, Wrapping(-22016));" ]# [ doc =  " ```" ]# [ stable ( feature =  "reverse_bits" ,  since =  "1.37.0" )]# [ rustc_const_stable ( feature =  "const_reverse_bits" ,  since =  "1.37.0" )]# [ inline ]# [ must_use ] pub  const  fn  reverse_bits ( self )->  Self { Wrapping ( self .  0 .  reverse_bits ())} doc_comment ! { concat ! ( "Converts an integer from big endian to the target's endianness.\n\nOn big endian this is a no-op. On little endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(0x1A" ,  stringify ! ($t ),  ");\n\nif cfg!(target_endian = \"big\") {\n    assert_eq!(<Wrapping<" ,  stringify ! ($t ),  ">>::from_be(n), n)\n} else {\n    assert_eq!(<Wrapping<" ,  stringify ! ($t ),  ">>::from_be(n), n.swap_bytes())\n}\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  from_be ( x :  Self )->  Self { Wrapping (<$t >::  from_be ( x .  0 ))}} doc_comment ! { concat ! ( "Converts an integer from little endian to the target's endianness.\n\nOn little endian this is a no-op. On big endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(0x1A" ,  stringify ! ($t ),  ");\n\nif cfg!(target_endian = \"little\") {\n    assert_eq!(<Wrapping<" ,  stringify ! ($t ),  ">>::from_le(n), n)\n} else {\n    assert_eq!(<Wrapping<" ,  stringify ! ($t ),  ">>::from_le(n), n.swap_bytes())\n}\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  from_le ( x :  Self )->  Self { Wrapping (<$t >::  from_le ( x .  0 ))}} doc_comment ! { concat ! ( "Converts `self` to big endian from the target's endianness.\n\nOn big endian this is a no-op. On little endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(0x1A" ,  stringify ! ($t ),  ");\n\nif cfg!(target_endian = \"big\") {\n    assert_eq!(n.to_be(), n)\n} else {\n    assert_eq!(n.to_be(), n.swap_bytes())\n}\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  to_be ( self )->  Self { Wrapping ( self .  0 .  to_be ())}} doc_comment ! { concat ! ( "Converts `self` to little endian from the target's endianness.\n\nOn little endian this is a no-op. On big endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(0x1A" ,  stringify ! ($t ),  ");\n\nif cfg!(target_endian = \"little\") {\n    assert_eq!(n.to_le(), n)\n} else {\n    assert_eq!(n.to_le(), n.swap_bytes())\n}\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  to_le ( self )->  Self { Wrapping ( self .  0 .  to_le ())}} doc_comment ! { concat ! ( "Raises self to the power of `exp`, using exponentiation by squaring.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(Wrapping(3" ,  stringify ! ($t ),  ").pow(4), Wrapping(81));\n```\n\nResults that are too large are wrapped:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(Wrapping(3i8).pow(5), Wrapping(-13));\nassert_eq!(Wrapping(3i8).pow(6), Wrapping(-39));\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  fn  pow ( self ,  exp :  u32 )->  Self { Wrapping ( self .  0 .  wrapping_pow ( exp ))}}})*)}
macro_rules! __ra_macro_fixture9 {($($t :  ty )*)=>($(impl  Wrapping <$t > { doc_comment ! { concat ! ( "Returns the number of leading zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(" ,  stringify ! ($t ),  "::MAX) >> 2;\n\nassert_eq!(n.leading_zeros(), 3);\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  leading_zeros ( self )->  u32 { self .  0 .  leading_zeros ()}} doc_comment ! { concat ! ( "Computes the absolute value of `self`, wrapping around at\nthe boundary of the type.\n\nThe only case where such wrapping can occur is when one takes the absolute value of the negative\nminimal value for the type this is a positive value that is too large to represent in the type. In\nsuch a case, this function returns `MIN` itself.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(Wrapping(100" ,  stringify ! ($t ),  ").abs(), Wrapping(100));\nassert_eq!(Wrapping(-100" ,  stringify ! ($t ),  ").abs(), Wrapping(100));\nassert_eq!(Wrapping(" ,  stringify ! ($t ),  "::MIN).abs(), Wrapping(" ,  stringify ! ($t ),  "::MIN));\nassert_eq!(Wrapping(-128i8).abs().0 as u8, 128u8);\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  fn  abs ( self )->  Wrapping <$t > { Wrapping ( self .  0 .  wrapping_abs ())}} doc_comment ! { concat ! ( "Returns a number representing sign of `self`.\n\n - `0` if the number is zero\n - `1` if the number is positive\n - `-1` if the number is negative\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(Wrapping(10" ,  stringify ! ($t ),  ").signum(), Wrapping(1));\nassert_eq!(Wrapping(0" ,  stringify ! ($t ),  ").signum(), Wrapping(0));\nassert_eq!(Wrapping(-10" ,  stringify ! ($t ),  ").signum(), Wrapping(-1));\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  fn  signum ( self )->  Wrapping <$t > { Wrapping ( self .  0 .  signum ())}} doc_comment ! { concat ! ( "Returns `true` if `self` is positive and `false` if the number is zero or\nnegative.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert!(Wrapping(10" ,  stringify ! ($t ),  ").is_positive());\nassert!(!Wrapping(-10" ,  stringify ! ($t ),  ").is_positive());\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  is_positive ( self )->  bool { self .  0 .  is_positive ()}} doc_comment ! { concat ! ( "Returns `true` if `self` is negative and `false` if the number is zero or\npositive.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert!(Wrapping(-10" ,  stringify ! ($t ),  ").is_negative());\nassert!(!Wrapping(10" ,  stringify ! ($t ),  ").is_negative());\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  is_negative ( self )->  bool { self .  0 .  is_negative ()}}})*)}
macro_rules! __ra_macro_fixture10 {($($t :  ty )*)=>($(impl  Wrapping <$t > { doc_comment ! { concat ! ( "Returns the number of leading zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(" ,  stringify ! ($t ),  "::MAX) >> 2;\n\nassert_eq!(n.leading_zeros(), 2);\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  const  fn  leading_zeros ( self )->  u32 { self .  0 .  leading_zeros ()}} doc_comment ! { concat ! ( "Returns `true` if and only if `self == 2^k` for some `k`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert!(Wrapping(16" ,  stringify ! ($t ),  ").is_power_of_two());\nassert!(!Wrapping(10" ,  stringify ! ($t ),  ").is_power_of_two());\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_int_impl" ,  issue =  "32463" )] pub  fn  is_power_of_two ( self )->  bool { self .  0 .  is_power_of_two ()}} doc_comment ! { concat ! ( "Returns the smallest power of two greater than or equal to `self`.\n\nWhen return value overflows (i.e., `self > (1 << (N-1))` for type\n`uN`), overflows to `2^N = 0`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_next_power_of_two)]\nuse std::num::Wrapping;\n\nassert_eq!(Wrapping(2" ,  stringify ! ($t ),  ").next_power_of_two(), Wrapping(2));\nassert_eq!(Wrapping(3" ,  stringify ! ($t ),  ").next_power_of_two(), Wrapping(4));\nassert_eq!(Wrapping(200_u8).next_power_of_two(), Wrapping(0));\n```" ), # [ inline ]# [ unstable ( feature =  "wrapping_next_power_of_two" ,  issue =  "32463" ,  reason =  "needs decision on wrapping behaviour" )] pub  fn  next_power_of_two ( self )->  Self { Wrapping ( self .  0 .  wrapping_next_power_of_two ())}}})*)}
macro_rules! __ra_macro_fixture11 {($($t :  ty )*)=>{$(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  FromStr  for $t { type  Err =  ParseIntError ;  fn  from_str ( src : &  str )->  Result <  Self ,  ParseIntError > { from_str_radix ( src ,  10 )}})*}}
macro_rules! __ra_macro_fixture12 {($($t :  ty )*)=>($(impl  FromStrRadixHelper  for $t {# [ inline ] fn  min_value ()->  Self { Self ::  MIN }# [ inline ] fn  max_value ()->  Self { Self ::  MAX }# [ inline ] fn  from_u32 ( u :  u32 )->  Self { u  as  Self }# [ inline ] fn  checked_mul (&  self ,  other :  u32 )->  Option <  Self > { Self ::  checked_mul (*  self ,  other  as  Self )}# [ inline ] fn  checked_sub (&  self ,  other :  u32 )->  Option <  Self > { Self ::  checked_sub (*  self ,  other  as  Self )}# [ inline ] fn  checked_add (&  self ,  other :  u32 )->  Option <  Self > { Self ::  checked_add (*  self ,  other  as  Self )}})*)}
macro_rules! __ra_macro_fixture13 {($($Arg :  ident ),+)=>{ fnptr_impls_safety_abi ! { extern  "Rust"  fn ($($Arg ),+)->  Ret , $($Arg ),+ } fnptr_impls_safety_abi ! { extern  "C"  fn ($($Arg ),+)->  Ret , $($Arg ),+ } fnptr_impls_safety_abi ! { extern  "C"  fn ($($Arg ),+ , ...)->  Ret , $($Arg ),+ } fnptr_impls_safety_abi ! { unsafe  extern  "Rust"  fn ($($Arg ),+)->  Ret , $($Arg ),+ } fnptr_impls_safety_abi ! { unsafe  extern  "C"  fn ($($Arg ),+)->  Ret , $($Arg ),+ } fnptr_impls_safety_abi ! { unsafe  extern  "C"  fn ($($Arg ),+ , ...)->  Ret , $($Arg ),+ }}; ()=>{ fnptr_impls_safety_abi ! { extern  "Rust"  fn ()->  Ret , } fnptr_impls_safety_abi ! { extern  "C"  fn ()->  Ret , } fnptr_impls_safety_abi ! { unsafe  extern  "Rust"  fn ()->  Ret , } fnptr_impls_safety_abi ! { unsafe  extern  "C"  fn ()->  Ret , }}; }
macro_rules! __ra_macro_fixture14 {($($t :  ty )*)=>{$(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Clone  for $t {# [ inline ] fn  clone (&  self )->  Self {*  self }})* }}
macro_rules! __ra_macro_fixture15 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  PartialEq  for $t {# [ inline ] fn  eq (&  self ,  other : &$t )->  bool {(*  self )== (*  other )}# [ inline ] fn  ne (&  self ,  other : &$t )->  bool {(*  self )!= (*  other )}})*)}
macro_rules! __ra_macro_fixture16 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Eq  for $t {})*)}
macro_rules! __ra_macro_fixture17 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  PartialOrd  for $t {# [ inline ] fn  partial_cmp (&  self ,  other : &$t )->  Option <  Ordering > { match ( self <=  other ,  self >=  other ){( false ,  false )=> None , ( false ,  true )=> Some ( Greater ), ( true ,  false )=> Some ( Less ), ( true ,  true )=> Some ( Equal ), }}# [ inline ] fn  lt (&  self ,  other : &$t )->  bool {(*  self )< (*  other )}# [ inline ] fn  le (&  self ,  other : &$t )->  bool {(*  self )<= (*  other )}# [ inline ] fn  ge (&  self ,  other : &$t )->  bool {(*  self )>= (*  other )}# [ inline ] fn  gt (&  self ,  other : &$t )->  bool {(*  self )> (*  other )}})*)}
macro_rules! __ra_macro_fixture18 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  PartialOrd  for $t {# [ inline ] fn  partial_cmp (&  self ,  other : &$t )->  Option <  Ordering > { Some ( self .  cmp ( other ))}# [ inline ] fn  lt (&  self ,  other : &$t )->  bool {(*  self )< (*  other )}# [ inline ] fn  le (&  self ,  other : &$t )->  bool {(*  self )<= (*  other )}# [ inline ] fn  ge (&  self ,  other : &$t )->  bool {(*  self )>= (*  other )}# [ inline ] fn  gt (&  self ,  other : &$t )->  bool {(*  self )> (*  other )}}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Ord  for $t {# [ inline ] fn  cmp (&  self ,  other : &$t )->  Ordering { if *  self < *  other { Less } else  if *  self == *  other { Equal } else { Greater }}})*)}
macro_rules! __ra_macro_fixture19 {($Float :  ident =>$($Int :  ident )+ )=>{# [ unstable ( feature =  "convert_float_to_int" ,  issue =  "67057" )] impl  private ::  Sealed  for $Float {}$(# [ unstable ( feature =  "convert_float_to_int" ,  issue =  "67057" )] impl  FloatToInt <$Int >  for $Float {# [ doc ( hidden )]# [ inline ] unsafe  fn  to_int_unchecked ( self )-> $Int { unsafe { crate ::  intrinsics ::  float_to_int_unchecked ( self )}}})+ }}
macro_rules! __ra_macro_fixture20 {($target :  ty , # [$attr :  meta ])=>{ impl_from ! ( bool , $target , # [$attr ],  concat ! ( "Converts a `bool` to a `" ,  stringify ! ($target ),  "`. The resulting value is `0` for `false` and `1` for `true`\nvalues.\n\n# Examples\n\n```\nassert_eq!(" ,  stringify ! ($target ),  "::from(true), 1);\nassert_eq!(" ,  stringify ! ($target ),  "::from(false), 0);\n```" )); }; }
macro_rules! __ra_macro_fixture21 {($Small :  ty , $Large :  ty , # [$attr :  meta ], $doc :  expr )=>{# [$attr ]# [ doc = $doc ] impl  From <$Small >  for $Large {# [ inline ] fn  from ( small : $Small )->  Self { small  as  Self }}}; ($Small :  ty , $Large :  ty , # [$attr :  meta ])=>{ impl_from ! ($Small , $Large , # [$attr ],  concat ! ( "Converts `" ,  stringify ! ($Small ),  "` to `" ,  stringify ! ($Large ),  "` losslessly." )); }}
macro_rules! __ra_macro_fixture22 {($source :  ty , $($target :  ty ),*)=>{$(# [ stable ( feature =  "try_from" ,  since =  "1.34.0" )] impl  TryFrom <$source >  for $target { type  Error =  TryFromIntError ; # [ doc =  " Try to create the target number type from a source" ]# [ doc =  " number type. This returns an error if the source value" ]# [ doc =  " is outside of the range of the target type." ]# [ inline ] fn  try_from ( u : $source )->  Result <  Self ,  Self ::  Error > { if  u > ( Self ::  MAX  as $source ){ Err ( TryFromIntError (()))} else { Ok ( u  as  Self )}}})*}}
macro_rules! __ra_macro_fixture23 {($source :  ty , $($target :  ty ),*)=>{$(# [ stable ( feature =  "try_from" ,  since =  "1.34.0" )] impl  TryFrom <$source >  for $target { type  Error =  TryFromIntError ; # [ doc =  " Try to create the target number type from a source" ]# [ doc =  " number type. This returns an error if the source value" ]# [ doc =  " is outside of the range of the target type." ]# [ inline ] fn  try_from ( u : $source )->  Result <  Self ,  Self ::  Error > { let  min =  Self ::  MIN  as $source ;  let  max =  Self ::  MAX  as $source ;  if  u <  min ||  u >  max { Err ( TryFromIntError (()))} else { Ok ( u  as  Self )}}})*}}
macro_rules! __ra_macro_fixture24 {($source :  ty , $($target :  ty ),*)=>{$(# [ stable ( feature =  "try_from" ,  since =  "1.34.0" )] impl  TryFrom <$source >  for $target { type  Error =  TryFromIntError ; # [ doc =  " Try to create the target number type from a source" ]# [ doc =  " number type. This returns an error if the source value" ]# [ doc =  " is outside of the range of the target type." ]# [ inline ] fn  try_from ( u : $source )->  Result <  Self ,  Self ::  Error > { if  u >=  0 { Ok ( u  as  Self )} else { Err ( TryFromIntError (()))}}})*}}
macro_rules! __ra_macro_fixture25 {($source :  ty , $($target :  ty ),*)=>{$(# [ stable ( feature =  "try_from" ,  since =  "1.34.0" )] impl  TryFrom <$source >  for $target { type  Error =  TryFromIntError ; # [ doc =  " Try to create the target number type from a source" ]# [ doc =  " number type. This returns an error if the source value" ]# [ doc =  " is outside of the range of the target type." ]# [ inline ] fn  try_from ( value : $source )->  Result <  Self ,  Self ::  Error > { Ok ( value  as  Self )}})*}}
macro_rules! __ra_macro_fixture26 {($mac :  ident , $source :  ty , $($target :  ty ),*)=>{$($mac ! ($target , $source ); )*}}
macro_rules! __ra_macro_fixture27 {($Small :  ty , $Large :  ty , # [$attr :  meta ], $doc :  expr )=>{# [$attr ]# [ doc = $doc ] impl  From <$Small >  for $Large {# [ inline ] fn  from ( small : $Small )->  Self { unsafe { Self ::  new_unchecked ( small .  get ().  into ())}}}}; ($Small :  ty , $Large :  ty , # [$attr :  meta ])=>{ nzint_impl_from ! ($Small , $Large , # [$attr ],  concat ! ( "Converts `" ,  stringify ! ($Small ),  "` to `" ,  stringify ! ($Large ),  "` losslessly." )); }}
macro_rules! __ra_macro_fixture28 {($Int :  ty , $NonZeroInt :  ty , # [$attr :  meta ], $doc :  expr )=>{# [$attr ]# [ doc = $doc ] impl  TryFrom <$Int >  for $NonZeroInt { type  Error =  TryFromIntError ; # [ inline ] fn  try_from ( value : $Int )->  Result <  Self ,  Self ::  Error > { Self ::  new ( value ).  ok_or ( TryFromIntError (()))}}}; ($Int :  ty , $NonZeroInt :  ty , # [$attr :  meta ])=>{ nzint_impl_try_from_int ! ($Int , $NonZeroInt , # [$attr ],  concat ! ( "Attempts to convert `" ,  stringify ! ($Int ),  "` to `" ,  stringify ! ($NonZeroInt ),  "`." )); }}
macro_rules! __ra_macro_fixture29 {($From :  ty =>$To :  ty , $doc :  expr )=>{# [ stable ( feature =  "nzint_try_from_nzint_conv" ,  since =  "1.49.0" )]# [ doc = $doc ] impl  TryFrom <$From >  for $To { type  Error =  TryFromIntError ; # [ inline ] fn  try_from ( value : $From )->  Result <  Self ,  Self ::  Error > { TryFrom ::  try_from ( value .  get ()).  map (|  v | { unsafe { Self ::  new_unchecked ( v )}})}}}; ($To :  ty : $($From :  ty ),*)=>{$(nzint_impl_try_from_nzint ! ($From =>$To ,  concat ! ( "Attempts to convert `" ,  stringify ! ($From ),  "` to `" ,  stringify ! ($To ),  "`." , )); )*}; }
macro_rules! __ra_macro_fixture30 {($t :  ty , $v :  expr , $doc :  tt )=>{# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Default  for $t {# [ inline ]# [ doc = $doc ] fn  default ()-> $t {$v }}}}
macro_rules! __ra_macro_fixture31 {($t :  ident )=>{# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <  T : ?  Sized >  Hash  for $t <  T > {# [ inline ] fn  hash <  H :  Hasher > (&  self , _: &  mut  H ){}}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <  T : ?  Sized >  cmp ::  PartialEq  for $t <  T > { fn  eq (&  self ,  _other : &$t <  T >)->  bool { true }}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <  T : ?  Sized >  cmp ::  Eq  for $t <  T > {}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <  T : ?  Sized >  cmp ::  PartialOrd  for $t <  T > { fn  partial_cmp (&  self ,  _other : &$t <  T >)->  Option <  cmp ::  Ordering > { Option ::  Some ( cmp ::  Ordering ::  Equal )}}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <  T : ?  Sized >  cmp ::  Ord  for $t <  T > { fn  cmp (&  self ,  _other : &$t <  T >)->  cmp ::  Ordering { cmp ::  Ordering ::  Equal }}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <  T : ?  Sized >  Copy  for $t <  T > {}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <  T : ?  Sized >  Clone  for $t <  T > { fn  clone (&  self )->  Self { Self }}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <  T : ?  Sized >  Default  for $t <  T > { fn  default ()->  Self { Self }}# [ unstable ( feature =  "structural_match" ,  issue =  "31434" )] impl <  T : ?  Sized >  StructuralPartialEq  for $t <  T > {}# [ unstable ( feature =  "structural_match" ,  issue =  "31434" )] impl <  T : ?  Sized >  StructuralEq  for $t <  T > {}}; }
macro_rules! __ra_macro_fixture32 {($($t :  ty )*)=>{$(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Copy  for $t {})* }}
macro_rules! __ra_macro_fixture33 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Add  for $t { type  Output = $t ; # [ inline ]# [ rustc_inherit_overflow_checks ] fn  add ( self ,  other : $t )-> $t { self +  other }} forward_ref_binop ! { impl  Add ,  add  for $t , $t })*)}
macro_rules! __ra_macro_fixture34 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Sub  for $t { type  Output = $t ; # [ inline ]# [ rustc_inherit_overflow_checks ] fn  sub ( self ,  other : $t )-> $t { self -  other }} forward_ref_binop ! { impl  Sub ,  sub  for $t , $t })*)}
macro_rules! __ra_macro_fixture35 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Mul  for $t { type  Output = $t ; # [ inline ]# [ rustc_inherit_overflow_checks ] fn  mul ( self ,  other : $t )-> $t { self *  other }} forward_ref_binop ! { impl  Mul ,  mul  for $t , $t })*)}
macro_rules! __ra_macro_fixture36 {($($t :  ty )*)=>($(# [ doc =  " This operation rounds towards zero, truncating any" ]# [ doc =  " fractional part of the exact result." ]# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Div  for $t { type  Output = $t ; # [ inline ] fn  div ( self ,  other : $t )-> $t { self /  other }} forward_ref_binop ! { impl  Div ,  div  for $t , $t })*)}
macro_rules! __ra_macro_fixture37 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Div  for $t { type  Output = $t ; # [ inline ] fn  div ( self ,  other : $t )-> $t { self /  other }} forward_ref_binop ! { impl  Div ,  div  for $t , $t })*)}
macro_rules! __ra_macro_fixture38 {($($t :  ty )*)=>($(# [ doc =  " This operation satisfies `n % d == n - (n / d) * d`. The" ]# [ doc =  " result has the same sign as the left operand." ]# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Rem  for $t { type  Output = $t ; # [ inline ] fn  rem ( self ,  other : $t )-> $t { self %  other }} forward_ref_binop ! { impl  Rem ,  rem  for $t , $t })*)}
macro_rules! __ra_macro_fixture39 {($($t :  ty )*)=>($(# [ doc =  " The remainder from the division of two floats." ]# [ doc =  "" ]# [ doc =  " The remainder has the same sign as the dividend and is computed as:" ]# [ doc =  " `x - (x / y).trunc() * y`." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  " ```" ]# [ doc =  " let x: f32 = 50.50;" ]# [ doc =  " let y: f32 = 8.125;" ]# [ doc =  " let remainder = x - (x / y).trunc() * y;" ]# [ doc =  "" ]# [ doc =  " // The answer to both operations is 1.75" ]# [ doc =  " assert_eq!(x % y, remainder);" ]# [ doc =  " ```" ]# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Rem  for $t { type  Output = $t ; # [ inline ] fn  rem ( self ,  other : $t )-> $t { self %  other }} forward_ref_binop ! { impl  Rem ,  rem  for $t , $t })*)}
macro_rules! __ra_macro_fixture40 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Neg  for $t { type  Output = $t ; # [ inline ]# [ rustc_inherit_overflow_checks ] fn  neg ( self )-> $t {-  self }} forward_ref_unop ! { impl  Neg ,  neg  for $t })*)}
macro_rules! __ra_macro_fixture41 {($($t :  ty )+)=>($(# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  AddAssign  for $t {# [ inline ]# [ rustc_inherit_overflow_checks ] fn  add_assign (&  mut  self ,  other : $t ){*  self +=  other }} forward_ref_op_assign ! { impl  AddAssign ,  add_assign  for $t , $t })+)}
macro_rules! __ra_macro_fixture42 {($($t :  ty )+)=>($(# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  SubAssign  for $t {# [ inline ]# [ rustc_inherit_overflow_checks ] fn  sub_assign (&  mut  self ,  other : $t ){*  self -=  other }} forward_ref_op_assign ! { impl  SubAssign ,  sub_assign  for $t , $t })+)}
macro_rules! __ra_macro_fixture43 {($($t :  ty )+)=>($(# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  MulAssign  for $t {# [ inline ]# [ rustc_inherit_overflow_checks ] fn  mul_assign (&  mut  self ,  other : $t ){*  self *=  other }} forward_ref_op_assign ! { impl  MulAssign ,  mul_assign  for $t , $t })+)}
macro_rules! __ra_macro_fixture44 {($($t :  ty )+)=>($(# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  DivAssign  for $t {# [ inline ] fn  div_assign (&  mut  self ,  other : $t ){*  self /=  other }} forward_ref_op_assign ! { impl  DivAssign ,  div_assign  for $t , $t })+)}
macro_rules! __ra_macro_fixture45 {($($t :  ty )+)=>($(# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  RemAssign  for $t {# [ inline ] fn  rem_assign (&  mut  self ,  other : $t ){*  self %=  other }} forward_ref_op_assign ! { impl  RemAssign ,  rem_assign  for $t , $t })+)}
macro_rules! __ra_macro_fixture46 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Not  for $t { type  Output = $t ; # [ inline ] fn  not ( self )-> $t {!  self }} forward_ref_unop ! { impl  Not ,  not  for $t })*)}
macro_rules! __ra_macro_fixture47 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  BitAnd  for $t { type  Output = $t ; # [ inline ] fn  bitand ( self ,  rhs : $t )-> $t { self &  rhs }} forward_ref_binop ! { impl  BitAnd ,  bitand  for $t , $t })*)}
macro_rules! __ra_macro_fixture48 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  BitOr  for $t { type  Output = $t ; # [ inline ] fn  bitor ( self ,  rhs : $t )-> $t { self |  rhs }} forward_ref_binop ! { impl  BitOr ,  bitor  for $t , $t })*)}
macro_rules! __ra_macro_fixture49 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  BitXor  for $t { type  Output = $t ; # [ inline ] fn  bitxor ( self ,  other : $t )-> $t { self ^  other }} forward_ref_binop ! { impl  BitXor ,  bitxor  for $t , $t })*)}
macro_rules! __ra_macro_fixture50 {($($t :  ty )*)=>($(shl_impl ! {$t ,  u8 } shl_impl ! {$t ,  u16 } shl_impl ! {$t ,  u32 } shl_impl ! {$t ,  u64 } shl_impl ! {$t ,  u128 } shl_impl ! {$t ,  usize } shl_impl ! {$t ,  i8 } shl_impl ! {$t ,  i16 } shl_impl ! {$t ,  i32 } shl_impl ! {$t ,  i64 } shl_impl ! {$t ,  i128 } shl_impl ! {$t ,  isize })*)}
macro_rules! __ra_macro_fixture51 {($($t :  ty )*)=>($(shr_impl ! {$t ,  u8 } shr_impl ! {$t ,  u16 } shr_impl ! {$t ,  u32 } shr_impl ! {$t ,  u64 } shr_impl ! {$t ,  u128 } shr_impl ! {$t ,  usize } shr_impl ! {$t ,  i8 } shr_impl ! {$t ,  i16 } shr_impl ! {$t ,  i32 } shr_impl ! {$t ,  i64 } shr_impl ! {$t ,  i128 } shr_impl ! {$t ,  isize })*)}
macro_rules! __ra_macro_fixture52 {($($t :  ty )+)=>($(# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  BitAndAssign  for $t {# [ inline ] fn  bitand_assign (&  mut  self ,  other : $t ){*  self &=  other }} forward_ref_op_assign ! { impl  BitAndAssign ,  bitand_assign  for $t , $t })+)}
macro_rules! __ra_macro_fixture53 {($($t :  ty )+)=>($(# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  BitOrAssign  for $t {# [ inline ] fn  bitor_assign (&  mut  self ,  other : $t ){*  self |=  other }} forward_ref_op_assign ! { impl  BitOrAssign ,  bitor_assign  for $t , $t })+)}
macro_rules! __ra_macro_fixture54 {($($t :  ty )+)=>($(# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  BitXorAssign  for $t {# [ inline ] fn  bitxor_assign (&  mut  self ,  other : $t ){*  self ^=  other }} forward_ref_op_assign ! { impl  BitXorAssign ,  bitxor_assign  for $t , $t })+)}
macro_rules! __ra_macro_fixture55 {($($t :  ty )*)=>($(shl_assign_impl ! {$t ,  u8 } shl_assign_impl ! {$t ,  u16 } shl_assign_impl ! {$t ,  u32 } shl_assign_impl ! {$t ,  u64 } shl_assign_impl ! {$t ,  u128 } shl_assign_impl ! {$t ,  usize } shl_assign_impl ! {$t ,  i8 } shl_assign_impl ! {$t ,  i16 } shl_assign_impl ! {$t ,  i32 } shl_assign_impl ! {$t ,  i64 } shl_assign_impl ! {$t ,  i128 } shl_assign_impl ! {$t ,  isize })*)}
macro_rules! __ra_macro_fixture56 {($($t :  ty )*)=>($(shr_assign_impl ! {$t ,  u8 } shr_assign_impl ! {$t ,  u16 } shr_assign_impl ! {$t ,  u32 } shr_assign_impl ! {$t ,  u64 } shr_assign_impl ! {$t ,  u128 } shr_assign_impl ! {$t ,  usize } shr_assign_impl ! {$t ,  i8 } shr_assign_impl ! {$t ,  i16 } shr_assign_impl ! {$t ,  i32 } shr_assign_impl ! {$t ,  i64 } shr_assign_impl ! {$t ,  i128 } shr_assign_impl ! {$t ,  isize })*)}
macro_rules! __ra_macro_fixture57 {{$n :  expr , $t :  ident $($ts :  ident )*}=>{# [ stable ( since =  "1.4.0" ,  feature =  "array_default" )] impl <  T >  Default  for [ T ; $n ] where  T :  Default { fn  default ()-> [ T ; $n ]{[$t ::  default (), $($ts ::  default ()),*]}} array_impl_default ! {($n -  1 ), $($ts )*}}; {$n :  expr ,}=>{# [ stable ( since =  "1.4.0" ,  feature =  "array_default" )] impl <  T >  Default  for [ T ; $n ]{ fn  default ()-> [ T ; $n ]{[]}}}; }
macro_rules! __ra_macro_fixture58 {($($t :  ty ),+)=>{$(# [ unstable ( feature =  "c_variadic" ,  reason =  "the `c_variadic` feature has not been properly tested on \\n                                 all supported platforms" ,  issue =  "44930" )] impl  sealed_trait ::  VaArgSafe  for $t {})+ }}
macro_rules! __ra_macro_fixture59 {{ narrower  than  or  same  width  as  usize : $([$u_narrower :  ident $i_narrower :  ident ]),+;  wider  than  usize : $([$u_wider :  ident $i_wider :  ident ]),+; }=>{$(# [ allow ( unreachable_patterns )]# [ unstable ( feature =  "step_trait" ,  reason =  "recently redesigned" ,  issue =  "42168" )] unsafe  impl  Step  for $u_narrower { step_identical_methods ! (); # [ inline ] fn  steps_between ( start : &  Self ,  end : &  Self )->  Option <  usize > { if *  start <= *  end { Some ((*  end - *  start ) as  usize )} else { None }}# [ inline ] fn  forward_checked ( start :  Self ,  n :  usize )->  Option <  Self > { match  Self ::  try_from ( n ){ Ok ( n )=> start .  checked_add ( n ),  Err (_)=> None , }}# [ inline ] fn  backward_checked ( start :  Self ,  n :  usize )->  Option <  Self > { match  Self ::  try_from ( n ){ Ok ( n )=> start .  checked_sub ( n ),  Err (_)=> None , }}}# [ allow ( unreachable_patterns )]# [ unstable ( feature =  "step_trait" ,  reason =  "recently redesigned" ,  issue =  "42168" )] unsafe  impl  Step  for $i_narrower { step_identical_methods ! (); # [ inline ] fn  steps_between ( start : &  Self ,  end : &  Self )->  Option <  usize > { if *  start <= *  end { Some ((*  end  as  isize ).  wrapping_sub (*  start  as  isize ) as  usize )} else { None }}# [ inline ] fn  forward_checked ( start :  Self ,  n :  usize )->  Option <  Self > { match $u_narrower ::  try_from ( n ){ Ok ( n )=>{ let  wrapped =  start .  wrapping_add ( n  as  Self );  if  wrapped >=  start { Some ( wrapped )} else { None }} Err (_)=> None , }}# [ inline ] fn  backward_checked ( start :  Self ,  n :  usize )->  Option <  Self > { match $u_narrower ::  try_from ( n ){ Ok ( n )=>{ let  wrapped =  start .  wrapping_sub ( n  as  Self );  if  wrapped <=  start { Some ( wrapped )} else { None }} Err (_)=> None , }}})+ $(# [ allow ( unreachable_patterns )]# [ unstable ( feature =  "step_trait" ,  reason =  "recently redesigned" ,  issue =  "42168" )] unsafe  impl  Step  for $u_wider { step_identical_methods ! (); # [ inline ] fn  steps_between ( start : &  Self ,  end : &  Self )->  Option <  usize > { if *  start <= *  end { usize ::  try_from (*  end - *  start ).  ok ()} else { None }}# [ inline ] fn  forward_checked ( start :  Self ,  n :  usize )->  Option <  Self > { start .  checked_add ( n  as  Self )}# [ inline ] fn  backward_checked ( start :  Self ,  n :  usize )->  Option <  Self > { start .  checked_sub ( n  as  Self )}}# [ allow ( unreachable_patterns )]# [ unstable ( feature =  "step_trait" ,  reason =  "recently redesigned" ,  issue =  "42168" )] unsafe  impl  Step  for $i_wider { step_identical_methods ! (); # [ inline ] fn  steps_between ( start : &  Self ,  end : &  Self )->  Option <  usize > { if *  start <= *  end { match  end .  checked_sub (*  start ){ Some ( result )=> usize ::  try_from ( result ).  ok (),  None => None , }} else { None }}# [ inline ] fn  forward_checked ( start :  Self ,  n :  usize )->  Option <  Self > { start .  checked_add ( n  as  Self )}# [ inline ] fn  backward_checked ( start :  Self ,  n :  usize )->  Option <  Self > { start .  checked_sub ( n  as  Self )}})+ }; }
macro_rules! __ra_macro_fixture60 {($($t :  ty )*)=>($(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  ExactSizeIterator  for  ops ::  Range <$t > {})*)}
macro_rules! __ra_macro_fixture61 {($($t :  ty )*)=>($(# [ stable ( feature =  "inclusive_range" ,  since =  "1.26.0" )] impl  ExactSizeIterator  for  ops ::  RangeInclusive <$t > {})*)}
macro_rules! __ra_macro_fixture62 {(@  impls $zero :  expr , $one :  expr , # [$attr :  meta ], $($a :  ty )*)=>($(# [$attr ] impl  Sum  for $a { fn  sum <  I :  Iterator <  Item =  Self >> ( iter :  I )->  Self { iter .  fold ($zero ,  Add ::  add )}}# [$attr ] impl  Product  for $a { fn  product <  I :  Iterator <  Item =  Self >> ( iter :  I )->  Self { iter .  fold ($one ,  Mul ::  mul )}}# [$attr ] impl < 'a >  Sum <& 'a $a >  for $a { fn  sum <  I :  Iterator <  Item =& 'a  Self >> ( iter :  I )->  Self { iter .  fold ($zero ,  Add ::  add )}}# [$attr ] impl < 'a >  Product <& 'a $a >  for $a { fn  product <  I :  Iterator <  Item =& 'a  Self >> ( iter :  I )->  Self { iter .  fold ($one ,  Mul ::  mul )}})*); ($($a :  ty )*)=>( integer_sum_product ! (@  impls  0 ,  1 , # [ stable ( feature =  "iter_arith_traits" ,  since =  "1.12.0" )], $($a )*);  integer_sum_product ! (@  impls  Wrapping ( 0 ),  Wrapping ( 1 ), # [ stable ( feature =  "wrapping_iter_arith" ,  since =  "1.14.0" )], $(Wrapping <$a >)*); ); }
macro_rules! __ra_macro_fixture63 {($($a :  ident )*)=>($(# [ stable ( feature =  "iter_arith_traits" ,  since =  "1.12.0" )] impl  Sum  for $a { fn  sum <  I :  Iterator <  Item =  Self >> ( iter :  I )->  Self { iter .  fold ( 0.0 ,  Add ::  add )}}# [ stable ( feature =  "iter_arith_traits" ,  since =  "1.12.0" )] impl  Product  for $a { fn  product <  I :  Iterator <  Item =  Self >> ( iter :  I )->  Self { iter .  fold ( 1.0 ,  Mul ::  mul )}}# [ stable ( feature =  "iter_arith_traits" ,  since =  "1.12.0" )] impl < 'a >  Sum <& 'a $a >  for $a { fn  sum <  I :  Iterator <  Item =& 'a  Self >> ( iter :  I )->  Self { iter .  fold ( 0.0 ,  Add ::  add )}}# [ stable ( feature =  "iter_arith_traits" ,  since =  "1.12.0" )] impl < 'a >  Product <& 'a $a >  for $a { fn  product <  I :  Iterator <  Item =& 'a  Self >> ( iter :  I )->  Self { iter .  fold ( 1.0 ,  Mul ::  mul )}})*)}
macro_rules! __ra_macro_fixture64 {($cfg_cas :  meta , $cfg_align :  meta , $stable :  meta , $stable_cxchg :  meta , $stable_debug :  meta , $stable_access :  meta , $stable_from :  meta , $stable_nand :  meta , $const_stable :  meta , $stable_init_const :  meta , $s_int_type :  literal , $int_ref :  expr , $extra_feature :  expr , $min_fn :  ident , $max_fn :  ident , $align :  expr , $atomic_new :  expr , $int_type :  ident $atomic_type :  ident $atomic_init :  ident )=>{# [ doc =  " An integer type which can be safely shared between threads." ]# [ doc =  "" ]# [ doc =  " This type has the same in-memory representation as the underlying" ]# [ doc =  " integer type, [`" ]# [ doc = $s_int_type ]# [ doc =  " `](" ]# [ doc = $int_ref ]# [ doc =  " ). For more about the differences between atomic types and" ]# [ doc =  " non-atomic types as well as information about the portability of" ]# [ doc =  " this type, please see the [module-level documentation]." ]# [ doc =  "" ]# [ doc =  " **Note:** This type is only available on platforms that support" ]# [ doc =  " atomic loads and stores of [`" ]# [ doc = $s_int_type ]# [ doc =  " `](" ]# [ doc = $int_ref ]# [ doc =  " )." ]# [ doc =  "" ]# [ doc =  " [module-level documentation]: crate::sync::atomic" ]# [$stable ]# [ repr ( C ,  align ($align ))] pub  struct $atomic_type { v :  UnsafeCell <$int_type >, }# [ doc =  " An atomic integer initialized to `0`." ]# [$stable_init_const ]# [ rustc_deprecated ( since =  "1.34.0" ,  reason =  "the `new` function is now preferred" ,  suggestion = $atomic_new , )] pub  const $atomic_init : $atomic_type = $atomic_type ::  new ( 0 ); # [$stable ] impl  Default  for $atomic_type {# [ inline ] fn  default ()->  Self { Self ::  new ( Default ::  default ())}}# [$stable_from ] impl  From <$int_type >  for $atomic_type { doc_comment ! { concat ! ( "Converts an `" ,  stringify ! ($int_type ),  "` into an `" ,  stringify ! ($atomic_type ),  "`." ), # [ inline ] fn  from ( v : $int_type )->  Self { Self ::  new ( v )}}}# [$stable_debug ] impl  fmt ::  Debug  for $atomic_type { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter < '_ >)->  fmt ::  Result { fmt ::  Debug ::  fmt (&  self .  load ( Ordering ::  SeqCst ),  f )}}# [$stable ] unsafe  impl  Sync  for $atomic_type {} impl $atomic_type { doc_comment ! { concat ! ( "Creates a new atomic integer.\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::" ,  stringify ! ($atomic_type ),  ";\n\nlet atomic_forty_two = " ,  stringify ! ($atomic_type ),  "::new(42);\n```" ), # [ inline ]# [$stable ]# [$const_stable ] pub  const  fn  new ( v : $int_type )->  Self { Self { v :  UnsafeCell ::  new ( v )}}} doc_comment ! { concat ! ( "Returns a mutable reference to the underlying integer.\n\nThis is safe because the mutable reference guarantees that no other threads are\nconcurrently accessing the atomic data.\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet mut some_var = " ,  stringify ! ($atomic_type ),  "::new(10);\nassert_eq!(*some_var.get_mut(), 10);\n*some_var.get_mut() = 5;\nassert_eq!(some_var.load(Ordering::SeqCst), 5);\n```" ), # [ inline ]# [$stable_access ] pub  fn  get_mut (&  mut  self )-> &  mut $int_type { self .  v .  get_mut ()}} doc_comment ! { concat ! ( "Get atomic access to a `&mut " ,  stringify ! ($int_type ),  "`.\n\n" ,  if_not_8_bit ! {$int_type ,  concat ! ( "**Note:** This function is only available on targets where `" ,  stringify ! ($int_type ),  "` has an alignment of " , $align ,  " bytes." )},  "\n\n# Examples\n\n```\n#![feature(atomic_from_mut)]\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet mut some_int = 123;\nlet a = " ,  stringify ! ($atomic_type ),  "::from_mut(&mut some_int);\na.store(100, Ordering::Relaxed);\nassert_eq!(some_int, 100);\n```\n                " ), # [ inline ]# [$cfg_align ]# [ unstable ( feature =  "atomic_from_mut" ,  issue =  "76314" )] pub  fn  from_mut ( v : &  mut $int_type )-> &  Self { use  crate ::  mem ::  align_of ;  let []= [();  align_of ::<  Self > ()-  align_of ::<$int_type > ()];  unsafe {&* ( v  as *  mut $int_type  as *  mut  Self )}}} doc_comment ! { concat ! ( "Consumes the atomic and returns the contained value.\n\nThis is safe because passing `self` by value guarantees that no other threads are\nconcurrently accessing the atomic data.\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::" ,  stringify ! ($atomic_type ),  ";\n\nlet some_var = " ,  stringify ! ($atomic_type ),  "::new(5);\nassert_eq!(some_var.into_inner(), 5);\n```" ), # [ inline ]# [$stable_access ]# [ rustc_const_unstable ( feature =  "const_cell_into_inner" ,  issue =  "78729" )] pub  const  fn  into_inner ( self )-> $int_type { self .  v .  into_inner ()}} doc_comment ! { concat ! ( "Loads a value from the atomic integer.\n\n`load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\nPossible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n# Panics\n\nPanics if `order` is [`Release`] or [`AcqRel`].\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet some_var = " ,  stringify ! ($atomic_type ),  "::new(5);\n\nassert_eq!(some_var.load(Ordering::Relaxed), 5);\n```" ), # [ inline ]# [$stable ] pub  fn  load (&  self ,  order :  Ordering )-> $int_type { unsafe { atomic_load ( self .  v .  get (),  order )}}} doc_comment ! { concat ! ( "Stores a value into the atomic integer.\n\n`store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n# Panics\n\nPanics if `order` is [`Acquire`] or [`AcqRel`].\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet some_var = " ,  stringify ! ($atomic_type ),  "::new(5);\n\nsome_var.store(10, Ordering::Relaxed);\nassert_eq!(some_var.load(Ordering::Relaxed), 10);\n```" ), # [ inline ]# [$stable ] pub  fn  store (&  self ,  val : $int_type ,  order :  Ordering ){ unsafe { atomic_store ( self .  v .  get (),  val ,  order ); }}} doc_comment ! { concat ! ( "Stores a value into the atomic integer, returning the previous value.\n\n`swap` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n**Note**: This method is only available on platforms that support atomic\noperations on [`" , $s_int_type ,  "`](" , $int_ref ,  ").\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet some_var = " ,  stringify ! ($atomic_type ),  "::new(5);\n\nassert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n```" ), # [ inline ]# [$stable ]# [$cfg_cas ] pub  fn  swap (&  self ,  val : $int_type ,  order :  Ordering )-> $int_type { unsafe { atomic_swap ( self .  v .  get (),  val ,  order )}}} doc_comment ! { concat ! ( "Stores a value into the atomic integer if the current value is the same as\nthe `current` value.\n\nThe return value is always the previous value. If it is equal to `current`, then the\nvalue was updated.\n\n`compare_and_swap` also takes an [`Ordering`] argument which describes the memory\nordering of this operation. Notice that even when using [`AcqRel`], the operation\nmight fail and hence just perform an `Acquire` load, but not have `Release` semantics.\nUsing [`Acquire`] makes the store part of this operation [`Relaxed`] if it\nhappens, and using [`Release`] makes the load part [`Relaxed`].\n\n**Note**: This method is only available on platforms that support atomic\noperations on [`" , $s_int_type ,  "`](" , $int_ref ,  ").\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet some_var = " ,  stringify ! ($atomic_type ),  "::new(5);\n\nassert_eq!(some_var.compare_and_swap(5, 10, Ordering::Relaxed), 5);\nassert_eq!(some_var.load(Ordering::Relaxed), 10);\n\nassert_eq!(some_var.compare_and_swap(6, 12, Ordering::Relaxed), 10);\nassert_eq!(some_var.load(Ordering::Relaxed), 10);\n```" ), # [ inline ]# [$stable ]# [$cfg_cas ] pub  fn  compare_and_swap (&  self ,  current : $int_type ,  new : $int_type ,  order :  Ordering )-> $int_type { match  self .  compare_exchange ( current ,  new ,  order ,  strongest_failure_ordering ( order )){ Ok ( x )=> x ,  Err ( x )=> x , }}} doc_comment ! { concat ! ( "Stores a value into the atomic integer if the current value is the same as\nthe `current` value.\n\nThe return value is a result indicating whether the new value was written and\ncontaining the previous value. On success this value is guaranteed to be equal to\n`current`.\n\n`compare_exchange` takes two [`Ordering`] arguments to describe the memory\nordering of this operation. The first describes the required ordering if the\noperation succeeds while the second describes the required ordering when the\noperation fails. Using [`Acquire`] as success ordering makes the store part\nof this operation [`Relaxed`], and using [`Release`] makes the successful load\n[`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\nand must be equivalent to or weaker than the success ordering.\n\n**Note**: This method is only available on platforms that support atomic\noperations on [`" , $s_int_type ,  "`](" , $int_ref ,  ").\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet some_var = " ,  stringify ! ($atomic_type ),  "::new(5);\n\nassert_eq!(some_var.compare_exchange(5, 10,\n                                     Ordering::Acquire,\n                                     Ordering::Relaxed),\n           Ok(5));\nassert_eq!(some_var.load(Ordering::Relaxed), 10);\n\nassert_eq!(some_var.compare_exchange(6, 12,\n                                     Ordering::SeqCst,\n                                     Ordering::Acquire),\n           Err(10));\nassert_eq!(some_var.load(Ordering::Relaxed), 10);\n```" ), # [ inline ]# [$stable_cxchg ]# [$cfg_cas ] pub  fn  compare_exchange (&  self ,  current : $int_type ,  new : $int_type ,  success :  Ordering ,  failure :  Ordering )->  Result <$int_type , $int_type > { unsafe { atomic_compare_exchange ( self .  v .  get (),  current ,  new ,  success ,  failure )}}} doc_comment ! { concat ! ( "Stores a value into the atomic integer if the current value is the same as\nthe `current` value.\n\nUnlike [`" ,  stringify ! ($atomic_type ),  "::compare_exchange`], this function is allowed to spuriously fail even\nwhen the comparison succeeds, which can result in more efficient code on some\nplatforms. The return value is a result indicating whether the new value was\nwritten and containing the previous value.\n\n`compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\nordering of this operation. The first describes the required ordering if the\noperation succeeds while the second describes the required ordering when the\noperation fails. Using [`Acquire`] as success ordering makes the store part\nof this operation [`Relaxed`], and using [`Release`] makes the successful load\n[`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\nand must be equivalent to or weaker than the success ordering.\n\n**Note**: This method is only available on platforms that support atomic\noperations on [`" , $s_int_type ,  "`](" , $int_ref ,  ").\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet val = " ,  stringify ! ($atomic_type ),  "::new(4);\n\nlet mut old = val.load(Ordering::Relaxed);\nloop {\n    let new = old * 2;\n    match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n        Ok(_) => break,\n        Err(x) => old = x,\n    }\n}\n```" ), # [ inline ]# [$stable_cxchg ]# [$cfg_cas ] pub  fn  compare_exchange_weak (&  self ,  current : $int_type ,  new : $int_type ,  success :  Ordering ,  failure :  Ordering )->  Result <$int_type , $int_type > { unsafe { atomic_compare_exchange_weak ( self .  v .  get (),  current ,  new ,  success ,  failure )}}} doc_comment ! { concat ! ( "Adds to the current value, returning the previous value.\n\nThis operation wraps around on overflow.\n\n`fetch_add` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n**Note**: This method is only available on platforms that support atomic\noperations on [`" , $s_int_type ,  "`](" , $int_ref ,  ").\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet foo = " ,  stringify ! ($atomic_type ),  "::new(0);\nassert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\nassert_eq!(foo.load(Ordering::SeqCst), 10);\n```" ), # [ inline ]# [$stable ]# [$cfg_cas ] pub  fn  fetch_add (&  self ,  val : $int_type ,  order :  Ordering )-> $int_type { unsafe { atomic_add ( self .  v .  get (),  val ,  order )}}} doc_comment ! { concat ! ( "Subtracts from the current value, returning the previous value.\n\nThis operation wraps around on overflow.\n\n`fetch_sub` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n**Note**: This method is only available on platforms that support atomic\noperations on [`" , $s_int_type ,  "`](" , $int_ref ,  ").\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet foo = " ,  stringify ! ($atomic_type ),  "::new(20);\nassert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\nassert_eq!(foo.load(Ordering::SeqCst), 10);\n```" ), # [ inline ]# [$stable ]# [$cfg_cas ] pub  fn  fetch_sub (&  self ,  val : $int_type ,  order :  Ordering )-> $int_type { unsafe { atomic_sub ( self .  v .  get (),  val ,  order )}}} doc_comment ! { concat ! ( "Bitwise \"and\" with the current value.\n\nPerforms a bitwise \"and\" operation on the current value and the argument `val`, and\nsets the new value to the result.\n\nReturns the previous value.\n\n`fetch_and` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n**Note**: This method is only available on platforms that support atomic\noperations on [`" , $s_int_type ,  "`](" , $int_ref ,  ").\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet foo = " ,  stringify ! ($atomic_type ),  "::new(0b101101);\nassert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\nassert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n```" ), # [ inline ]# [$stable ]# [$cfg_cas ] pub  fn  fetch_and (&  self ,  val : $int_type ,  order :  Ordering )-> $int_type { unsafe { atomic_and ( self .  v .  get (),  val ,  order )}}} doc_comment ! { concat ! ( "Bitwise \"nand\" with the current value.\n\nPerforms a bitwise \"nand\" operation on the current value and the argument `val`, and\nsets the new value to the result.\n\nReturns the previous value.\n\n`fetch_nand` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n**Note**: This method is only available on platforms that support atomic\noperations on [`" , $s_int_type ,  "`](" , $int_ref ,  ").\n\n# Examples\n\n```\n" , $extra_feature ,  "\nuse std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet foo = " ,  stringify ! ($atomic_type ),  "::new(0x13);\nassert_eq!(foo.fetch_nand(0x31, Ordering::SeqCst), 0x13);\nassert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n```" ), # [ inline ]# [$stable_nand ]# [$cfg_cas ] pub  fn  fetch_nand (&  self ,  val : $int_type ,  order :  Ordering )-> $int_type { unsafe { atomic_nand ( self .  v .  get (),  val ,  order )}}} doc_comment ! { concat ! ( "Bitwise \"or\" with the current value.\n\nPerforms a bitwise \"or\" operation on the current value and the argument `val`, and\nsets the new value to the result.\n\nReturns the previous value.\n\n`fetch_or` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n**Note**: This method is only available on platforms that support atomic\noperations on [`" , $s_int_type ,  "`](" , $int_ref ,  ").\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet foo = " ,  stringify ! ($atomic_type ),  "::new(0b101101);\nassert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\nassert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n```" ), # [ inline ]# [$stable ]# [$cfg_cas ] pub  fn  fetch_or (&  self ,  val : $int_type ,  order :  Ordering )-> $int_type { unsafe { atomic_or ( self .  v .  get (),  val ,  order )}}} doc_comment ! { concat ! ( "Bitwise \"xor\" with the current value.\n\nPerforms a bitwise \"xor\" operation on the current value and the argument `val`, and\nsets the new value to the result.\n\nReturns the previous value.\n\n`fetch_xor` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n**Note**: This method is only available on platforms that support atomic\noperations on [`" , $s_int_type ,  "`](" , $int_ref ,  ").\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet foo = " ,  stringify ! ($atomic_type ),  "::new(0b101101);\nassert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\nassert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n```" ), # [ inline ]# [$stable ]# [$cfg_cas ] pub  fn  fetch_xor (&  self ,  val : $int_type ,  order :  Ordering )-> $int_type { unsafe { atomic_xor ( self .  v .  get (),  val ,  order )}}} doc_comment ! { concat ! ( "Fetches the value, and applies a function to it that returns an optional\nnew value. Returns a `Result` of `Ok(previous_value)` if the function returned `Some(_)`, else\n`Err(previous_value)`.\n\nNote: This may call the function multiple times if the value has been changed from other threads in\nthe meantime, as long as the function returns `Some(_)`, but the function will have been applied\nonly once to the stored value.\n\n`fetch_update` takes two [`Ordering`] arguments to describe the memory ordering of this operation.\nThe first describes the required ordering for when the operation finally succeeds while the second\ndescribes the required ordering for loads. These correspond to the success and failure orderings of\n[`" ,  stringify ! ($atomic_type ),  "::compare_exchange`] respectively.\n\nUsing [`Acquire`] as success ordering makes the store part\nof this operation [`Relaxed`], and using [`Release`] makes the final successful load\n[`Relaxed`]. The (failed) load ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\nand must be equivalent to or weaker than the success ordering.\n\n**Note**: This method is only available on platforms that support atomic\noperations on [`" , $s_int_type ,  "`](" , $int_ref ,  ").\n\n# Examples\n\n```rust\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet x = " ,  stringify ! ($atomic_type ),  "::new(7);\nassert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(7));\nassert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(7));\nassert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(8));\nassert_eq!(x.load(Ordering::SeqCst), 9);\n```" ), # [ inline ]# [ stable ( feature =  "no_more_cas" ,  since =  "1.45.0" )]# [$cfg_cas ] pub  fn  fetch_update <  F > (&  self ,  set_order :  Ordering ,  fetch_order :  Ordering ,  mut  f :  F )->  Result <$int_type , $int_type >  where  F :  FnMut ($int_type )->  Option <$int_type > { let  mut  prev =  self .  load ( fetch_order );  while  let  Some ( next )=  f ( prev ){ match  self .  compare_exchange_weak ( prev ,  next ,  set_order ,  fetch_order ){ x @  Ok (_)=> return  x ,  Err ( next_prev )=> prev =  next_prev }} Err ( prev )}} doc_comment ! { concat ! ( "Maximum with the current value.\n\nFinds the maximum of the current value and the argument `val`, and\nsets the new value to the result.\n\nReturns the previous value.\n\n`fetch_max` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n**Note**: This method is only available on platforms that support atomic\noperations on [`" , $s_int_type ,  "`](" , $int_ref ,  ").\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet foo = " ,  stringify ! ($atomic_type ),  "::new(23);\nassert_eq!(foo.fetch_max(42, Ordering::SeqCst), 23);\nassert_eq!(foo.load(Ordering::SeqCst), 42);\n```\n\nIf you want to obtain the maximum value in one step, you can use the following:\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet foo = " ,  stringify ! ($atomic_type ),  "::new(23);\nlet bar = 42;\nlet max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\nassert!(max_foo == 42);\n```" ), # [ inline ]# [ stable ( feature =  "atomic_min_max" ,  since =  "1.45.0" )]# [$cfg_cas ] pub  fn  fetch_max (&  self ,  val : $int_type ,  order :  Ordering )-> $int_type { unsafe {$max_fn ( self .  v .  get (),  val ,  order )}}} doc_comment ! { concat ! ( "Minimum with the current value.\n\nFinds the minimum of the current value and the argument `val`, and\nsets the new value to the result.\n\nReturns the previous value.\n\n`fetch_min` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n**Note**: This method is only available on platforms that support atomic\noperations on [`" , $s_int_type ,  "`](" , $int_ref ,  ").\n\n# Examples\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet foo = " ,  stringify ! ($atomic_type ),  "::new(23);\nassert_eq!(foo.fetch_min(42, Ordering::Relaxed), 23);\nassert_eq!(foo.load(Ordering::Relaxed), 23);\nassert_eq!(foo.fetch_min(22, Ordering::Relaxed), 23);\nassert_eq!(foo.load(Ordering::Relaxed), 22);\n```\n\nIf you want to obtain the minimum value in one step, you can use the following:\n\n```\n" , $extra_feature ,  "use std::sync::atomic::{" ,  stringify ! ($atomic_type ),  ", Ordering};\n\nlet foo = " ,  stringify ! ($atomic_type ),  "::new(23);\nlet bar = 12;\nlet min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\nassert_eq!(min_foo, 12);\n```" ), # [ inline ]# [ stable ( feature =  "atomic_min_max" ,  since =  "1.45.0" )]# [$cfg_cas ] pub  fn  fetch_min (&  self ,  val : $int_type ,  order :  Ordering )-> $int_type { unsafe {$min_fn ( self .  v .  get (),  val ,  order )}}} doc_comment ! { concat ! ( "Returns a mutable pointer to the underlying integer.\n\nDoing non-atomic reads and writes on the resulting integer can be a data race.\nThis method is mostly useful for FFI, where the function signature may use\n`*mut " ,  stringify ! ($int_type ),  "` instead of `&" ,  stringify ! ($atomic_type ),  "`.\n\nReturning an `*mut` pointer from a shared reference to this atomic is safe because the\natomic types work with interior mutability. All modifications of an atomic change the value\nthrough a shared reference, and can do so safely as long as they use atomic operations. Any\nuse of the returned raw pointer requires an `unsafe` block and still has to uphold the same\nrestriction: operations on it must be atomic.\n\n# Examples\n\n```ignore (extern-declaration)\n# fn main() {\n" , $extra_feature ,  "use std::sync::atomic::" ,  stringify ! ($atomic_type ),  ";\n\nextern {\n    fn my_atomic_op(arg: *mut " ,  stringify ! ($int_type ),  ");\n}\n\nlet mut atomic = " ,  stringify ! ($atomic_type ),  "::new(1);\n" ,  "unsafe {\n    my_atomic_op(atomic.as_mut_ptr());\n}\n# }\n```" ), # [ inline ]# [ unstable ( feature =  "atomic_mut_ptr" ,  reason =  "recently added" ,  issue =  "66893" )] pub  fn  as_mut_ptr (&  self )-> *  mut $int_type { self .  v .  get ()}}}}}
macro_rules! __ra_macro_fixture65 {($($target_pointer_width :  literal $align :  literal )* )=>{$(# [ cfg ( target_has_atomic_load_store =  "ptr" )]# [ cfg ( target_pointer_width = $target_pointer_width )] atomic_int ! { cfg ( target_has_atomic =  "ptr" ),  cfg ( target_has_atomic_equal_alignment =  "ptr" ),  stable ( feature =  "rust1" ,  since =  "1.0.0" ),  stable ( feature =  "extended_compare_and_swap" ,  since =  "1.10.0" ),  stable ( feature =  "atomic_debug" ,  since =  "1.3.0" ),  stable ( feature =  "atomic_access" ,  since =  "1.15.0" ),  stable ( feature =  "atomic_from" ,  since =  "1.23.0" ),  stable ( feature =  "atomic_nand" ,  since =  "1.27.0" ),  rustc_const_stable ( feature =  "const_integer_atomics" ,  since =  "1.34.0" ),  stable ( feature =  "rust1" ,  since =  "1.0.0" ),  "isize" ,  "../../../std/primitive.isize.html" ,  "" ,  atomic_min ,  atomic_max , $align ,  "AtomicIsize::new(0)" ,  isize  AtomicIsize  ATOMIC_ISIZE_INIT }# [ cfg ( target_has_atomic_load_store =  "ptr" )]# [ cfg ( target_pointer_width = $target_pointer_width )] atomic_int ! { cfg ( target_has_atomic =  "ptr" ),  cfg ( target_has_atomic_equal_alignment =  "ptr" ),  stable ( feature =  "rust1" ,  since =  "1.0.0" ),  stable ( feature =  "extended_compare_and_swap" ,  since =  "1.10.0" ),  stable ( feature =  "atomic_debug" ,  since =  "1.3.0" ),  stable ( feature =  "atomic_access" ,  since =  "1.15.0" ),  stable ( feature =  "atomic_from" ,  since =  "1.23.0" ),  stable ( feature =  "atomic_nand" ,  since =  "1.27.0" ),  rustc_const_stable ( feature =  "const_integer_atomics" ,  since =  "1.34.0" ),  stable ( feature =  "rust1" ,  since =  "1.0.0" ),  "usize" ,  "../../../std/primitive.usize.html" ,  "" ,  atomic_umin ,  atomic_umax , $align ,  "AtomicUsize::new(0)" ,  usize  AtomicUsize  ATOMIC_USIZE_INIT })* }; }
macro_rules! __ra_macro_fixture66 {($ty :  ident )=>{# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Debug  for $ty { fn  fmt (&  self ,  fmt : &  mut  Formatter < '_ >)->  Result { float_to_decimal_common ( fmt ,  self ,  true ,  1 )}}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Display  for $ty { fn  fmt (&  self ,  fmt : &  mut  Formatter < '_ >)->  Result { float_to_decimal_common ( fmt ,  self ,  false ,  0 )}}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  LowerExp  for $ty { fn  fmt (&  self ,  fmt : &  mut  Formatter < '_ >)->  Result { float_to_exponential_common ( fmt ,  self ,  false )}}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  UpperExp  for $ty { fn  fmt (&  self ,  fmt : &  mut  Formatter < '_ >)->  Result { float_to_exponential_common ( fmt ,  self ,  true )}}}; }
macro_rules! __ra_macro_fixture67 {($($t :  ident )*)=>($(impl  DisplayInt  for $t { fn  zero ()->  Self { 0 } fn  from_u8 ( u :  u8 )->  Self { u  as  Self } fn  to_u8 (&  self )->  u8 {*  self  as  u8 } fn  to_u16 (&  self )->  u16 {*  self  as  u16 } fn  to_u32 (&  self )->  u32 {*  self  as  u32 } fn  to_u64 (&  self )->  u64 {*  self  as  u64 } fn  to_u128 (&  self )->  u128 {*  self  as  u128 }})* )}
macro_rules! __ra_macro_fixture68 {($($t :  ident )*)=>($(impl  DisplayInt  for $t { fn  zero ()->  Self { 0 } fn  from_u8 ( u :  u8 )->  Self { u  as  Self } fn  to_u8 (&  self )->  u8 {*  self  as  u8 } fn  to_u16 (&  self )->  u16 {*  self  as  u16 } fn  to_u32 (&  self )->  u32 {*  self  as  u32 } fn  to_u64 (&  self )->  u64 {*  self  as  u64 } fn  to_u128 (&  self )->  u128 {*  self  as  u128 }})* )}
macro_rules! __ra_macro_fixture69 {($T :  ident , $base :  expr , $prefix :  expr , $($x :  pat =>$conv :  expr ),+)=>{ impl  GenericRadix  for $T { const  BASE :  u8 = $base ;  const  PREFIX : & 'static  str = $prefix ;  fn  digit ( x :  u8 )->  u8 { match  x {$($x =>$conv ,)+  x => panic ! ( "number not in the range 0..={}: {}" ,  Self ::  BASE -  1 ,  x ), }}}}}
macro_rules! __ra_macro_fixture70 {($Int :  ident , $Uint :  ident )=>{ int_base ! { fmt ::  Binary  for $Int  as $Uint ->  Binary } int_base ! { fmt ::  Octal  for $Int  as $Uint ->  Octal } int_base ! { fmt ::  LowerHex  for $Int  as $Uint ->  LowerHex } int_base ! { fmt ::  UpperHex  for $Int  as $Uint ->  UpperHex } int_base ! { fmt ::  Binary  for $Uint  as $Uint ->  Binary } int_base ! { fmt ::  Octal  for $Uint  as $Uint ->  Octal } int_base ! { fmt ::  LowerHex  for $Uint  as $Uint ->  LowerHex } int_base ! { fmt ::  UpperHex  for $Uint  as $Uint ->  UpperHex }}; }
macro_rules! __ra_macro_fixture71 {($($T :  ident )*)=>{$(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  fmt ::  Debug  for $T {# [ inline ] fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter < '_ >)->  fmt ::  Result { if  f .  debug_lower_hex (){ fmt ::  LowerHex ::  fmt ( self ,  f )} else  if  f .  debug_upper_hex (){ fmt ::  UpperHex ::  fmt ( self ,  f )} else { fmt ::  Display ::  fmt ( self ,  f )}}})*}; }
macro_rules! __ra_macro_fixture72 {($($t :  ident ),*  as $u :  ident  via $conv_fn :  ident  named $name :  ident )=>{ fn $name ( mut  n : $u ,  is_nonnegative :  bool ,  f : &  mut  fmt ::  Formatter < '_ >)->  fmt ::  Result { let  mut  buf = [ MaybeUninit ::<  u8 >::  uninit ();  39 ];  let  mut  curr =  buf .  len () as  isize ;  let  buf_ptr =  MaybeUninit ::  slice_as_mut_ptr (&  mut  buf );  let  lut_ptr =  DEC_DIGITS_LUT .  as_ptr ();  unsafe { assert ! ( crate ::  mem ::  size_of ::<$u > ()>=  2 );  while  n >=  10000 { let  rem = ( n %  10000 ) as  isize ;  n /=  10000 ;  let  d1 = ( rem /  100 )<<  1 ;  let  d2 = ( rem %  100 )<<  1 ;  curr -=  4 ;  ptr ::  copy_nonoverlapping ( lut_ptr .  offset ( d1 ),  buf_ptr .  offset ( curr ),  2 );  ptr ::  copy_nonoverlapping ( lut_ptr .  offset ( d2 ),  buf_ptr .  offset ( curr +  2 ),  2 ); } let  mut  n =  n  as  isize ;  if  n >=  100 { let  d1 = ( n %  100 )<<  1 ;  n /=  100 ;  curr -=  2 ;  ptr ::  copy_nonoverlapping ( lut_ptr .  offset ( d1 ),  buf_ptr .  offset ( curr ),  2 ); } if  n <  10 { curr -=  1 ; *  buf_ptr .  offset ( curr )= ( n  as  u8 )+  b'0' ; } else { let  d1 =  n <<  1 ;  curr -=  2 ;  ptr ::  copy_nonoverlapping ( lut_ptr .  offset ( d1 ),  buf_ptr .  offset ( curr ),  2 ); }} let  buf_slice =  unsafe { str ::  from_utf8_unchecked ( slice ::  from_raw_parts ( buf_ptr .  offset ( curr ),  buf .  len ()-  curr  as  usize ))};  f .  pad_integral ( is_nonnegative ,  "" ,  buf_slice )}$(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  fmt ::  Display  for $t {# [ allow ( unused_comparisons )] fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter < '_ >)->  fmt ::  Result { let  is_nonnegative = *  self >=  0 ;  let  n =  if  is_nonnegative { self .$conv_fn ()} else {(!  self .$conv_fn ()).  wrapping_add ( 1 )}; $name ( n ,  is_nonnegative ,  f )}})* }; }
macro_rules! __ra_macro_fixture73 {($($t :  ident ),*  as $u :  ident  via $conv_fn :  ident  named $name :  ident )=>{ fn $name ( mut  n : $u ,  is_nonnegative :  bool ,  upper :  bool ,  f : &  mut  fmt ::  Formatter < '_ > )->  fmt ::  Result { let ( mut  n ,  mut  exponent ,  trailing_zeros ,  added_precision )= { let  mut  exponent =  0 ;  while  n %  10 ==  0 &&  n >=  10 { n /=  10 ;  exponent +=  1 ; } let  trailing_zeros =  exponent ;  let ( added_precision ,  subtracted_precision )=  match  f .  precision (){ Some ( fmt_prec )=>{ let  mut  tmp =  n ;  let  mut  prec =  0 ;  while  tmp >=  10 { tmp /=  10 ;  prec +=  1 ; }( fmt_prec .  saturating_sub ( prec ),  prec .  saturating_sub ( fmt_prec ))} None =>( 0 ,  0 )};  for _  in  1 ..  subtracted_precision { n /=  10 ;  exponent +=  1 ; } if  subtracted_precision !=  0 { let  rem =  n %  10 ;  n /=  10 ;  exponent +=  1 ;  if  rem >=  5 { n +=  1 ; }}( n ,  exponent ,  trailing_zeros ,  added_precision )};  let  mut  buf = [ MaybeUninit ::<  u8 >::  uninit ();  40 ];  let  mut  curr =  buf .  len () as  isize ;  let  buf_ptr =  MaybeUninit ::  slice_as_mut_ptr (&  mut  buf );  let  lut_ptr =  DEC_DIGITS_LUT .  as_ptr ();  while  n >=  100 { let  d1 = (( n %  100 ) as  isize )<<  1 ;  curr -=  2 ;  unsafe { ptr ::  copy_nonoverlapping ( lut_ptr .  offset ( d1 ),  buf_ptr .  offset ( curr ),  2 ); } n /=  100 ;  exponent +=  2 ; } let  mut  n =  n  as  isize ;  if  n >=  10 { curr -=  1 ;  unsafe {*  buf_ptr .  offset ( curr )= ( n  as  u8 %  10_u8 )+  b'0' ; } n /=  10 ;  exponent +=  1 ; } if  exponent !=  trailing_zeros ||  added_precision !=  0 { curr -=  1 ;  unsafe {*  buf_ptr .  offset ( curr )=  b'.' ; }} let  buf_slice =  unsafe { curr -=  1 ; *  buf_ptr .  offset ( curr )= ( n  as  u8 )+  b'0' ;  let  len =  buf .  len ()-  curr  as  usize ;  slice ::  from_raw_parts ( buf_ptr .  offset ( curr ),  len )};  let  mut  exp_buf = [ MaybeUninit ::<  u8 >::  uninit ();  3 ];  let  exp_ptr =  MaybeUninit ::  slice_as_mut_ptr (&  mut  exp_buf );  let  exp_slice =  unsafe {*  exp_ptr .  offset ( 0 )=  if  upper { b'E' } else { b'e' };  let  len =  if  exponent <  10 {*  exp_ptr .  offset ( 1 )= ( exponent  as  u8 )+  b'0' ;  2 } else { let  off =  exponent <<  1 ;  ptr ::  copy_nonoverlapping ( lut_ptr .  offset ( off ),  exp_ptr .  offset ( 1 ),  2 );  3 };  slice ::  from_raw_parts ( exp_ptr ,  len )};  let  parts = & [ flt2dec ::  Part ::  Copy ( buf_slice ),  flt2dec ::  Part ::  Zero ( added_precision ),  flt2dec ::  Part ::  Copy ( exp_slice )];  let  sign =  if !  is_nonnegative { "-" } else  if  f .  sign_plus (){ "+" } else { "" };  let  formatted =  flt2dec ::  Formatted { sign ,  parts };  f .  pad_formatted_parts (&  formatted )}$(# [ stable ( feature =  "integer_exp_format" ,  since =  "1.42.0" )] impl  fmt ::  LowerExp  for $t {# [ allow ( unused_comparisons )] fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter < '_ >)->  fmt ::  Result { let  is_nonnegative = *  self >=  0 ;  let  n =  if  is_nonnegative { self .$conv_fn ()} else {(!  self .$conv_fn ()).  wrapping_add ( 1 )}; $name ( n ,  is_nonnegative ,  false ,  f )}})* $(# [ stable ( feature =  "integer_exp_format" ,  since =  "1.42.0" )] impl  fmt ::  UpperExp  for $t {# [ allow ( unused_comparisons )] fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter < '_ >)->  fmt ::  Result { let  is_nonnegative = *  self >=  0 ;  let  n =  if  is_nonnegative { self .$conv_fn ()} else {(!  self .$conv_fn ()).  wrapping_add ( 1 )}; $name ( n ,  is_nonnegative ,  true ,  f )}})* }; }
macro_rules! __ra_macro_fixture74 {($($tr :  ident ),*)=>{$(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <  T : ?  Sized + $tr > $tr  for &  T { fn  fmt (&  self ,  f : &  mut  Formatter < '_ >)->  Result {$tr ::  fmt (&**  self ,  f )}}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <  T : ?  Sized + $tr > $tr  for &  mut  T { fn  fmt (&  self ,  f : &  mut  Formatter < '_ >)->  Result {$tr ::  fmt (&**  self ,  f )}})* }}
macro_rules! __ra_macro_fixture75 {()=>(); ($($name :  ident ,)+ )=>(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <$($name :  Debug ),+>  Debug  for ($($name ,)+) where  last_type ! ($($name ,)+): ?  Sized {# [ allow ( non_snake_case ,  unused_assignments )] fn  fmt (&  self ,  f : &  mut  Formatter < '_ >)->  Result { let  mut  builder =  f .  debug_tuple ( "" );  let ($(ref $name ,)+)= *  self ; $(builder .  field (&$name ); )+  builder .  finish ()}} peel ! {$($name ,)+ })}
macro_rules! __ra_macro_fixture76 {($(($ty :  ident , $meth :  ident ),)*)=>{$(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Hash  for $ty { fn  hash <  H :  Hasher > (&  self ,  state : &  mut  H ){ state .$meth (*  self )} fn  hash_slice <  H :  Hasher > ( data : & [$ty ],  state : &  mut  H ){ let  newlen =  data .  len ()*  mem ::  size_of ::<$ty > ();  let  ptr =  data .  as_ptr () as *  const  u8 ;  state .  write ( unsafe { slice ::  from_raw_parts ( ptr ,  newlen )})}})*}}
macro_rules! __ra_macro_fixture77 {()=>(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Hash  for (){ fn  hash <  H :  Hasher > (&  self ,  _state : &  mut  H ){}}); ($($name :  ident )+)=>(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <$($name :  Hash ),+>  Hash  for ($($name ,)+) where  last_type ! ($($name ,)+): ?  Sized {# [ allow ( non_snake_case )] fn  hash <  S :  Hasher > (&  self ,  state : &  mut  S ){ let ($(ref $name ,)+)= *  self ; $($name .  hash ( state );)+ }}); }
macro_rules! __ra_macro_fixture78 {($([$($p :  tt )*]$t :  ty ,)*)=>{$(impl <$($p )*>  AlwaysApplicableOrd  for $t {})* }}
macro_rules! __ra_macro_fixture79 {($traitname :  ident , $($ty :  ty )*)=>{$(impl $traitname <$ty >  for $ty {})* }}
macro_rules! __ra_macro_fixture80 {( struct $name :  ident -> $ptr :  ty , $elem :  ty , $raw_mut :  tt , {$($mut_ :  tt )?}, {$($extra :  tt )*})=>{ macro_rules !  next_unchecked {($self :  ident )=>{& $($mut_ )? *$self .  post_inc_start ( 1 )}} macro_rules !  next_back_unchecked {($self :  ident )=>{& $($mut_ )? *$self .  pre_dec_end ( 1 )}} macro_rules !  zst_shrink {($self :  ident , $n :  ident )=>{$self .  end = ($self .  end  as * $raw_mut  u8 ).  wrapping_offset (-$n ) as * $raw_mut  T ; }} impl < 'a ,  T > $name < 'a ,  T > {# [ inline ( always )] fn  make_slice (&  self )-> & 'a [ T ]{ unsafe { from_raw_parts ( self .  ptr .  as_ptr (),  len ! ( self ))}}# [ inline ( always )] unsafe  fn  post_inc_start (&  mut  self ,  offset :  isize )-> * $raw_mut  T { if  mem ::  size_of ::<  T > ()==  0 { zst_shrink ! ( self ,  offset );  self .  ptr .  as_ptr ()} else { let  old =  self .  ptr .  as_ptr ();  self .  ptr =  unsafe { NonNull ::  new_unchecked ( self .  ptr .  as_ptr ().  offset ( offset ))};  old }}# [ inline ( always )] unsafe  fn  pre_dec_end (&  mut  self ,  offset :  isize )-> * $raw_mut  T { if  mem ::  size_of ::<  T > ()==  0 { zst_shrink ! ( self ,  offset );  self .  ptr .  as_ptr ()} else { self .  end =  unsafe { self .  end .  offset (-  offset )};  self .  end }}}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <  T >  ExactSizeIterator  for $name < '_ ,  T > {# [ inline ( always )] fn  len (&  self )->  usize { len ! ( self )}# [ inline ( always )] fn  is_empty (&  self )->  bool { is_empty ! ( self )}}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl < 'a ,  T >  Iterator  for $name < 'a ,  T > { type  Item = $elem ; # [ inline ] fn  next (&  mut  self )->  Option <$elem > { unsafe { assume (!  self .  ptr .  as_ptr ().  is_null ());  if  mem ::  size_of ::<  T > ()!=  0 { assume (!  self .  end .  is_null ()); } if  is_empty ! ( self ){ None } else { Some ( next_unchecked ! ( self ))}}}# [ inline ] fn  size_hint (&  self )-> ( usize ,  Option <  usize >){ let  exact =  len ! ( self ); ( exact ,  Some ( exact ))}# [ inline ] fn  count ( self )->  usize { len ! ( self )}# [ inline ] fn  nth (&  mut  self ,  n :  usize )->  Option <$elem > { if  n >=  len ! ( self ){ if  mem ::  size_of ::<  T > ()==  0 { self .  end =  self .  ptr .  as_ptr (); } else { unsafe { self .  ptr =  NonNull ::  new_unchecked ( self .  end  as *  mut  T ); }} return  None ; } unsafe { self .  post_inc_start ( n  as  isize );  Some ( next_unchecked ! ( self ))}}# [ inline ] fn  last ( mut  self )->  Option <$elem > { self .  next_back ()}# [ inline ] fn  for_each <  F > ( mut  self ,  mut  f :  F ) where  Self :  Sized ,  F :  FnMut ( Self ::  Item ), { while  let  Some ( x )=  self .  next (){ f ( x ); }}# [ inline ] fn  all <  F > (&  mut  self ,  mut  f :  F )->  bool  where  Self :  Sized ,  F :  FnMut ( Self ::  Item )->  bool , { while  let  Some ( x )=  self .  next (){ if !  f ( x ){ return  false ; }} true }# [ inline ] fn  any <  F > (&  mut  self ,  mut  f :  F )->  bool  where  Self :  Sized ,  F :  FnMut ( Self ::  Item )->  bool , { while  let  Some ( x )=  self .  next (){ if  f ( x ){ return  true ; }} false }# [ inline ] fn  find <  P > (&  mut  self ,  mut  predicate :  P )->  Option <  Self ::  Item >  where  Self :  Sized ,  P :  FnMut (&  Self ::  Item )->  bool , { while  let  Some ( x )=  self .  next (){ if  predicate (&  x ){ return  Some ( x ); }} None }# [ inline ] fn  find_map <  B ,  F > (&  mut  self ,  mut  f :  F )->  Option <  B >  where  Self :  Sized ,  F :  FnMut ( Self ::  Item )->  Option <  B >, { while  let  Some ( x )=  self .  next (){ if  let  Some ( y )=  f ( x ){ return  Some ( y ); }} None }# [ inline ]# [ rustc_inherit_overflow_checks ] fn  position <  P > (&  mut  self ,  mut  predicate :  P )->  Option <  usize >  where  Self :  Sized ,  P :  FnMut ( Self ::  Item )->  bool , { let  n =  len ! ( self );  let  mut  i =  0 ;  while  let  Some ( x )=  self .  next (){ if  predicate ( x ){ unsafe { assume ( i <  n )};  return  Some ( i ); } i +=  1 ; } None }# [ inline ] fn  rposition <  P > (&  mut  self ,  mut  predicate :  P )->  Option <  usize >  where  P :  FnMut ( Self ::  Item )->  bool ,  Self :  Sized +  ExactSizeIterator +  DoubleEndedIterator { let  n =  len ! ( self );  let  mut  i =  n ;  while  let  Some ( x )=  self .  next_back (){ i -=  1 ;  if  predicate ( x ){ unsafe { assume ( i <  n )};  return  Some ( i ); }} None }# [ doc ( hidden )] unsafe  fn  __iterator_get_unchecked (&  mut  self ,  idx :  usize )->  Self ::  Item { unsafe {& $($mut_ )? *  self .  ptr .  as_ptr ().  add ( idx )}}$($extra )* }# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl < 'a ,  T >  DoubleEndedIterator  for $name < 'a ,  T > {# [ inline ] fn  next_back (&  mut  self )->  Option <$elem > { unsafe { assume (!  self .  ptr .  as_ptr ().  is_null ());  if  mem ::  size_of ::<  T > ()!=  0 { assume (!  self .  end .  is_null ()); } if  is_empty ! ( self ){ None } else { Some ( next_back_unchecked ! ( self ))}}}# [ inline ] fn  nth_back (&  mut  self ,  n :  usize )->  Option <$elem > { if  n >=  len ! ( self ){ self .  end =  self .  ptr .  as_ptr ();  return  None ; } unsafe { self .  pre_dec_end ( n  as  isize );  Some ( next_back_unchecked ! ( self ))}}}# [ stable ( feature =  "fused" ,  since =  "1.26.0" )] impl <  T >  FusedIterator  for $name < '_ ,  T > {}# [ unstable ( feature =  "trusted_len" ,  issue =  "37572" )] unsafe  impl <  T >  TrustedLen  for $name < '_ ,  T > {}}}
macro_rules! __ra_macro_fixture81 {($name :  ident : $elem :  ident , $iter_of :  ty )=>{# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl < 'a , $elem ,  P >  Iterator  for $name < 'a , $elem ,  P >  where  P :  FnMut (&  T )->  bool , { type  Item = $iter_of ; # [ inline ] fn  next (&  mut  self )->  Option <$iter_of > { self .  inner .  next ()}# [ inline ] fn  size_hint (&  self )-> ( usize ,  Option <  usize >){ self .  inner .  size_hint ()}}# [ stable ( feature =  "fused" ,  since =  "1.26.0" )] impl < 'a , $elem ,  P >  FusedIterator  for $name < 'a , $elem ,  P >  where  P :  FnMut (&  T )->  bool {}}; }
macro_rules! __ra_macro_fixture82 {( clone $t :  ident  with |$s :  ident | $e :  expr )=>{ impl < 'a ,  P >  Clone  for $t < 'a ,  P >  where  P :  Pattern < 'a ,  Searcher :  Clone >, { fn  clone (&  self )->  Self { let $s =  self ; $e }}}; }
macro_rules! __ra_macro_fixture83 {{ forward : $(# [$forward_iterator_attribute :  meta ])*  struct $forward_iterator :  ident ;  reverse : $(# [$reverse_iterator_attribute :  meta ])*  struct $reverse_iterator :  ident ;  stability : $(# [$common_stability_attribute :  meta ])*  internal : $internal_iterator :  ident  yielding ($iterty :  ty );  delegate $($t :  tt )* }=>{$(# [$forward_iterator_attribute ])* $(# [$common_stability_attribute ])*  pub  struct $forward_iterator < 'a ,  P :  Pattern < 'a >> ( pub ( super )$internal_iterator < 'a ,  P >); $(# [$common_stability_attribute ])*  impl < 'a ,  P >  fmt ::  Debug  for $forward_iterator < 'a ,  P >  where  P :  Pattern < 'a ,  Searcher :  fmt ::  Debug >, { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter < '_ >)->  fmt ::  Result { f .  debug_tuple ( stringify ! ($forward_iterator )).  field (&  self .  0 ).  finish ()}}$(# [$common_stability_attribute ])*  impl < 'a ,  P :  Pattern < 'a >>  Iterator  for $forward_iterator < 'a ,  P > { type  Item = $iterty ; # [ inline ] fn  next (&  mut  self )->  Option <$iterty > { self .  0 .  next ()}}$(# [$common_stability_attribute ])*  impl < 'a ,  P >  Clone  for $forward_iterator < 'a ,  P >  where  P :  Pattern < 'a ,  Searcher :  Clone >, { fn  clone (&  self )->  Self {$forward_iterator ( self .  0 .  clone ())}}$(# [$reverse_iterator_attribute ])* $(# [$common_stability_attribute ])*  pub  struct $reverse_iterator < 'a ,  P :  Pattern < 'a >> ( pub ( super )$internal_iterator < 'a ,  P >); $(# [$common_stability_attribute ])*  impl < 'a ,  P >  fmt ::  Debug  for $reverse_iterator < 'a ,  P >  where  P :  Pattern < 'a ,  Searcher :  fmt ::  Debug >, { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter < '_ >)->  fmt ::  Result { f .  debug_tuple ( stringify ! ($reverse_iterator )).  field (&  self .  0 ).  finish ()}}$(# [$common_stability_attribute ])*  impl < 'a ,  P >  Iterator  for $reverse_iterator < 'a ,  P >  where  P :  Pattern < 'a ,  Searcher :  ReverseSearcher < 'a >>, { type  Item = $iterty ; # [ inline ] fn  next (&  mut  self )->  Option <$iterty > { self .  0 .  next_back ()}}$(# [$common_stability_attribute ])*  impl < 'a ,  P >  Clone  for $reverse_iterator < 'a ,  P >  where  P :  Pattern < 'a ,  Searcher :  Clone >, { fn  clone (&  self )->  Self {$reverse_iterator ( self .  0 .  clone ())}}# [ stable ( feature =  "fused" ,  since =  "1.26.0" )] impl < 'a ,  P :  Pattern < 'a >>  FusedIterator  for $forward_iterator < 'a ,  P > {}# [ stable ( feature =  "fused" ,  since =  "1.26.0" )] impl < 'a ,  P >  FusedIterator  for $reverse_iterator < 'a ,  P >  where  P :  Pattern < 'a ,  Searcher :  ReverseSearcher < 'a >>, {} generate_pattern_iterators ! ($($t )*  with $(# [$common_stability_attribute ])*, $forward_iterator , $reverse_iterator , $iterty ); }; { double  ended ;  with $(# [$common_stability_attribute :  meta ])*, $forward_iterator :  ident , $reverse_iterator :  ident , $iterty :  ty }=>{$(# [$common_stability_attribute ])*  impl < 'a ,  P >  DoubleEndedIterator  for $forward_iterator < 'a ,  P >  where  P :  Pattern < 'a ,  Searcher :  DoubleEndedSearcher < 'a >>, {# [ inline ] fn  next_back (&  mut  self )->  Option <$iterty > { self .  0 .  next_back ()}}$(# [$common_stability_attribute ])*  impl < 'a ,  P >  DoubleEndedIterator  for $reverse_iterator < 'a ,  P >  where  P :  Pattern < 'a ,  Searcher :  DoubleEndedSearcher < 'a >>, {# [ inline ] fn  next_back (&  mut  self )->  Option <$iterty > { self .  0 .  next ()}}}; { single  ended ;  with $(# [$common_stability_attribute :  meta ])*, $forward_iterator :  ident , $reverse_iterator :  ident , $iterty :  ty }=>{}}
macro_rules! __ra_macro_fixture84 {($($Name :  ident ),+)=>{$(# [ stable ( feature =  "str_escape" ,  since =  "1.34.0" )] impl < 'a >  fmt ::  Display  for $Name < 'a > { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter < '_ >)->  fmt ::  Result { self .  clone ().  try_for_each (|  c |  f .  write_char ( c ))}}# [ stable ( feature =  "str_escape" ,  since =  "1.34.0" )] impl < 'a >  Iterator  for $Name < 'a > { type  Item =  char ; # [ inline ] fn  next (&  mut  self )->  Option <  char > { self .  inner .  next ()}# [ inline ] fn  size_hint (&  self )-> ( usize ,  Option <  usize >){ self .  inner .  size_hint ()}# [ inline ] fn  try_fold <  Acc ,  Fold ,  R > (&  mut  self ,  init :  Acc ,  fold :  Fold )->  R  where  Self :  Sized ,  Fold :  FnMut ( Acc ,  Self ::  Item )->  R ,  R :  Try <  Ok =  Acc >{ self .  inner .  try_fold ( init ,  fold )}# [ inline ] fn  fold <  Acc ,  Fold > ( self ,  init :  Acc ,  fold :  Fold )->  Acc  where  Fold :  FnMut ( Acc ,  Self ::  Item )->  Acc , { self .  inner .  fold ( init ,  fold )}}# [ stable ( feature =  "str_escape" ,  since =  "1.34.0" )] impl < 'a >  FusedIterator  for $Name < 'a > {})+}}
macro_rules! __ra_macro_fixture85 {($($(# [$attr :  meta ])*  struct $Name :  ident  impl $(<$($lifetime :  lifetime ),+> )?  Fn = |$($arg :  ident : $ArgTy :  ty ),*| -> $ReturnTy :  ty $body :  block ; )+)=>{$($(# [$attr ])*  struct $Name ;  impl $(<$($lifetime ),+> )?  Fn < ($($ArgTy , )*)>  for $Name {# [ inline ] extern  "rust-call"  fn  call (&  self , ($($arg , )*): ($($ArgTy , )*))-> $ReturnTy {$body }} impl $(<$($lifetime ),+> )?  FnMut < ($($ArgTy , )*)>  for $Name {# [ inline ] extern  "rust-call"  fn  call_mut (&  mut  self , ($($arg , )*): ($($ArgTy , )*))-> $ReturnTy { Fn ::  call (&*  self , ($($arg , )*))}} impl $(<$($lifetime ),+> )?  FnOnce < ($($ArgTy , )*)>  for $Name { type  Output = $ReturnTy ; # [ inline ] extern  "rust-call"  fn  call_once ( self , ($($arg , )*): ($($ArgTy , )*))-> $ReturnTy { Fn ::  call (&  self , ($($arg , )*))}})+ }}
macro_rules! __ra_macro_fixture86 {($($Tuple :  ident {$(($idx :  tt )-> $T :  ident )+ })+)=>{$(# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <$($T :  PartialEq ),+>  PartialEq  for ($($T ,)+) where  last_type ! ($($T ,)+): ?  Sized {# [ inline ] fn  eq (&  self ,  other : & ($($T ,)+))->  bool {$(self .$idx ==  other .$idx )&&+ }# [ inline ] fn  ne (&  self ,  other : & ($($T ,)+))->  bool {$(self .$idx !=  other .$idx )||+ }}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <$($T :  Eq ),+>  Eq  for ($($T ,)+) where  last_type ! ($($T ,)+): ?  Sized {}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <$($T :  PartialOrd +  PartialEq ),+>  PartialOrd  for ($($T ,)+) where  last_type ! ($($T ,)+): ?  Sized {# [ inline ] fn  partial_cmp (&  self ,  other : & ($($T ,)+))->  Option <  Ordering > { lexical_partial_cmp ! ($(self .$idx ,  other .$idx ),+)}# [ inline ] fn  lt (&  self ,  other : & ($($T ,)+))->  bool { lexical_ord ! ( lt , $(self .$idx ,  other .$idx ),+)}# [ inline ] fn  le (&  self ,  other : & ($($T ,)+))->  bool { lexical_ord ! ( le , $(self .$idx ,  other .$idx ),+)}# [ inline ] fn  ge (&  self ,  other : & ($($T ,)+))->  bool { lexical_ord ! ( ge , $(self .$idx ,  other .$idx ),+)}# [ inline ] fn  gt (&  self ,  other : & ($($T ,)+))->  bool { lexical_ord ! ( gt , $(self .$idx ,  other .$idx ),+)}}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <$($T :  Ord ),+>  Ord  for ($($T ,)+) where  last_type ! ($($T ,)+): ?  Sized {# [ inline ] fn  cmp (&  self ,  other : & ($($T ,)+))->  Ordering { lexical_cmp ! ($(self .$idx ,  other .$idx ),+)}}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl <$($T :  Default ),+>  Default  for ($($T ,)+){# [ inline ] fn  default ()-> ($($T ,)+){($({let  x : $T =  Default ::  default ();  x },)+)}})+ }}
macro_rules! __ra_macro_fixture87 {($x :  expr , $($tt :  tt )*)=>{# [ doc = $x ]$($tt )* }; }
macro_rules! __ra_macro_fixture88 {($x :  expr , $($tt :  tt )*)=>{# [ doc = $x ]$($tt )* }; }
macro_rules! __ra_macro_fixture89 {(# [$stability :  meta ]($($Trait :  ident ),+ ) for $Ty :  ident )=>{$(# [$stability ] impl  fmt ::$Trait  for $Ty {# [ inline ] fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter < '_ >)->  fmt ::  Result { self .  get ().  fmt ( f )}})+ }}
macro_rules! __ra_macro_fixture90 {($t :  ident , $f :  ident )=>{# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Shl <$f >  for  Wrapping <$t > { type  Output =  Wrapping <$t >; # [ inline ] fn  shl ( self ,  other : $f )->  Wrapping <$t > { Wrapping ( self .  0 .  wrapping_shl (( other &  self ::  shift_max ::$t  as $f ) as  u32 ))}} forward_ref_binop ! { impl  Shl ,  shl  for  Wrapping <$t >, $f , # [ stable ( feature =  "wrapping_ref_ops" ,  since =  "1.39.0" )]}# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  ShlAssign <$f >  for  Wrapping <$t > {# [ inline ] fn  shl_assign (&  mut  self ,  other : $f ){*  self = *  self <<  other ; }} forward_ref_op_assign ! { impl  ShlAssign ,  shl_assign  for  Wrapping <$t >, $f }# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Shr <$f >  for  Wrapping <$t > { type  Output =  Wrapping <$t >; # [ inline ] fn  shr ( self ,  other : $f )->  Wrapping <$t > { Wrapping ( self .  0 .  wrapping_shr (( other &  self ::  shift_max ::$t  as $f ) as  u32 ))}} forward_ref_binop ! { impl  Shr ,  shr  for  Wrapping <$t >, $f , # [ stable ( feature =  "wrapping_ref_ops" ,  since =  "1.39.0" )]}# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  ShrAssign <$f >  for  Wrapping <$t > {# [ inline ] fn  shr_assign (&  mut  self ,  other : $f ){*  self = *  self >>  other ; }} forward_ref_op_assign ! { impl  ShrAssign ,  shr_assign  for  Wrapping <$t >, $f }}; }
macro_rules! __ra_macro_fixture91 {( impl $imp :  ident , $method :  ident  for $t :  ty , $u :  ty )=>{ forward_ref_binop ! ( impl $imp , $method  for $t , $u , # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]); }; ( impl $imp :  ident , $method :  ident  for $t :  ty , $u :  ty , # [$attr :  meta ])=>{# [$attr ] impl < 'a > $imp <$u >  for & 'a $t { type  Output = <$t  as $imp <$u >>::  Output ; # [ inline ] fn $method ( self ,  other : $u )-> <$t  as $imp <$u >>::  Output {$imp ::$method (*  self ,  other )}}# [$attr ] impl $imp <&$u >  for $t { type  Output = <$t  as $imp <$u >>::  Output ; # [ inline ] fn $method ( self ,  other : &$u )-> <$t  as $imp <$u >>::  Output {$imp ::$method ( self , *  other )}}# [$attr ] impl $imp <&$u >  for &$t { type  Output = <$t  as $imp <$u >>::  Output ; # [ inline ] fn $method ( self ,  other : &$u )-> <$t  as $imp <$u >>::  Output {$imp ::$method (*  self , *  other )}}}}
macro_rules! __ra_macro_fixture92 {( impl $imp :  ident , $method :  ident  for $t :  ty , $u :  ty )=>{ forward_ref_op_assign ! ( impl $imp , $method  for $t , $u , # [ stable ( feature =  "op_assign_builtins_by_ref" ,  since =  "1.22.0" )]); }; ( impl $imp :  ident , $method :  ident  for $t :  ty , $u :  ty , # [$attr :  meta ])=>{# [$attr ] impl $imp <&$u >  for $t {# [ inline ] fn $method (&  mut  self ,  other : &$u ){$imp ::$method ( self , *  other ); }}}}
macro_rules! __ra_macro_fixture93 {( impl $imp :  ident , $method :  ident  for $t :  ty )=>{ forward_ref_unop ! ( impl $imp , $method  for $t , # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]); }; ( impl $imp :  ident , $method :  ident  for $t :  ty , # [$attr :  meta ])=>{# [$attr ] impl $imp  for &$t { type  Output = <$t  as $imp >::  Output ; # [ inline ] fn $method ( self )-> <$t  as $imp >::  Output {$imp ::$method (*  self )}}}}
macro_rules! __ra_macro_fixture94 {($FnTy :  ty , $($Arg :  ident ),*)=>{# [ stable ( feature =  "fnptr_impls" ,  since =  "1.4.0" )] impl <  Ret , $($Arg ),*>  PartialEq  for $FnTy {# [ inline ] fn  eq (&  self ,  other : &  Self )->  bool {*  self  as  usize == *  other  as  usize }}# [ stable ( feature =  "fnptr_impls" ,  since =  "1.4.0" )] impl <  Ret , $($Arg ),*>  Eq  for $FnTy {}# [ stable ( feature =  "fnptr_impls" ,  since =  "1.4.0" )] impl <  Ret , $($Arg ),*>  PartialOrd  for $FnTy {# [ inline ] fn  partial_cmp (&  self ,  other : &  Self )->  Option <  Ordering > {(*  self  as  usize ).  partial_cmp (& (*  other  as  usize ))}}# [ stable ( feature =  "fnptr_impls" ,  since =  "1.4.0" )] impl <  Ret , $($Arg ),*>  Ord  for $FnTy {# [ inline ] fn  cmp (&  self ,  other : &  Self )->  Ordering {(*  self  as  usize ).  cmp (& (*  other  as  usize ))}}# [ stable ( feature =  "fnptr_impls" ,  since =  "1.4.0" )] impl <  Ret , $($Arg ),*>  hash ::  Hash  for $FnTy { fn  hash <  HH :  hash ::  Hasher > (&  self ,  state : &  mut  HH ){ state .  write_usize (*  self  as  usize )}}# [ stable ( feature =  "fnptr_impls" ,  since =  "1.4.0" )] impl <  Ret , $($Arg ),*>  fmt ::  Pointer  for $FnTy { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter < '_ >)->  fmt ::  Result { fmt ::  Pointer ::  fmt (& (*  self  as  usize  as *  const ()),  f )}}# [ stable ( feature =  "fnptr_impls" ,  since =  "1.4.0" )] impl <  Ret , $($Arg ),*>  fmt ::  Debug  for $FnTy { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter < '_ >)->  fmt ::  Result { fmt ::  Pointer ::  fmt (& (*  self  as  usize  as *  const ()),  f )}}}}
macro_rules! __ra_macro_fixture95 {($t :  ty , $f :  ty )=>{# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Shl <$f >  for $t { type  Output = $t ; # [ inline ]# [ rustc_inherit_overflow_checks ] fn  shl ( self ,  other : $f )-> $t { self <<  other }} forward_ref_binop ! { impl  Shl ,  shl  for $t , $f }}; }
macro_rules! __ra_macro_fixture96 {($t :  ty , $f :  ty )=>{# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  Shr <$f >  for $t { type  Output = $t ; # [ inline ]# [ rustc_inherit_overflow_checks ] fn  shr ( self ,  other : $f )-> $t { self >>  other }} forward_ref_binop ! { impl  Shr ,  shr  for $t , $f }}; }
macro_rules! __ra_macro_fixture97 {($t :  ty , $f :  ty )=>{# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  ShlAssign <$f >  for $t {# [ inline ]# [ rustc_inherit_overflow_checks ] fn  shl_assign (&  mut  self ,  other : $f ){*  self <<=  other }} forward_ref_op_assign ! { impl  ShlAssign ,  shl_assign  for $t , $f }}; }
macro_rules! __ra_macro_fixture98 {($t :  ty , $f :  ty )=>{# [ stable ( feature =  "op_assign_traits" ,  since =  "1.8.0" )] impl  ShrAssign <$f >  for $t {# [ inline ]# [ rustc_inherit_overflow_checks ] fn  shr_assign (&  mut  self ,  other : $f ){*  self >>=  other }} forward_ref_op_assign ! { impl  ShrAssign ,  shr_assign  for $t , $f }}; }
macro_rules! __ra_macro_fixture99 {( fmt ::$Trait :  ident  for $T :  ident  as $U :  ident -> $Radix :  ident )=>{# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] impl  fmt ::$Trait  for $T { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter < '_ >)->  fmt ::  Result {$Radix .  fmt_int (*  self  as $U ,  f )}}}; }
macro_rules! __ra_macro_fixture100 {($name :  ident , $($other :  ident ,)*)=>( tuple ! {$($other ,)* })}
macro_rules! __ra_macro_fixture101 {{ unsafe  fn $name :  ident : $adjacent_kv :  ident }=>{# [ doc =  " Given a leaf edge handle into an owned tree, returns a handle to the next KV," ]# [ doc =  " while deallocating any node left behind yet leaving the corresponding edge" ]# [ doc =  " in its parent node dangling." ]# [ doc =  "" ]# [ doc =  " # Safety" ]# [ doc =  " - The leaf edge must not be the last one in the direction travelled." ]# [ doc =  " - The node carrying the next KV returned must not have been deallocated by a" ]# [ doc =  "   previous call on any handle obtained for this tree." ] unsafe  fn $name <  K ,  V > ( leaf_edge :  Handle <  NodeRef <  marker ::  Owned ,  K ,  V ,  marker ::  Leaf >,  marker ::  Edge >, )->  Handle <  NodeRef <  marker ::  Owned ,  K ,  V ,  marker ::  LeafOrInternal >,  marker ::  KV > { let  mut  edge =  leaf_edge .  forget_node_type ();  loop { edge =  match  edge .$adjacent_kv (){ Ok ( internal_kv )=> return  internal_kv ,  Err ( last_edge )=>{ unsafe { let  parent_edge =  last_edge .  into_node ().  deallocate_and_ascend ();  unwrap_unchecked ( parent_edge ).  forget_node_type ()}}}}}}; }
macro_rules! __ra_macro_fixture102 {([$($vars :  tt )*]$lhs :  ty , $rhs :  ty , $($constraints :  tt )*)=>{# [ stable ( feature =  "vec_deque_partial_eq_slice" ,  since =  "1.17.0" )] impl <  A ,  B , $($vars )*>  PartialEq <$rhs >  for $lhs  where  A :  PartialEq <  B >, $($constraints )* { fn  eq (&  self ,  other : &$rhs )->  bool { if  self .  len ()!=  other .  len (){ return  false ; } let ( sa ,  sb )=  self .  as_slices ();  let ( oa ,  ob )=  other [..].  split_at ( sa .  len ());  sa ==  oa &&  sb ==  ob }}}}
macro_rules! __ra_macro_fixture103 {($lhs :  ty , $rhs :  ty )=>{# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ allow ( unused_lifetimes )] impl < 'a , 'b >  PartialEq <$rhs >  for $lhs {# [ inline ] fn  eq (&  self ,  other : &$rhs )->  bool { PartialEq ::  eq (&  self [..], &  other [..])}# [ inline ] fn  ne (&  self ,  other : &$rhs )->  bool { PartialEq ::  ne (&  self [..], &  other [..])}}# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ allow ( unused_lifetimes )] impl < 'a , 'b >  PartialEq <$lhs >  for $rhs {# [ inline ] fn  eq (&  self ,  other : &$lhs )->  bool { PartialEq ::  eq (&  self [..], &  other [..])}# [ inline ] fn  ne (&  self ,  other : &$lhs )->  bool { PartialEq ::  ne (&  self [..], &  other [..])}}}; }
macro_rules! __ra_macro_fixture104 {($t :  ty , $is_zero :  expr )=>{ unsafe  impl  IsZero  for $t {# [ inline ] fn  is_zero (&  self )->  bool {$is_zero (*  self )}}}; }
macro_rules! __ra_macro_fixture105 {([$($vars :  tt )*]$lhs :  ty , $rhs :  ty $(where $ty :  ty : $bound :  ident )?, # [$stability :  meta ])=>{# [$stability ] impl <  A ,  B , $($vars )*>  PartialEq <$rhs >  for $lhs  where  A :  PartialEq <  B >, $($ty : $bound )? {# [ inline ] fn  eq (&  self ,  other : &$rhs )->  bool { self [..]==  other [..]}# [ inline ] fn  ne (&  self ,  other : &$rhs )->  bool { self [..]!=  other [..]}}}}
macro_rules! __ra_macro_fixture106 {('owned : $($oty :  ident ,)* 'interned : $($ity :  ident ,)* )=>{# [ repr ( C )]# [ allow ( non_snake_case )] pub  struct  HandleCounters {$($oty :  AtomicUsize ,)* $($ity :  AtomicUsize ,)* } impl  HandleCounters { extern  "C"  fn  get ()-> & 'static  Self { static  COUNTERS :  HandleCounters =  HandleCounters {$($oty :  AtomicUsize ::  new ( 1 ),)* $($ity :  AtomicUsize ::  new ( 1 ),)* }; &  COUNTERS }}# [ repr ( C )]# [ allow ( non_snake_case )] pub ( super ) struct  HandleStore <  S :  server ::  Types > {$($oty :  handle ::  OwnedStore <  S ::$oty >,)* $($ity :  handle ::  InternedStore <  S ::$ity >,)* } impl <  S :  server ::  Types >  HandleStore <  S > { pub ( super ) fn  new ( handle_counters : & 'static  HandleCounters )->  Self { HandleStore {$($oty :  handle ::  OwnedStore ::  new (&  handle_counters .$oty ),)* $($ity :  handle ::  InternedStore ::  new (&  handle_counters .$ity ),)* }}}$(# [ repr ( C )] pub ( crate ) struct $oty ( handle ::  Handle );  impl !  Send  for $oty {} impl !  Sync  for $oty {} impl  Drop  for $oty { fn  drop (&  mut  self ){$oty ( self .  0 ).  drop (); }} impl <  S >  Encode <  S >  for $oty { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  S ){ let  handle =  self .  0 ;  mem ::  forget ( self );  handle .  encode ( w ,  s ); }} impl <  S :  server ::  Types >  DecodeMut < '_ , '_ ,  HandleStore <  server ::  MarkedTypes <  S >>>  for  Marked <  S ::$oty , $oty > { fn  decode ( r : &  mut  Reader < '_ >,  s : &  mut  HandleStore <  server ::  MarkedTypes <  S >>)->  Self { s .$oty .  take ( handle ::  Handle ::  decode ( r , &  mut ()))}} impl <  S >  Encode <  S >  for &$oty { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  S ){ self .  0 .  encode ( w ,  s ); }} impl <  S :  server ::  Types >  Decode < '_ , 's ,  HandleStore <  server ::  MarkedTypes <  S >>>  for & 's  Marked <  S ::$oty , $oty > { fn  decode ( r : &  mut  Reader < '_ >,  s : & 's  HandleStore <  server ::  MarkedTypes <  S >>)->  Self {&  s .$oty [ handle ::  Handle ::  decode ( r , &  mut ())]}} impl <  S >  Encode <  S >  for &  mut $oty { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  S ){ self .  0 .  encode ( w ,  s ); }} impl <  S :  server ::  Types >  DecodeMut < '_ , 's ,  HandleStore <  server ::  MarkedTypes <  S >>>  for & 's  mut  Marked <  S ::$oty , $oty > { fn  decode ( r : &  mut  Reader < '_ >,  s : & 's  mut  HandleStore <  server ::  MarkedTypes <  S >> )->  Self {&  mut  s .$oty [ handle ::  Handle ::  decode ( r , &  mut ())]}} impl <  S :  server ::  Types >  Encode <  HandleStore <  server ::  MarkedTypes <  S >>>  for  Marked <  S ::$oty , $oty > { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  HandleStore <  server ::  MarkedTypes <  S >>){ s .$oty .  alloc ( self ).  encode ( w ,  s ); }} impl <  S >  DecodeMut < '_ , '_ ,  S >  for $oty { fn  decode ( r : &  mut  Reader < '_ >,  s : &  mut  S )->  Self {$oty ( handle ::  Handle ::  decode ( r ,  s ))}})* $(# [ repr ( C )]# [ derive ( Copy ,  Clone ,  PartialEq ,  Eq ,  Hash )] pub ( crate ) struct $ity ( handle ::  Handle );  impl !  Send  for $ity {} impl !  Sync  for $ity {} impl <  S >  Encode <  S >  for $ity { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  S ){ self .  0 .  encode ( w ,  s ); }} impl <  S :  server ::  Types >  DecodeMut < '_ , '_ ,  HandleStore <  server ::  MarkedTypes <  S >>>  for  Marked <  S ::$ity , $ity > { fn  decode ( r : &  mut  Reader < '_ >,  s : &  mut  HandleStore <  server ::  MarkedTypes <  S >>)->  Self { s .$ity .  copy ( handle ::  Handle ::  decode ( r , &  mut ()))}} impl <  S :  server ::  Types >  Encode <  HandleStore <  server ::  MarkedTypes <  S >>>  for  Marked <  S ::$ity , $ity > { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  HandleStore <  server ::  MarkedTypes <  S >>){ s .$ity .  alloc ( self ).  encode ( w ,  s ); }} impl <  S >  DecodeMut < '_ , '_ ,  S >  for $ity { fn  decode ( r : &  mut  Reader < '_ >,  s : &  mut  S )->  Self {$ity ( handle ::  Handle ::  decode ( r ,  s ))}})* }}
macro_rules! __ra_macro_fixture107 {($S :  ident , $self :  ident , $m :  ident )=>{$m ! { FreeFunctions { fn  drop ($self : $S ::  FreeFunctions );  fn  track_env_var ( var : &  str ,  value :  Option <&  str >); },  TokenStream { fn  drop ($self : $S ::  TokenStream );  fn  clone ($self : &$S ::  TokenStream )-> $S ::  TokenStream ;  fn  new ()-> $S ::  TokenStream ;  fn  is_empty ($self : &$S ::  TokenStream )->  bool ;  fn  from_str ( src : &  str )-> $S ::  TokenStream ;  fn  to_string ($self : &$S ::  TokenStream )->  String ;  fn  from_token_tree ( tree :  TokenTree <$S ::  Group , $S ::  Punct , $S ::  Ident , $S ::  Literal >, )-> $S ::  TokenStream ;  fn  into_iter ($self : $S ::  TokenStream )-> $S ::  TokenStreamIter ; },  TokenStreamBuilder { fn  drop ($self : $S ::  TokenStreamBuilder );  fn  new ()-> $S ::  TokenStreamBuilder ;  fn  push ($self : &  mut $S ::  TokenStreamBuilder ,  stream : $S ::  TokenStream );  fn  build ($self : $S ::  TokenStreamBuilder )-> $S ::  TokenStream ; },  TokenStreamIter { fn  drop ($self : $S ::  TokenStreamIter );  fn  clone ($self : &$S ::  TokenStreamIter )-> $S ::  TokenStreamIter ;  fn  next ($self : &  mut $S ::  TokenStreamIter , )->  Option <  TokenTree <$S ::  Group , $S ::  Punct , $S ::  Ident , $S ::  Literal >>; },  Group { fn  drop ($self : $S ::  Group );  fn  clone ($self : &$S ::  Group )-> $S ::  Group ;  fn  new ( delimiter :  Delimiter ,  stream : $S ::  TokenStream )-> $S ::  Group ;  fn  delimiter ($self : &$S ::  Group )->  Delimiter ;  fn  stream ($self : &$S ::  Group )-> $S ::  TokenStream ;  fn  span ($self : &$S ::  Group )-> $S ::  Span ;  fn  span_open ($self : &$S ::  Group )-> $S ::  Span ;  fn  span_close ($self : &$S ::  Group )-> $S ::  Span ;  fn  set_span ($self : &  mut $S ::  Group ,  span : $S ::  Span ); },  Punct { fn  new ( ch :  char ,  spacing :  Spacing )-> $S ::  Punct ;  fn  as_char ($self : $S ::  Punct )->  char ;  fn  spacing ($self : $S ::  Punct )->  Spacing ;  fn  span ($self : $S ::  Punct )-> $S ::  Span ;  fn  with_span ($self : $S ::  Punct ,  span : $S ::  Span )-> $S ::  Punct ; },  Ident { fn  new ( string : &  str ,  span : $S ::  Span ,  is_raw :  bool )-> $S ::  Ident ;  fn  span ($self : $S ::  Ident )-> $S ::  Span ;  fn  with_span ($self : $S ::  Ident ,  span : $S ::  Span )-> $S ::  Ident ; },  Literal { fn  drop ($self : $S ::  Literal );  fn  clone ($self : &$S ::  Literal )-> $S ::  Literal ;  fn  debug_kind ($self : &$S ::  Literal )->  String ;  fn  symbol ($self : &$S ::  Literal )->  String ;  fn  suffix ($self : &$S ::  Literal )->  Option <  String >;  fn  integer ( n : &  str )-> $S ::  Literal ;  fn  typed_integer ( n : &  str ,  kind : &  str )-> $S ::  Literal ;  fn  float ( n : &  str )-> $S ::  Literal ;  fn  f32 ( n : &  str )-> $S ::  Literal ;  fn  f64 ( n : &  str )-> $S ::  Literal ;  fn  string ( string : &  str )-> $S ::  Literal ;  fn  character ( ch :  char )-> $S ::  Literal ;  fn  byte_string ( bytes : & [ u8 ])-> $S ::  Literal ;  fn  span ($self : &$S ::  Literal )-> $S ::  Span ;  fn  set_span ($self : &  mut $S ::  Literal ,  span : $S ::  Span );  fn  subspan ($self : &$S ::  Literal ,  start :  Bound <  usize >,  end :  Bound <  usize >, )->  Option <$S ::  Span >; },  SourceFile { fn  drop ($self : $S ::  SourceFile );  fn  clone ($self : &$S ::  SourceFile )-> $S ::  SourceFile ;  fn  eq ($self : &$S ::  SourceFile ,  other : &$S ::  SourceFile )->  bool ;  fn  path ($self : &$S ::  SourceFile )->  String ;  fn  is_real ($self : &$S ::  SourceFile )->  bool ; },  MultiSpan { fn  drop ($self : $S ::  MultiSpan );  fn  new ()-> $S ::  MultiSpan ;  fn  push ($self : &  mut $S ::  MultiSpan ,  span : $S ::  Span ); },  Diagnostic { fn  drop ($self : $S ::  Diagnostic );  fn  new ( level :  Level ,  msg : &  str ,  span : $S ::  MultiSpan )-> $S ::  Diagnostic ;  fn  sub ($self : &  mut $S ::  Diagnostic ,  level :  Level ,  msg : &  str ,  span : $S ::  MultiSpan , );  fn  emit ($self : $S ::  Diagnostic ); },  Span { fn  debug ($self : $S ::  Span )->  String ;  fn  def_site ()-> $S ::  Span ;  fn  call_site ()-> $S ::  Span ;  fn  mixed_site ()-> $S ::  Span ;  fn  source_file ($self : $S ::  Span )-> $S ::  SourceFile ;  fn  parent ($self : $S ::  Span )->  Option <$S ::  Span >;  fn  source ($self : $S ::  Span )-> $S ::  Span ;  fn  start ($self : $S ::  Span )->  LineColumn ;  fn  end ($self : $S ::  Span )->  LineColumn ;  fn  join ($self : $S ::  Span ,  other : $S ::  Span )->  Option <$S ::  Span >;  fn  resolved_at ($self : $S ::  Span ,  at : $S ::  Span )-> $S ::  Span ;  fn  source_text ($self : $S ::  Span )->  Option <  String >; }, }}; }
macro_rules! __ra_macro_fixture108 {( le $ty :  ty )=>{ impl <  S >  Encode <  S >  for $ty { fn  encode ( self ,  w : &  mut  Writer , _: &  mut  S ){ w .  write_all (&  self .  to_le_bytes ()).  unwrap (); }} impl <  S >  DecodeMut < '_ , '_ ,  S >  for $ty { fn  decode ( r : &  mut  Reader < '_ >, _: &  mut  S )->  Self { const  N :  usize = ::  std ::  mem ::  size_of ::<$ty > ();  let  mut  bytes = [ 0 ;  N ];  bytes .  copy_from_slice (&  r [..  N ]); *  r = &  r [ N ..];  Self ::  from_le_bytes ( bytes )}}}; ( struct $name :  ident {$($field :  ident ),* $(,)? })=>{ impl <  S >  Encode <  S >  for $name { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  S ){$(self .$field .  encode ( w ,  s );)* }} impl <  S >  DecodeMut < '_ , '_ ,  S >  for $name { fn  decode ( r : &  mut  Reader < '_ >,  s : &  mut  S )->  Self {$name {$($field :  DecodeMut ::  decode ( r ,  s )),* }}}}; ( enum $name :  ident $(<$($T :  ident ),+>)? {$($variant :  ident $(($field :  ident ))*),* $(,)? })=>{ impl <  S , $($($T :  Encode <  S >),+)?>  Encode <  S >  for $name $(<$($T ),+>)? { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  S ){# [ allow ( non_upper_case_globals )] mod  tag {# [ repr ( u8 )] enum  Tag {$($variant ),* }$(pub  const $variant :  u8 =  Tag ::$variant  as  u8 ;)* } match  self {$($name ::$variant $(($field ))* =>{ tag ::$variant .  encode ( w ,  s ); $($field .  encode ( w ,  s );)* })* }}} impl <  S , $($($T :  for < 's >  DecodeMut < 'a , 's ,  S >),+)?>  DecodeMut < 'a , '_ ,  S >  for $name $(<$($T ),+>)? { fn  decode ( r : &  mut  Reader < 'a >,  s : &  mut  S )->  Self {# [ allow ( non_upper_case_globals )] mod  tag {# [ repr ( u8 )] enum  Tag {$($variant ),* }$(pub  const $variant :  u8 =  Tag ::$variant  as  u8 ;)* } match  u8 ::  decode ( r ,  s ){$(tag ::$variant =>{$(let $field =  DecodeMut ::  decode ( r ,  s );)* $name ::$variant $(($field ))* })* _ => unreachable ! (), }}}}}
macro_rules! __ra_macro_fixture109 {($($ty :  ty ),* $(,)?)=>{$(impl  Mark  for $ty { type  Unmarked =  Self ;  fn  mark ( unmarked :  Self ::  Unmarked )->  Self { unmarked }} impl  Unmark  for $ty { type  Unmarked =  Self ;  fn  unmark ( self )->  Self ::  Unmarked { self }})* }}
macro_rules! __ra_macro_fixture110 {($($name :  ident {$(fn $method :  ident ($($arg :  ident : $arg_ty :  ty ),* $(,)?)$(-> $ret_ty :  ty )*;)* }),* $(,)?)=>{$(impl $name {$(pub ( crate ) fn $method ($($arg : $arg_ty ),*)$(-> $ret_ty )* { Bridge ::  with (|  bridge | { let  mut  b =  bridge .  cached_buffer .  take ();  b .  clear ();  api_tags ::  Method ::$name ( api_tags ::$name ::$method ).  encode (&  mut  b , &  mut ());  reverse_encode ! ( b ; $($arg ),*);  b =  bridge .  dispatch .  call ( b );  let  r =  Result ::<_,  PanicMessage >::  decode (&  mut &  b [..], &  mut ());  bridge .  cached_buffer =  b ;  r .  unwrap_or_else (|  e |  panic ::  resume_unwind ( e .  into ()))})})* })* }}
macro_rules! __ra_macro_fixture111 {($($name :  ident {$(fn $method :  ident ($($arg :  ident : $arg_ty :  ty ),* $(,)?)$(-> $ret_ty :  ty )?;)* }),* $(,)?)=>{ pub  trait  Types {$(associated_item ! ( type $name );)* }$(pub  trait $name :  Types {$(associated_item ! ( fn $method (&  mut  self , $($arg : $arg_ty ),*)$(-> $ret_ty )?);)* })*  pub  trait  Server :  Types $(+ $name )* {} impl <  S :  Types $(+ $name )*>  Server  for  S {}}}
macro_rules! __ra_macro_fixture112 {($($name :  ident {$(fn $method :  ident ($($arg :  ident : $arg_ty :  ty ),* $(,)?)$(-> $ret_ty :  ty )?;)* }),* $(,)?)=>{ impl <  S :  Types >  Types  for  MarkedTypes <  S > {$(type $name =  Marked <  S ::$name ,  client ::$name >;)* }$(impl <  S : $name > $name  for  MarkedTypes <  S > {$(fn $method (&  mut  self , $($arg : $arg_ty ),*)$(-> $ret_ty )? {<_>::  mark ($name ::$method (&  mut  self .  0 , $($arg .  unmark ()),*))})* })* }}
macro_rules! __ra_macro_fixture113 {($($name :  ident {$(fn $method :  ident ($($arg :  ident : $arg_ty :  ty ),* $(,)?)$(-> $ret_ty :  ty )?;)* }),* $(,)?)=>{ pub  trait  DispatcherTrait {$(type $name ;)*  fn  dispatch (&  mut  self ,  b :  Buffer <  u8 >)->  Buffer <  u8 >; } impl <  S :  Server >  DispatcherTrait  for  Dispatcher <  MarkedTypes <  S >> {$(type $name = <  MarkedTypes <  S >  as  Types >::$name ;)*  fn  dispatch (&  mut  self ,  mut  b :  Buffer <  u8 >)->  Buffer <  u8 > { let  Dispatcher { handle_store ,  server }=  self ;  let  mut  reader = &  b [..];  match  api_tags ::  Method ::  decode (&  mut  reader , &  mut ()){$(api_tags ::  Method ::$name ( m )=> match  m {$(api_tags ::$name ::$method =>{ let  mut  call_method = || { reverse_decode ! ( reader ,  handle_store ; $($arg : $arg_ty ),*); $name ::$method ( server , $($arg ),*)};  let  r =  if  thread ::  panicking (){ Ok ( call_method ())} else { panic ::  catch_unwind ( panic ::  AssertUnwindSafe ( call_method )).  map_err ( PanicMessage ::  from )};  b .  clear ();  r .  encode (&  mut  b ,  handle_store ); })* }),* } b }}}}
macro_rules! __ra_macro_fixture114 {($($name :  ident {$(fn $method :  ident ($($arg :  ident : $arg_ty :  ty ),* $(,)?)$(-> $ret_ty :  ty )*;)* }),* $(,)?)=>{$(pub ( super ) enum $name {$($method ),* } rpc_encode_decode ! ( enum $name {$($method ),* }); )*  pub ( super ) enum  Method {$($name ($name )),* } rpc_encode_decode ! ( enum  Method {$($name ( m )),* }); }}
macro_rules! __ra_macro_fixture115 {($(if # [ cfg ($meta :  meta )]{$($tokens :  tt )* }) else *  else {$($tokens2 :  tt )* })=>{$crate ::  cfg_if ! {@  __items (); $((($meta )($($tokens )*)), )* (()($($tokens2 )*)), }}; ( if # [ cfg ($i_met :  meta )]{$($i_tokens :  tt )* }$(else  if # [ cfg ($e_met :  meta )]{$($e_tokens :  tt )* })* )=>{$crate ::  cfg_if ! {@  __items (); (($i_met )($($i_tokens )*)), $((($e_met )($($e_tokens )*)), )* (()()), }}; (@  __items ($($not :  meta ,)*); )=>{}; (@  __items ($($not :  meta ,)*); (($($m :  meta ),*)($($tokens :  tt )*)), $($rest :  tt )*)=>{# [ cfg ( all ($($m ,)*  not ( any ($($not ),*))))]$crate ::  cfg_if ! {@  __identity $($tokens )* }$crate ::  cfg_if ! {@  __items ($($not ,)* $($m ,)*); $($rest )* }}; (@  __identity $($tokens :  tt )*)=>{$($tokens )* }; }
macro_rules! __ra_macro_fixture116 {($lhs :  ty , $rhs :  ty )=>{# [ stable ( feature =  "cmp_os_str" ,  since =  "1.8.0" )] impl < 'a , 'b >  PartialEq <$rhs >  for $lhs {# [ inline ] fn  eq (&  self ,  other : &$rhs )->  bool {<  OsStr  as  PartialEq >::  eq ( self ,  other )}}# [ stable ( feature =  "cmp_os_str" ,  since =  "1.8.0" )] impl < 'a , 'b >  PartialEq <$lhs >  for $rhs {# [ inline ] fn  eq (&  self ,  other : &$lhs )->  bool {<  OsStr  as  PartialEq >::  eq ( self ,  other )}}# [ stable ( feature =  "cmp_os_str" ,  since =  "1.8.0" )] impl < 'a , 'b >  PartialOrd <$rhs >  for $lhs {# [ inline ] fn  partial_cmp (&  self ,  other : &$rhs )->  Option <  cmp ::  Ordering > {<  OsStr  as  PartialOrd >::  partial_cmp ( self ,  other )}}# [ stable ( feature =  "cmp_os_str" ,  since =  "1.8.0" )] impl < 'a , 'b >  PartialOrd <$lhs >  for $rhs {# [ inline ] fn  partial_cmp (&  self ,  other : &$lhs )->  Option <  cmp ::  Ordering > {<  OsStr  as  PartialOrd >::  partial_cmp ( self ,  other )}}}; }
macro_rules! __ra_macro_fixture117 {()=>{}; ($(# [$attr :  meta ])* $vis :  vis  static $name :  ident : $t :  ty = $init :  expr ; $($rest :  tt )*)=>($crate ::  __thread_local_inner ! ($(# [$attr ])* $vis $name , $t , $init ); $crate ::  thread_local ! ($($rest )*); ); ($(# [$attr :  meta ])* $vis :  vis  static $name :  ident : $t :  ty = $init :  expr )=>($crate ::  __thread_local_inner ! ($(# [$attr ])* $vis $name , $t , $init ); ); }
macro_rules! __ra_macro_fixture118 {($($t :  ty )*)=>($(impl  ReadNumberHelper  for $t { const  ZERO :  Self =  0 ; # [ inline ] fn  checked_mul (&  self ,  other :  u32 )->  Option <  Self > { Self ::  checked_mul (*  self ,  other .  try_into ().  ok ()?)}# [ inline ] fn  checked_add (&  self ,  other :  u32 )->  Option <  Self > { Self ::  checked_add (*  self ,  other .  try_into ().  ok ()?)}})*)}
macro_rules! __ra_macro_fixture119 {($lhs :  ty , $rhs :  ty )=>{# [ stable ( feature =  "partialeq_path" ,  since =  "1.6.0" )] impl < 'a , 'b >  PartialEq <$rhs >  for $lhs {# [ inline ] fn  eq (&  self ,  other : &$rhs )->  bool {<  Path  as  PartialEq >::  eq ( self ,  other )}}# [ stable ( feature =  "partialeq_path" ,  since =  "1.6.0" )] impl < 'a , 'b >  PartialEq <$lhs >  for $rhs {# [ inline ] fn  eq (&  self ,  other : &$lhs )->  bool {<  Path  as  PartialEq >::  eq ( self ,  other )}}# [ stable ( feature =  "cmp_path" ,  since =  "1.8.0" )] impl < 'a , 'b >  PartialOrd <$rhs >  for $lhs {# [ inline ] fn  partial_cmp (&  self ,  other : &$rhs )->  Option <  cmp ::  Ordering > {<  Path  as  PartialOrd >::  partial_cmp ( self ,  other )}}# [ stable ( feature =  "cmp_path" ,  since =  "1.8.0" )] impl < 'a , 'b >  PartialOrd <$lhs >  for $rhs {# [ inline ] fn  partial_cmp (&  self ,  other : &$lhs )->  Option <  cmp ::  Ordering > {<  Path  as  PartialOrd >::  partial_cmp ( self ,  other )}}}; }
macro_rules! __ra_macro_fixture120 {($lhs :  ty , $rhs :  ty )=>{# [ stable ( feature =  "cmp_path" ,  since =  "1.8.0" )] impl < 'a , 'b >  PartialEq <$rhs >  for $lhs {# [ inline ] fn  eq (&  self ,  other : &$rhs )->  bool {<  Path  as  PartialEq >::  eq ( self ,  other .  as_ref ())}}# [ stable ( feature =  "cmp_path" ,  since =  "1.8.0" )] impl < 'a , 'b >  PartialEq <$lhs >  for $rhs {# [ inline ] fn  eq (&  self ,  other : &$lhs )->  bool {<  Path  as  PartialEq >::  eq ( self .  as_ref (),  other )}}# [ stable ( feature =  "cmp_path" ,  since =  "1.8.0" )] impl < 'a , 'b >  PartialOrd <$rhs >  for $lhs {# [ inline ] fn  partial_cmp (&  self ,  other : &$rhs )->  Option <  cmp ::  Ordering > {<  Path  as  PartialOrd >::  partial_cmp ( self ,  other .  as_ref ())}}# [ stable ( feature =  "cmp_path" ,  since =  "1.8.0" )] impl < 'a , 'b >  PartialOrd <$lhs >  for $rhs {# [ inline ] fn  partial_cmp (&  self ,  other : &$lhs )->  Option <  cmp ::  Ordering > {<  Path  as  PartialOrd >::  partial_cmp ( self .  as_ref (),  other )}}}; }
macro_rules! __ra_macro_fixture121 {(@  key $t :  ty , $init :  expr )=>{{# [ inline ] fn  __init ()-> $t {$init } unsafe  fn  __getit ()-> $crate ::  option ::  Option <& 'static $t > {# [ cfg ( all ( target_arch =  "wasm32" ,  not ( target_feature =  "atomics" )))] static  __KEY : $crate ::  thread ::  __StaticLocalKeyInner <$t > = $crate ::  thread ::  __StaticLocalKeyInner ::  new (); # [ thread_local ]# [ cfg ( all ( target_thread_local ,  not ( all ( target_arch =  "wasm32" ,  not ( target_feature =  "atomics" ))), ))] static  __KEY : $crate ::  thread ::  __FastLocalKeyInner <$t > = $crate ::  thread ::  __FastLocalKeyInner ::  new (); # [ cfg ( all ( not ( target_thread_local ),  not ( all ( target_arch =  "wasm32" ,  not ( target_feature =  "atomics" ))), ))] static  __KEY : $crate ::  thread ::  __OsLocalKeyInner <$t > = $crate ::  thread ::  __OsLocalKeyInner ::  new (); # [ allow ( unused_unsafe )] unsafe { __KEY .  get ( __init )}} unsafe {$crate ::  thread ::  LocalKey ::  new ( __getit )}}}; ($(# [$attr :  meta ])* $vis :  vis $name :  ident , $t :  ty , $init :  expr )=>{$(# [$attr ])* $vis  const $name : $crate ::  thread ::  LocalKey <$t > = $crate ::  __thread_local_inner ! (@  key $t , $init ); }}
macro_rules! __ra_macro_fixture122 {({$($then_tt :  tt )* } else {$($else_tt :  tt )* })=>{ cfg_if ::  cfg_if ! { if # [ cfg ( all ( target_os =  "linux" ,  target_env =  "gnu" ))]{$($then_tt )* } else {$($else_tt )* }}}; ($($block_inner :  tt )*)=>{# [ cfg ( all ( target_os =  "linux" ,  target_env =  "gnu" ))]{$($block_inner )* }}; }
macro_rules! __ra_macro_fixture123 {($($t :  ident )*)=>($(impl  IsMinusOne  for $t { fn  is_minus_one (&  self )->  bool {*  self == -  1 }})*)}
macro_rules! __ra_macro_fixture124 {($(if # [ cfg ($($meta :  meta ),*)]{$($it :  item )* }) else *  else {$($it2 :  item )* })=>{ cfg_if ! {@  __items (); $((($($meta ),*)($($it )*)), )* (()($($it2 )*)), }}; ( if # [ cfg ($($i_met :  meta ),*)]{$($i_it :  item )* }$(else  if # [ cfg ($($e_met :  meta ),*)]{$($e_it :  item )* })* )=>{ cfg_if ! {@  __items (); (($($i_met ),*)($($i_it )*)), $((($($e_met ),*)($($e_it )*)), )* (()()), }}; (@  __items ($($not :  meta ,)*); )=>{}; (@  __items ($($not :  meta ,)*); (($($m :  meta ),*)($($it :  item )*)), $($rest :  tt )*)=>{ cfg_if ! {@  __apply  cfg ( all ($($m ,)*  not ( any ($($not ),*)))), $($it )* } cfg_if ! {@  __items ($($not ,)* $($m ,)*); $($rest )* }}; (@  __apply $m :  meta , $($it :  item )*)=>{$(# [$m ]$it )* }; }
macro_rules! __ra_macro_fixture125 {($bench_macro :  ident , $bench_ahash_serial :  ident , $bench_std_serial :  ident , $bench_ahash_highbits :  ident , $bench_std_highbits :  ident , $bench_ahash_random :  ident , $bench_std_random :  ident )=>{$bench_macro ! ($bench_ahash_serial ,  AHashMap ,  0 ..); $bench_macro ! ($bench_std_serial ,  StdHashMap ,  0 ..); $bench_macro ! ($bench_ahash_highbits ,  AHashMap , ( 0 ..).  map ( usize ::  swap_bytes )); $bench_macro ! ($bench_std_highbits ,  StdHashMap , ( 0 ..).  map ( usize ::  swap_bytes )); $bench_macro ! ($bench_ahash_random ,  AHashMap ,  RandomKeys ::  new ()); $bench_macro ! ($bench_std_random ,  StdHashMap ,  RandomKeys ::  new ()); }; }
macro_rules! __ra_macro_fixture126 {($name :  ident , $maptype :  ident , $keydist :  expr )=>{# [ bench ] fn $name ( b : &  mut  Bencher ){ let  mut  m = $maptype ::  with_capacity_and_hasher ( SIZE ,  Default ::  default ());  b .  iter (|| { m .  clear ();  for  i  in ($keydist ).  take ( SIZE ){ m .  insert ( i ,  i ); } black_box (&  mut  m ); })}}; }
macro_rules! __ra_macro_fixture127 {($name :  ident , $maptype :  ident , $keydist :  expr )=>{# [ bench ] fn $name ( b : &  mut  Bencher ){ let  mut  base = $maptype ::  default ();  for  i  in ($keydist ).  take ( SIZE ){ base .  insert ( i ,  i ); } let  skip = $keydist .  skip ( SIZE );  b .  iter (|| { let  mut  m =  base .  clone ();  let  mut  add_iter =  skip .  clone ();  let  mut  remove_iter = $keydist ;  for ( add ,  remove ) in (&  mut  add_iter ).  zip (&  mut  remove_iter ).  take ( SIZE ){ m .  insert ( add ,  add );  black_box ( m .  remove (&  remove )); } black_box ( m ); })}}; }
macro_rules! __ra_macro_fixture128 {($name :  ident , $maptype :  ident , $keydist :  expr )=>{# [ bench ] fn $name ( b : &  mut  Bencher ){ let  mut  m = $maptype ::  default ();  for  i  in $keydist .  take ( SIZE ){ m .  insert ( i ,  i ); } b .  iter (|| { for  i  in $keydist .  take ( SIZE ){ black_box ( m .  get (&  i )); }})}}; }
macro_rules! __ra_macro_fixture129 {($name :  ident , $maptype :  ident , $keydist :  expr )=>{# [ bench ] fn $name ( b : &  mut  Bencher ){ let  mut  m = $maptype ::  default ();  let  mut  iter = $keydist ;  for  i  in (&  mut  iter ).  take ( SIZE ){ m .  insert ( i ,  i ); } b .  iter (|| { for  i  in (&  mut  iter ).  take ( SIZE ){ black_box ( m .  get (&  i )); }})}}; }
macro_rules! __ra_macro_fixture130 {($name :  ident , $maptype :  ident , $keydist :  expr )=>{# [ bench ] fn $name ( b : &  mut  Bencher ){ let  mut  m = $maptype ::  default ();  for  i  in ($keydist ).  take ( SIZE ){ m .  insert ( i ,  i ); } b .  iter (|| { for  i  in &  m { black_box ( i ); }})}}; }
macro_rules! __ra_macro_fixture131 {($(if # [ cfg ($($meta :  meta ),*)]{$($it :  item )* }) else *  else {$($it2 :  item )* })=>{ cfg_if ! {@  __items (); $((($($meta ),*)($($it )*)), )* (()($($it2 )*)), }}; ( if # [ cfg ($($i_met :  meta ),*)]{$($i_it :  item )* }$(else  if # [ cfg ($($e_met :  meta ),*)]{$($e_it :  item )* })* )=>{ cfg_if ! {@  __items (); (($($i_met ),*)($($i_it )*)), $((($($e_met ),*)($($e_it )*)), )* (()()), }}; (@  __items ($($not :  meta ,)*); )=>{}; (@  __items ($($not :  meta ,)*); (($($m :  meta ),*)($($it :  item )*)), $($rest :  tt )*)=>{ cfg_if ! {@  __apply  cfg ( all ($($m ,)*  not ( any ($($not ),*)))), $($it )* } cfg_if ! {@  __items ($($not ,)* $($m ,)*); $($rest )* }}; (@  __apply $m :  meta , $($it :  item )*)=>{$(# [$m ]$it )* }; }
macro_rules! __ra_macro_fixture132 {($($(# [$attr :  meta ])*  pub $t :  ident $i :  ident {$($field :  tt )* })*)=>($(s ! ( it : $(# [$attr ])*  pub $t $i {$($field )* }); )*); ( it : $(# [$attr :  meta ])*  pub  union $i :  ident {$($field :  tt )* })=>( compile_error ! ( "unions cannot derive extra traits, use s_no_extra_traits instead" ); ); ( it : $(# [$attr :  meta ])*  pub  struct $i :  ident {$($field :  tt )* })=>( __item ! {# [ repr ( C )]# [ cfg_attr ( feature =  "extra_traits" ,  derive ( Debug ,  Eq ,  Hash ,  PartialEq ))]# [ allow ( deprecated )]$(# [$attr ])*  pub  struct $i {$($field )* }}# [ allow ( deprecated )] impl ::  Copy  for $i {}# [ allow ( deprecated )] impl ::  Clone  for $i { fn  clone (&  self )-> $i {*  self }}); }
macro_rules! __ra_macro_fixture133 {($i :  item )=>{$i }; }
macro_rules! __ra_macro_fixture134 {($($(# [$attr :  meta ])*  pub $t :  ident $i :  ident {$($field :  tt )* })*)=>($(s_no_extra_traits ! ( it : $(# [$attr ])*  pub $t $i {$($field )* }); )*); ( it : $(# [$attr :  meta ])*  pub  union $i :  ident {$($field :  tt )* })=>( cfg_if ! { if # [ cfg ( libc_union )]{ __item ! {# [ repr ( C )]$(# [$attr ])*  pub  union $i {$($field )* }} impl ::  Copy  for $i {} impl ::  Clone  for $i { fn  clone (&  self )-> $i {*  self }}}}); ( it : $(# [$attr :  meta ])*  pub  struct $i :  ident {$($field :  tt )* })=>( __item ! {# [ repr ( C )]$(# [$attr ])*  pub  struct $i {$($field )* }}# [ allow ( deprecated )] impl ::  Copy  for $i {}# [ allow ( deprecated )] impl ::  Clone  for $i { fn  clone (&  self )-> $i {*  self }}); }
macro_rules! __ra_macro_fixture135 {($($(# [$attr :  meta ])*  pub  const $name :  ident : $t1 :  ty = $t2 :  ident {$($field :  tt )* };)*)=>($(# [ cfg ( libc_align )]$(# [$attr ])*  pub  const $name : $t1 = $t2 {$($field )* }; # [ cfg ( not ( libc_align ))]$(# [$attr ])*  pub  const $name : $t1 = $t2 {$($field )*  __align : [], }; )*)}
macro_rules! __ra_macro_fixture136 {($($args :  tt )* )=>{$(define_ioctl ! ($args ); )* }}
macro_rules! __ra_macro_fixture137 {({$name :  ident , $ioctl :  ident , $arg_type :  ty })=>{ pub  unsafe  fn $name ( fd :  c_int ,  arg : $arg_type )->  c_int { untyped_ioctl ( fd ,  bindings ::$ioctl ,  arg )}}; }
macro_rules! __ra_macro_fixture138 {($($T :  ty ),*)=>{$(impl  IdentFragment  for $T { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter )->  fmt ::  Result { fmt ::  Display ::  fmt ( self ,  f )}})* }}
macro_rules! __ra_macro_fixture139 {($($t :  ident =>$name :  ident )*)=>($(impl  ToTokens  for $t { fn  to_tokens (&  self ,  tokens : &  mut  TokenStream ){ tokens .  append ( Literal ::$name (*  self )); }})*)}
macro_rules! __ra_macro_fixture140 {($($l :  tt )*)=>{$(impl < 'q ,  T : 'q >  RepAsIteratorExt < 'q >  for [ T ; $l ]{ type  Iter =  slice ::  Iter < 'q ,  T >;  fn  quote_into_iter (& 'q  self )-> ( Self ::  Iter ,  HasIter ){( self .  iter (),  HasIter )}})* }}
macro_rules! __ra_macro_fixture141 {($name :  ident $spanned :  ident $char1 :  tt )=>{ pub  fn $name ( tokens : &  mut  TokenStream ){ tokens .  append ( Punct ::  new ($char1 ,  Spacing ::  Alone )); } pub  fn $spanned ( tokens : &  mut  TokenStream ,  span :  Span ){ let  mut  punct =  Punct ::  new ($char1 ,  Spacing ::  Alone );  punct .  set_span ( span );  tokens .  append ( punct ); }}; ($name :  ident $spanned :  ident $char1 :  tt $char2 :  tt )=>{ pub  fn $name ( tokens : &  mut  TokenStream ){ tokens .  append ( Punct ::  new ($char1 ,  Spacing ::  Joint ));  tokens .  append ( Punct ::  new ($char2 ,  Spacing ::  Alone )); } pub  fn $spanned ( tokens : &  mut  TokenStream ,  span :  Span ){ let  mut  punct =  Punct ::  new ($char1 ,  Spacing ::  Joint );  punct .  set_span ( span );  tokens .  append ( punct );  let  mut  punct =  Punct ::  new ($char2 ,  Spacing ::  Alone );  punct .  set_span ( span );  tokens .  append ( punct ); }}; ($name :  ident $spanned :  ident $char1 :  tt $char2 :  tt $char3 :  tt )=>{ pub  fn $name ( tokens : &  mut  TokenStream ){ tokens .  append ( Punct ::  new ($char1 ,  Spacing ::  Joint ));  tokens .  append ( Punct ::  new ($char2 ,  Spacing ::  Joint ));  tokens .  append ( Punct ::  new ($char3 ,  Spacing ::  Alone )); } pub  fn $spanned ( tokens : &  mut  TokenStream ,  span :  Span ){ let  mut  punct =  Punct ::  new ($char1 ,  Spacing ::  Joint );  punct .  set_span ( span );  tokens .  append ( punct );  let  mut  punct =  Punct ::  new ($char2 ,  Spacing ::  Joint );  punct .  set_span ( span );  tokens .  append ( punct );  let  mut  punct =  Punct ::  new ($char3 ,  Spacing ::  Alone );  punct .  set_span ( span );  tokens .  append ( punct ); }}; }
macro_rules! __ra_macro_fixture142 {($display :  tt $name :  ty )=>{# [ cfg ( feature =  "parsing" )] impl  Token  for $name { fn  peek ( cursor :  Cursor )->  bool { fn  peek ( input :  ParseStream )->  bool {<$name  as  Parse >::  parse ( input ).  is_ok ()} peek_impl ( cursor ,  peek )} fn  display ()-> & 'static  str {$display }}# [ cfg ( feature =  "parsing" )] impl  private ::  Sealed  for $name {}}; }
macro_rules! __ra_macro_fixture143 {($display :  tt $ty :  ident $get :  ident )=>{# [ cfg ( feature =  "parsing" )] impl  Token  for $ty { fn  peek ( cursor :  Cursor )->  bool { cursor .$get ().  is_some ()} fn  display ()-> & 'static  str {$display }}# [ cfg ( feature =  "parsing" )] impl  private ::  Sealed  for $ty {}}; }
macro_rules! __ra_macro_fixture144 {($($token :  tt  pub  struct $name :  ident /$len :  tt # [$doc :  meta ])*)=>{$(# [ repr ( C )]# [$doc ]# [ doc =  "" ]# [ doc =  " Don\\\'t try to remember the name of this type &mdash; use the" ]# [ doc =  " [`Token!`] macro instead." ]# [ doc =  "" ]# [ doc =  " [`Token!`]: crate::token" ] pub  struct $name { pub  spans : [ Span ; $len ], }# [ doc ( hidden )]# [ allow ( non_snake_case )] pub  fn $name <  S :  IntoSpans < [ Span ; $len ]>> ( spans :  S )-> $name {$name { spans :  spans .  into_spans (), }} impl  std ::  default ::  Default  for $name { fn  default ()->  Self {$name { spans : [ Span ::  call_site (); $len ], }}}# [ cfg ( feature =  "clone-impls" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "clone-impls" )))] impl  Copy  for $name {}# [ cfg ( feature =  "clone-impls" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "clone-impls" )))] impl  Clone  for $name { fn  clone (&  self )->  Self {*  self }}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  Debug  for $name { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter )->  fmt ::  Result { f .  write_str ( stringify ! ($name ))}}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  cmp ::  Eq  for $name {}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  PartialEq  for $name { fn  eq (&  self ,  _other : &$name )->  bool { true }}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  Hash  for $name { fn  hash <  H :  Hasher > (&  self ,  _state : &  mut  H ){}} impl_deref_if_len_is_1 ! ($name /$len ); )* }; }
macro_rules! __ra_macro_fixture145 {($($token :  tt  pub  struct $name :  ident # [$doc :  meta ])*)=>{$(# [$doc ]# [ doc =  "" ]# [ doc =  " Don\\\'t try to remember the name of this type &mdash; use the" ]# [ doc =  " [`Token!`] macro instead." ]# [ doc =  "" ]# [ doc =  " [`Token!`]: crate::token" ] pub  struct $name { pub  span :  Span , }# [ doc ( hidden )]# [ allow ( non_snake_case )] pub  fn $name <  S :  IntoSpans < [ Span ;  1 ]>> ( span :  S )-> $name {$name { span :  span .  into_spans ()[ 0 ], }} impl  std ::  default ::  Default  for $name { fn  default ()->  Self {$name { span :  Span ::  call_site (), }}}# [ cfg ( feature =  "clone-impls" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "clone-impls" )))] impl  Copy  for $name {}# [ cfg ( feature =  "clone-impls" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "clone-impls" )))] impl  Clone  for $name { fn  clone (&  self )->  Self {*  self }}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  Debug  for $name { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter )->  fmt ::  Result { f .  write_str ( stringify ! ($name ))}}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  cmp ::  Eq  for $name {}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  PartialEq  for $name { fn  eq (&  self ,  _other : &$name )->  bool { true }}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  Hash  for $name { fn  hash <  H :  Hasher > (&  self ,  _state : &  mut  H ){}}# [ cfg ( feature =  "printing" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "printing" )))] impl  ToTokens  for $name { fn  to_tokens (&  self ,  tokens : &  mut  TokenStream ){ printing ::  keyword ($token ,  self .  span ,  tokens ); }}# [ cfg ( feature =  "parsing" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "parsing" )))] impl  Parse  for $name { fn  parse ( input :  ParseStream )->  Result <  Self > { Ok ($name { span :  parsing ::  keyword ( input , $token )?, })}}# [ cfg ( feature =  "parsing" )] impl  Token  for $name { fn  peek ( cursor :  Cursor )->  bool { parsing ::  peek_keyword ( cursor , $token )} fn  display ()-> & 'static  str { concat ! ( "`" , $token ,  "`" )}}# [ cfg ( feature =  "parsing" )] impl  private ::  Sealed  for $name {})* }; }
macro_rules! __ra_macro_fixture146 {($($token :  tt  pub  struct $name :  ident /$len :  tt # [$doc :  meta ])*)=>{$(define_punctuation_structs ! {$token  pub  struct $name /$len # [$doc ]}# [ cfg ( feature =  "printing" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "printing" )))] impl  ToTokens  for $name { fn  to_tokens (&  self ,  tokens : &  mut  TokenStream ){ printing ::  punct ($token , &  self .  spans ,  tokens ); }}# [ cfg ( feature =  "parsing" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "parsing" )))] impl  Parse  for $name { fn  parse ( input :  ParseStream )->  Result <  Self > { Ok ($name { spans :  parsing ::  punct ( input , $token )?, })}}# [ cfg ( feature =  "parsing" )] impl  Token  for $name { fn  peek ( cursor :  Cursor )->  bool { parsing ::  peek_punct ( cursor , $token )} fn  display ()-> & 'static  str { concat ! ( "`" , $token ,  "`" )}}# [ cfg ( feature =  "parsing" )] impl  private ::  Sealed  for $name {})* }; }
macro_rules! __ra_macro_fixture147 {($($token :  tt  pub  struct $name :  ident # [$doc :  meta ])*)=>{$(# [$doc ] pub  struct $name { pub  span :  Span , }# [ doc ( hidden )]# [ allow ( non_snake_case )] pub  fn $name <  S :  IntoSpans < [ Span ;  1 ]>> ( span :  S )-> $name {$name { span :  span .  into_spans ()[ 0 ], }} impl  std ::  default ::  Default  for $name { fn  default ()->  Self {$name { span :  Span ::  call_site (), }}}# [ cfg ( feature =  "clone-impls" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "clone-impls" )))] impl  Copy  for $name {}# [ cfg ( feature =  "clone-impls" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "clone-impls" )))] impl  Clone  for $name { fn  clone (&  self )->  Self {*  self }}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  Debug  for $name { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter )->  fmt ::  Result { f .  write_str ( stringify ! ($name ))}}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  cmp ::  Eq  for $name {}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  PartialEq  for $name { fn  eq (&  self ,  _other : &$name )->  bool { true }}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  Hash  for $name { fn  hash <  H :  Hasher > (&  self ,  _state : &  mut  H ){}} impl $name {# [ cfg ( feature =  "printing" )] pub  fn  surround <  F > (&  self ,  tokens : &  mut  TokenStream ,  f :  F ) where  F :  FnOnce (&  mut  TokenStream ), { printing ::  delim ($token ,  self .  span ,  tokens ,  f ); }}# [ cfg ( feature =  "parsing" )] impl  private ::  Sealed  for $name {})* }; }
macro_rules! __ra_macro_fixture148 {($token :  ident )=>{ impl  From <  Token ! [$token ]>  for  Ident { fn  from ( token :  Token ! [$token ])->  Ident { Ident ::  new ( stringify ! ($token ),  token .  span )}}}; }
macro_rules! __ra_macro_fixture149 {([$($attrs_pub :  tt )*] struct $name :  ident #  full $($rest :  tt )* )=>{# [ cfg ( feature =  "full" )]$($attrs_pub )*  struct $name $($rest )* # [ cfg ( not ( feature =  "full" ))]$($attrs_pub )*  struct $name { _noconstruct : ::  std ::  marker ::  PhantomData <::  proc_macro2 ::  Span >, }# [ cfg ( all ( not ( feature =  "full" ),  feature =  "printing" ))] impl ::  quote ::  ToTokens  for $name { fn  to_tokens (&  self , _: &  mut ::  proc_macro2 ::  TokenStream ){ unreachable ! ()}}}; ([$($attrs_pub :  tt )*] struct $name :  ident $($rest :  tt )* )=>{$($attrs_pub )*  struct $name $($rest )* }; ($($t :  tt )*)=>{ strip_attrs_pub ! ( ast_struct ! ($($t )*)); }; }
macro_rules! __ra_macro_fixture150 {([$($attrs_pub :  tt )*] enum $name :  ident #  no_visit $($rest :  tt )* )=>( ast_enum ! ([$($attrs_pub )*] enum $name $($rest )*); ); ([$($attrs_pub :  tt )*] enum $name :  ident $($rest :  tt )* )=>($($attrs_pub )*  enum $name $($rest )* ); ($($t :  tt )*)=>{ strip_attrs_pub ! ( ast_enum ! ($($t )*)); }; }
macro_rules! __ra_macro_fixture151 {($(# [$enum_attr :  meta ])* $pub :  ident $enum :  ident $name :  ident #$tag :  ident $body :  tt $($remaining :  tt )* )=>{ ast_enum ! ($(# [$enum_attr ])* $pub $enum $name #$tag $body );  ast_enum_of_structs_impl ! ($pub $enum $name $body $($remaining )*); }; ($(# [$enum_attr :  meta ])* $pub :  ident $enum :  ident $name :  ident $body :  tt $($remaining :  tt )* )=>{ ast_enum ! ($(# [$enum_attr ])* $pub $enum $name $body );  ast_enum_of_structs_impl ! ($pub $enum $name $body $($remaining )*); }; }
macro_rules! __ra_macro_fixture152 {($ident :  ident )=>{# [ allow ( non_camel_case_types )] pub  struct $ident { pub  span : $crate ::  __private ::  Span , }# [ doc ( hidden )]# [ allow ( dead_code ,  non_snake_case )] pub  fn $ident <  __S : $crate ::  __private ::  IntoSpans < [$crate ::  __private ::  Span ;  1 ]>> ( span :  __S , )-> $ident {$ident { span : $crate ::  __private ::  IntoSpans ::  into_spans ( span )[ 0 ], }} impl $crate ::  __private ::  Default  for $ident { fn  default ()->  Self {$ident { span : $crate ::  __private ::  Span ::  call_site (), }}}$crate ::  impl_parse_for_custom_keyword ! ($ident ); $crate ::  impl_to_tokens_for_custom_keyword ! ($ident ); $crate ::  impl_clone_for_custom_keyword ! ($ident ); $crate ::  impl_extra_traits_for_custom_keyword ! ($ident ); }; }
macro_rules! __ra_macro_fixture153 {($($expr_type :  ty , $variant :  ident , $msg :  expr , )* )=>{$(# [ cfg ( all ( feature =  "full" ,  feature =  "printing" ))]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "parsing" )))] impl  Parse  for $expr_type { fn  parse ( input :  ParseStream )->  Result <  Self > { let  mut  expr :  Expr =  input .  parse ()?;  loop { match  expr { Expr ::$variant ( inner )=> return  Ok ( inner ),  Expr ::  Group ( next )=> expr = *  next .  expr , _ => return  Err ( Error ::  new_spanned ( expr , $msg )), }}}})* }; }
macro_rules! __ra_macro_fixture154 {($ty :  ident )=>{# [ cfg ( feature =  "clone-impls" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "clone-impls" )))] impl < 'a >  Clone  for $ty < 'a > { fn  clone (&  self )->  Self {$ty ( self .  0 )}}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl < 'a >  Debug  for $ty < 'a > { fn  fmt (&  self ,  formatter : &  mut  fmt ::  Formatter )->  fmt ::  Result { formatter .  debug_tuple ( stringify ! ($ty )).  field ( self .  0 ).  finish ()}}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl < 'a >  Eq  for $ty < 'a > {}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl < 'a >  PartialEq  for $ty < 'a > { fn  eq (&  self ,  other : &  Self )->  bool { self .  0 ==  other .  0 }}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl < 'a >  Hash  for $ty < 'a > { fn  hash <  H :  Hasher > (&  self ,  state : &  mut  H ){ self .  0 .  hash ( state ); }}}; }
macro_rules! __ra_macro_fixture155 {($ty :  ident )=>{# [ cfg ( feature =  "clone-impls" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "clone-impls" )))] impl  Clone  for $ty { fn  clone (&  self )->  Self {$ty { repr :  self .  repr .  clone (), }}}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  PartialEq  for $ty { fn  eq (&  self ,  other : &  Self )->  bool { self .  repr .  token .  to_string ()==  other .  repr .  token .  to_string ()}}# [ cfg ( feature =  "extra-traits" )]# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "extra-traits" )))] impl  Hash  for $ty { fn  hash <  H > (&  self ,  state : &  mut  H ) where  H :  Hasher , { self .  repr .  token .  to_string ().  hash ( state ); }}# [ cfg ( feature =  "parsing" )]# [ doc ( hidden )]# [ allow ( non_snake_case )] pub  fn $ty ( marker :  lookahead ::  TokenMarker )-> $ty { match  marker {}}}; }
macro_rules! __ra_macro_fixture156 {($name :  ident /  1 )=>{ impl  Deref  for $name { type  Target =  WithSpan ;  fn  deref (&  self )-> &  Self ::  Target { unsafe {&* ( self  as *  const  Self  as *  const  WithSpan )}}} impl  DerefMut  for $name { fn  deref_mut (&  mut  self )-> &  mut  Self ::  Target { unsafe {&  mut * ( self  as *  mut  Self  as *  mut  WithSpan )}}}}; ($name :  ident /$len :  tt )=>{}; }
macro_rules! __ra_macro_fixture157 {($($await_rule :  tt )*)=>{# [ doc =  " A type-macro that expands to the name of the Rust type representation of a" ]# [ doc =  " given token." ]# [ doc =  "" ]# [ doc =  " See the [token module] documentation for details and examples." ]# [ doc =  "" ]# [ doc =  " [token module]: crate::token" ]# [ macro_export ] macro_rules !  Token {[ abstract ]=>{$crate ::  token ::  Abstract }; [ as ]=>{$crate ::  token ::  As }; [ async ]=>{$crate ::  token ::  Async }; [ auto ]=>{$crate ::  token ::  Auto }; $($await_rule =>{$crate ::  token ::  Await };)* [ become ]=>{$crate ::  token ::  Become }; [ box ]=>{$crate ::  token ::  Box }; [ break ]=>{$crate ::  token ::  Break }; [ const ]=>{$crate ::  token ::  Const }; [ continue ]=>{$crate ::  token ::  Continue }; [ crate ]=>{$crate ::  token ::  Crate }; [ default ]=>{$crate ::  token ::  Default }; [ do ]=>{$crate ::  token ::  Do }; [ dyn ]=>{$crate ::  token ::  Dyn }; [ else ]=>{$crate ::  token ::  Else }; [ enum ]=>{$crate ::  token ::  Enum }; [ extern ]=>{$crate ::  token ::  Extern }; [ final ]=>{$crate ::  token ::  Final }; [ fn ]=>{$crate ::  token ::  Fn }; [ for ]=>{$crate ::  token ::  For }; [ if ]=>{$crate ::  token ::  If }; [ impl ]=>{$crate ::  token ::  Impl }; [ in ]=>{$crate ::  token ::  In }; [ let ]=>{$crate ::  token ::  Let }; [ loop ]=>{$crate ::  token ::  Loop }; [ macro ]=>{$crate ::  token ::  Macro }; [ match ]=>{$crate ::  token ::  Match }; [ mod ]=>{$crate ::  token ::  Mod }; [ move ]=>{$crate ::  token ::  Move }; [ mut ]=>{$crate ::  token ::  Mut }; [ override ]=>{$crate ::  token ::  Override }; [ priv ]=>{$crate ::  token ::  Priv }; [ pub ]=>{$crate ::  token ::  Pub }; [ ref ]=>{$crate ::  token ::  Ref }; [ return ]=>{$crate ::  token ::  Return }; [ Self ]=>{$crate ::  token ::  SelfType }; [ self ]=>{$crate ::  token ::  SelfValue }; [ static ]=>{$crate ::  token ::  Static }; [ struct ]=>{$crate ::  token ::  Struct }; [ super ]=>{$crate ::  token ::  Super }; [ trait ]=>{$crate ::  token ::  Trait }; [ try ]=>{$crate ::  token ::  Try }; [ type ]=>{$crate ::  token ::  Type }; [ typeof ]=>{$crate ::  token ::  Typeof }; [ union ]=>{$crate ::  token ::  Union }; [ unsafe ]=>{$crate ::  token ::  Unsafe }; [ unsized ]=>{$crate ::  token ::  Unsized }; [ use ]=>{$crate ::  token ::  Use }; [ virtual ]=>{$crate ::  token ::  Virtual }; [ where ]=>{$crate ::  token ::  Where }; [ while ]=>{$crate ::  token ::  While }; [ yield ]=>{$crate ::  token ::  Yield }; [+]=>{$crate ::  token ::  Add }; [+=]=>{$crate ::  token ::  AddEq }; [&]=>{$crate ::  token ::  And }; [&&]=>{$crate ::  token ::  AndAnd }; [&=]=>{$crate ::  token ::  AndEq }; [@]=>{$crate ::  token ::  At }; [!]=>{$crate ::  token ::  Bang }; [^]=>{$crate ::  token ::  Caret }; [^=]=>{$crate ::  token ::  CaretEq }; [:]=>{$crate ::  token ::  Colon }; [::]=>{$crate ::  token ::  Colon2 }; [,]=>{$crate ::  token ::  Comma }; [/]=>{$crate ::  token ::  Div }; [/=]=>{$crate ::  token ::  DivEq }; [$]=>{$crate ::  token ::  Dollar }; [.]=>{$crate ::  token ::  Dot }; [..]=>{$crate ::  token ::  Dot2 }; [...]=>{$crate ::  token ::  Dot3 }; [..=]=>{$crate ::  token ::  DotDotEq }; [=]=>{$crate ::  token ::  Eq }; [==]=>{$crate ::  token ::  EqEq }; [>=]=>{$crate ::  token ::  Ge }; [>]=>{$crate ::  token ::  Gt }; [<=]=>{$crate ::  token ::  Le }; [<]=>{$crate ::  token ::  Lt }; [*=]=>{$crate ::  token ::  MulEq }; [!=]=>{$crate ::  token ::  Ne }; [|]=>{$crate ::  token ::  Or }; [|=]=>{$crate ::  token ::  OrEq }; [||]=>{$crate ::  token ::  OrOr }; [#]=>{$crate ::  token ::  Pound }; [?]=>{$crate ::  token ::  Question }; [->]=>{$crate ::  token ::  RArrow }; [<-]=>{$crate ::  token ::  LArrow }; [%]=>{$crate ::  token ::  Rem }; [%=]=>{$crate ::  token ::  RemEq }; [=>]=>{$crate ::  token ::  FatArrow }; [;]=>{$crate ::  token ::  Semi }; [<<]=>{$crate ::  token ::  Shl }; [<<=]=>{$crate ::  token ::  ShlEq }; [>>]=>{$crate ::  token ::  Shr }; [>>=]=>{$crate ::  token ::  ShrEq }; [*]=>{$crate ::  token ::  Star }; [-]=>{$crate ::  token ::  Sub }; [-=]=>{$crate ::  token ::  SubEq }; [~]=>{$crate ::  token ::  Tilde }; [_]=>{$crate ::  token ::  Underscore }; }}; }
macro_rules! __ra_macro_fixture158 {($mac :  ident ! ($(# [$m :  meta ])* $pub :  ident $($t :  tt )*))=>{ check_keyword_matches ! ( pub $pub ); $mac ! ([$(# [$m ])* $pub ]$($t )*); }; }
macro_rules! __ra_macro_fixture159 {($pub :  ident $enum :  ident $name :  ident {$($(# [$variant_attr :  meta ])* $variant :  ident $(($($member :  ident )::+))*, )* }$($remaining :  tt )* )=>{ check_keyword_matches ! ( pub $pub );  check_keyword_matches ! ( enum $enum ); $($(ast_enum_from_struct ! ($name ::$variant , $($member )::+); )*)* # [ cfg ( feature =  "printing" )] generate_to_tokens ! {$($remaining )* () tokens $name {$($variant $($($member )::+)*,)* }}}; }
macro_rules! __ra_macro_fixture160 {($ident :  ident )=>{ impl $crate ::  token ::  CustomToken  for $ident { fn  peek ( cursor : $crate ::  buffer ::  Cursor )-> $crate ::  __private ::  bool { if  let  Some (( ident ,  _rest ))=  cursor .  ident (){ ident ==  stringify ! ($ident )} else { false }} fn  display ()-> & 'static $crate ::  __private ::  str { concat ! ( "`" ,  stringify ! ($ident ),  "`" )}} impl $crate ::  parse ::  Parse  for $ident { fn  parse ( input : $crate ::  parse ::  ParseStream )-> $crate ::  parse ::  Result <$ident > { input .  step (|  cursor | { if  let $crate ::  __private ::  Some (( ident ,  rest ))=  cursor .  ident (){ if  ident ==  stringify ! ($ident ){ return $crate ::  __private ::  Ok (($ident { span :  ident .  span ()},  rest )); }}$crate ::  __private ::  Err ( cursor .  error ( concat ! ( "expected `" ,  stringify ! ($ident ),  "`" )))})}}}; }
macro_rules! __ra_macro_fixture161 {($ident :  ident )=>{ impl $crate ::  __private ::  ToTokens  for $ident { fn  to_tokens (&  self ,  tokens : &  mut $crate ::  __private ::  TokenStream2 ){ let  ident = $crate ::  Ident ::  new ( stringify ! ($ident ),  self .  span ); $crate ::  __private ::  TokenStreamExt ::  append ( tokens ,  ident ); }}}; }
macro_rules! __ra_macro_fixture162 {($ident :  ident )=>{ impl $crate ::  __private ::  Copy  for $ident {} impl $crate ::  __private ::  Clone  for $ident { fn  clone (&  self )->  Self {*  self }}}; }
macro_rules! __ra_macro_fixture163 {($ident :  ident )=>{ impl $crate ::  __private ::  Debug  for $ident { fn  fmt (&  self ,  f : &  mut $crate ::  __private ::  Formatter )-> $crate ::  __private ::  fmt ::  Result {$crate ::  __private ::  Formatter ::  write_str ( f ,  concat ! ( "Keyword [" ,  stringify ! ($ident ),  "]" ), )}} impl $crate ::  __private ::  Eq  for $ident {} impl $crate ::  __private ::  PartialEq  for $ident { fn  eq (&  self ,  _other : &  Self )-> $crate ::  __private ::  bool { true }} impl $crate ::  __private ::  Hash  for $ident { fn  hash <  __H : $crate ::  __private ::  Hasher > (&  self ,  _state : &  mut  __H ){}}}; }
macro_rules! __ra_macro_fixture164 {( struct  struct )=>{}; ( enum  enum )=>{}; ( pub  pub )=>{}; }
macro_rules! __ra_macro_fixture165 {($name :  ident ::  Verbatim , $member :  ident )=>{}; ($name :  ident ::$variant :  ident ,  crate ::  private )=>{}; ($name :  ident ::$variant :  ident , $member :  ident )=>{ impl  From <$member >  for $name { fn  from ( e : $member )-> $name {$name ::$variant ( e )}}}; }
macro_rules! __ra_macro_fixture166 {( do_not_generate_to_tokens $($foo :  tt )*)=>(); (($($arms :  tt )*)$tokens :  ident $name :  ident {$variant :  ident , $($next :  tt )*})=>{ generate_to_tokens ! (($($arms )* $name ::$variant =>{})$tokens $name {$($next )* }); }; (($($arms :  tt )*)$tokens :  ident $name :  ident {$variant :  ident $member :  ident , $($next :  tt )*})=>{ generate_to_tokens ! (($($arms )* $name ::$variant ( _e )=> _e .  to_tokens ($tokens ),)$tokens $name {$($next )* }); }; (($($arms :  tt )*)$tokens :  ident $name :  ident {$variant :  ident  crate ::  private , $($next :  tt )*})=>{ generate_to_tokens ! (($($arms )* $name ::$variant (_)=> unreachable ! (),)$tokens $name {$($next )* }); }; (($($arms :  tt )*)$tokens :  ident $name :  ident {})=>{# [ cfg_attr ( doc_cfg ,  doc ( cfg ( feature =  "printing" )))] impl ::  quote ::  ToTokens  for $name { fn  to_tokens (&  self , $tokens : &  mut ::  proc_macro2 ::  TokenStream ){ match  self {$($arms )* }}}}; }
macro_rules! __ra_macro_fixture167 {($(# [$attr :  meta ])*  static  ref $N :  ident : $T :  ty = $e :  expr ; $($t :  tt )*)=>{ __lazy_static_internal ! ($(# [$attr ])* () static  ref $N : $T = $e ; $($t )*); }; ($(# [$attr :  meta ])*  pub  static  ref $N :  ident : $T :  ty = $e :  expr ; $($t :  tt )*)=>{ __lazy_static_internal ! ($(# [$attr ])* ( pub ) static  ref $N : $T = $e ; $($t )*); }; ($(# [$attr :  meta ])*  pub ($($vis :  tt )+) static  ref $N :  ident : $T :  ty = $e :  expr ; $($t :  tt )*)=>{ __lazy_static_internal ! ($(# [$attr ])* ( pub ($($vis )+)) static  ref $N : $T = $e ; $($t )*); }; ()=>()}
macro_rules! __ra_macro_fixture168 {($($record :  ident ($($whatever :  tt )+ )),+ )=>{$(impl_value ! {$record ($($whatever )+ )})+ }}
macro_rules! __ra_macro_fixture169 {($($len :  tt ),+ )=>{$(impl < 'a >  private ::  ValidLen < 'a >  for [(& 'a  Field ,  Option <& 'a ( dyn  Value + 'a )>); $len ]{})+ }}
macro_rules! __ra_macro_fixture170 {($(# [$attr :  meta ])* ($($vis :  tt )*) static  ref $N :  ident : $T :  ty = $e :  expr ; $($t :  tt )*)=>{ __lazy_static_internal ! (@  MAKE  TY , $(# [$attr ])*, ($($vis )*), $N );  __lazy_static_internal ! (@  TAIL , $N : $T = $e );  lazy_static ! ($($t )*); }; (@  TAIL , $N :  ident : $T :  ty = $e :  expr )=>{ impl $crate ::  __Deref  for $N { type  Target = $T ;  fn  deref (&  self )-> &$T {# [ inline ( always )] fn  __static_ref_initialize ()-> $T {$e }# [ inline ( always )] fn  __stability ()-> & 'static $T { __lazy_static_create ! ( LAZY , $T );  LAZY .  get ( __static_ref_initialize )} __stability ()}} impl $crate ::  LazyStatic  for $N { fn  initialize ( lazy : &  Self ){ let _ = &**  lazy ; }}}; (@  MAKE  TY , $(# [$attr :  meta ])*, ($($vis :  tt )*), $N :  ident )=>{# [ allow ( missing_copy_implementations )]# [ allow ( non_camel_case_types )]# [ allow ( dead_code )]$(# [$attr ])* $($vis )*  struct $N { __private_field : ()}# [ doc ( hidden )]$($vis )*  static $N : $N = $N { __private_field : ()}; }; ()=>()}
macro_rules! __ra_macro_fixture171 {($record :  ident ($($value_ty :  tt ),+ ))=>{$(impl_one_value ! ($value_ty , |  this : $value_ty |  this , $record ); )+ }; ($record :  ident ($($value_ty :  tt ),+  as $as_ty :  ty ))=>{$(impl_one_value ! ($value_ty , |  this : $value_ty |  this  as $as_ty , $record ); )+ }; }
macro_rules! __ra_macro_fixture172 {( bool , $op :  expr , $record :  ident )=>{ impl_one_value ! ( normal ,  bool , $op , $record ); }; ($value_ty :  tt , $op :  expr , $record :  ident )=>{ impl_one_value ! ( normal , $value_ty , $op , $record );  impl_one_value ! ( nonzero , $value_ty , $op , $record ); }; ( normal , $value_ty :  tt , $op :  expr , $record :  ident )=>{ impl $crate ::  sealed ::  Sealed  for $value_ty {} impl $crate ::  field ::  Value  for $value_ty { fn  record (&  self ,  key : &$crate ::  field ::  Field ,  visitor : &  mut  dyn $crate ::  field ::  Visit ){ visitor .$record ( key , $op (*  self ))}}}; ( nonzero , $value_ty :  tt , $op :  expr , $record :  ident )=>{# [ allow ( clippy ::  useless_attribute ,  unused )] use  num ::*;  impl $crate ::  sealed ::  Sealed  for  ty_to_nonzero ! ($value_ty ){} impl $crate ::  field ::  Value  for  ty_to_nonzero ! ($value_ty ){ fn  record (&  self ,  key : &$crate ::  field ::  Field ,  visitor : &  mut  dyn $crate ::  field ::  Visit ){ visitor .$record ( key , $op ( self .  get ()))}}}; }
macro_rules! __ra_macro_fixture173 {($(# [ doc $($doc :  tt )*])* # [ project = $proj_mut_ident :  ident ]# [ project_ref = $proj_ref_ident :  ident ]# [ project_replace = $proj_replace_ident :  ident ]$($tt :  tt )* )=>{$crate ::  __pin_project_internal ! {[$proj_mut_ident ][$proj_ref_ident ][$proj_replace_ident ]$(# [ doc $($doc )*])* $($tt )* }}; ($(# [ doc $($doc :  tt )*])* # [ project = $proj_mut_ident :  ident ]# [ project_ref = $proj_ref_ident :  ident ]$($tt :  tt )* )=>{$crate ::  __pin_project_internal ! {[$proj_mut_ident ][$proj_ref_ident ][]$(# [ doc $($doc )*])* $($tt )* }}; ($(# [ doc $($doc :  tt )*])* # [ project = $proj_mut_ident :  ident ]# [ project_replace = $proj_replace_ident :  ident ]$($tt :  tt )* )=>{$crate ::  __pin_project_internal ! {[$proj_mut_ident ][][$proj_replace_ident ]$(# [ doc $($doc )*])* $($tt )* }}; ($(# [ doc $($doc :  tt )*])* # [ project_ref = $proj_ref_ident :  ident ]# [ project_replace = $proj_replace_ident :  ident ]$($tt :  tt )* )=>{$crate ::  __pin_project_internal ! {[][$proj_ref_ident ][$proj_replace_ident ]$(# [ doc $($doc )*])* $($tt )* }}; ($(# [ doc $($doc :  tt )*])* # [ project = $proj_mut_ident :  ident ]$($tt :  tt )* )=>{$crate ::  __pin_project_internal ! {[$proj_mut_ident ][][]$(# [ doc $($doc )*])* $($tt )* }}; ($(# [ doc $($doc :  tt )*])* # [ project_ref = $proj_ref_ident :  ident ]$($tt :  tt )* )=>{$crate ::  __pin_project_internal ! {[][$proj_ref_ident ][]$(# [ doc $($doc )*])* $($tt )* }}; ($(# [ doc $($doc :  tt )*])* # [ project_replace = $proj_replace_ident :  ident ]$($tt :  tt )* )=>{$crate ::  __pin_project_internal ! {[][][$proj_replace_ident ]$(# [ doc $($doc )*])* $($tt )* }}; ($($tt :  tt )* )=>{$crate ::  __pin_project_internal ! {[][][]$($tt )* }}; }
macro_rules! __ra_macro_fixture174 {(@  struct => internal ; [$($proj_mut_ident :  ident )?][$($proj_ref_ident :  ident )?][$($proj_replace_ident :  ident )?][$proj_vis :  vis ][$(# [$attrs :  meta ])* $vis :  vis  struct $ident :  ident ][$($def_generics :  tt )*][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )*)?]{$($(# [$pin :  ident ])? $field_vis :  vis $field :  ident : $field_ty :  ty ),+ })=>{$(# [$attrs ])* $vis  struct $ident $($def_generics )* $(where $($where_clause )*)? {$($field_vis $field : $field_ty ),+ }$crate ::  __pin_project_internal ! {@  struct => make_proj_ty => named ; [$proj_vis ][$($proj_mut_ident )?][ make_proj_field_mut ][$ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]{$($(# [$pin ])? $field_vis $field : $field_ty ),+ }}$crate ::  __pin_project_internal ! {@  struct => make_proj_ty => named ; [$proj_vis ][$($proj_ref_ident )?][ make_proj_field_ref ][$ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]{$($(# [$pin ])? $field_vis $field : $field_ty ),+ }}$crate ::  __pin_project_internal ! {@  struct => make_proj_replace_ty => named ; [$proj_vis ][$($proj_replace_ident )?][ make_proj_field_replace ][$ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]{$($(# [$pin ])? $field_vis $field : $field_ty ),+ }}# [ allow ( explicit_outlives_requirements )]# [ allow ( single_use_lifetimes )]# [ allow ( clippy ::  unknown_clippy_lints )]# [ allow ( clippy ::  redundant_pub_crate )]# [ allow ( clippy ::  used_underscore_binding )] const _: ()= {$crate ::  __pin_project_internal ! {@  struct => make_proj_ty => unnamed ; [$proj_vis ][$($proj_mut_ident )?][ Projection ][ make_proj_field_mut ][$ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]{$($(# [$pin ])? $field_vis $field : $field_ty ),+ }}$crate ::  __pin_project_internal ! {@  struct => make_proj_ty => unnamed ; [$proj_vis ][$($proj_ref_ident )?][ ProjectionRef ][ make_proj_field_ref ][$ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]{$($(# [$pin ])? $field_vis $field : $field_ty ),+ }}$crate ::  __pin_project_internal ! {@  struct => make_proj_replace_ty => unnamed ; [$proj_vis ][$($proj_replace_ident )?][ ProjectionReplace ][ make_proj_field_replace ][$ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]{$($(# [$pin ])? $field_vis $field : $field_ty ),+ }} impl <$($impl_generics )*> $ident <$($ty_generics )*> $(where $($where_clause )*)? {$crate ::  __pin_project_internal ! {@  struct => make_proj_method ; [$proj_vis ][$($proj_mut_ident )?][ Projection ][ project  get_unchecked_mut  mut ][$($ty_generics )*]{$($(# [$pin ])? $field_vis $field ),+ }}$crate ::  __pin_project_internal ! {@  struct => make_proj_method ; [$proj_vis ][$($proj_ref_ident )?][ ProjectionRef ][ project_ref  get_ref ][$($ty_generics )*]{$($(# [$pin ])? $field_vis $field ),+ }}$crate ::  __pin_project_internal ! {@  struct => make_proj_replace_method ; [$proj_vis ][$($proj_replace_ident )?][ ProjectionReplace ][$($ty_generics )*]{$($(# [$pin ])? $field_vis $field ),+ }}}$crate ::  __pin_project_internal ! {@  make_unpin_impl ; [$vis $ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]$($field : $crate ::  __pin_project_internal ! (@  make_unpin_bound ; $(# [$pin ])? $field_ty )),+ }$crate ::  __pin_project_internal ! {@  make_drop_impl ; [$ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]}# [ forbid ( safe_packed_borrows )] fn  __assert_not_repr_packed <$($impl_generics )*> ( this : &$ident <$($ty_generics )*>)$(where $($where_clause )*)? {$(let _ = &  this .$field ; )+ }}; }; (@  enum => internal ; [$($proj_mut_ident :  ident )?][$($proj_ref_ident :  ident )?][$($proj_replace_ident :  ident )?][$proj_vis :  vis ][$(# [$attrs :  meta ])* $vis :  vis  enum $ident :  ident ][$($def_generics :  tt )*][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )*)?]{$($(# [$variant_attrs :  meta ])* $variant :  ident $({$($(# [$pin :  ident ])? $field :  ident : $field_ty :  ty ),+ })? ),+ })=>{$(# [$attrs ])* $vis  enum $ident $($def_generics )* $(where $($where_clause )*)? {$($(# [$variant_attrs ])* $variant $({$($field : $field_ty ),+ })? ),+ }$crate ::  __pin_project_internal ! {@  enum => make_proj_ty ; [$proj_vis ][$($proj_mut_ident )?][ make_proj_field_mut ][$ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]{$($variant $({$($(# [$pin ])? $field : $field_ty ),+ })? ),+ }}$crate ::  __pin_project_internal ! {@  enum => make_proj_ty ; [$proj_vis ][$($proj_ref_ident )?][ make_proj_field_ref ][$ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]{$($variant $({$($(# [$pin ])? $field : $field_ty ),+ })? ),+ }}$crate ::  __pin_project_internal ! {@  enum => make_proj_replace_ty ; [$proj_vis ][$($proj_replace_ident )?][ make_proj_field_replace ][$ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]{$($variant $({$($(# [$pin ])? $field : $field_ty ),+ })? ),+ }}# [ allow ( single_use_lifetimes )]# [ allow ( clippy ::  unknown_clippy_lints )]# [ allow ( clippy ::  used_underscore_binding )] const _: ()= { impl <$($impl_generics )*> $ident <$($ty_generics )*> $(where $($where_clause )*)? {$crate ::  __pin_project_internal ! {@  enum => make_proj_method ; [$proj_vis ][$($proj_mut_ident )?][ project  get_unchecked_mut  mut ][$($ty_generics )*]{$($variant $({$($(# [$pin ])? $field ),+ })? ),+ }}$crate ::  __pin_project_internal ! {@  enum => make_proj_method ; [$proj_vis ][$($proj_ref_ident )?][ project_ref  get_ref ][$($ty_generics )*]{$($variant $({$($(# [$pin ])? $field ),+ })? ),+ }}$crate ::  __pin_project_internal ! {@  enum => make_proj_replace_method ; [$proj_vis ][$($proj_replace_ident )?][$($ty_generics )*]{$($variant $({$($(# [$pin ])? $field ),+ })? ),+ }}}$crate ::  __pin_project_internal ! {@  make_unpin_impl ; [$vis $ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]$($variant : ($($($crate ::  __pin_project_internal ! (@  make_unpin_bound ; $(# [$pin ])? $field_ty )),+ )?)),+ }$crate ::  __pin_project_internal ! {@  make_drop_impl ; [$ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]}}; }; (@  struct => make_proj_ty => unnamed ; [$proj_vis :  vis ][$_proj_ty_ident :  ident ][$proj_ty_ident :  ident ][$make_proj_field :  ident ][$ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?]$($field :  tt )* )=>{}; (@  struct => make_proj_ty => unnamed ; [$proj_vis :  vis ][][$proj_ty_ident :  ident ][$make_proj_field :  ident ][$ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?]$($field :  tt )* )=>{$crate ::  __pin_project_internal ! {@  struct => make_proj_ty => named ; [$proj_vis ][$proj_ty_ident ][$make_proj_field ][$ident ][$($impl_generics )*][$($ty_generics )*][$(where $($where_clause )*)?]$($field )* }}; (@  struct => make_proj_ty => named ; [$proj_vis :  vis ][$proj_ty_ident :  ident ][$make_proj_field :  ident ][$ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?]{$($(# [$pin :  ident ])? $field_vis :  vis $field :  ident : $field_ty :  ty ),+ })=>{# [ allow ( dead_code )]# [ allow ( single_use_lifetimes )]# [ allow ( clippy ::  unknown_clippy_lints )]# [ allow ( clippy ::  mut_mut )]# [ allow ( clippy ::  redundant_pub_crate )]# [ allow ( clippy ::  ref_option_ref )]# [ allow ( clippy ::  type_repetition_in_bounds )]$proj_vis  struct $proj_ty_ident < '__pin , $($impl_generics )*>  where $ident <$($ty_generics )*>: '__pin $(, $($where_clause )*)? {$($field_vis $field : $crate ::  __pin_project_internal ! (@$make_proj_field ; $(# [$pin ])? $field_ty )),+ }}; (@  struct => make_proj_ty => named ; [$proj_vis :  vis ][][$make_proj_field :  ident ][$ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?]$($field :  tt )* )=>{}; (@  struct => make_proj_replace_ty => unnamed ; [$proj_vis :  vis ][$_proj_ty_ident :  ident ][$proj_ty_ident :  ident ][$make_proj_field :  ident ][$ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?]$($field :  tt )* )=>{}; (@  struct => make_proj_replace_ty => unnamed ; [$proj_vis :  vis ][][$proj_ty_ident :  ident ][$make_proj_field :  ident ][$ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?]$($field :  tt )* )=>{}; (@  struct => make_proj_replace_ty => named ; [$proj_vis :  vis ][$proj_ty_ident :  ident ][$make_proj_field :  ident ][$ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?]{$($(# [$pin :  ident ])? $field_vis :  vis $field :  ident : $field_ty :  ty ),+ })=>{# [ allow ( dead_code )]# [ allow ( single_use_lifetimes )]# [ allow ( clippy ::  mut_mut )]# [ allow ( clippy ::  redundant_pub_crate )]# [ allow ( clippy ::  type_repetition_in_bounds )]$proj_vis  struct $proj_ty_ident <$($impl_generics )*>  where $($($where_clause )*)? {$($field_vis $field : $crate ::  __pin_project_internal ! (@$make_proj_field ; $(# [$pin ])? $field_ty )),+ }}; (@  struct => make_proj_replace_ty => named ; [$proj_vis :  vis ][][$make_proj_field :  ident ][$ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?]$($field :  tt )* )=>{}; (@  enum => make_proj_ty ; [$proj_vis :  vis ][$proj_ty_ident :  ident ][$make_proj_field :  ident ][$ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?]{$($variant :  ident $({$($(# [$pin :  ident ])? $field :  ident : $field_ty :  ty ),+ })? ),+ })=>{# [ allow ( dead_code )]# [ allow ( single_use_lifetimes )]# [ allow ( clippy ::  unknown_clippy_lints )]# [ allow ( clippy ::  mut_mut )]# [ allow ( clippy ::  redundant_pub_crate )]# [ allow ( clippy ::  ref_option_ref )]# [ allow ( clippy ::  type_repetition_in_bounds )]$proj_vis  enum $proj_ty_ident < '__pin , $($impl_generics )*>  where $ident <$($ty_generics )*>: '__pin $(, $($where_clause )*)? {$($variant $({$($field : $crate ::  __pin_project_internal ! (@$make_proj_field ; $(# [$pin ])? $field_ty )),+ })? ),+ }}; (@  enum => make_proj_ty ; [$proj_vis :  vis ][][$make_proj_field :  ident ][$ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?]$($variant :  tt )* )=>{}; (@  enum => make_proj_replace_ty ; [$proj_vis :  vis ][$proj_ty_ident :  ident ][$make_proj_field :  ident ][$ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?]{$($variant :  ident $({$($(# [$pin :  ident ])? $field :  ident : $field_ty :  ty ),+ })? ),+ })=>{# [ allow ( dead_code )]# [ allow ( single_use_lifetimes )]# [ allow ( clippy ::  mut_mut )]# [ allow ( clippy ::  redundant_pub_crate )]# [ allow ( clippy ::  type_repetition_in_bounds )]$proj_vis  enum $proj_ty_ident <$($impl_generics )*>  where $($($where_clause )*)? {$($variant $({$($field : $crate ::  __pin_project_internal ! (@$make_proj_field ; $(# [$pin ])? $field_ty )),+ })? ),+ }}; (@  enum => make_proj_replace_ty ; [$proj_vis :  vis ][][$make_proj_field :  ident ][$ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?]$($variant :  tt )* )=>{}; (@  make_proj_replace_block ; [$($proj_path :  tt )+]{$($(# [$pin :  ident ])? $field_vis :  vis $field :  ident ),+ })=>{ let  result = $($proj_path )* {$($field : $crate ::  __pin_project_internal ! (@  make_replace_field_proj ; $(# [$pin ])? $field )),+ }; {($($crate ::  __pin_project_internal ! (@  make_unsafe_drop_in_place_guard ; $(# [$pin ])? $field ), )* ); } result }; (@  make_proj_replace_block ; [$($proj_path :  tt )+])=>{$($proj_path )* }; (@  struct => make_proj_method ; [$proj_vis :  vis ][$proj_ty_ident :  ident ][$_proj_ty_ident :  ident ][$method_ident :  ident $get_method :  ident $($mut :  ident )?][$($ty_generics :  tt )*]{$($(# [$pin :  ident ])? $field_vis :  vis $field :  ident ),+ })=>{$proj_vis  fn $method_ident < '__pin > ( self : $crate ::  __private ::  Pin <& '__pin $($mut )?  Self >, )-> $proj_ty_ident < '__pin , $($ty_generics )*> { unsafe { let  Self {$($field ),* }=  self .$get_method (); $proj_ty_ident {$($field : $crate ::  __pin_project_internal ! (@  make_unsafe_field_proj ; $(# [$pin ])? $field )),+ }}}}; (@  struct => make_proj_method ; [$proj_vis :  vis ][][$proj_ty_ident :  ident ][$method_ident :  ident $get_method :  ident $($mut :  ident )?][$($ty_generics :  tt )*]$($variant :  tt )* )=>{$crate ::  __pin_project_internal ! {@  struct => make_proj_method ; [$proj_vis ][$proj_ty_ident ][$proj_ty_ident ][$method_ident $get_method $($mut )?][$($ty_generics )*]$($variant )* }}; (@  struct => make_proj_replace_method ; [$proj_vis :  vis ][$proj_ty_ident :  ident ][$_proj_ty_ident :  ident ][$($ty_generics :  tt )*]{$($(# [$pin :  ident ])? $field_vis :  vis $field :  ident ),+ })=>{$proj_vis  fn  project_replace ( self : $crate ::  __private ::  Pin <&  mut  Self >,  replacement :  Self , )-> $proj_ty_ident <$($ty_generics )*> { unsafe { let  __self_ptr : *  mut  Self =  self .  get_unchecked_mut ();  let  __guard = $crate ::  __private ::  UnsafeOverwriteGuard { target :  __self_ptr ,  value : $crate ::  __private ::  ManuallyDrop ::  new ( replacement ), };  let  Self {$($field ),* }= &  mut *  __self_ptr ; $crate ::  __pin_project_internal ! {@  make_proj_replace_block ; [$proj_ty_ident ]{$($(# [$pin ])? $field ),+ }}}}}; (@  struct => make_proj_replace_method ; [$proj_vis :  vis ][][$proj_ty_ident :  ident ][$($ty_generics :  tt )*]$($variant :  tt )* )=>{}; (@  enum => make_proj_method ; [$proj_vis :  vis ][$proj_ty_ident :  ident ][$method_ident :  ident $get_method :  ident $($mut :  ident )?][$($ty_generics :  tt )*]{$($variant :  ident $({$($(# [$pin :  ident ])? $field :  ident ),+ })? ),+ })=>{$proj_vis  fn $method_ident < '__pin > ( self : $crate ::  __private ::  Pin <& '__pin $($mut )?  Self >, )-> $proj_ty_ident < '__pin , $($ty_generics )*> { unsafe { match  self .$get_method (){$(Self ::$variant $({$($field ),+ })? =>{$proj_ty_ident ::$variant $({$($field : $crate ::  __pin_project_internal ! (@  make_unsafe_field_proj ; $(# [$pin ])? $field )),+ })? }),+ }}}}; (@  enum => make_proj_method ; [$proj_vis :  vis ][][$method_ident :  ident $get_method :  ident $($mut :  ident )?][$($ty_generics :  tt )*]$($variant :  tt )* )=>{}; (@  enum => make_proj_replace_method ; [$proj_vis :  vis ][$proj_ty_ident :  ident ][$($ty_generics :  tt )*]{$($variant :  ident $({$($(# [$pin :  ident ])? $field :  ident ),+ })? ),+ })=>{$proj_vis  fn  project_replace ( self : $crate ::  __private ::  Pin <&  mut  Self >,  replacement :  Self , )-> $proj_ty_ident <$($ty_generics )*> { unsafe { let  __self_ptr : *  mut  Self =  self .  get_unchecked_mut ();  let  __guard = $crate ::  __private ::  UnsafeOverwriteGuard { target :  __self_ptr ,  value : $crate ::  __private ::  ManuallyDrop ::  new ( replacement ), };  match &  mut *  __self_ptr {$(Self ::$variant $({$($field ),+ })? =>{$crate ::  __pin_project_internal ! {@  make_proj_replace_block ; [$proj_ty_ident :: $variant ]$({$($(# [$pin ])? $field ),+ })? }}),+ }}}}; (@  enum => make_proj_replace_method ; [$proj_vis :  vis ][][$($ty_generics :  tt )*]$($variant :  tt )* )=>{}; (@  make_unpin_impl ; [$vis :  vis $ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?]$($field :  tt )* )=>{# [ allow ( non_snake_case )]$vis  struct  __Origin < '__pin , $($impl_generics )*> $(where $($where_clause )*)? { __dummy_lifetime : $crate ::  __private ::  PhantomData <& '__pin ()>, $($field )* } impl < '__pin , $($impl_generics )*> $crate ::  __private ::  Unpin  for $ident <$($ty_generics )*>  where  __Origin < '__pin , $($ty_generics )*>: $crate ::  __private ::  Unpin $(, $($where_clause )*)? {}}; (@  make_drop_impl ; [$ident :  ident ][$($impl_generics :  tt )*][$($ty_generics :  tt )*][$(where $($where_clause :  tt )* )?])=>{ trait  MustNotImplDrop {}# [ allow ( clippy ::  drop_bounds ,  drop_bounds )] impl <  T : $crate ::  __private ::  Drop >  MustNotImplDrop  for  T {} impl <$($impl_generics )*>  MustNotImplDrop  for $ident <$($ty_generics )*> $(where $($where_clause )*)? {}}; (@  make_unpin_bound ; # [ pin ]$field_ty :  ty )=>{$field_ty }; (@  make_unpin_bound ; $field_ty :  ty )=>{$crate ::  __private ::  AlwaysUnpin <$field_ty > }; (@  make_unsafe_field_proj ; # [ pin ]$field :  ident )=>{$crate ::  __private ::  Pin ::  new_unchecked ($field )}; (@  make_unsafe_field_proj ; $field :  ident )=>{$field }; (@  make_replace_field_proj ; # [ pin ]$field :  ident )=>{$crate ::  __private ::  PhantomData }; (@  make_replace_field_proj ; $field :  ident )=>{$crate ::  __private ::  ptr ::  read ($field )}; (@  make_unsafe_drop_in_place_guard ; # [ pin ]$field :  ident )=>{$crate ::  __private ::  UnsafeDropInPlaceGuard ($field )}; (@  make_unsafe_drop_in_place_guard ; $field :  ident )=>{()}; (@  make_proj_field_mut ; # [ pin ]$field_ty :  ty )=>{$crate ::  __private ::  Pin <& '__pin  mut ($field_ty )> }; (@  make_proj_field_mut ; $field_ty :  ty )=>{& '__pin  mut ($field_ty )}; (@  make_proj_field_ref ; # [ pin ]$field_ty :  ty )=>{$crate ::  __private ::  Pin <& '__pin ($field_ty )> }; (@  make_proj_field_ref ; $field_ty :  ty )=>{& '__pin ($field_ty )}; (@  make_proj_field_replace ; # [ pin ]$field_ty :  ty )=>{$crate ::  __private ::  PhantomData <$field_ty > }; (@  make_proj_field_replace ; $field_ty :  ty )=>{$field_ty }; ([$($proj_mut_ident :  ident )?][$($proj_ref_ident :  ident )?][$($proj_replace_ident :  ident )?]$(# [$attrs :  meta ])*  pub  struct $ident :  ident $(< $($lifetime :  lifetime $(: $lifetime_bound :  lifetime )? ),* $(,)? $($generics :  ident $(: $generics_bound :  path )? $(: ?$generics_unsized_bound :  path )? $(: $generics_lifetime_bound :  lifetime )? $(= $generics_default :  ty )? ),* $(,)? >)? $(where $($where_clause_ty :  ty $(: $where_clause_bound :  path )? $(: ?$where_clause_unsized_bound :  path )? $(: $where_clause_lifetime_bound :  lifetime )? ),* $(,)? )? {$($(# [$pin :  ident ])? $field_vis :  vis $field :  ident : $field_ty :  ty ),+ $(,)? })=>{$crate ::  __pin_project_internal ! {@  struct => internal ; [$($proj_mut_ident )?][$($proj_ref_ident )?][$($proj_replace_ident )?][ pub ( crate )][$(# [$attrs ])*  pub  struct $ident ][$(< $($lifetime $(: $lifetime_bound )? ,)* $($generics $(: $generics_bound )? $(: ?$generics_unsized_bound )? $(: $generics_lifetime_bound )? $(= $generics_default )? ),* >)?][$($($lifetime $(: $lifetime_bound )? ,)* $($generics $(: $generics_bound )? $(: ?$generics_unsized_bound )? $(: $generics_lifetime_bound )? ),* )?][$($($lifetime ,)* $($generics ),* )?][$(where $($where_clause_ty $(: $where_clause_bound )? $(: ?$where_clause_unsized_bound )? $(: $where_clause_lifetime_bound )? ),* )?]{$($(# [$pin ])? $field_vis $field : $field_ty ),+ }}}; ([$($proj_mut_ident :  ident )?][$($proj_ref_ident :  ident )?][$($proj_replace_ident :  ident )?]$(# [$attrs :  meta ])* $vis :  vis  struct $ident :  ident $(< $($lifetime :  lifetime $(: $lifetime_bound :  lifetime )? ),* $(,)? $($generics :  ident $(: $generics_bound :  path )? $(: ?$generics_unsized_bound :  path )? $(: $generics_lifetime_bound :  lifetime )? $(= $generics_default :  ty )? ),* $(,)? >)? $(where $($where_clause_ty :  ty $(: $where_clause_bound :  path )? $(: ?$where_clause_unsized_bound :  path )? $(: $where_clause_lifetime_bound :  lifetime )? ),* $(,)? )? {$($(# [$pin :  ident ])? $field_vis :  vis $field :  ident : $field_ty :  ty ),+ $(,)? })=>{$crate ::  __pin_project_internal ! {@  struct => internal ; [$($proj_mut_ident )?][$($proj_ref_ident )?][$($proj_replace_ident )?][$vis ][$(# [$attrs ])* $vis  struct $ident ][$(< $($lifetime $(: $lifetime_bound )? ,)* $($generics $(: $generics_bound )? $(: ?$generics_unsized_bound )? $(: $generics_lifetime_bound )? $(= $generics_default )? ),* >)?][$($($lifetime $(: $lifetime_bound )? ,)* $($generics $(: $generics_bound )? $(: ?$generics_unsized_bound )? $(: $generics_lifetime_bound )? ),* )?][$($($lifetime ,)* $($generics ),* )?][$(where $($where_clause_ty $(: $where_clause_bound )? $(: ?$where_clause_unsized_bound )? $(: $where_clause_lifetime_bound )? ),* )?]{$($(# [$pin ])? $field_vis $field : $field_ty ),+ }}}; ([$($proj_mut_ident :  ident )?][$($proj_ref_ident :  ident )?][$($proj_replace_ident :  ident )?]$(# [$attrs :  meta ])*  pub  enum $ident :  ident $(< $($lifetime :  lifetime $(: $lifetime_bound :  lifetime )? ),* $(,)? $($generics :  ident $(: $generics_bound :  path )? $(: ?$generics_unsized_bound :  path )? $(: $generics_lifetime_bound :  lifetime )? $(= $generics_default :  ty )? ),* $(,)? >)? $(where $($where_clause_ty :  ty $(: $where_clause_bound :  path )? $(: ?$where_clause_unsized_bound :  path )? $(: $where_clause_lifetime_bound :  lifetime )? ),* $(,)? )? {$($(# [$variant_attrs :  meta ])* $variant :  ident $({$($(# [$pin :  ident ])? $field :  ident : $field_ty :  ty ),+ $(,)? })? ),+ $(,)? })=>{$crate ::  __pin_project_internal ! {@  enum => internal ; [$($proj_mut_ident )?][$($proj_ref_ident )?][$($proj_replace_ident )?][ pub ( crate )][$(# [$attrs ])*  pub  enum $ident ][$(< $($lifetime $(: $lifetime_bound )? ,)* $($generics $(: $generics_bound )? $(: ?$generics_unsized_bound )? $(: $generics_lifetime_bound )? $(= $generics_default )? ),* >)?][$($($lifetime $(: $lifetime_bound )? ,)* $($generics $(: $generics_bound )? $(: ?$generics_unsized_bound )? $(: $generics_lifetime_bound )? ),* )?][$($($lifetime ,)* $($generics ),* )?][$(where $($where_clause_ty $(: $where_clause_bound )? $(: ?$where_clause_unsized_bound )? $(: $where_clause_lifetime_bound )? ),* )?]{$($(# [$variant_attrs ])* $variant $({$($(# [$pin ])? $field : $field_ty ),+ })? ),+ }}}; ([$($proj_mut_ident :  ident )?][$($proj_ref_ident :  ident )?][$($proj_replace_ident :  ident )?]$(# [$attrs :  meta ])* $vis :  vis  enum $ident :  ident $(< $($lifetime :  lifetime $(: $lifetime_bound :  lifetime )? ),* $(,)? $($generics :  ident $(: $generics_bound :  path )? $(: ?$generics_unsized_bound :  path )? $(: $generics_lifetime_bound :  lifetime )? $(= $generics_default :  ty )? ),* $(,)? >)? $(where $($where_clause_ty :  ty $(: $where_clause_bound :  path )? $(: ?$where_clause_unsized_bound :  path )? $(: $where_clause_lifetime_bound :  lifetime )? ),* $(,)? )? {$($(# [$variant_attrs :  meta ])* $variant :  ident $({$($(# [$pin :  ident ])? $field :  ident : $field_ty :  ty ),+ $(,)? })? ),+ $(,)? })=>{$crate ::  __pin_project_internal ! {@  enum => internal ; [$($proj_mut_ident )?][$($proj_ref_ident )?][$($proj_replace_ident )?][$vis ][$(# [$attrs ])* $vis  enum $ident ][$(< $($lifetime $(: $lifetime_bound )? ,)* $($generics $(: $generics_bound )? $(: ?$generics_unsized_bound )? $(: $generics_lifetime_bound )? $(= $generics_default )? ),* >)?][$($($lifetime $(: $lifetime_bound )? ,)* $($generics $(: $generics_bound )? $(: ?$generics_unsized_bound )? $(: $generics_lifetime_bound )? ),* )?][$($($lifetime ,)* $($generics ),* )?][$(where $($where_clause_ty $(: $where_clause_bound )? $(: ?$where_clause_unsized_bound )? $(: $where_clause_lifetime_bound )? ),* )?]{$($(# [$variant_attrs ])* $variant $({$($(# [$pin ])? $field : $field_ty ),+ })? ),+ }}}; }
macro_rules! __ra_macro_fixture175 {($t :  ty , $example :  tt )=>{ impl  AtomicCell <$t > {# [ doc =  " Increments the current value by `val` and returns the previous value." ]# [ doc =  "" ]# [ doc =  " The addition wraps on overflow." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " use crossbeam_utils::atomic::AtomicCell;" ]# [ doc =  "" ]# [ doc = $example ]# [ doc =  "" ]# [ doc =  " assert_eq!(a.fetch_add(3), 7);" ]# [ doc =  " assert_eq!(a.load(), 10);" ]# [ doc =  " ```" ]# [ inline ] pub  fn  fetch_add (&  self ,  val : $t )-> $t { if  can_transmute ::<$t ,  atomic ::  AtomicUsize > (){ let  a =  unsafe {&* ( self .  value .  get () as *  const  atomic ::  AtomicUsize )};  a .  fetch_add ( val  as  usize ,  Ordering ::  AcqRel ) as $t } else { let  _guard =  lock ( self .  value .  get () as  usize ).  write ();  let  value =  unsafe {&  mut * ( self .  value .  get ())};  let  old = *  value ; *  value =  value .  wrapping_add ( val );  old }}# [ doc =  " Decrements the current value by `val` and returns the previous value." ]# [ doc =  "" ]# [ doc =  " The subtraction wraps on overflow." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " use crossbeam_utils::atomic::AtomicCell;" ]# [ doc =  "" ]# [ doc = $example ]# [ doc =  "" ]# [ doc =  " assert_eq!(a.fetch_sub(3), 7);" ]# [ doc =  " assert_eq!(a.load(), 4);" ]# [ doc =  " ```" ]# [ inline ] pub  fn  fetch_sub (&  self ,  val : $t )-> $t { if  can_transmute ::<$t ,  atomic ::  AtomicUsize > (){ let  a =  unsafe {&* ( self .  value .  get () as *  const  atomic ::  AtomicUsize )};  a .  fetch_sub ( val  as  usize ,  Ordering ::  AcqRel ) as $t } else { let  _guard =  lock ( self .  value .  get () as  usize ).  write ();  let  value =  unsafe {&  mut * ( self .  value .  get ())};  let  old = *  value ; *  value =  value .  wrapping_sub ( val );  old }}# [ doc =  " Applies bitwise \\\"and\\\" to the current value and returns the previous value." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " use crossbeam_utils::atomic::AtomicCell;" ]# [ doc =  "" ]# [ doc = $example ]# [ doc =  "" ]# [ doc =  " assert_eq!(a.fetch_and(3), 7);" ]# [ doc =  " assert_eq!(a.load(), 3);" ]# [ doc =  " ```" ]# [ inline ] pub  fn  fetch_and (&  self ,  val : $t )-> $t { if  can_transmute ::<$t ,  atomic ::  AtomicUsize > (){ let  a =  unsafe {&* ( self .  value .  get () as *  const  atomic ::  AtomicUsize )};  a .  fetch_and ( val  as  usize ,  Ordering ::  AcqRel ) as $t } else { let  _guard =  lock ( self .  value .  get () as  usize ).  write ();  let  value =  unsafe {&  mut * ( self .  value .  get ())};  let  old = *  value ; *  value &=  val ;  old }}# [ doc =  " Applies bitwise \\\"or\\\" to the current value and returns the previous value." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " use crossbeam_utils::atomic::AtomicCell;" ]# [ doc =  "" ]# [ doc = $example ]# [ doc =  "" ]# [ doc =  " assert_eq!(a.fetch_or(16), 7);" ]# [ doc =  " assert_eq!(a.load(), 23);" ]# [ doc =  " ```" ]# [ inline ] pub  fn  fetch_or (&  self ,  val : $t )-> $t { if  can_transmute ::<$t ,  atomic ::  AtomicUsize > (){ let  a =  unsafe {&* ( self .  value .  get () as *  const  atomic ::  AtomicUsize )};  a .  fetch_or ( val  as  usize ,  Ordering ::  AcqRel ) as $t } else { let  _guard =  lock ( self .  value .  get () as  usize ).  write ();  let  value =  unsafe {&  mut * ( self .  value .  get ())};  let  old = *  value ; *  value |=  val ;  old }}# [ doc =  " Applies bitwise \\\"xor\\\" to the current value and returns the previous value." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " use crossbeam_utils::atomic::AtomicCell;" ]# [ doc =  "" ]# [ doc = $example ]# [ doc =  "" ]# [ doc =  " assert_eq!(a.fetch_xor(2), 7);" ]# [ doc =  " assert_eq!(a.load(), 5);" ]# [ doc =  " ```" ]# [ inline ] pub  fn  fetch_xor (&  self ,  val : $t )-> $t { if  can_transmute ::<$t ,  atomic ::  AtomicUsize > (){ let  a =  unsafe {&* ( self .  value .  get () as *  const  atomic ::  AtomicUsize )};  a .  fetch_xor ( val  as  usize ,  Ordering ::  AcqRel ) as $t } else { let  _guard =  lock ( self .  value .  get () as  usize ).  write ();  let  value =  unsafe {&  mut * ( self .  value .  get ())};  let  old = *  value ; *  value ^=  val ;  old }}}}; ($t :  ty , $atomic :  ty , $example :  tt )=>{ impl  AtomicCell <$t > {# [ doc =  " Increments the current value by `val` and returns the previous value." ]# [ doc =  "" ]# [ doc =  " The addition wraps on overflow." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " use crossbeam_utils::atomic::AtomicCell;" ]# [ doc =  "" ]# [ doc = $example ]# [ doc =  "" ]# [ doc =  " assert_eq!(a.fetch_add(3), 7);" ]# [ doc =  " assert_eq!(a.load(), 10);" ]# [ doc =  " ```" ]# [ inline ] pub  fn  fetch_add (&  self ,  val : $t )-> $t { let  a =  unsafe {&* ( self .  value .  get () as *  const $atomic )};  a .  fetch_add ( val ,  Ordering ::  AcqRel )}# [ doc =  " Decrements the current value by `val` and returns the previous value." ]# [ doc =  "" ]# [ doc =  " The subtraction wraps on overflow." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " use crossbeam_utils::atomic::AtomicCell;" ]# [ doc =  "" ]# [ doc = $example ]# [ doc =  "" ]# [ doc =  " assert_eq!(a.fetch_sub(3), 7);" ]# [ doc =  " assert_eq!(a.load(), 4);" ]# [ doc =  " ```" ]# [ inline ] pub  fn  fetch_sub (&  self ,  val : $t )-> $t { let  a =  unsafe {&* ( self .  value .  get () as *  const $atomic )};  a .  fetch_sub ( val ,  Ordering ::  AcqRel )}# [ doc =  " Applies bitwise \\\"and\\\" to the current value and returns the previous value." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " use crossbeam_utils::atomic::AtomicCell;" ]# [ doc =  "" ]# [ doc = $example ]# [ doc =  "" ]# [ doc =  " assert_eq!(a.fetch_and(3), 7);" ]# [ doc =  " assert_eq!(a.load(), 3);" ]# [ doc =  " ```" ]# [ inline ] pub  fn  fetch_and (&  self ,  val : $t )-> $t { let  a =  unsafe {&* ( self .  value .  get () as *  const $atomic )};  a .  fetch_and ( val ,  Ordering ::  AcqRel )}# [ doc =  " Applies bitwise \\\"or\\\" to the current value and returns the previous value." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " use crossbeam_utils::atomic::AtomicCell;" ]# [ doc =  "" ]# [ doc = $example ]# [ doc =  "" ]# [ doc =  " assert_eq!(a.fetch_or(16), 7);" ]# [ doc =  " assert_eq!(a.load(), 23);" ]# [ doc =  " ```" ]# [ inline ] pub  fn  fetch_or (&  self ,  val : $t )-> $t { let  a =  unsafe {&* ( self .  value .  get () as *  const $atomic )};  a .  fetch_or ( val ,  Ordering ::  AcqRel )}# [ doc =  " Applies bitwise \\\"xor\\\" to the current value and returns the previous value." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " use crossbeam_utils::atomic::AtomicCell;" ]# [ doc =  "" ]# [ doc = $example ]# [ doc =  "" ]# [ doc =  " assert_eq!(a.fetch_xor(2), 7);" ]# [ doc =  " assert_eq!(a.load(), 5);" ]# [ doc =  " ```" ]# [ inline ] pub  fn  fetch_xor (&  self ,  val : $t )-> $t { let  a =  unsafe {&* ( self .  value .  get () as *  const $atomic )};  a .  fetch_xor ( val ,  Ordering ::  AcqRel )}}}; }
macro_rules! __ra_macro_fixture176 {($atomic :  ident , $val :  ty )=>{ impl  AtomicConsume  for ::  core ::  sync ::  atomic ::$atomic { type  Val = $val ;  impl_consume ! (); }}; }
macro_rules! __ra_macro_fixture177 {($t :  ty , $min :  expr , $max :  expr )=>{ impl  Bounded  for $t {# [ inline ] fn  min_value ()-> $t {$min }# [ inline ] fn  max_value ()-> $t {$max }}}; }
macro_rules! __ra_macro_fixture178 {($m :  ident )=>{ for_each_tuple_ ! {$m !!  A ,  B ,  C ,  D ,  E ,  F ,  G ,  H ,  I ,  J ,  K ,  L ,  M ,  N ,  O ,  P ,  Q ,  R ,  S ,  T , }}; }
macro_rules! __ra_macro_fixture179 {($T :  ident )=>{ impl  ToPrimitive  for $T { impl_to_primitive_int_to_int ! {$T :  fn  to_isize ->  isize ;  fn  to_i8 ->  i8 ;  fn  to_i16 ->  i16 ;  fn  to_i32 ->  i32 ;  fn  to_i64 ->  i64 ; # [ cfg ( has_i128 )] fn  to_i128 ->  i128 ; } impl_to_primitive_int_to_uint ! {$T :  fn  to_usize ->  usize ;  fn  to_u8 ->  u8 ;  fn  to_u16 ->  u16 ;  fn  to_u32 ->  u32 ;  fn  to_u64 ->  u64 ; # [ cfg ( has_i128 )] fn  to_u128 ->  u128 ; }# [ inline ] fn  to_f32 (&  self )->  Option <  f32 > { Some (*  self  as  f32 )}# [ inline ] fn  to_f64 (&  self )->  Option <  f64 > { Some (*  self  as  f64 )}}}; }
macro_rules! __ra_macro_fixture180 {($T :  ident )=>{ impl  ToPrimitive  for $T { impl_to_primitive_uint_to_int ! {$T :  fn  to_isize ->  isize ;  fn  to_i8 ->  i8 ;  fn  to_i16 ->  i16 ;  fn  to_i32 ->  i32 ;  fn  to_i64 ->  i64 ; # [ cfg ( has_i128 )] fn  to_i128 ->  i128 ; } impl_to_primitive_uint_to_uint ! {$T :  fn  to_usize ->  usize ;  fn  to_u8 ->  u8 ;  fn  to_u16 ->  u16 ;  fn  to_u32 ->  u32 ;  fn  to_u64 ->  u64 ; # [ cfg ( has_i128 )] fn  to_u128 ->  u128 ; }# [ inline ] fn  to_f32 (&  self )->  Option <  f32 > { Some (*  self  as  f32 )}# [ inline ] fn  to_f64 (&  self )->  Option <  f64 > { Some (*  self  as  f64 )}}}; }
macro_rules! __ra_macro_fixture181 {($T :  ident )=>{ impl  ToPrimitive  for $T { impl_to_primitive_float_to_signed_int ! {$T :  fn  to_isize ->  isize ;  fn  to_i8 ->  i8 ;  fn  to_i16 ->  i16 ;  fn  to_i32 ->  i32 ;  fn  to_i64 ->  i64 ; # [ cfg ( has_i128 )] fn  to_i128 ->  i128 ; } impl_to_primitive_float_to_unsigned_int ! {$T :  fn  to_usize ->  usize ;  fn  to_u8 ->  u8 ;  fn  to_u16 ->  u16 ;  fn  to_u32 ->  u32 ;  fn  to_u64 ->  u64 ; # [ cfg ( has_i128 )] fn  to_u128 ->  u128 ; } impl_to_primitive_float_to_float ! {$T :  fn  to_f32 ->  f32 ;  fn  to_f64 ->  f64 ; }}}; }
macro_rules! __ra_macro_fixture182 {($T :  ty , $to_ty :  ident )=>{# [ allow ( deprecated )] impl  FromPrimitive  for $T {# [ inline ] fn  from_isize ( n :  isize )->  Option <$T > { n .$to_ty ()}# [ inline ] fn  from_i8 ( n :  i8 )->  Option <$T > { n .$to_ty ()}# [ inline ] fn  from_i16 ( n :  i16 )->  Option <$T > { n .$to_ty ()}# [ inline ] fn  from_i32 ( n :  i32 )->  Option <$T > { n .$to_ty ()}# [ inline ] fn  from_i64 ( n :  i64 )->  Option <$T > { n .$to_ty ()}# [ cfg ( has_i128 )]# [ inline ] fn  from_i128 ( n :  i128 )->  Option <$T > { n .$to_ty ()}# [ inline ] fn  from_usize ( n :  usize )->  Option <$T > { n .$to_ty ()}# [ inline ] fn  from_u8 ( n :  u8 )->  Option <$T > { n .$to_ty ()}# [ inline ] fn  from_u16 ( n :  u16 )->  Option <$T > { n .$to_ty ()}# [ inline ] fn  from_u32 ( n :  u32 )->  Option <$T > { n .$to_ty ()}# [ inline ] fn  from_u64 ( n :  u64 )->  Option <$T > { n .$to_ty ()}# [ cfg ( has_i128 )]# [ inline ] fn  from_u128 ( n :  u128 )->  Option <$T > { n .$to_ty ()}# [ inline ] fn  from_f32 ( n :  f32 )->  Option <$T > { n .$to_ty ()}# [ inline ] fn  from_f64 ( n :  f64 )->  Option <$T > { n .$to_ty ()}}}; }
macro_rules! __ra_macro_fixture183 {($T :  ty , $conv :  ident )=>{ impl  NumCast  for $T {# [ inline ]# [ allow ( deprecated )] fn  from <  N :  ToPrimitive > ( n :  N )->  Option <$T > { n .$conv ()}}}; }
macro_rules! __ra_macro_fixture184 {(@ $T :  ty =>$(# [$cfg :  meta ])*  impl $U :  ty )=>{$(# [$cfg ])*  impl  AsPrimitive <$U >  for $T {# [ inline ] fn  as_ ( self )-> $U { self  as $U }}}; (@ $T :  ty =>{$($U :  ty ),* })=>{$(impl_as_primitive ! (@ $T => impl $U ); )*}; ($T :  ty =>{$($U :  ty ),* })=>{ impl_as_primitive ! (@ $T =>{$($U ),* });  impl_as_primitive ! (@ $T =>{ u8 ,  u16 ,  u32 ,  u64 ,  usize });  impl_as_primitive ! (@ $T =># [ cfg ( has_i128 )] impl  u128 );  impl_as_primitive ! (@ $T =>{ i8 ,  i16 ,  i32 ,  i64 ,  isize });  impl_as_primitive ! (@ $T =># [ cfg ( has_i128 )] impl  i128 ); }; }
macro_rules! __ra_macro_fixture185 {($(# [$doc :  meta ]$constant :  ident ,)+)=>(# [ allow ( non_snake_case )] pub  trait  FloatConst {$(# [$doc ] fn $constant ()->  Self ;)+ # [ doc =  "Return the full circle constant ``." ]# [ inline ] fn  TAU ()->  Self  where  Self :  Sized +  Add <  Self ,  Output =  Self >{ Self ::  PI ()+  Self ::  PI ()}# [ doc =  "Return `log10(2.0)`." ]# [ inline ] fn  LOG10_2 ()->  Self  where  Self :  Sized +  Div <  Self ,  Output =  Self >{ Self ::  LN_2 ()/  Self ::  LN_10 ()}# [ doc =  "Return `log2(10.0)`." ]# [ inline ] fn  LOG2_10 ()->  Self  where  Self :  Sized +  Div <  Self ,  Output =  Self >{ Self ::  LN_10 ()/  Self ::  LN_2 ()}} float_const_impl ! {@  float  f32 , $($constant ,)+ } float_const_impl ! {@  float  f64 , $($constant ,)+ }); (@  float $T :  ident , $($constant :  ident ,)+)=>( impl  FloatConst  for $T { constant ! {$($constant ()-> $T ::  consts ::$constant ; )+  TAU ()->  6.28318530717958647692528676655900577 ;  LOG10_2 ()->  0.301029995663981195213738894724493027 ;  LOG2_10 ()->  3.32192809488736234787031942948939018 ; }}); }
macro_rules! __ra_macro_fixture186 {($t :  ty , $v :  expr )=>{ impl  Zero  for $t {# [ inline ] fn  zero ()-> $t {$v }# [ inline ] fn  is_zero (&  self )->  bool {*  self == $v }}}; }
macro_rules! __ra_macro_fixture187 {($t :  ty , $v :  expr )=>{ impl  One  for $t {# [ inline ] fn  one ()-> $t {$v }# [ inline ] fn  is_one (&  self )->  bool {*  self == $v }}}; }
macro_rules! __ra_macro_fixture188 {($T :  ty , $S :  ty , $U :  ty )=>{ impl  PrimInt  for $T {# [ inline ] fn  count_ones ( self )->  u32 {<$T >::  count_ones ( self )}# [ inline ] fn  count_zeros ( self )->  u32 {<$T >::  count_zeros ( self )}# [ inline ] fn  leading_zeros ( self )->  u32 {<$T >::  leading_zeros ( self )}# [ inline ] fn  trailing_zeros ( self )->  u32 {<$T >::  trailing_zeros ( self )}# [ inline ] fn  rotate_left ( self ,  n :  u32 )->  Self {<$T >::  rotate_left ( self ,  n )}# [ inline ] fn  rotate_right ( self ,  n :  u32 )->  Self {<$T >::  rotate_right ( self ,  n )}# [ inline ] fn  signed_shl ( self ,  n :  u32 )->  Self {(( self  as $S )<<  n ) as $T }# [ inline ] fn  signed_shr ( self ,  n :  u32 )->  Self {(( self  as $S )>>  n ) as $T }# [ inline ] fn  unsigned_shl ( self ,  n :  u32 )->  Self {(( self  as $U )<<  n ) as $T }# [ inline ] fn  unsigned_shr ( self ,  n :  u32 )->  Self {(( self  as $U )>>  n ) as $T }# [ inline ] fn  swap_bytes ( self )->  Self {<$T >::  swap_bytes ( self )}# [ inline ] fn  from_be ( x :  Self )->  Self {<$T >::  from_be ( x )}# [ inline ] fn  from_le ( x :  Self )->  Self {<$T >::  from_le ( x )}# [ inline ] fn  to_be ( self )->  Self {<$T >::  to_be ( self )}# [ inline ] fn  to_le ( self )->  Self {<$T >::  to_le ( self )}# [ inline ] fn  pow ( self ,  exp :  u32 )->  Self {<$T >::  pow ( self ,  exp )}}}; }
macro_rules! __ra_macro_fixture189 {($trait_name :  ident , $method :  ident , $t :  ty )=>{ impl $trait_name  for $t {# [ inline ] fn $method (&  self ,  v : &$t )->  Option <$t > {<$t >::$method (*  self , *  v )}}}; }
macro_rules! __ra_macro_fixture190 {($trait_name :  ident , $method :  ident , $t :  ty )=>{ impl $trait_name  for $t {# [ inline ] fn $method (&  self )->  Option <$t > {<$t >::$method (*  self )}}}; }
macro_rules! __ra_macro_fixture191 {($trait_name :  ident , $method :  ident , $t :  ty )=>{ impl $trait_name  for $t {# [ inline ] fn $method (&  self ,  rhs :  u32 )->  Option <$t > {<$t >::$method (*  self ,  rhs )}}}; }
macro_rules! __ra_macro_fixture192 {($trait_name :  ident  for $($t :  ty )*)=>{$(impl $trait_name  for $t { type  Output =  Self ; # [ inline ] fn  mul_add ( self ,  a :  Self ,  b :  Self )->  Self ::  Output {( self *  a )+  b }})*}}
macro_rules! __ra_macro_fixture193 {($trait_name :  ident  for $($t :  ty )*)=>{$(impl $trait_name  for $t {# [ inline ] fn  mul_add_assign (&  mut  self ,  a :  Self ,  b :  Self ){*  self = (*  self *  a )+  b }})*}}
macro_rules! __ra_macro_fixture194 {($trait_name :  ident , $method :  ident , $t :  ty )=>{ impl $trait_name  for $t {# [ inline ] fn $method (&  self ,  v : &  Self )-> ( Self ,  bool ){<$t >::$method (*  self , *  v )}}}; }
macro_rules! __ra_macro_fixture195 {($trait_name :  ident  for $($t :  ty )*)=>{$(impl $trait_name  for $t {# [ inline ] fn  saturating_add ( self ,  v :  Self )->  Self { Self ::  saturating_add ( self ,  v )}# [ inline ] fn  saturating_sub ( self ,  v :  Self )->  Self { Self ::  saturating_sub ( self ,  v )}})*}}
macro_rules! __ra_macro_fixture196 {($trait_name :  ident , $method :  ident , $t :  ty )=>{ impl $trait_name  for $t {# [ inline ] fn $method (&  self ,  v : &  Self )->  Self {<$t >::$method (*  self , *  v )}}}; }
macro_rules! __ra_macro_fixture197 {($trait_name :  ident , $method :  ident , $t :  ty )=>{ impl $trait_name  for $t {# [ inline ] fn $method (&  self ,  v : &  Self )->  Self {<$t >::$method (*  self , *  v )}}}; ($trait_name :  ident , $method :  ident , $t :  ty , $rhs :  ty )=>{ impl $trait_name <$rhs >  for $t {# [ inline ] fn $method (&  self ,  v : &$rhs )->  Self {<$t >::$method (*  self , *  v )}}}; }
macro_rules! __ra_macro_fixture198 {($trait_name :  ident , $method :  ident , $t :  ty )=>{ impl $trait_name  for $t {# [ inline ] fn $method (&  self )-> $t {<$t >::$method (*  self )}}}; }
macro_rules! __ra_macro_fixture199 {($trait_name :  ident , $method :  ident , $t :  ty )=>{ impl $trait_name  for $t {# [ inline ] fn $method (&  self ,  rhs :  u32 )-> $t {<$t >::$method (*  self ,  rhs )}}}; }
macro_rules! __ra_macro_fixture200 {($t :  ty )=>{ pow_impl ! ($t ,  u8 );  pow_impl ! ($t ,  usize ); }; ($t :  ty , $rhs :  ty )=>{ pow_impl ! ($t , $rhs ,  usize ,  pow ); }; ($t :  ty , $rhs :  ty , $desired_rhs :  ty , $method :  expr )=>{ impl  Pow <$rhs >  for $t { type  Output = $t ; # [ inline ] fn  pow ( self ,  rhs : $rhs )-> $t {($method )( self , <$desired_rhs >::  from ( rhs ))}} impl < 'a >  Pow <& 'a $rhs >  for $t { type  Output = $t ; # [ inline ] fn  pow ( self ,  rhs : & 'a $rhs )-> $t {($method )( self , <$desired_rhs >::  from (*  rhs ))}} impl < 'a >  Pow <$rhs >  for & 'a $t { type  Output = $t ; # [ inline ] fn  pow ( self ,  rhs : $rhs )-> $t {($method )(*  self , <$desired_rhs >::  from ( rhs ))}} impl < 'a , 'b >  Pow <& 'a $rhs >  for & 'b $t { type  Output = $t ; # [ inline ] fn  pow ( self ,  rhs : & 'a $rhs )-> $t {($method )(*  self , <$desired_rhs >::  from (*  rhs ))}}}; }
macro_rules! __ra_macro_fixture201 {($($t :  ty )*)=>($(impl  Signed  for $t {# [ inline ] fn  abs (&  self )-> $t { if  self .  is_negative (){-*  self } else {*  self }}# [ inline ] fn  abs_sub (&  self ,  other : &$t )-> $t { if *  self <= *  other { 0 } else {*  self - *  other }}# [ inline ] fn  signum (&  self )-> $t { match *  self { n  if  n >  0 => 1 ,  0 => 0 , _ =>-  1 , }}# [ inline ] fn  is_positive (&  self )->  bool {*  self >  0 }# [ inline ] fn  is_negative (&  self )->  bool {*  self <  0 }})*)}
macro_rules! __ra_macro_fixture202 {($t :  ty )=>{ impl  Signed  for $t {# [ doc =  " Computes the absolute value. Returns `NAN` if the number is `NAN`." ]# [ inline ] fn  abs (&  self )-> $t { FloatCore ::  abs (*  self )}# [ doc =  " The positive difference of two numbers. Returns `0.0` if the number is" ]# [ doc =  " less than or equal to `other`, otherwise the difference between`self`" ]# [ doc =  " and `other` is returned." ]# [ inline ] fn  abs_sub (&  self ,  other : &$t )-> $t { if *  self <= *  other { 0. } else {*  self - *  other }}# [ doc =  " # Returns" ]# [ doc =  "" ]# [ doc =  " - `1.0` if the number is positive, `+0.0` or `INFINITY`" ]# [ doc =  " - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`" ]# [ doc =  " - `NAN` if the number is NaN" ]# [ inline ] fn  signum (&  self )-> $t { FloatCore ::  signum (*  self )}# [ doc =  " Returns `true` if the number is positive, including `+0.0` and `INFINITY`" ]# [ inline ] fn  is_positive (&  self )->  bool { FloatCore ::  is_sign_positive (*  self )}# [ doc =  " Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`" ]# [ inline ] fn  is_negative (&  self )->  bool { FloatCore ::  is_sign_negative (*  self )}}}; }
macro_rules! __ra_macro_fixture203 {($name :  ident  for $($t :  ty )*)=>($(impl $name  for $t {})*)}
macro_rules! __ra_macro_fixture204 {($name :  ident  for $($t :  ty )*)=>($(impl $name  for $t { type  FromStrRadixErr = ::  core ::  num ::  ParseIntError ; # [ inline ] fn  from_str_radix ( s : &  str ,  radix :  u32 )->  Result <  Self , ::  core ::  num ::  ParseIntError > {<$t >::  from_str_radix ( s ,  radix )}})*)}
macro_rules! __ra_macro_fixture205 {($name :  ident  for $($t :  ident )*)=>($(impl $name  for $t { type  FromStrRadixErr =  ParseFloatError ;  fn  from_str_radix ( src : &  str ,  radix :  u32 )->  Result <  Self ,  Self ::  FromStrRadixErr > { use  self ::  FloatErrorKind ::*;  use  self ::  ParseFloatError  as  PFE ;  match  src { "inf" => return  Ok ( core ::$t ::  INFINITY ),  "-inf" => return  Ok ( core ::$t ::  NEG_INFINITY ),  "NaN" => return  Ok ( core ::$t ::  NAN ), _ =>{}, } fn  slice_shift_char ( src : &  str )->  Option < ( char , &  str )> { let  mut  chars =  src .  chars ();  if  let  Some ( ch )=  chars .  next (){ Some (( ch ,  chars .  as_str ()))} else { None }} let ( is_positive ,  src )=  match  slice_shift_char ( src ){ None => return  Err ( PFE { kind :  Empty }),  Some (( '-' ,  "" ))=> return  Err ( PFE { kind :  Empty }),  Some (( '-' ,  src ))=>( false ,  src ),  Some ((_, _))=>( true ,  src ), };  let  mut  sig =  if  is_positive { 0.0 } else {-  0.0 };  let  mut  prev_sig =  sig ;  let  mut  cs =  src .  chars ().  enumerate ();  let  mut  exp_info =  None ::< ( char ,  usize )>;  for ( i ,  c ) in  cs .  by_ref (){ match  c .  to_digit ( radix ){ Some ( digit )=>{ sig =  sig * ( radix  as $t );  if  is_positive { sig =  sig + (( digit  as  isize ) as $t ); } else { sig =  sig - (( digit  as  isize ) as $t ); } if  prev_sig !=  0.0 { if  is_positive &&  sig <=  prev_sig { return  Ok ( core ::$t ::  INFINITY ); } if !  is_positive &&  sig >=  prev_sig { return  Ok ( core ::$t ::  NEG_INFINITY ); } if  is_positive && ( prev_sig != ( sig -  digit  as $t )/  radix  as $t ){ return  Ok ( core ::$t ::  INFINITY ); } if !  is_positive && ( prev_sig != ( sig +  digit  as $t )/  radix  as $t ){ return  Ok ( core ::$t ::  NEG_INFINITY ); }} prev_sig =  sig ; },  None => match  c { 'e' |  'E' |  'p' |  'P' =>{ exp_info =  Some (( c ,  i +  1 ));  break ; },  '.' =>{ break ; }, _ =>{ return  Err ( PFE { kind :  Invalid }); }, }, }} if  exp_info .  is_none (){ let  mut  power =  1.0 ;  for ( i ,  c ) in  cs .  by_ref (){ match  c .  to_digit ( radix ){ Some ( digit )=>{ power =  power / ( radix  as $t );  sig =  if  is_positive { sig + ( digit  as $t )*  power } else { sig - ( digit  as $t )*  power };  if  is_positive &&  sig <  prev_sig { return  Ok ( core ::$t ::  INFINITY ); } if !  is_positive &&  sig >  prev_sig { return  Ok ( core ::$t ::  NEG_INFINITY ); } prev_sig =  sig ; },  None => match  c { 'e' |  'E' |  'p' |  'P' =>{ exp_info =  Some (( c ,  i +  1 ));  break ; }, _ =>{ return  Err ( PFE { kind :  Invalid }); }, }, }}} let  exp =  match  exp_info { Some (( c ,  offset ))=>{ let  base =  match  c { 'E' |  'e'  if  radix ==  10 => 10.0 ,  'P' |  'p'  if  radix ==  16 => 2.0 , _ => return  Err ( PFE { kind :  Invalid }), };  let  src = &  src [ offset ..];  let ( is_positive ,  exp )=  match  slice_shift_char ( src ){ Some (( '-' ,  src ))=>( false ,  src .  parse ::<  usize > ()),  Some (( '+' ,  src ))=>( true ,  src .  parse ::<  usize > ()),  Some ((_, _))=>( true ,  src .  parse ::<  usize > ()),  None => return  Err ( PFE { kind :  Invalid }), }; # [ cfg ( feature =  "std" )] fn  pow ( base : $t ,  exp :  usize )-> $t { Float ::  powi ( base ,  exp  as  i32 )} match ( is_positive ,  exp ){( true ,  Ok ( exp ))=> pow ( base ,  exp ), ( false ,  Ok ( exp ))=> 1.0 /  pow ( base ,  exp ), (_,  Err (_))=> return  Err ( PFE { kind :  Invalid }), }},  None => 1.0 , };  Ok ( sig *  exp )}})*)}
macro_rules! __ra_macro_fixture206 {($m :  ident !! )=>($m ! {}); ($m :  ident !! $h :  ident , $($t :  ident ,)* )=>($m ! {$h $($t )* } for_each_tuple_ ! {$m !! $($t ,)* }); }
macro_rules! __ra_macro_fixture207 {($($name :  ident )* )=>( impl <$($name :  Bounded ,)*>  Bounded  for ($($name ,)*){# [ inline ] fn  min_value ()->  Self {($($name ::  min_value (),)*)}# [ inline ] fn  max_value ()->  Self {($($name ::  max_value (),)*)}}); }
macro_rules! __ra_macro_fixture208 {($T :  ty , $U :  ty )=>{ impl  Roots  for $T {# [ inline ] fn  nth_root (&  self ,  n :  u32 )->  Self { if *  self >=  0 {(*  self  as $U ).  nth_root ( n ) as  Self } else { assert ! ( n .  is_odd (),  "even roots of a negative are imaginary" ); - (( self .  wrapping_neg () as $U ).  nth_root ( n ) as  Self )}}# [ inline ] fn  sqrt (&  self )->  Self { assert ! (*  self >=  0 ,  "the square root of a negative is imaginary" ); (*  self  as $U ).  sqrt () as  Self }# [ inline ] fn  cbrt (&  self )->  Self { if *  self >=  0 {(*  self  as $U ).  cbrt () as  Self } else {- (( self .  wrapping_neg () as $U ).  cbrt () as  Self )}}}}; }
macro_rules! __ra_macro_fixture209 {($T :  ident )=>{ impl  Roots  for $T {# [ inline ] fn  nth_root (&  self ,  n :  u32 )->  Self { fn  go ( a : $T ,  n :  u32 )-> $T { match  n { 0 => panic ! ( "can't find a root of degree 0!" ),  1 => return  a ,  2 => return  a .  sqrt (),  3 => return  a .  cbrt (), _ =>(), } if  bits ::<$T > ()<=  n ||  a < ( 1 <<  n ){ return ( a >  0 ) as $T ; } if  bits ::<$T > ()>  64 { return  if  a <=  core ::  u64 ::  MAX  as $T {( a  as  u64 ).  nth_root ( n ) as $T } else { let  lo = ( a >>  n ).  nth_root ( n )<<  1 ;  let  hi =  lo +  1 ;  if  hi .  next_power_of_two ().  trailing_zeros ()*  n >=  bits ::<$T > (){ match  checked_pow ( hi ,  n  as  usize ){ Some ( x ) if  x <=  a => hi , _ => lo , }} else { if  hi .  pow ( n )<=  a { hi } else { lo }}}; }# [ cfg ( feature =  "std" )]# [ inline ] fn  guess ( x : $T ,  n :  u32 )-> $T { if  bits ::<$T > ()<=  32 ||  x <=  core ::  u32 ::  MAX  as $T { 1 << (( log2 ( x )+  n -  1 )/  n )} else {(( x  as  f64 ).  ln ()/  f64 ::  from ( n )).  exp () as $T }}# [ cfg ( not ( feature =  "std" ))]# [ inline ] fn  guess ( x : $T ,  n :  u32 )-> $T { 1 << (( log2 ( x )+  n -  1 )/  n )} let  n1 =  n -  1 ;  let  next = |  x : $T | { let  y =  match  checked_pow ( x ,  n1  as  usize ){ Some ( ax )=> a /  ax ,  None => 0 , }; ( y +  x *  n1  as $T )/  n  as $T };  fixpoint ( guess ( a ,  n ),  next )} go (*  self ,  n )}# [ inline ] fn  sqrt (&  self )->  Self { fn  go ( a : $T )-> $T { if  bits ::<$T > ()>  64 { return  if  a <=  core ::  u64 ::  MAX  as $T {( a  as  u64 ).  sqrt () as $T } else { let  lo = ( a >>  2u32 ).  sqrt ()<<  1 ;  let  hi =  lo +  1 ;  if  hi *  hi <=  a { hi } else { lo }}; } if  a <  4 { return ( a >  0 ) as $T ; }# [ cfg ( feature =  "std" )]# [ inline ] fn  guess ( x : $T )-> $T {( x  as  f64 ).  sqrt () as $T }# [ cfg ( not ( feature =  "std" ))]# [ inline ] fn  guess ( x : $T )-> $T { 1 << (( log2 ( x )+  1 )/  2 )} let  next = |  x : $T | ( a /  x +  x )>>  1 ;  fixpoint ( guess ( a ),  next )} go (*  self )}# [ inline ] fn  cbrt (&  self )->  Self { fn  go ( a : $T )-> $T { if  bits ::<$T > ()>  64 { return  if  a <=  core ::  u64 ::  MAX  as $T {( a  as  u64 ).  cbrt () as $T } else { let  lo = ( a >>  3u32 ).  cbrt ()<<  1 ;  let  hi =  lo +  1 ;  if  hi *  hi *  hi <=  a { hi } else { lo }}; } if  bits ::<$T > ()<=  32 { let  mut  x =  a ;  let  mut  y2 =  0 ;  let  mut  y =  0 ;  let  smax =  bits ::<$T > ()/  3 ;  for  s  in ( 0 ..  smax +  1 ).  rev (){ let  s =  s *  3 ;  y2 *=  4 ;  y *=  2 ;  let  b =  3 * ( y2 +  y )+  1 ;  if  x >>  s >=  b { x -=  b <<  s ;  y2 +=  2 *  y +  1 ;  y +=  1 ; }} return  y ; } if  a <  8 { return ( a >  0 ) as $T ; } if  a <=  core ::  u32 ::  MAX  as $T { return ( a  as  u32 ).  cbrt () as $T ; }# [ cfg ( feature =  "std" )]# [ inline ] fn  guess ( x : $T )-> $T {( x  as  f64 ).  cbrt () as $T }# [ cfg ( not ( feature =  "std" ))]# [ inline ] fn  guess ( x : $T )-> $T { 1 << (( log2 ( x )+  2 )/  3 )} let  next = |  x : $T | ( a / ( x *  x )+  x *  2 )/  3 ;  fixpoint ( guess ( a ),  next )} go (*  self )}}}; }
macro_rules! __ra_macro_fixture210 {($T :  ty , $test_mod :  ident )=>{ impl  Integer  for $T {# [ doc =  " Floored integer division" ]# [ inline ] fn  div_floor (&  self ,  other : &  Self )->  Self { let ( d ,  r )=  self .  div_rem ( other );  if ( r >  0 && *  other <  0 )|| ( r <  0 && *  other >  0 ){ d -  1 } else { d }}# [ doc =  " Floored integer modulo" ]# [ inline ] fn  mod_floor (&  self ,  other : &  Self )->  Self { let  r = *  self % *  other ;  if ( r >  0 && *  other <  0 )|| ( r <  0 && *  other >  0 ){ r + *  other } else { r }}# [ doc =  " Calculates `div_floor` and `mod_floor` simultaneously" ]# [ inline ] fn  div_mod_floor (&  self ,  other : &  Self )-> ( Self ,  Self ){ let ( d ,  r )=  self .  div_rem ( other );  if ( r >  0 && *  other <  0 )|| ( r <  0 && *  other >  0 ){( d -  1 ,  r + *  other )} else {( d ,  r )}}# [ inline ] fn  div_ceil (&  self ,  other : &  Self )->  Self { let ( d ,  r )=  self .  div_rem ( other );  if ( r >  0 && *  other >  0 )|| ( r <  0 && *  other <  0 ){ d +  1 } else { d }}# [ doc =  " Calculates the Greatest Common Divisor (GCD) of the number and" ]# [ doc =  " `other`. The result is always positive." ]# [ inline ] fn  gcd (&  self ,  other : &  Self )->  Self { let  mut  m = *  self ;  let  mut  n = *  other ;  if  m ==  0 ||  n ==  0 { return ( m |  n ).  abs (); } let  shift = ( m |  n ).  trailing_zeros ();  if  m ==  Self ::  min_value ()||  n ==  Self ::  min_value (){ return ( 1 <<  shift ).  abs (); } m =  m .  abs ();  n =  n .  abs ();  m >>=  m .  trailing_zeros ();  n >>=  n .  trailing_zeros ();  while  m !=  n { if  m > n { m -=  n ;  m >>=  m .  trailing_zeros (); } else { n -=  m ;  n >>=  n .  trailing_zeros (); }} m <<  shift }# [ inline ] fn  extended_gcd_lcm (&  self ,  other : &  Self )-> ( ExtendedGcd <  Self >,  Self ){ let  egcd =  self .  extended_gcd ( other );  let  lcm =  if  egcd .  gcd .  is_zero (){ Self ::  zero ()} else {(*  self * (*  other /  egcd .  gcd )).  abs ()}; ( egcd ,  lcm )}# [ doc =  " Calculates the Lowest Common Multiple (LCM) of the number and" ]# [ doc =  " `other`." ]# [ inline ] fn  lcm (&  self ,  other : &  Self )->  Self { self .  gcd_lcm ( other ).  1 }# [ doc =  " Calculates the Greatest Common Divisor (GCD) and" ]# [ doc =  " Lowest Common Multiple (LCM) of the number and `other`." ]# [ inline ] fn  gcd_lcm (&  self ,  other : &  Self )-> ( Self ,  Self ){ if  self .  is_zero ()&&  other .  is_zero (){ return ( Self ::  zero (),  Self ::  zero ()); } let  gcd =  self .  gcd ( other );  let  lcm = (*  self * (*  other /  gcd )).  abs (); ( gcd ,  lcm )}# [ doc =  " Deprecated, use `is_multiple_of` instead." ]# [ inline ] fn  divides (&  self ,  other : &  Self )->  bool { self .  is_multiple_of ( other )}# [ doc =  " Returns `true` if the number is a multiple of `other`." ]# [ inline ] fn  is_multiple_of (&  self ,  other : &  Self )->  bool {*  self % *  other ==  0 }# [ doc =  " Returns `true` if the number is divisible by `2`" ]# [ inline ] fn  is_even (&  self )->  bool {(*  self )&  1 ==  0 }# [ doc =  " Returns `true` if the number is not divisible by `2`" ]# [ inline ] fn  is_odd (&  self )->  bool {!  self .  is_even ()}# [ doc =  " Simultaneous truncated integer division and modulus." ]# [ inline ] fn  div_rem (&  self ,  other : &  Self )-> ( Self ,  Self ){(*  self / *  other , *  self % *  other )}}# [ cfg ( test )] mod $test_mod { use  core ::  mem ;  use  Integer ; # [ doc =  " Checks that the division rule holds for:" ]# [ doc =  "" ]# [ doc =  " - `n`: numerator (dividend)" ]# [ doc =  " - `d`: denominator (divisor)" ]# [ doc =  " - `qr`: quotient and remainder" ]# [ cfg ( test )] fn  test_division_rule (( n ,  d ): ($T , $T ), ( q ,  r ): ($T , $T )){ assert_eq ! ( d *  q +  r ,  n ); }# [ test ] fn  test_div_rem (){ fn  test_nd_dr ( nd : ($T , $T ),  qr : ($T , $T )){ let ( n ,  d )=  nd ;  let  separate_div_rem = ( n /  d ,  n %  d );  let  combined_div_rem =  n .  div_rem (&  d );  assert_eq ! ( separate_div_rem ,  qr );  assert_eq ! ( combined_div_rem ,  qr );  test_division_rule ( nd ,  separate_div_rem );  test_division_rule ( nd ,  combined_div_rem ); } test_nd_dr (( 8 ,  3 ), ( 2 ,  2 ));  test_nd_dr (( 8 , -  3 ), (-  2 ,  2 ));  test_nd_dr ((-  8 ,  3 ), (-  2 , -  2 ));  test_nd_dr ((-  8 , -  3 ), ( 2 , -  2 ));  test_nd_dr (( 1 ,  2 ), ( 0 ,  1 ));  test_nd_dr (( 1 , -  2 ), ( 0 ,  1 ));  test_nd_dr ((-  1 ,  2 ), ( 0 , -  1 ));  test_nd_dr ((-  1 , -  2 ), ( 0 , -  1 )); }# [ test ] fn  test_div_mod_floor (){ fn  test_nd_dm ( nd : ($T , $T ),  dm : ($T , $T )){ let ( n ,  d )=  nd ;  let  separate_div_mod_floor = ( n .  div_floor (&  d ),  n .  mod_floor (&  d ));  let  combined_div_mod_floor =  n .  div_mod_floor (&  d );  assert_eq ! ( separate_div_mod_floor ,  dm );  assert_eq ! ( combined_div_mod_floor ,  dm );  test_division_rule ( nd ,  separate_div_mod_floor );  test_division_rule ( nd ,  combined_div_mod_floor ); } test_nd_dm (( 8 ,  3 ), ( 2 ,  2 ));  test_nd_dm (( 8 , -  3 ), (-  3 , -  1 ));  test_nd_dm ((-  8 ,  3 ), (-  3 ,  1 ));  test_nd_dm ((-  8 , -  3 ), ( 2 , -  2 ));  test_nd_dm (( 1 ,  2 ), ( 0 ,  1 ));  test_nd_dm (( 1 , -  2 ), (-  1 , -  1 ));  test_nd_dm ((-  1 ,  2 ), (-  1 ,  1 ));  test_nd_dm ((-  1 , -  2 ), ( 0 , -  1 )); }# [ test ] fn  test_gcd (){ assert_eq ! (( 10  as $T ).  gcd (&  2 ),  2  as $T );  assert_eq ! (( 10  as $T ).  gcd (&  3 ),  1  as $T );  assert_eq ! (( 0  as $T ).  gcd (&  3 ),  3  as $T );  assert_eq ! (( 3  as $T ).  gcd (&  3 ),  3  as $T );  assert_eq ! (( 56  as $T ).  gcd (&  42 ),  14  as $T );  assert_eq ! (( 3  as $T ).  gcd (&-  3 ),  3  as $T );  assert_eq ! ((-  6  as $T ).  gcd (&  3 ),  3  as $T );  assert_eq ! ((-  4  as $T ).  gcd (&-  2 ),  2  as $T ); }# [ test ] fn  test_gcd_cmp_with_euclidean (){ fn  euclidean_gcd ( mut  m : $T ,  mut  n : $T )-> $T { while  m !=  0 { mem ::  swap (&  mut  m , &  mut  n );  m %=  n ; } n .  abs ()} for  i  in -  127 ..  127 { for  j  in -  127 ..  127 { assert_eq ! ( euclidean_gcd ( i ,  j ),  i .  gcd (&  j )); }} let  i =  127 ;  for  j  in -  127 ..  127 { assert_eq ! ( euclidean_gcd ( i ,  j ),  i .  gcd (&  j )); } assert_eq ! ( 127 .  gcd (&  127 ),  127 ); }# [ test ] fn  test_gcd_min_val (){ let  min = <$T >::  min_value ();  let  max = <$T >::  max_value ();  let  max_pow2 =  max /  2 +  1 ;  assert_eq ! ( min .  gcd (&  max ),  1  as $T );  assert_eq ! ( max .  gcd (&  min ),  1  as $T );  assert_eq ! ( min .  gcd (&  max_pow2 ),  max_pow2 );  assert_eq ! ( max_pow2 .  gcd (&  min ),  max_pow2 );  assert_eq ! ( min .  gcd (&  42 ),  2  as $T );  assert_eq ! (( 42  as $T ).  gcd (&  min ),  2  as $T ); }# [ test ]# [ should_panic ] fn  test_gcd_min_val_min_val (){ let  min = <$T >::  min_value ();  assert ! ( min .  gcd (&  min )>=  0 ); }# [ test ]# [ should_panic ] fn  test_gcd_min_val_0 (){ let  min = <$T >::  min_value ();  assert ! ( min .  gcd (&  0 )>=  0 ); }# [ test ]# [ should_panic ] fn  test_gcd_0_min_val (){ let  min = <$T >::  min_value ();  assert ! (( 0  as $T ).  gcd (&  min )>=  0 ); }# [ test ] fn  test_lcm (){ assert_eq ! (( 1  as $T ).  lcm (&  0 ),  0  as $T );  assert_eq ! (( 0  as $T ).  lcm (&  1 ),  0  as $T );  assert_eq ! (( 1  as $T ).  lcm (&  1 ),  1  as $T );  assert_eq ! ((-  1  as $T ).  lcm (&  1 ),  1  as $T );  assert_eq ! (( 1  as $T ).  lcm (&-  1 ),  1  as $T );  assert_eq ! ((-  1  as $T ).  lcm (&-  1 ),  1  as $T );  assert_eq ! (( 8  as $T ).  lcm (&  9 ),  72  as $T );  assert_eq ! (( 11  as $T ).  lcm (&  5 ),  55  as $T ); }# [ test ] fn  test_gcd_lcm (){ use  core ::  iter ::  once ;  for  i  in  once ( 0 ).  chain (( 1 ..).  take ( 127 ).  flat_map (|  a |  once ( a ).  chain ( once (-  a )))).  chain ( once (-  128 )){ for  j  in  once ( 0 ).  chain (( 1 ..).  take ( 127 ).  flat_map (|  a |  once ( a ).  chain ( once (-  a )))).  chain ( once (-  128 )){ assert_eq ! ( i .  gcd_lcm (&  j ), ( i .  gcd (&  j ),  i .  lcm (&  j ))); }}}# [ test ] fn  test_extended_gcd_lcm (){ use  core ::  fmt ::  Debug ;  use  traits ::  NumAssign ;  use  ExtendedGcd ;  fn  check <  A :  Copy +  Debug +  Integer +  NumAssign > ( a :  A ,  b :  A ){ let  ExtendedGcd { gcd ,  x ,  y , .. }=  a .  extended_gcd (&  b );  assert_eq ! ( gcd ,  x *  a +  y *  b ); } use  core ::  iter ::  once ;  for  i  in  once ( 0 ).  chain (( 1 ..).  take ( 127 ).  flat_map (|  a |  once ( a ).  chain ( once (-  a )))).  chain ( once (-  128 )){ for  j  in  once ( 0 ).  chain (( 1 ..).  take ( 127 ).  flat_map (|  a |  once ( a ).  chain ( once (-  a )))).  chain ( once (-  128 )){ check ( i ,  j );  let ( ExtendedGcd { gcd , .. },  lcm )=  i .  extended_gcd_lcm (&  j );  assert_eq ! (( gcd ,  lcm ), ( i .  gcd (&  j ),  i .  lcm (&  j ))); }}}# [ test ] fn  test_even (){ assert_eq ! ((-  4  as $T ).  is_even (),  true );  assert_eq ! ((-  3  as $T ).  is_even (),  false );  assert_eq ! ((-  2  as $T ).  is_even (),  true );  assert_eq ! ((-  1  as $T ).  is_even (),  false );  assert_eq ! (( 0  as $T ).  is_even (),  true );  assert_eq ! (( 1  as $T ).  is_even (),  false );  assert_eq ! (( 2  as $T ).  is_even (),  true );  assert_eq ! (( 3  as $T ).  is_even (),  false );  assert_eq ! (( 4  as $T ).  is_even (),  true ); }# [ test ] fn  test_odd (){ assert_eq ! ((-  4  as $T ).  is_odd (),  false );  assert_eq ! ((-  3  as $T ).  is_odd (),  true );  assert_eq ! ((-  2  as $T ).  is_odd (),  false );  assert_eq ! ((-  1  as $T ).  is_odd (),  true );  assert_eq ! (( 0  as $T ).  is_odd (),  false );  assert_eq ! (( 1  as $T ).  is_odd (),  true );  assert_eq ! (( 2  as $T ).  is_odd (),  false );  assert_eq ! (( 3  as $T ).  is_odd (),  true );  assert_eq ! (( 4  as $T ).  is_odd (),  false ); }}}; }
macro_rules! __ra_macro_fixture211 {($T :  ty , $test_mod :  ident )=>{ impl  Integer  for $T {# [ doc =  " Unsigned integer division. Returns the same result as `div` (`/`)." ]# [ inline ] fn  div_floor (&  self ,  other : &  Self )->  Self {*  self / *  other }# [ doc =  " Unsigned integer modulo operation. Returns the same result as `rem` (`%`)." ]# [ inline ] fn  mod_floor (&  self ,  other : &  Self )->  Self {*  self % *  other }# [ inline ] fn  div_ceil (&  self ,  other : &  Self )->  Self {*  self / *  other + ( 0 != *  self % *  other ) as  Self }# [ doc =  " Calculates the Greatest Common Divisor (GCD) of the number and `other`" ]# [ inline ] fn  gcd (&  self ,  other : &  Self )->  Self { let  mut  m = *  self ;  let  mut  n = *  other ;  if  m ==  0 ||  n ==  0 { return  m |  n ; } let  shift = ( m |  n ).  trailing_zeros ();  m >>=  m .  trailing_zeros ();  n >>=  n .  trailing_zeros ();  while  m !=  n { if  m > n { m -=  n ;  m >>=  m .  trailing_zeros (); } else { n -=  m ;  n >>=  n .  trailing_zeros (); }} m <<  shift }# [ inline ] fn  extended_gcd_lcm (&  self ,  other : &  Self )-> ( ExtendedGcd <  Self >,  Self ){ let  egcd =  self .  extended_gcd ( other );  let  lcm =  if  egcd .  gcd .  is_zero (){ Self ::  zero ()} else {*  self * (*  other /  egcd .  gcd )}; ( egcd ,  lcm )}# [ doc =  " Calculates the Lowest Common Multiple (LCM) of the number and `other`." ]# [ inline ] fn  lcm (&  self ,  other : &  Self )->  Self { self .  gcd_lcm ( other ).  1 }# [ doc =  " Calculates the Greatest Common Divisor (GCD) and" ]# [ doc =  " Lowest Common Multiple (LCM) of the number and `other`." ]# [ inline ] fn  gcd_lcm (&  self ,  other : &  Self )-> ( Self ,  Self ){ if  self .  is_zero ()&&  other .  is_zero (){ return ( Self ::  zero (),  Self ::  zero ()); } let  gcd =  self .  gcd ( other );  let  lcm = *  self * (*  other /  gcd ); ( gcd ,  lcm )}# [ doc =  " Deprecated, use `is_multiple_of` instead." ]# [ inline ] fn  divides (&  self ,  other : &  Self )->  bool { self .  is_multiple_of ( other )}# [ doc =  " Returns `true` if the number is a multiple of `other`." ]# [ inline ] fn  is_multiple_of (&  self ,  other : &  Self )->  bool {*  self % *  other ==  0 }# [ doc =  " Returns `true` if the number is divisible by `2`." ]# [ inline ] fn  is_even (&  self )->  bool {*  self %  2 ==  0 }# [ doc =  " Returns `true` if the number is not divisible by `2`." ]# [ inline ] fn  is_odd (&  self )->  bool {!  self .  is_even ()}# [ doc =  " Simultaneous truncated integer division and modulus." ]# [ inline ] fn  div_rem (&  self ,  other : &  Self )-> ( Self ,  Self ){(*  self / *  other , *  self % *  other )}}# [ cfg ( test )] mod $test_mod { use  core ::  mem ;  use  Integer ; # [ test ] fn  test_div_mod_floor (){ assert_eq ! (( 10  as $T ).  div_floor (& ( 3  as $T )),  3  as $T );  assert_eq ! (( 10  as $T ).  mod_floor (& ( 3  as $T )),  1  as $T );  assert_eq ! (( 10  as $T ).  div_mod_floor (& ( 3  as $T )), ( 3  as $T ,  1  as $T ));  assert_eq ! (( 5  as $T ).  div_floor (& ( 5  as $T )),  1  as $T );  assert_eq ! (( 5  as $T ).  mod_floor (& ( 5  as $T )),  0  as $T );  assert_eq ! (( 5  as $T ).  div_mod_floor (& ( 5  as $T )), ( 1  as $T ,  0  as $T ));  assert_eq ! (( 3  as $T ).  div_floor (& ( 7  as $T )),  0  as $T );  assert_eq ! (( 3  as $T ).  mod_floor (& ( 7  as $T )),  3  as $T );  assert_eq ! (( 3  as $T ).  div_mod_floor (& ( 7  as $T )), ( 0  as $T ,  3  as $T )); }# [ test ] fn  test_gcd (){ assert_eq ! (( 10  as $T ).  gcd (&  2 ),  2  as $T );  assert_eq ! (( 10  as $T ).  gcd (&  3 ),  1  as $T );  assert_eq ! (( 0  as $T ).  gcd (&  3 ),  3  as $T );  assert_eq ! (( 3  as $T ).  gcd (&  3 ),  3  as $T );  assert_eq ! (( 56  as $T ).  gcd (&  42 ),  14  as $T ); }# [ test ] fn  test_gcd_cmp_with_euclidean (){ fn  euclidean_gcd ( mut  m : $T ,  mut  n : $T )-> $T { while  m !=  0 { mem ::  swap (&  mut  m , &  mut  n );  m %=  n ; } n } for  i  in  0 ..  255 { for  j  in  0 ..  255 { assert_eq ! ( euclidean_gcd ( i ,  j ),  i .  gcd (&  j )); }} let  i =  255 ;  for  j  in  0 ..  255 { assert_eq ! ( euclidean_gcd ( i ,  j ),  i .  gcd (&  j )); } assert_eq ! ( 255 .  gcd (&  255 ),  255 ); }# [ test ] fn  test_lcm (){ assert_eq ! (( 1  as $T ).  lcm (&  0 ),  0  as $T );  assert_eq ! (( 0  as $T ).  lcm (&  1 ),  0  as $T );  assert_eq ! (( 1  as $T ).  lcm (&  1 ),  1  as $T );  assert_eq ! (( 8  as $T ).  lcm (&  9 ),  72  as $T );  assert_eq ! (( 11  as $T ).  lcm (&  5 ),  55  as $T );  assert_eq ! (( 15  as $T ).  lcm (&  17 ),  255  as $T ); }# [ test ] fn  test_gcd_lcm (){ for  i  in ( 0 ..).  take ( 256 ){ for  j  in ( 0 ..).  take ( 256 ){ assert_eq ! ( i .  gcd_lcm (&  j ), ( i .  gcd (&  j ),  i .  lcm (&  j ))); }}}# [ test ] fn  test_is_multiple_of (){ assert ! (( 6  as $T ).  is_multiple_of (& ( 6  as $T )));  assert ! (( 6  as $T ).  is_multiple_of (& ( 3  as $T )));  assert ! (( 6  as $T ).  is_multiple_of (& ( 1  as $T ))); }# [ test ] fn  test_even (){ assert_eq ! (( 0  as $T ).  is_even (),  true );  assert_eq ! (( 1  as $T ).  is_even (),  false );  assert_eq ! (( 2  as $T ).  is_even (),  true );  assert_eq ! (( 3  as $T ).  is_even (),  false );  assert_eq ! (( 4  as $T ).  is_even (),  true ); }# [ test ] fn  test_odd (){ assert_eq ! (( 0  as $T ).  is_odd (),  false );  assert_eq ! (( 1  as $T ).  is_odd (),  true );  assert_eq ! (( 2  as $T ).  is_odd (),  false );  assert_eq ! (( 3  as $T ).  is_odd (),  true );  assert_eq ! (( 4  as $T ).  is_odd (),  false ); }}}; }
macro_rules! __ra_macro_fixture212 {($I :  ident , $U :  ident )=>{ mod $I { use  check ;  use  neg ;  use  num_integer ::  Roots ;  use  pos ;  use  std ::  mem ; # [ test ]# [ should_panic ] fn  zeroth_root (){( 123  as $I ).  nth_root ( 0 ); }# [ test ] fn  sqrt (){ check (&  pos ::<$I > (),  2 ); }# [ test ]# [ should_panic ] fn  sqrt_neg (){(-  123  as $I ).  sqrt (); }# [ test ] fn  cbrt (){ check (&  pos ::<$I > (),  3 ); }# [ test ] fn  cbrt_neg (){ check (&  neg ::<$I > (),  3 ); }# [ test ] fn  nth_root (){ let  bits =  8 *  mem ::  size_of ::<$I > () as  u32 -  1 ;  let  pos =  pos ::<$I > ();  for  n  in  4 ..  bits { check (&  pos ,  n ); }}# [ test ] fn  nth_root_neg (){ let  bits =  8 *  mem ::  size_of ::<$I > () as  u32 -  1 ;  let  neg =  neg ::<$I > ();  for  n  in  2 ..  bits /  2 { check (&  neg ,  2 *  n +  1 ); }}# [ test ] fn  bit_size (){ let  bits =  8 *  mem ::  size_of ::<$I > () as  u32 -  1 ;  assert_eq ! ($I ::  max_value ().  nth_root ( bits -  1 ),  2 );  assert_eq ! ($I ::  max_value ().  nth_root ( bits ),  1 );  assert_eq ! ($I ::  min_value ().  nth_root ( bits ), -  2 );  assert_eq ! (($I ::  min_value ()+  1 ).  nth_root ( bits ), -  1 ); }} mod $U { use  check ;  use  num_integer ::  Roots ;  use  pos ;  use  std ::  mem ; # [ test ]# [ should_panic ] fn  zeroth_root (){( 123  as $U ).  nth_root ( 0 ); }# [ test ] fn  sqrt (){ check (&  pos ::<$U > (),  2 ); }# [ test ] fn  cbrt (){ check (&  pos ::<$U > (),  3 ); }# [ test ] fn  nth_root (){ let  bits =  8 *  mem ::  size_of ::<$I > () as  u32 -  1 ;  let  pos =  pos ::<$I > ();  for  n  in  4 ..  bits { check (&  pos ,  n ); }}# [ test ] fn  bit_size (){ let  bits =  8 *  mem ::  size_of ::<$U > () as  u32 ;  assert_eq ! ($U ::  max_value ().  nth_root ( bits -  1 ),  2 );  assert_eq ! ($U ::  max_value ().  nth_root ( bits ),  1 ); }}}; }
macro_rules! __ra_macro_fixture213 {($name :  ident , $ranges :  ident )=>{# [ test ] fn $name (){ let  set =  ranges_to_set ( general_category ::$ranges );  let  hashset :  HashSet <  u32 > =  set .  iter ().  cloned ().  collect ();  let  trie =  TrieSetOwned ::  from_codepoints (&  set ).  unwrap ();  for  cp  in  0 ..  0x110000 { assert ! ( trie .  contains_u32 ( cp )==  hashset .  contains (&  cp )); } assert ! (!  trie .  contains_u32 ( 0x110000 ));  assert ! (!  hashset .  contains (&  0x110000 )); }}; }
macro_rules! __ra_macro_fixture214 {{$(mod $module :  ident ; [$($prop :  ident , )*]; )*}=>{$(# [ allow ( unused )] mod $module ; $(pub  fn $prop ( c :  char )->  bool { self ::$module ::$prop .  contains_char ( c )})* )*}; }
macro_rules! __ra_macro_fixture215 {($name :  ident : $input :  expr , $($x :  tt )* )=>{# [ test ] fn $name (){ let  expected_sets =  vec ! [$($x )*];  let  range_set :  RangeSet = $input .  parse ().  expect ( "parse failed" );  assert_eq ! ( range_set .  ranges .  len (),  expected_sets .  len ());  for  it  in  range_set .  ranges .  iter ().  zip ( expected_sets .  iter ()){ let ( ai ,  bi )=  it ;  assert_eq ! ( ai .  comparator_set .  len (), *  bi ); }}}; }
macro_rules! __ra_macro_fixture216 {($name :  ident : $input :  expr , $($x :  tt )* )=>{# [ test ] fn $name (){ let  expected_sets =  vec ! [$($x )*];  let  range_set =  RangeSet ::  parse ($input ,  Compat ::  Npm ).  expect ( "parse failed" );  assert_eq ! ( range_set .  ranges .  len (),  expected_sets .  len ());  for  it  in  range_set .  ranges .  iter ().  zip ( expected_sets .  iter ()){ let ( ai ,  bi )=  it ;  assert_eq ! ( ai .  comparator_set .  len (), *  bi ); }}}; }
macro_rules! __ra_macro_fixture217 {($($name :  ident : $value :  expr , )* )=>{$(# [ test ] fn $name (){ assert ! ($value .  parse ::<  RangeSet > ().  is_err ()); })* }; }
macro_rules! __ra_macro_fixture218 {($($name :  ident : $value :  expr , )* )=>{$(# [ test ] fn $name (){ let ( input ,  expected_range )= $value ;  let  parsed_range =  parse_range ( input );  let  range =  from_pair_iterator ( parsed_range ,  range_set ::  Compat ::  Cargo ).  expect ( "parsing failed" );  let  num_comparators =  range .  comparator_set .  len ();  let  expected_comparators =  expected_range .  comparator_set .  len ();  assert_eq ! ( expected_comparators ,  num_comparators ,  "expected number of comparators: {}, got: {}" ,  expected_comparators ,  num_comparators );  assert_eq ! ( range ,  expected_range ); })* }; }
macro_rules! __ra_macro_fixture219 {($($name :  ident : $value :  expr , )* )=>{$(# [ test ] fn $name (){ let ( input ,  expected_range )= $value ;  let  parsed_range =  parse_range ( input );  let  range =  from_pair_iterator ( parsed_range ,  range_set ::  Compat ::  Npm ).  expect ( "parsing failed" );  let  num_comparators =  range .  comparator_set .  len ();  let  expected_comparators =  expected_range .  comparator_set .  len ();  assert_eq ! ( expected_comparators ,  num_comparators ,  "expected number of comparators: {}, got: {}" ,  expected_comparators ,  num_comparators );  assert_eq ! ( range ,  expected_range ); })* }; }
macro_rules! __ra_macro_fixture220 {($ty :  ident $(<$lifetime :  tt >)*)=>{ impl <$($lifetime ,)*  E >  Copy  for $ty <$($lifetime ,)*  E > {} impl <$($lifetime ,)*  E >  Clone  for $ty <$($lifetime ,)*  E > { fn  clone (&  self )->  Self {*  self }}}; }
macro_rules! __ra_macro_fixture221 {($ty :  ty , $doc :  tt , $name :  ident , $method :  ident $($cast :  tt )*)=>{# [ doc =  "A deserializer holding" ]# [ doc = $doc ] pub  struct $name <  E > { value : $ty ,  marker :  PhantomData <  E > } impl_copy_clone ! ($name );  impl < 'de ,  E >  IntoDeserializer < 'de ,  E >  for $ty  where  E :  de ::  Error , { type  Deserializer = $name <  E >;  fn  into_deserializer ( self )-> $name <  E > {$name { value :  self ,  marker :  PhantomData , }}} impl < 'de ,  E >  de ::  Deserializer < 'de >  for $name <  E >  where  E :  de ::  Error , { type  Error =  E ;  forward_to_deserialize_any ! { bool  i8  i16  i32  i64  i128  u8  u16  u32  u64  u128  f32  f64  char  str  string  bytes  byte_buf  option  unit  unit_struct  newtype_struct  seq  tuple  tuple_struct  map  struct  enum  identifier  ignored_any } fn  deserialize_any <  V > ( self ,  visitor :  V )->  Result <  V ::  Value ,  Self ::  Error >  where  V :  de ::  Visitor < 'de >, { visitor .$method ( self .  value $($cast )*)}} impl <  E >  Debug  for $name <  E > { fn  fmt (&  self ,  formatter : &  mut  fmt ::  Formatter )->  fmt ::  Result { formatter .  debug_struct ( stringify ! ($name )).  field ( "value" , &  self .  value ).  finish ()}}}}
macro_rules! __ra_macro_fixture222 {($($tt :  tt )*)=>{}; }
macro_rules! __ra_macro_fixture223 {($ty :  ident , $deserialize :  ident $($methods :  tt )*)=>{ impl < 'de >  Deserialize < 'de >  for $ty {# [ inline ] fn  deserialize <  D > ( deserializer :  D )->  Result <  Self ,  D ::  Error >  where  D :  Deserializer < 'de >, { struct  PrimitiveVisitor ;  impl < 'de >  Visitor < 'de >  for  PrimitiveVisitor { type  Value = $ty ;  fn  expecting (&  self ,  formatter : &  mut  fmt ::  Formatter )->  fmt ::  Result { formatter .  write_str ( stringify ! ($ty ))}$($methods )* } deserializer .$deserialize ( PrimitiveVisitor )}}}; }
macro_rules! __ra_macro_fixture224 {($ty :  ident <  T $(: $tbound1 :  ident $(+ $tbound2 :  ident )*)* $(, $typaram :  ident : $bound1 :  ident $(+ $bound2 :  ident )*)* >, $access :  ident , $clear :  expr , $with_capacity :  expr , $reserve :  expr , $insert :  expr )=>{ impl < 'de ,  T $(, $typaram )*>  Deserialize < 'de >  for $ty <  T $(, $typaram )*>  where  T :  Deserialize < 'de > $(+ $tbound1 $(+ $tbound2 )*)*, $($typaram : $bound1 $(+ $bound2 )*,)* { fn  deserialize <  D > ( deserializer :  D )->  Result <  Self ,  D ::  Error >  where  D :  Deserializer < 'de >, { struct  SeqVisitor <  T $(, $typaram )*> { marker :  PhantomData <$ty <  T $(, $typaram )*>>, } impl < 'de ,  T $(, $typaram )*>  Visitor < 'de >  for  SeqVisitor <  T $(, $typaram )*>  where  T :  Deserialize < 'de > $(+ $tbound1 $(+ $tbound2 )*)*, $($typaram : $bound1 $(+ $bound2 )*,)* { type  Value = $ty <  T $(, $typaram )*>;  fn  expecting (&  self ,  formatter : &  mut  fmt ::  Formatter )->  fmt ::  Result { formatter .  write_str ( "a sequence" )}# [ inline ] fn  visit_seq <  A > ( self ,  mut $access :  A )->  Result <  Self ::  Value ,  A ::  Error >  where  A :  SeqAccess < 'de >, { let  mut  values = $with_capacity ;  while  let  Some ( value )=  try ! ($access .  next_element ()){$insert (&  mut  values ,  value ); } Ok ( values )}} let  visitor =  SeqVisitor { marker :  PhantomData };  deserializer .  deserialize_seq ( visitor )} fn  deserialize_in_place <  D > ( deserializer :  D ,  place : &  mut  Self )->  Result < (),  D ::  Error >  where  D :  Deserializer < 'de >, { struct  SeqInPlaceVisitor < 'a ,  T : 'a $(, $typaram : 'a )*> (& 'a  mut $ty <  T $(, $typaram )*>);  impl < 'a , 'de ,  T $(, $typaram )*>  Visitor < 'de >  for  SeqInPlaceVisitor < 'a ,  T $(, $typaram )*>  where  T :  Deserialize < 'de > $(+ $tbound1 $(+ $tbound2 )*)*, $($typaram : $bound1 $(+ $bound2 )*,)* { type  Value = ();  fn  expecting (&  self ,  formatter : &  mut  fmt ::  Formatter )->  fmt ::  Result { formatter .  write_str ( "a sequence" )}# [ inline ] fn  visit_seq <  A > ( mut  self ,  mut $access :  A )->  Result <  Self ::  Value ,  A ::  Error >  where  A :  SeqAccess < 'de >, {$clear (&  mut  self .  0 ); $reserve (&  mut  self .  0 ,  size_hint ::  cautious ($access .  size_hint ()));  while  let  Some ( value )=  try ! ($access .  next_element ()){$insert (&  mut  self .  0 ,  value ); } Ok (())}} deserializer .  deserialize_seq ( SeqInPlaceVisitor ( place ))}}}}
macro_rules! __ra_macro_fixture225 {($($len :  expr =>($($n :  tt )+))+)=>{$(impl < 'de ,  T >  Visitor < 'de >  for  ArrayVisitor < [ T ; $len ]>  where  T :  Deserialize < 'de >, { type  Value = [ T ; $len ];  fn  expecting (&  self ,  formatter : &  mut  fmt ::  Formatter )->  fmt ::  Result { formatter .  write_str ( concat ! ( "an array of length " , $len ))}# [ inline ] fn  visit_seq <  A > ( self ,  mut  seq :  A )->  Result <  Self ::  Value ,  A ::  Error >  where  A :  SeqAccess < 'de >, { Ok ([$(match  try ! ( seq .  next_element ()){ Some ( val )=> val ,  None => return  Err ( Error ::  invalid_length ($n , &  self )), }),+])}} impl < 'a , 'de ,  T >  Visitor < 'de >  for  ArrayInPlaceVisitor < 'a , [ T ; $len ]>  where  T :  Deserialize < 'de >, { type  Value = ();  fn  expecting (&  self ,  formatter : &  mut  fmt ::  Formatter )->  fmt ::  Result { formatter .  write_str ( concat ! ( "an array of length " , $len ))}# [ inline ] fn  visit_seq <  A > ( self ,  mut  seq :  A )->  Result <  Self ::  Value ,  A ::  Error >  where  A :  SeqAccess < 'de >, { let  mut  fail_idx =  None ;  for ( idx ,  dest ) in  self .  0 [..].  iter_mut ().  enumerate (){ if  try ! ( seq .  next_element_seed ( InPlaceSeed ( dest ))).  is_none (){ fail_idx =  Some ( idx );  break ; }} if  let  Some ( idx )=  fail_idx { return  Err ( Error ::  invalid_length ( idx , &  self )); } Ok (())}} impl < 'de ,  T >  Deserialize < 'de >  for [ T ; $len ] where  T :  Deserialize < 'de >, { fn  deserialize <  D > ( deserializer :  D )->  Result <  Self ,  D ::  Error >  where  D :  Deserializer < 'de >, { deserializer .  deserialize_tuple ($len ,  ArrayVisitor ::< [ T ; $len ]>::  new ())} fn  deserialize_in_place <  D > ( deserializer :  D ,  place : &  mut  Self )->  Result < (),  D ::  Error >  where  D :  Deserializer < 'de >, { deserializer .  deserialize_tuple ($len ,  ArrayInPlaceVisitor ( place ))}})+ }}
macro_rules! __ra_macro_fixture226 {($($len :  tt =>($($n :  tt $name :  ident )+))+)=>{$(impl < 'de , $($name :  Deserialize < 'de >),+>  Deserialize < 'de >  for ($($name ,)+){# [ inline ] fn  deserialize <  D > ( deserializer :  D )->  Result <  Self ,  D ::  Error >  where  D :  Deserializer < 'de >, { struct  TupleVisitor <$($name ,)+> { marker :  PhantomData < ($($name ,)+)>, } impl < 'de , $($name :  Deserialize < 'de >),+>  Visitor < 'de >  for  TupleVisitor <$($name ,)+> { type  Value = ($($name ,)+);  fn  expecting (&  self ,  formatter : &  mut  fmt ::  Formatter )->  fmt ::  Result { formatter .  write_str ( concat ! ( "a tuple of size " , $len ))}# [ inline ]# [ allow ( non_snake_case )] fn  visit_seq <  A > ( self ,  mut  seq :  A )->  Result <  Self ::  Value ,  A ::  Error >  where  A :  SeqAccess < 'de >, {$(let $name =  match  try ! ( seq .  next_element ()){ Some ( value )=> value ,  None => return  Err ( Error ::  invalid_length ($n , &  self )), }; )+  Ok (($($name ,)+))}} deserializer .  deserialize_tuple ($len ,  TupleVisitor { marker :  PhantomData })}# [ inline ] fn  deserialize_in_place <  D > ( deserializer :  D ,  place : &  mut  Self )->  Result < (),  D ::  Error >  where  D :  Deserializer < 'de >, { struct  TupleInPlaceVisitor < 'a , $($name : 'a ,)+> (& 'a  mut ($($name ,)+));  impl < 'a , 'de , $($name :  Deserialize < 'de >),+>  Visitor < 'de >  for  TupleInPlaceVisitor < 'a , $($name ,)+> { type  Value = ();  fn  expecting (&  self ,  formatter : &  mut  fmt ::  Formatter )->  fmt ::  Result { formatter .  write_str ( concat ! ( "a tuple of size " , $len ))}# [ inline ]# [ allow ( non_snake_case )] fn  visit_seq <  A > ( self ,  mut  seq :  A )->  Result <  Self ::  Value ,  A ::  Error >  where  A :  SeqAccess < 'de >, {$(if  try ! ( seq .  next_element_seed ( InPlaceSeed (&  mut ( self .  0 ).$n ))).  is_none (){ return  Err ( Error ::  invalid_length ($n , &  self )); })+  Ok (())}} deserializer .  deserialize_tuple ($len ,  TupleInPlaceVisitor ( place ))}})+ }}
macro_rules! __ra_macro_fixture227 {($ty :  ident <  K $(: $kbound1 :  ident $(+ $kbound2 :  ident )*)*,  V $(, $typaram :  ident : $bound1 :  ident $(+ $bound2 :  ident )*)* >, $access :  ident , $with_capacity :  expr )=>{ impl < 'de ,  K ,  V $(, $typaram )*>  Deserialize < 'de >  for $ty <  K ,  V $(, $typaram )*>  where  K :  Deserialize < 'de > $(+ $kbound1 $(+ $kbound2 )*)*,  V :  Deserialize < 'de >, $($typaram : $bound1 $(+ $bound2 )*),* { fn  deserialize <  D > ( deserializer :  D )->  Result <  Self ,  D ::  Error >  where  D :  Deserializer < 'de >, { struct  MapVisitor <  K ,  V $(, $typaram )*> { marker :  PhantomData <$ty <  K ,  V $(, $typaram )*>>, } impl < 'de ,  K ,  V $(, $typaram )*>  Visitor < 'de >  for  MapVisitor <  K ,  V $(, $typaram )*>  where  K :  Deserialize < 'de > $(+ $kbound1 $(+ $kbound2 )*)*,  V :  Deserialize < 'de >, $($typaram : $bound1 $(+ $bound2 )*),* { type  Value = $ty <  K ,  V $(, $typaram )*>;  fn  expecting (&  self ,  formatter : &  mut  fmt ::  Formatter )->  fmt ::  Result { formatter .  write_str ( "a map" )}# [ inline ] fn  visit_map <  A > ( self ,  mut $access :  A )->  Result <  Self ::  Value ,  A ::  Error >  where  A :  MapAccess < 'de >, { let  mut  values = $with_capacity ;  while  let  Some (( key ,  value ))=  try ! ($access .  next_entry ()){ values .  insert ( key ,  value ); } Ok ( values )}} let  visitor =  MapVisitor { marker :  PhantomData };  deserializer .  deserialize_map ( visitor )}}}}
macro_rules! __ra_macro_fixture228 {($expecting :  tt $ty :  ty ; $size :  tt )=>{ impl < 'de >  Deserialize < 'de >  for $ty { fn  deserialize <  D > ( deserializer :  D )->  Result <  Self ,  D ::  Error >  where  D :  Deserializer < 'de >, { if  deserializer .  is_human_readable (){ deserializer .  deserialize_str ( FromStrVisitor ::  new ($expecting ))} else {< [ u8 ; $size ]>::  deserialize ( deserializer ).  map (<$ty >::  from )}}}}; }
macro_rules! __ra_macro_fixture229 {($expecting :  tt $ty :  ty , $new :  expr )=>{ impl < 'de >  Deserialize < 'de >  for $ty { fn  deserialize <  D > ( deserializer :  D )->  Result <  Self ,  D ::  Error >  where  D :  Deserializer < 'de >, { if  deserializer .  is_human_readable (){ deserializer .  deserialize_str ( FromStrVisitor ::  new ($expecting ))} else {< (_,  u16 )>::  deserialize ( deserializer ).  map (| ( ip ,  port )| $new ( ip ,  port ))}}}}; }
macro_rules! __ra_macro_fixture230 {($name_kind :  ident ($($variant :  ident ; $bytes :  expr ; $index :  expr ),* )$expecting_message :  expr , $variants_name :  ident )=>{ enum $name_kind {$($variant ),* } static $variants_name : & 'static [& 'static  str ]= & [$(stringify ! ($variant )),*];  impl < 'de >  Deserialize < 'de >  for $name_kind { fn  deserialize <  D > ( deserializer :  D )->  Result <  Self ,  D ::  Error >  where  D :  Deserializer < 'de >, { struct  KindVisitor ;  impl < 'de >  Visitor < 'de >  for  KindVisitor { type  Value = $name_kind ;  fn  expecting (&  self ,  formatter : &  mut  fmt ::  Formatter )->  fmt ::  Result { formatter .  write_str ($expecting_message )} fn  visit_u64 <  E > ( self ,  value :  u64 )->  Result <  Self ::  Value ,  E >  where  E :  Error , { match  value {$($index => Ok ($name_kind :: $variant ), )* _ => Err ( Error ::  invalid_value ( Unexpected ::  Unsigned ( value ), &  self ),), }} fn  visit_str <  E > ( self ,  value : &  str )->  Result <  Self ::  Value ,  E >  where  E :  Error , { match  value {$(stringify ! ($variant )=> Ok ($name_kind :: $variant ), )* _ => Err ( Error ::  unknown_variant ( value , $variants_name )), }} fn  visit_bytes <  E > ( self ,  value : & [ u8 ])->  Result <  Self ::  Value ,  E >  where  E :  Error , { match  value {$($bytes => Ok ($name_kind :: $variant ), )* _ =>{ match  str ::  from_utf8 ( value ){ Ok ( value )=> Err ( Error ::  unknown_variant ( value , $variants_name )),  Err (_)=> Err ( Error ::  invalid_value ( Unexpected ::  Bytes ( value ), &  self )), }}}}} deserializer .  deserialize_identifier ( KindVisitor )}}}}
macro_rules! __ra_macro_fixture231 {($(# [ doc = $doc :  tt ])* ($($id :  ident ),* ), $ty :  ty , $func :  expr )=>{$(# [ doc = $doc ])*  impl < 'de $(, $id :  Deserialize < 'de >,)*>  Deserialize < 'de >  for $ty { fn  deserialize <  D > ( deserializer :  D )->  Result <  Self ,  D ::  Error >  where  D :  Deserializer < 'de >, { Deserialize ::  deserialize ( deserializer ).  map ($func )}}}}
macro_rules! __ra_macro_fixture232 {($($T :  ident , )+ )=>{$(# [ cfg ( num_nonzero )] impl < 'de >  Deserialize < 'de >  for  num ::$T { fn  deserialize <  D > ( deserializer :  D )->  Result <  Self ,  D ::  Error >  where  D :  Deserializer < 'de >, { let  value =  try ! ( Deserialize ::  deserialize ( deserializer ));  match <  num ::$T >::  new ( value ){ Some ( nonzero )=> Ok ( nonzero ),  None => Err ( Error ::  custom ( "expected a non-zero value" )), }}})+ }; }
macro_rules! __ra_macro_fixture233 {( Error :  Sized $(+ $($supertrait :  ident )::+)*)=>{# [ doc =  " The `Error` trait allows `Deserialize` implementations to create descriptive" ]# [ doc =  " error messages belonging to the `Deserializer` against which they are" ]# [ doc =  " currently running." ]# [ doc =  "" ]# [ doc =  " Every `Deserializer` declares an `Error` type that encompasses both" ]# [ doc =  " general-purpose deserialization errors as well as errors specific to the" ]# [ doc =  " particular deserialization format. For example the `Error` type of" ]# [ doc =  " `serde_json` can represent errors like an invalid JSON escape sequence or an" ]# [ doc =  " unterminated string literal, in addition to the error cases that are part of" ]# [ doc =  " this trait." ]# [ doc =  "" ]# [ doc =  " Most deserializers should only need to provide the `Error::custom` method" ]# [ doc =  " and inherit the default behavior for the other methods." ]# [ doc =  "" ]# [ doc =  " # Example implementation" ]# [ doc =  "" ]# [ doc =  " The [example data format] presented on the website shows an error" ]# [ doc =  " type appropriate for a basic JSON data format." ]# [ doc =  "" ]# [ doc =  " [example data format]: https://serde.rs/data-format.html" ] pub  trait  Error :  Sized $(+ $($supertrait )::+)* {# [ doc =  " Raised when there is general error when deserializing a type." ]# [ doc =  "" ]# [ doc =  " The message should not be capitalized and should not end with a period." ]# [ doc =  "" ]# [ doc =  " ```edition2018" ]# [ doc =  " # use std::str::FromStr;" ]# [ doc =  " #" ]# [ doc =  " # struct IpAddr;" ]# [ doc =  " #" ]# [ doc =  " # impl FromStr for IpAddr {" ]# [ doc =  " #     type Err = String;" ]# [ doc =  " #" ]# [ doc =  " #     fn from_str(_: &str) -> Result<Self, String> {" ]# [ doc =  " #         unimplemented!()" ]# [ doc =  " #     }" ]# [ doc =  " # }" ]# [ doc =  " #" ]# [ doc =  " use serde::de::{self, Deserialize, Deserializer};" ]# [ doc =  "" ]# [ doc =  " impl<\\\'de> Deserialize<\\\'de> for IpAddr {" ]# [ doc =  "     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>" ]# [ doc =  "     where" ]# [ doc =  "         D: Deserializer<\\\'de>," ]# [ doc =  "     {" ]# [ doc =  "         let s = String::deserialize(deserializer)?;" ]# [ doc =  "         s.parse().map_err(de::Error::custom)" ]# [ doc =  "     }" ]# [ doc =  " }" ]# [ doc =  " ```" ] fn  custom <  T > ( msg :  T )->  Self  where  T :  Display ; # [ doc =  " Raised when a `Deserialize` receives a type different from what it was" ]# [ doc =  " expecting." ]# [ doc =  "" ]# [ doc =  " The `unexp` argument provides information about what type was received." ]# [ doc =  " This is the type that was present in the input file or other source data" ]# [ doc =  " of the Deserializer." ]# [ doc =  "" ]# [ doc =  " The `exp` argument provides information about what type was being" ]# [ doc =  " expected. This is the type that is written in the program." ]# [ doc =  "" ]# [ doc =  " For example if we try to deserialize a String out of a JSON file" ]# [ doc =  " containing an integer, the unexpected type is the integer and the" ]# [ doc =  " expected type is the string." ]# [ cold ] fn  invalid_type ( unexp :  Unexpected ,  exp : &  Expected )->  Self { Error ::  custom ( format_args ! ( "invalid type: {}, expected {}" ,  unexp ,  exp ))}# [ doc =  " Raised when a `Deserialize` receives a value of the right type but that" ]# [ doc =  " is wrong for some other reason." ]# [ doc =  "" ]# [ doc =  " The `unexp` argument provides information about what value was received." ]# [ doc =  " This is the value that was present in the input file or other source" ]# [ doc =  " data of the Deserializer." ]# [ doc =  "" ]# [ doc =  " The `exp` argument provides information about what value was being" ]# [ doc =  " expected. This is the type that is written in the program." ]# [ doc =  "" ]# [ doc =  " For example if we try to deserialize a String out of some binary data" ]# [ doc =  " that is not valid UTF-8, the unexpected value is the bytes and the" ]# [ doc =  " expected value is a string." ]# [ cold ] fn  invalid_value ( unexp :  Unexpected ,  exp : &  Expected )->  Self { Error ::  custom ( format_args ! ( "invalid value: {}, expected {}" ,  unexp ,  exp ))}# [ doc =  " Raised when deserializing a sequence or map and the input data contains" ]# [ doc =  " too many or too few elements." ]# [ doc =  "" ]# [ doc =  " The `len` argument is the number of elements encountered. The sequence" ]# [ doc =  " or map may have expected more arguments or fewer arguments." ]# [ doc =  "" ]# [ doc =  " The `exp` argument provides information about what data was being" ]# [ doc =  " expected. For example `exp` might say that a tuple of size 6 was" ]# [ doc =  " expected." ]# [ cold ] fn  invalid_length ( len :  usize ,  exp : &  Expected )->  Self { Error ::  custom ( format_args ! ( "invalid length {}, expected {}" ,  len ,  exp ))}# [ doc =  " Raised when a `Deserialize` enum type received a variant with an" ]# [ doc =  " unrecognized name." ]# [ cold ] fn  unknown_variant ( variant : &  str ,  expected : & 'static [& 'static  str ])->  Self { if  expected .  is_empty (){ Error ::  custom ( format_args ! ( "unknown variant `{}`, there are no variants" ,  variant ))} else { Error ::  custom ( format_args ! ( "unknown variant `{}`, expected {}" ,  variant ,  OneOf { names :  expected }))}}# [ doc =  " Raised when a `Deserialize` struct type received a field with an" ]# [ doc =  " unrecognized name." ]# [ cold ] fn  unknown_field ( field : &  str ,  expected : & 'static [& 'static  str ])->  Self { if  expected .  is_empty (){ Error ::  custom ( format_args ! ( "unknown field `{}`, there are no fields" ,  field ))} else { Error ::  custom ( format_args ! ( "unknown field `{}`, expected {}" ,  field ,  OneOf { names :  expected }))}}# [ doc =  " Raised when a `Deserialize` struct type expected to receive a required" ]# [ doc =  " field with a particular name but that field was not present in the" ]# [ doc =  " input." ]# [ cold ] fn  missing_field ( field : & 'static  str )->  Self { Error ::  custom ( format_args ! ( "missing field `{}`" ,  field ))}# [ doc =  " Raised when a `Deserialize` struct type received more than one of the" ]# [ doc =  " same field." ]# [ cold ] fn  duplicate_field ( field : & 'static  str )->  Self { Error ::  custom ( format_args ! ( "duplicate field `{}`" ,  field ))}}}}
macro_rules! __ra_macro_fixture234 {($ty :  ident , $method :  ident $($cast :  tt )*)=>{ impl  Serialize  for $ty {# [ inline ] fn  serialize <  S > (&  self ,  serializer :  S )->  Result <  S ::  Ok ,  S ::  Error >  where  S :  Serializer , { serializer .$method (*  self $($cast )*)}}}}
macro_rules! __ra_macro_fixture235 {($($len :  tt )+)=>{$(impl <  T >  Serialize  for [ T ; $len ] where  T :  Serialize , {# [ inline ] fn  serialize <  S > (&  self ,  serializer :  S )->  Result <  S ::  Ok ,  S ::  Error >  where  S :  Serializer , { let  mut  seq =  try ! ( serializer .  serialize_tuple ($len ));  for  e  in  self { try ! ( seq .  serialize_element ( e )); } seq .  end ()}})+ }}
macro_rules! __ra_macro_fixture236 {($ty :  ident <  T $(: $tbound1 :  ident $(+ $tbound2 :  ident )*)* $(, $typaram :  ident : $bound :  ident )* >)=>{ impl <  T $(, $typaram )*>  Serialize  for $ty <  T $(, $typaram )*>  where  T :  Serialize $(+ $tbound1 $(+ $tbound2 )*)*, $($typaram : $bound ,)* {# [ inline ] fn  serialize <  S > (&  self ,  serializer :  S )->  Result <  S ::  Ok ,  S ::  Error >  where  S :  Serializer , { serializer .  collect_seq ( self )}}}}
macro_rules! __ra_macro_fixture237 {($($len :  expr =>($($n :  tt $name :  ident )+))+)=>{$(impl <$($name ),+>  Serialize  for ($($name ,)+) where $($name :  Serialize ,)+ {# [ inline ] fn  serialize <  S > (&  self ,  serializer :  S )->  Result <  S ::  Ok ,  S ::  Error >  where  S :  Serializer , { let  mut  tuple =  try ! ( serializer .  serialize_tuple ($len )); $(try ! ( tuple .  serialize_element (&  self .$n )); )+  tuple .  end ()}})+ }}
macro_rules! __ra_macro_fixture238 {($ty :  ident <  K $(: $kbound1 :  ident $(+ $kbound2 :  ident )*)*,  V $(, $typaram :  ident : $bound :  ident )* >)=>{ impl <  K ,  V $(, $typaram )*>  Serialize  for $ty <  K ,  V $(, $typaram )*>  where  K :  Serialize $(+ $kbound1 $(+ $kbound2 )*)*,  V :  Serialize , $($typaram : $bound ,)* {# [ inline ] fn  serialize <  S > (&  self ,  serializer :  S )->  Result <  S ::  Ok ,  S ::  Error >  where  S :  Serializer , { serializer .  collect_map ( self )}}}}
macro_rules! __ra_macro_fixture239 {($(# [ doc = $doc :  tt ])* <$($desc :  tt )+ )=>{$(# [ doc = $doc ])*  impl <$($desc )+ {# [ inline ] fn  serialize <  S > (&  self ,  serializer :  S )->  Result <  S ::  Ok ,  S ::  Error >  where  S :  Serializer , {(**  self ).  serialize ( serializer )}}}; }
macro_rules! __ra_macro_fixture240 {($($T :  ident , )+ )=>{$(# [ cfg ( num_nonzero )] impl  Serialize  for  num ::$T { fn  serialize <  S > (&  self ,  serializer :  S )->  Result <  S ::  Ok ,  S ::  Error >  where  S :  Serializer , { self .  get ().  serialize ( serializer )}})+ }}
macro_rules! __ra_macro_fixture241 {( Error :  Sized $(+ $($supertrait :  ident )::+)*)=>{# [ doc =  " Trait used by `Serialize` implementations to generically construct" ]# [ doc =  " errors belonging to the `Serializer` against which they are" ]# [ doc =  " currently running." ]# [ doc =  "" ]# [ doc =  " # Example implementation" ]# [ doc =  "" ]# [ doc =  " The [example data format] presented on the website shows an error" ]# [ doc =  " type appropriate for a basic JSON data format." ]# [ doc =  "" ]# [ doc =  " [example data format]: https://serde.rs/data-format.html" ] pub  trait  Error :  Sized $(+ $($supertrait )::+)* {# [ doc =  " Used when a [`Serialize`] implementation encounters any error" ]# [ doc =  " while serializing a type." ]# [ doc =  "" ]# [ doc =  " The message should not be capitalized and should not end with a" ]# [ doc =  " period." ]# [ doc =  "" ]# [ doc =  " For example, a filesystem [`Path`] may refuse to serialize" ]# [ doc =  " itself if it contains invalid UTF-8 data." ]# [ doc =  "" ]# [ doc =  " ```edition2018" ]# [ doc =  " # struct Path;" ]# [ doc =  " #" ]# [ doc =  " # impl Path {" ]# [ doc =  " #     fn to_str(&self) -> Option<&str> {" ]# [ doc =  " #         unimplemented!()" ]# [ doc =  " #     }" ]# [ doc =  " # }" ]# [ doc =  " #" ]# [ doc =  " use serde::ser::{self, Serialize, Serializer};" ]# [ doc =  "" ]# [ doc =  " impl Serialize for Path {" ]# [ doc =  "     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>" ]# [ doc =  "     where" ]# [ doc =  "         S: Serializer," ]# [ doc =  "     {" ]# [ doc =  "         match self.to_str() {" ]# [ doc =  "             Some(s) => serializer.serialize_str(s)," ]# [ doc =  "             None => Err(ser::Error::custom(\\\"path contains invalid UTF-8 characters\\\"))," ]# [ doc =  "         }" ]# [ doc =  "     }" ]# [ doc =  " }" ]# [ doc =  " ```" ]# [ doc =  "" ]# [ doc =  " [`Path`]: https://doc.rust-lang.org/std/path/struct.Path.html" ]# [ doc =  " [`Serialize`]: ../trait.Serialize.html" ] fn  custom <  T > ( msg :  T )->  Self  where  T :  Display ; }}}
macro_rules! __ra_macro_fixture242 {($t :  ty , $($attr :  meta ),* )=>{$(# [$attr ])*  impl <  L ,  R >  AsRef <$t >  for  Either <  L ,  R >  where  L :  AsRef <$t >,  R :  AsRef <$t > { fn  as_ref (&  self )-> &$t { either ! (*  self ,  ref  inner => inner .  as_ref ())}}$(# [$attr ])*  impl <  L ,  R >  AsMut <$t >  for  Either <  L ,  R >  where  L :  AsMut <$t >,  R :  AsMut <$t > { fn  as_mut (&  mut  self )-> &  mut $t { either ! (*  self ,  ref  mut  inner => inner .  as_mut ())}}}; }
macro_rules! __ra_macro_fixture243 {($C :  ident $P :  ident ; $A :  ident , $($I :  ident ),* ; $($X :  ident )*)=>(# [ derive ( Clone ,  Debug )] pub  struct $C <  I :  Iterator > { item :  Option <  I ::  Item >,  iter :  I ,  c : $P <  I >, } impl <  I :  Iterator +  Clone >  From <  I >  for $C <  I > { fn  from ( mut  iter :  I )->  Self {$C { item :  iter .  next (),  iter :  iter .  clone (),  c : $P ::  from ( iter ), }}} impl <  I :  Iterator +  Clone >  From <  I >  for $C <  Fuse <  I >> { fn  from ( iter :  I )->  Self { let  mut  iter =  iter .  fuse (); $C { item :  iter .  next (),  iter :  iter .  clone (),  c : $P ::  from ( iter ), }}} impl <  I , $A >  Iterator  for $C <  I >  where  I :  Iterator <  Item = $A > +  Clone ,  I ::  Item :  Clone { type  Item = ($($I ),*);  fn  next (&  mut  self )->  Option <  Self ::  Item > { if  let  Some (($($X ),*,))=  self .  c .  next (){ let  z =  self .  item .  clone ().  unwrap ();  Some (( z , $($X ),*))} else { self .  item =  self .  iter .  next ();  self .  item .  clone ().  and_then (|  z | { self .  c = $P ::  from ( self .  iter .  clone ());  self .  c .  next ().  map (| ($($X ),*,)| ( z , $($X ),*))})}}} impl <  I , $A >  HasCombination <  I >  for ($($I ),*) where  I :  Iterator <  Item = $A > +  Clone ,  I ::  Item :  Clone { type  Combination = $C <  Fuse <  I >>; })}
macro_rules! __ra_macro_fixture244 (($_A :  ident , $_B :  ident , )=>(); ($A :  ident , $($B :  ident ,)*)=>( impl_cons_iter ! ($($B ,)*); # [ allow ( non_snake_case )] impl <  X ,  Iter , $($B ),*>  Iterator  for  ConsTuples <  Iter , (($($B ,)*),  X )>  where  Iter :  Iterator <  Item = (($($B ,)*),  X )>, { type  Item = ($($B ,)*  X , );  fn  next (&  mut  self )->  Option <  Self ::  Item > { self .  iter .  next ().  map (| (($($B ,)*),  x )| ($($B ,)*  x , ))} fn  size_hint (&  self )-> ( usize ,  Option <  usize >){ self .  iter .  size_hint ()} fn  fold <  Acc ,  Fold > ( self ,  accum :  Acc ,  mut  f :  Fold )->  Acc  where  Fold :  FnMut ( Acc ,  Self ::  Item )->  Acc , { self .  iter .  fold ( accum ,  move |  acc , (($($B ,)*),  x )|  f ( acc , ($($B ,)*  x , )))}}# [ allow ( non_snake_case )] impl <  X ,  Iter , $($B ),*>  DoubleEndedIterator  for  ConsTuples <  Iter , (($($B ,)*),  X )>  where  Iter :  DoubleEndedIterator <  Item = (($($B ,)*),  X )>, { fn  next_back (&  mut  self )->  Option <  Self ::  Item > { self .  iter .  next ().  map (| (($($B ,)*),  x )| ($($B ,)*  x , ))}}); );
macro_rules! __ra_macro_fixture245 {($($fmt_trait :  ident )*)=>{$(impl < 'a ,  I >  fmt ::$fmt_trait  for  Format < 'a ,  I >  where  I :  Iterator ,  I ::  Item :  fmt ::$fmt_trait , { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter )->  fmt ::  Result { self .  format ( f ,  fmt ::$fmt_trait ::  fmt )}})* }}
macro_rules! __ra_macro_fixture246 {([$($typarm :  tt )*]$type_ :  ty )=>{ impl <$($typarm )*>  PeekingNext  for $type_ { fn  peeking_next <  F > (&  mut  self ,  accept :  F )->  Option <  Self ::  Item >  where  F :  FnOnce (&  Self ::  Item )->  bool { let  saved_state =  self .  clone ();  if  let  Some ( r )=  self .  next (){ if !  accept (&  r ){*  self =  saved_state ; } else { return  Some ( r )}} None }}}}
macro_rules! __ra_macro_fixture247 {($dummy :  ident ,)=>{}; ($dummy :  ident , $($Y :  ident ,)*)=>( impl_tuple_collect ! ($($Y ,)*);  impl <  A >  TupleCollect  for ($(ignore_ident ! ($Y ,  A ),)*){ type  Item =  A ;  type  Buffer = [ Option <  A >;  count_ident ! ($($Y ,)*)-  1 ]; # [ allow ( unused_assignments ,  unused_mut )] fn  collect_from_iter <  I > ( iter :  I ,  buf : &  mut  Self ::  Buffer )->  Option <  Self >  where  I :  IntoIterator <  Item =  A >{ let  mut  iter =  iter .  into_iter (); $(let  mut $Y =  None ; )*  loop {$($Y =  iter .  next ();  if $Y .  is_none (){ break })*  return  Some (($($Y .  unwrap ()),*,))} let  mut  i =  0 ;  let  mut  s =  buf .  as_mut (); $(if  i <  s .  len (){ s [ i ]= $Y ;  i +=  1 ; })*  return  None ; } fn  collect_from_iter_no_buf <  I > ( iter :  I )->  Option <  Self >  where  I :  IntoIterator <  Item =  A >{ let  mut  iter =  iter .  into_iter ();  Some (($({let $Y =  iter .  next ()?; $Y }, )*))} fn  num_items ()->  usize { count_ident ! ($($Y ,)*)} fn  left_shift_push (&  mut  self ,  mut  item :  A ){ use  std ::  mem ::  replace ;  let &  mut ($(ref  mut $Y ),*,)=  self ;  macro_rules !  replace_item {($i :  ident )=>{ item =  replace ($i ,  item ); }};  rev_for_each_ident ! ( replace_item , $($Y ,)*);  drop ( item ); }})}
macro_rules! __ra_macro_fixture248 {($($B :  ident ),*)=>(# [ allow ( non_snake_case )] impl <$($B :  IntoIterator ),*>  From < ($($B ,)*)>  for  Zip < ($($B ::  IntoIter ,)*)> { fn  from ( t : ($($B ,)*))->  Self { let ($($B ,)*)=  t ;  Zip { t : ($($B .  into_iter (),)*)}}}# [ allow ( non_snake_case )]# [ allow ( unused_assignments )] impl <$($B ),*>  Iterator  for  Zip < ($($B ,)*)>  where $($B :  Iterator , )* { type  Item = ($($B ::  Item ,)*);  fn  next (&  mut  self )->  Option <  Self ::  Item > { let ($(ref  mut $B ,)*)=  self .  t ; $(let $B =  match $B .  next (){ None => return  None ,  Some ( elt )=> elt }; )*  Some (($($B ,)*))} fn  size_hint (&  self )-> ( usize ,  Option <  usize >){ let  sh = (::  std ::  usize ::  MAX ,  None );  let ($(ref $B ,)*)=  self .  t ; $(let  sh =  size_hint ::  min ($B .  size_hint (),  sh ); )*  sh }}# [ allow ( non_snake_case )] impl <$($B ),*>  ExactSizeIterator  for  Zip < ($($B ,)*)>  where $($B :  ExactSizeIterator , )* {}# [ allow ( non_snake_case )] impl <$($B ),*>  DoubleEndedIterator  for  Zip < ($($B ,)*)>  where $($B :  DoubleEndedIterator +  ExactSizeIterator , )* {# [ inline ] fn  next_back (&  mut  self )->  Option <  Self ::  Item > { let ($(ref  mut $B ,)*)=  self .  t ;  let  size = * [$($B .  len (), )*].  iter ().  min ().  unwrap (); $(if $B .  len ()!=  size { for _  in  0 ..$B .  len ()-  size {$B .  next_back (); }})*  match ($($B .  next_back (),)*){($(Some ($B ),)*)=> Some (($($B ,)*)), _ => None , }}}); }
macro_rules! __ra_macro_fixture249 {($iter :  ty =>$item :  ty ,  impl $($args :  tt )* )=>{ delegate_iterator ! {$iter =>$item ,  impl $($args )* } impl $($args )*  IndexedParallelIterator  for $iter { fn  drive <  C > ( self ,  consumer :  C )->  C ::  Result  where  C :  Consumer <  Self ::  Item > { self .  inner .  drive ( consumer )} fn  len (&  self )->  usize { self .  inner .  len ()} fn  with_producer <  CB > ( self ,  callback :  CB )->  CB ::  Output  where  CB :  ProducerCallback <  Self ::  Item > { self .  inner .  with_producer ( callback )}}}}
macro_rules! __ra_macro_fixture250 {($t :  ty =>$iter :  ident <$($i :  tt ),*>,  impl $($args :  tt )*)=>{ impl $($args )*  IntoParallelIterator  for $t { type  Item = <$t  as  IntoIterator >::  Item ;  type  Iter = $iter <$($i ),*>;  fn  into_par_iter ( self )->  Self ::  Iter { use  std ::  iter ::  FromIterator ; $iter { inner :  Vec ::  from_iter ( self ).  into_par_iter ()}}}}; }
macro_rules! __ra_macro_fixture251 {($iter :  ty =>$item :  ty ,  impl $($args :  tt )* )=>{ impl $($args )*  ParallelIterator  for $iter { type  Item = $item ;  fn  drive_unindexed <  C > ( self ,  consumer :  C )->  C ::  Result  where  C :  UnindexedConsumer <  Self ::  Item > { self .  inner .  drive_unindexed ( consumer )} fn  opt_len (&  self )->  Option <  usize > { self .  inner .  opt_len ()}}}}
macro_rules! __ra_macro_fixture252 {($($Tuple :  ident {$(($idx :  tt )-> $T :  ident )+ })+)=>{$(impl <$($T , )+>  IntoParallelIterator  for ($($T , )+) where $($T :  IntoParallelIterator , $T ::  Iter :  IndexedParallelIterator , )+ { type  Item = ($($T ::  Item , )+);  type  Iter =  MultiZip < ($($T ::  Iter , )+)>;  fn  into_par_iter ( self )->  Self ::  Iter { MultiZip { tuple : ($(self .$idx .  into_par_iter (), )+ ), }}} impl < 'a , $($T , )+>  IntoParallelIterator  for & 'a ($($T , )+) where $($T :  IntoParallelRefIterator < 'a >, $T ::  Iter :  IndexedParallelIterator , )+ { type  Item = ($($T ::  Item , )+);  type  Iter =  MultiZip < ($($T ::  Iter , )+)>;  fn  into_par_iter ( self )->  Self ::  Iter { MultiZip { tuple : ($(self .$idx .  par_iter (), )+ ), }}} impl < 'a , $($T , )+>  IntoParallelIterator  for & 'a  mut ($($T , )+) where $($T :  IntoParallelRefMutIterator < 'a >, $T ::  Iter :  IndexedParallelIterator , )+ { type  Item = ($($T ::  Item , )+);  type  Iter =  MultiZip < ($($T ::  Iter , )+)>;  fn  into_par_iter ( self )->  Self ::  Iter { MultiZip { tuple : ($(self .$idx .  par_iter_mut (), )+ ), }}} impl <$($T , )+>  ParallelIterator  for  MultiZip < ($($T , )+)>  where $($T :  IndexedParallelIterator , )+ { type  Item = ($($T ::  Item , )+);  fn  drive_unindexed <  CONSUMER > ( self ,  consumer :  CONSUMER )->  CONSUMER ::  Result  where  CONSUMER :  UnindexedConsumer <  Self ::  Item >, { self .  drive ( consumer )} fn  opt_len (&  self )->  Option <  usize > { Some ( self .  len ())}} impl <$($T , )+>  IndexedParallelIterator  for  MultiZip < ($($T , )+)>  where $($T :  IndexedParallelIterator , )+ { fn  drive <  CONSUMER > ( self ,  consumer :  CONSUMER )->  CONSUMER ::  Result  where  CONSUMER :  Consumer <  Self ::  Item >, { reduce ! ($(self .  tuple .$idx ),+ => IndexedParallelIterator ::  zip ).  map ( flatten ! ($($T ),+)).  drive ( consumer )} fn  len (&  self )->  usize { reduce ! ($(self .  tuple .$idx .  len ()),+ => Ord ::  min )} fn  with_producer <  CB > ( self ,  callback :  CB )->  CB ::  Output  where  CB :  ProducerCallback <  Self ::  Item >, { reduce ! ($(self .  tuple .$idx ),+ => IndexedParallelIterator ::  zip ).  map ( flatten ! ($($T ),+)).  with_producer ( callback )}})+ }}
macro_rules! __ra_macro_fixture253 {($t :  ty )=>{ impl  ParallelIterator  for  Iter <$t > { type  Item = $t ;  fn  drive_unindexed <  C > ( self ,  consumer :  C )->  C ::  Result  where  C :  UnindexedConsumer <  Self ::  Item >, { bridge ( self ,  consumer )} fn  opt_len (&  self )->  Option <  usize > { Some ( self .  len ())}} impl  IndexedParallelIterator  for  Iter <$t > { fn  drive <  C > ( self ,  consumer :  C )->  C ::  Result  where  C :  Consumer <  Self ::  Item >, { bridge ( self ,  consumer )} fn  len (&  self )->  usize { self .  range .  len ()} fn  with_producer <  CB > ( self ,  callback :  CB )->  CB ::  Output  where  CB :  ProducerCallback <  Self ::  Item >, { callback .  callback ( IterProducer { range :  self .  range })}} impl  Producer  for  IterProducer <$t > { type  Item = <  Range <$t >  as  Iterator >::  Item ;  type  IntoIter =  Range <$t >;  fn  into_iter ( self )->  Self ::  IntoIter { self .  range } fn  split_at ( self ,  index :  usize )-> ( Self ,  Self ){ assert ! ( index <=  self .  range .  len ());  let  mid =  self .  range .  start .  wrapping_add ( index  as $t );  let  left =  self .  range .  start ..  mid ;  let  right =  mid ..  self .  range .  end ; ( IterProducer { range :  left },  IterProducer { range :  right })}}}; }
macro_rules! __ra_macro_fixture254 {($t :  ty , $len_t :  ty )=>{ impl  UnindexedRangeLen <$len_t >  for  Range <$t > { fn  len (&  self )-> $len_t { let &  Range { start ,  end }=  self ;  if  end >  start { end .  wrapping_sub ( start ) as $len_t } else { 0 }}} impl  ParallelIterator  for  Iter <$t > { type  Item = $t ;  fn  drive_unindexed <  C > ( self ,  consumer :  C )->  C ::  Result  where  C :  UnindexedConsumer <  Self ::  Item >, {# [ inline ] fn  offset ( start : $t )->  impl  Fn ( usize )-> $t { move |  i |  start .  wrapping_add ( i  as $t )} if  let  Some ( len )=  self .  opt_len (){( 0 ..  len ).  into_par_iter ().  map ( offset ( self .  range .  start )).  drive ( consumer )} else { bridge_unindexed ( IterProducer { range :  self .  range },  consumer )}} fn  opt_len (&  self )->  Option <  usize > { let  len =  self .  range .  len ();  if  len <=  usize ::  MAX  as $len_t { Some ( len  as  usize )} else { None }}} impl  UnindexedProducer  for  IterProducer <$t > { type  Item = $t ;  fn  split ( mut  self )-> ( Self ,  Option <  Self >){ let  index =  self .  range .  len ()/  2 ;  if  index >  0 { let  mid =  self .  range .  start .  wrapping_add ( index  as $t );  let  right =  mid ..  self .  range .  end ;  self .  range .  end =  mid ; ( self ,  Some ( IterProducer { range :  right }))} else {( self ,  None )}} fn  fold_with <  F > ( self ,  folder :  F )->  F  where  F :  Folder <  Self ::  Item >, { folder .  consume_iter ( self )}}}; }
macro_rules! __ra_macro_fixture255 {($t :  ty )=>{ parallel_range_impl ! {$t } impl  IndexedParallelIterator  for  Iter <$t > { fn  drive <  C > ( self ,  consumer :  C )->  C ::  Result  where  C :  Consumer <  Self ::  Item >, { convert ! ( self .  drive ( consumer ))} fn  len (&  self )->  usize { self .  range .  len ()} fn  with_producer <  CB > ( self ,  callback :  CB )->  CB ::  Output  where  CB :  ProducerCallback <  Self ::  Item >, { convert ! ( self .  with_producer ( callback ))}}}; }
macro_rules! __ra_macro_fixture256 {($t :  ty )=>{ impl  ParallelIterator  for  Iter <$t > { type  Item = $t ;  fn  drive_unindexed <  C > ( self ,  consumer :  C )->  C ::  Result  where  C :  UnindexedConsumer <  Self ::  Item >, { convert ! ( self .  drive_unindexed ( consumer ))} fn  opt_len (&  self )->  Option <  usize > { convert ! ( self .  opt_len ())}}}; }
macro_rules! __ra_macro_fixture257 {($f :  ident , $name :  ident )=>{# [ test ] fn $name (){ let  mut  rng =  thread_rng ();  for  len  in ( 0 ..  25 ).  chain ( 500 ..  501 ){ for &  modulus  in & [ 5 ,  10 ,  100 ]{ let  dist =  Uniform ::  new ( 0 ,  modulus );  for _  in  0 ..  100 { let  v :  Vec <  i32 > =  rng .  sample_iter (&  dist ).  take ( len ).  collect ();  let  mut  tmp =  v .  clone ();  tmp .$f (|  a ,  b |  a .  cmp ( b ));  assert ! ( tmp .  windows ( 2 ).  all (|  w |  w [ 0 ]<=  w [ 1 ]));  let  mut  tmp =  v .  clone ();  tmp .$f (|  a ,  b |  b .  cmp ( a ));  assert ! ( tmp .  windows ( 2 ).  all (|  w |  w [ 0 ]>=  w [ 1 ])); }}} for &  len  in & [ 1_000 ,  10_000 ,  100_000 ]{ for &  modulus  in & [ 5 ,  10 ,  100 ,  10_000 ]{ let  dist =  Uniform ::  new ( 0 ,  modulus );  let  mut  v :  Vec <  i32 > =  rng .  sample_iter (&  dist ).  take ( len ).  collect ();  v .$f (|  a ,  b |  a .  cmp ( b ));  assert ! ( v .  windows ( 2 ).  all (|  w |  w [ 0 ]<=  w [ 1 ])); }} for &  len  in & [ 1_000 ,  10_000 ,  100_000 ]{ let  len_dist =  Uniform ::  new ( 0 ,  len );  for &  modulus  in & [ 5 ,  10 ,  1000 ,  50_000 ]{ let  dist =  Uniform ::  new ( 0 ,  modulus );  let  mut  v :  Vec <  i32 > =  rng .  sample_iter (&  dist ).  take ( len ).  collect ();  v .  sort ();  v .  reverse ();  for _  in  0 ..  5 { let  a =  rng .  sample (&  len_dist );  let  b =  rng .  sample (&  len_dist );  if  a <  b { v [ a ..  b ].  reverse (); } else { v .  swap ( a ,  b ); }} v .$f (|  a ,  b |  a .  cmp ( b ));  assert ! ( v .  windows ( 2 ).  all (|  w |  w [ 0 ]<=  w [ 1 ])); }} let  mut  v :  Vec <_> = ( 0 ..  100 ).  collect ();  v .$f (|_, _| * [ Less ,  Equal ,  Greater ].  choose (&  mut  thread_rng ()).  unwrap ());  v .$f (|  a ,  b |  a .  cmp ( b ));  for  i  in  0 ..  v .  len (){ assert_eq ! ( v [ i ],  i ); }[ 0i32 ;  0 ].$f (|  a ,  b |  a .  cmp ( b )); [();  10 ].$f (|  a ,  b |  a .  cmp ( b )); [();  100 ].$f (|  a ,  b |  a .  cmp ( b ));  let  mut  v = [ 0xDEAD_BEEFu64 ];  v .$f (|  a ,  b |  a .  cmp ( b ));  assert ! ( v == [ 0xDEAD_BEEF ]); }}; }
macro_rules! __ra_macro_fixture258 {($($name :  ident # [$expr :  meta ])*)=>{$(# [ doc =  " First sanity check that the expression is OK." ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " #![deny(unused_must_use)]" ]# [ doc =  "" ]# [ doc =  " use rayon::prelude::*;" ]# [ doc =  "" ]# [ doc =  " let v: Vec<_> = (0..100).map(Some).collect();" ]# [ doc =  " let _ =" ]# [$expr ]# [ doc =  " ```" ]# [ doc =  "" ]# [ doc =  " Now trigger the `must_use`." ]# [ doc =  "" ]# [ doc =  " ```compile_fail" ]# [ doc =  " #![deny(unused_must_use)]" ]# [ doc =  "" ]# [ doc =  " use rayon::prelude::*;" ]# [ doc =  "" ]# [ doc =  " let v: Vec<_> = (0..100).map(Some).collect();" ]# [$expr ]# [ doc =  " ```" ] mod $name {})*}}
macro_rules! __ra_macro_fixture259 {($name :  ident : $style :  expr ; $input :  expr =>$result :  expr )=>{# [ test ] fn $name (){ assert_eq ! ($style .  paint ($input ).  to_string (), $result .  to_string ());  let  mut  v =  Vec ::  new (); $style .  paint ($input .  as_bytes ()).  write_to (&  mut  v ).  unwrap ();  assert_eq ! ( v .  as_slice (), $result .  as_bytes ()); }}; }
macro_rules! __ra_macro_fixture260 {($name :  ident : $first :  expr ; $next :  expr =>$result :  expr )=>{# [ test ] fn $name (){ assert_eq ! ($result ,  Difference ::  between (&$first , &$next )); }}; }
macro_rules! __ra_macro_fixture261 {($name :  ident : $obj :  expr =>$result :  expr )=>{# [ test ] fn $name (){ assert_eq ! ($result ,  format ! ( "{:?}" , $obj )); }}; }
macro_rules! __ra_macro_fixture262 {($name :  ident , $ty_int :  ty , $max :  expr , $bytes :  expr , $read :  ident , $write :  ident )=>{ mod $name {# [ allow ( unused_imports )] use  super :: { qc_sized ,  Wi128 };  use  crate :: { BigEndian ,  ByteOrder ,  LittleEndian ,  NativeEndian , }; # [ test ] fn  big_endian (){ fn  prop ( n : $ty_int )->  bool { let  mut  buf = [ 0 ;  16 ];  BigEndian ::$write (&  mut  buf ,  n .  clone (), $bytes );  n ==  BigEndian ::$read (&  buf [..$bytes ], $bytes )} qc_sized ( prop  as  fn ($ty_int )->  bool , $max ); }# [ test ] fn  little_endian (){ fn  prop ( n : $ty_int )->  bool { let  mut  buf = [ 0 ;  16 ];  LittleEndian ::$write (&  mut  buf ,  n .  clone (), $bytes );  n ==  LittleEndian ::$read (&  buf [..$bytes ], $bytes )} qc_sized ( prop  as  fn ($ty_int )->  bool , $max ); }# [ test ] fn  native_endian (){ fn  prop ( n : $ty_int )->  bool { let  mut  buf = [ 0 ;  16 ];  NativeEndian ::$write (&  mut  buf ,  n .  clone (), $bytes );  n ==  NativeEndian ::$read (&  buf [..$bytes ], $bytes )} qc_sized ( prop  as  fn ($ty_int )->  bool , $max ); }}}; ($name :  ident , $ty_int :  ty , $max :  expr , $read :  ident , $write :  ident )=>{ mod $name {# [ allow ( unused_imports )] use  super :: { qc_sized ,  Wi128 };  use  crate :: { BigEndian ,  ByteOrder ,  LittleEndian ,  NativeEndian , };  use  core ::  mem ::  size_of ; # [ test ] fn  big_endian (){ fn  prop ( n : $ty_int )->  bool { let  bytes =  size_of ::<$ty_int > ();  let  mut  buf = [ 0 ;  16 ];  BigEndian ::$write (&  mut  buf [ 16 -  bytes ..],  n .  clone ());  n ==  BigEndian ::$read (&  buf [ 16 -  bytes ..])} qc_sized ( prop  as  fn ($ty_int )->  bool , $max -  1 ); }# [ test ] fn  little_endian (){ fn  prop ( n : $ty_int )->  bool { let  bytes =  size_of ::<$ty_int > ();  let  mut  buf = [ 0 ;  16 ];  LittleEndian ::$write (&  mut  buf [..  bytes ],  n .  clone ());  n ==  LittleEndian ::$read (&  buf [..  bytes ])} qc_sized ( prop  as  fn ($ty_int )->  bool , $max -  1 ); }# [ test ] fn  native_endian (){ fn  prop ( n : $ty_int )->  bool { let  bytes =  size_of ::<$ty_int > ();  let  mut  buf = [ 0 ;  16 ];  NativeEndian ::$write (&  mut  buf [..  bytes ],  n .  clone ());  n ==  NativeEndian ::$read (&  buf [..  bytes ])} qc_sized ( prop  as  fn ($ty_int )->  bool , $max -  1 ); }}}; }
macro_rules! __ra_macro_fixture263 {($name :  ident , $maximally_small :  expr , $zero :  expr , $read :  ident , $write :  ident )=>{ mod $name { use  crate :: { BigEndian ,  ByteOrder ,  LittleEndian ,  NativeEndian , }; # [ test ]# [ should_panic ] fn  read_big_endian (){ let  buf = [ 0 ; $maximally_small ];  BigEndian ::$read (&  buf ); }# [ test ]# [ should_panic ] fn  read_little_endian (){ let  buf = [ 0 ; $maximally_small ];  LittleEndian ::$read (&  buf ); }# [ test ]# [ should_panic ] fn  read_native_endian (){ let  buf = [ 0 ; $maximally_small ];  NativeEndian ::$read (&  buf ); }# [ test ]# [ should_panic ] fn  write_big_endian (){ let  mut  buf = [ 0 ; $maximally_small ];  BigEndian ::$write (&  mut  buf , $zero ); }# [ test ]# [ should_panic ] fn  write_little_endian (){ let  mut  buf = [ 0 ; $maximally_small ];  LittleEndian ::$write (&  mut  buf , $zero ); }# [ test ]# [ should_panic ] fn  write_native_endian (){ let  mut  buf = [ 0 ; $maximally_small ];  NativeEndian ::$write (&  mut  buf , $zero ); }}}; ($name :  ident , $maximally_small :  expr , $read :  ident )=>{ mod $name { use  crate :: { BigEndian ,  ByteOrder ,  LittleEndian ,  NativeEndian , }; # [ test ]# [ should_panic ] fn  read_big_endian (){ let  buf = [ 0 ; $maximally_small ];  BigEndian ::$read (&  buf , $maximally_small +  1 ); }# [ test ]# [ should_panic ] fn  read_little_endian (){ let  buf = [ 0 ; $maximally_small ];  LittleEndian ::$read (&  buf , $maximally_small +  1 ); }# [ test ]# [ should_panic ] fn  read_native_endian (){ let  buf = [ 0 ; $maximally_small ];  NativeEndian ::$read (&  buf , $maximally_small +  1 ); }}}; }
macro_rules! __ra_macro_fixture264 {($name :  ident , $read :  ident , $write :  ident , $num_bytes :  expr , $numbers :  expr )=>{ mod $name { use  crate :: { BigEndian ,  ByteOrder ,  LittleEndian ,  NativeEndian , }; # [ test ]# [ should_panic ] fn  read_big_endian (){ let  bytes = [ 0 ; $num_bytes ];  let  mut  numbers = $numbers ;  BigEndian ::$read (&  bytes , &  mut  numbers ); }# [ test ]# [ should_panic ] fn  read_little_endian (){ let  bytes = [ 0 ; $num_bytes ];  let  mut  numbers = $numbers ;  LittleEndian ::$read (&  bytes , &  mut  numbers ); }# [ test ]# [ should_panic ] fn  read_native_endian (){ let  bytes = [ 0 ; $num_bytes ];  let  mut  numbers = $numbers ;  NativeEndian ::$read (&  bytes , &  mut  numbers ); }# [ test ]# [ should_panic ] fn  write_big_endian (){ let  mut  bytes = [ 0 ; $num_bytes ];  let  numbers = $numbers ;  BigEndian ::$write (&  numbers , &  mut  bytes ); }# [ test ]# [ should_panic ] fn  write_little_endian (){ let  mut  bytes = [ 0 ; $num_bytes ];  let  numbers = $numbers ;  LittleEndian ::$write (&  numbers , &  mut  bytes ); }# [ test ]# [ should_panic ] fn  write_native_endian (){ let  mut  bytes = [ 0 ; $num_bytes ];  let  numbers = $numbers ;  NativeEndian ::$write (&  numbers , &  mut  bytes ); }}}; }
macro_rules! __ra_macro_fixture265 {($name :  ident , $which :  ident , $re :  expr )=>{ test_lit ! ($name , $which , $re ,); }; ($name :  ident , $which :  ident , $re :  expr , $($lit :  expr ),*)=>{# [ test ] fn $name (){ let  expr =  ParserBuilder ::  new ().  build ().  parse ($re ).  unwrap ();  let  lits =  Literals ::$which (&  expr );  assert_lit_eq ! ( Unicode ,  lits , $($lit ),*);  let  expr =  ParserBuilder ::  new ().  allow_invalid_utf8 ( true ).  unicode ( false ).  build ().  parse ($re ).  unwrap ();  let  lits =  Literals ::$which (&  expr );  assert_lit_eq ! ( Bytes ,  lits , $($lit ),*); }}; }
macro_rules! __ra_macro_fixture266 {($name :  ident , $which :  ident , $re :  expr )=>{ test_exhausted ! ($name , $which , $re ,); }; ($name :  ident , $which :  ident , $re :  expr , $($lit :  expr ),*)=>{# [ test ] fn $name (){ let  expr =  ParserBuilder ::  new ().  build ().  parse ($re ).  unwrap ();  let  mut  lits =  Literals ::  empty ();  lits .  set_limit_size ( 20 ).  set_limit_class ( 10 ); $which (&  mut  lits , &  expr );  assert_lit_eq ! ( Unicode ,  lits , $($lit ),*);  let  expr =  ParserBuilder ::  new ().  allow_invalid_utf8 ( true ).  unicode ( false ).  build ().  parse ($re ).  unwrap ();  let  mut  lits =  Literals ::  empty ();  lits .  set_limit_size ( 20 ).  set_limit_class ( 10 ); $which (&  mut  lits , &  expr );  assert_lit_eq ! ( Bytes ,  lits , $($lit ),*); }}; }
macro_rules! __ra_macro_fixture267 {($name :  ident , $given :  expr , $expected :  expr )=>{# [ test ] fn $name (){ let  given :  Vec <  Literal > = $given .  into_iter ().  map (|  ul | { let  cut =  ul .  is_cut ();  Literal { v :  ul .  v .  into_bytes (),  cut :  cut }}).  collect ();  let  lits =  create_lits ( given );  let  got =  lits .  unambiguous_prefixes ();  assert_eq ! ($expected ,  escape_lits ( got .  literals ())); }}; }
macro_rules! __ra_macro_fixture268 {($name :  ident , $trim :  expr , $given :  expr , $expected :  expr )=>{# [ test ] fn $name (){ let  given :  Vec <  Literal > = $given .  into_iter ().  map (|  ul | { let  cut =  ul .  is_cut ();  Literal { v :  ul .  v .  into_bytes (),  cut :  cut }}).  collect ();  let  lits =  create_lits ( given );  let  got =  lits .  trim_suffix ($trim ).  unwrap ();  assert_eq ! ($expected ,  escape_lits ( got .  literals ())); }}; }
macro_rules! __ra_macro_fixture269 {($name :  ident , $given :  expr , $expected :  expr )=>{# [ test ] fn $name (){ let  given :  Vec <  Literal > = $given .  into_iter ().  map (|  s : &  str |  Literal { v :  s .  to_owned ().  into_bytes (),  cut :  false , }).  collect ();  let  lits =  create_lits ( given );  let  got =  lits .  longest_common_prefix ();  assert_eq ! ($expected ,  escape_bytes ( got )); }}; }
macro_rules! __ra_macro_fixture270 {($name :  ident , $given :  expr , $expected :  expr )=>{# [ test ] fn $name (){ let  given :  Vec <  Literal > = $given .  into_iter ().  map (|  s : &  str |  Literal { v :  s .  to_owned ().  into_bytes (),  cut :  false , }).  collect ();  let  lits =  create_lits ( given );  let  got =  lits .  longest_common_suffix ();  assert_eq ! ($expected ,  escape_bytes ( got )); }}; }
macro_rules! __ra_macro_fixture271 {($name :  ident , $text :  expr )=>{# [ test ] fn $name (){ assert_eq ! ( None ,  find_cap_ref ($text .  as_bytes ())); }}; ($name :  ident , $text :  expr , $capref :  expr )=>{# [ test ] fn $name (){ assert_eq ! ( Some ($capref ),  find_cap_ref ($text .  as_bytes ())); }}; }
macro_rules! __ra_macro_fixture272 {($name :  ident , $regex_mod :  ident , $only_utf8 :  expr )=>{ pub  mod $name { use  super ::  RegexOptions ;  use  error ::  Error ;  use  exec ::  ExecBuilder ;  use $regex_mod ::  Regex ; # [ doc =  " A configurable builder for a regular expression." ]# [ doc =  "" ]# [ doc =  " A builder can be used to configure how the regex is built, for example, by" ]# [ doc =  " setting the default flags (which can be overridden in the expression" ]# [ doc =  " itself) or setting various limits." ]# [ derive ( Debug )] pub  struct  RegexBuilder ( RegexOptions );  impl  RegexBuilder {# [ doc =  " Create a new regular expression builder with the given pattern." ]# [ doc =  "" ]# [ doc =  " If the pattern is invalid, then an error will be returned when" ]# [ doc =  " `build` is called." ] pub  fn  new ( pattern : &  str )->  RegexBuilder { let  mut  builder =  RegexBuilder ( RegexOptions ::  default ());  builder .  0 .  pats .  push ( pattern .  to_owned ());  builder }# [ doc =  " Consume the builder and compile the regular expression." ]# [ doc =  "" ]# [ doc =  " Note that calling `as_str` on the resulting `Regex` will produce the" ]# [ doc =  " pattern given to `new` verbatim. Notably, it will not incorporate any" ]# [ doc =  " of the flags set on this builder." ] pub  fn  build (&  self )->  Result <  Regex ,  Error > { ExecBuilder ::  new_options ( self .  0 .  clone ()).  only_utf8 ($only_utf8 ).  build ().  map ( Regex ::  from )}# [ doc =  " Set the value for the case insensitive (`i`) flag." ]# [ doc =  "" ]# [ doc =  " When enabled, letters in the pattern will match both upper case and" ]# [ doc =  " lower case variants." ] pub  fn  case_insensitive (&  mut  self ,  yes :  bool , )-> &  mut  RegexBuilder { self .  0 .  case_insensitive =  yes ;  self }# [ doc =  " Set the value for the multi-line matching (`m`) flag." ]# [ doc =  "" ]# [ doc =  " When enabled, `^` matches the beginning of lines and `$` matches the" ]# [ doc =  " end of lines." ]# [ doc =  "" ]# [ doc =  " By default, they match beginning/end of the input." ] pub  fn  multi_line (&  mut  self ,  yes :  bool )-> &  mut  RegexBuilder { self .  0 .  multi_line =  yes ;  self }# [ doc =  " Set the value for the any character (`s`) flag, where in `.` matches" ]# [ doc =  " anything when `s` is set and matches anything except for new line when" ]# [ doc =  " it is not set (the default)." ]# [ doc =  "" ]# [ doc =  " N.B. \\\"matches anything\\\" means \\\"any byte\\\" when Unicode is disabled and" ]# [ doc =  " means \\\"any valid UTF-8 encoding of any Unicode scalar value\\\" when" ]# [ doc =  " Unicode is enabled." ] pub  fn  dot_matches_new_line (&  mut  self ,  yes :  bool , )-> &  mut  RegexBuilder { self .  0 .  dot_matches_new_line =  yes ;  self }# [ doc =  " Set the value for the greedy swap (`U`) flag." ]# [ doc =  "" ]# [ doc =  " When enabled, a pattern like `a*` is lazy (tries to find shortest" ]# [ doc =  " match) and `a*?` is greedy (tries to find longest match)." ]# [ doc =  "" ]# [ doc =  " By default, `a*` is greedy and `a*?` is lazy." ] pub  fn  swap_greed (&  mut  self ,  yes :  bool )-> &  mut  RegexBuilder { self .  0 .  swap_greed =  yes ;  self }# [ doc =  " Set the value for the ignore whitespace (`x`) flag." ]# [ doc =  "" ]# [ doc =  " When enabled, whitespace such as new lines and spaces will be ignored" ]# [ doc =  " between expressions of the pattern, and `#` can be used to start a" ]# [ doc =  " comment until the next new line." ] pub  fn  ignore_whitespace (&  mut  self ,  yes :  bool , )-> &  mut  RegexBuilder { self .  0 .  ignore_whitespace =  yes ;  self }# [ doc =  " Set the value for the Unicode (`u`) flag." ]# [ doc =  "" ]# [ doc =  " Enabled by default. When disabled, character classes such as `\\\\w` only" ]# [ doc =  " match ASCII word characters instead of all Unicode word characters." ] pub  fn  unicode (&  mut  self ,  yes :  bool )-> &  mut  RegexBuilder { self .  0 .  unicode =  yes ;  self }# [ doc =  " Whether to support octal syntax or not." ]# [ doc =  "" ]# [ doc =  " Octal syntax is a little-known way of uttering Unicode codepoints in" ]# [ doc =  " a regular expression. For example, `a`, `\\\\x61`, `\\\\u0061` and" ]# [ doc =  " `\\\\141` are all equivalent regular expressions, where the last example" ]# [ doc =  " shows octal syntax." ]# [ doc =  "" ]# [ doc =  " While supporting octal syntax isn\\\'t in and of itself a problem, it does" ]# [ doc =  " make good error messages harder. That is, in PCRE based regex engines," ]# [ doc =  " syntax like `\\\\0` invokes a backreference, which is explicitly" ]# [ doc =  " unsupported in Rust\\\'s regex engine. However, many users expect it to" ]# [ doc =  " be supported. Therefore, when octal support is disabled, the error" ]# [ doc =  " message will explicitly mention that backreferences aren\\\'t supported." ]# [ doc =  "" ]# [ doc =  " Octal syntax is disabled by default." ] pub  fn  octal (&  mut  self ,  yes :  bool )-> &  mut  RegexBuilder { self .  0 .  octal =  yes ;  self }# [ doc =  " Set the approximate size limit of the compiled regular expression." ]# [ doc =  "" ]# [ doc =  " This roughly corresponds to the number of bytes occupied by a single" ]# [ doc =  " compiled program. If the program exceeds this number, then a" ]# [ doc =  " compilation error is returned." ] pub  fn  size_limit (&  mut  self ,  limit :  usize , )-> &  mut  RegexBuilder { self .  0 .  size_limit =  limit ;  self }# [ doc =  " Set the approximate size of the cache used by the DFA." ]# [ doc =  "" ]# [ doc =  " This roughly corresponds to the number of bytes that the DFA will" ]# [ doc =  " use while searching." ]# [ doc =  "" ]# [ doc =  " Note that this is a *per thread* limit. There is no way to set a global" ]# [ doc =  " limit. In particular, if a regex is used from multiple threads" ]# [ doc =  " simultaneously, then each thread may use up to the number of bytes" ]# [ doc =  " specified here." ] pub  fn  dfa_size_limit (&  mut  self ,  limit :  usize , )-> &  mut  RegexBuilder { self .  0 .  dfa_size_limit =  limit ;  self }# [ doc =  " Set the nesting limit for this parser." ]# [ doc =  "" ]# [ doc =  " The nesting limit controls how deep the abstract syntax tree is allowed" ]# [ doc =  " to be. If the AST exceeds the given limit (e.g., with too many nested" ]# [ doc =  " groups), then an error is returned by the parser." ]# [ doc =  "" ]# [ doc =  " The purpose of this limit is to act as a heuristic to prevent stack" ]# [ doc =  " overflow for consumers that do structural induction on an `Ast` using" ]# [ doc =  " explicit recursion. While this crate never does this (instead using" ]# [ doc =  " constant stack space and moving the call stack to the heap), other" ]# [ doc =  " crates may." ]# [ doc =  "" ]# [ doc =  " This limit is not checked until the entire Ast is parsed. Therefore," ]# [ doc =  " if callers want to put a limit on the amount of heap space used, then" ]# [ doc =  " they should impose a limit on the length, in bytes, of the concrete" ]# [ doc =  " pattern string. In particular, this is viable since this parser" ]# [ doc =  " implementation will limit itself to heap space proportional to the" ]# [ doc =  " length of the pattern string." ]# [ doc =  "" ]# [ doc =  " Note that a nest limit of `0` will return a nest limit error for most" ]# [ doc =  " patterns but not all. For example, a nest limit of `0` permits `a` but" ]# [ doc =  " not `ab`, since `ab` requires a concatenation, which results in a nest" ]# [ doc =  " depth of `1`. In general, a nest limit is not something that manifests" ]# [ doc =  " in an obvious way in the concrete syntax, therefore, it should not be" ]# [ doc =  " used in a granular way." ] pub  fn  nest_limit (&  mut  self ,  limit :  u32 )-> &  mut  RegexBuilder { self .  0 .  nest_limit =  limit ;  self }}}}; }
macro_rules! __ra_macro_fixture273 {($name :  ident , $regex_mod :  ident , $only_utf8 :  expr )=>{ pub  mod $name { use  super ::  RegexOptions ;  use  error ::  Error ;  use  exec ::  ExecBuilder ;  use  re_set ::$regex_mod ::  RegexSet ; # [ doc =  " A configurable builder for a set of regular expressions." ]# [ doc =  "" ]# [ doc =  " A builder can be used to configure how the regexes are built, for example," ]# [ doc =  " by setting the default flags (which can be overridden in the expression" ]# [ doc =  " itself) or setting various limits." ]# [ derive ( Debug )] pub  struct  RegexSetBuilder ( RegexOptions );  impl  RegexSetBuilder {# [ doc =  " Create a new regular expression builder with the given pattern." ]# [ doc =  "" ]# [ doc =  " If the pattern is invalid, then an error will be returned when" ]# [ doc =  " `build` is called." ] pub  fn  new <  I ,  S > ( patterns :  I )->  RegexSetBuilder  where  S :  AsRef <  str >,  I :  IntoIterator <  Item =  S >, { let  mut  builder =  RegexSetBuilder ( RegexOptions ::  default ());  for  pat  in  patterns { builder .  0 .  pats .  push ( pat .  as_ref ().  to_owned ()); } builder }# [ doc =  " Consume the builder and compile the regular expressions into a set." ] pub  fn  build (&  self )->  Result <  RegexSet ,  Error > { ExecBuilder ::  new_options ( self .  0 .  clone ()).  only_utf8 ($only_utf8 ).  build ().  map ( RegexSet ::  from )}# [ doc =  " Set the value for the case insensitive (`i`) flag." ] pub  fn  case_insensitive (&  mut  self ,  yes :  bool , )-> &  mut  RegexSetBuilder { self .  0 .  case_insensitive =  yes ;  self }# [ doc =  " Set the value for the multi-line matching (`m`) flag." ] pub  fn  multi_line (&  mut  self ,  yes :  bool , )-> &  mut  RegexSetBuilder { self .  0 .  multi_line =  yes ;  self }# [ doc =  " Set the value for the any character (`s`) flag, where in `.` matches" ]# [ doc =  " anything when `s` is set and matches anything except for new line when" ]# [ doc =  " it is not set (the default)." ]# [ doc =  "" ]# [ doc =  " N.B. \\\"matches anything\\\" means \\\"any byte\\\" for `regex::bytes::RegexSet`" ]# [ doc =  " expressions and means \\\"any Unicode scalar value\\\" for `regex::RegexSet`" ]# [ doc =  " expressions." ] pub  fn  dot_matches_new_line (&  mut  self ,  yes :  bool , )-> &  mut  RegexSetBuilder { self .  0 .  dot_matches_new_line =  yes ;  self }# [ doc =  " Set the value for the greedy swap (`U`) flag." ] pub  fn  swap_greed (&  mut  self ,  yes :  bool , )-> &  mut  RegexSetBuilder { self .  0 .  swap_greed =  yes ;  self }# [ doc =  " Set the value for the ignore whitespace (`x`) flag." ] pub  fn  ignore_whitespace (&  mut  self ,  yes :  bool , )-> &  mut  RegexSetBuilder { self .  0 .  ignore_whitespace =  yes ;  self }# [ doc =  " Set the value for the Unicode (`u`) flag." ] pub  fn  unicode (&  mut  self ,  yes :  bool )-> &  mut  RegexSetBuilder { self .  0 .  unicode =  yes ;  self }# [ doc =  " Whether to support octal syntax or not." ]# [ doc =  "" ]# [ doc =  " Octal syntax is a little-known way of uttering Unicode codepoints in" ]# [ doc =  " a regular expression. For example, `a`, `\\\\x61`, `\\\\u0061` and" ]# [ doc =  " `\\\\141` are all equivalent regular expressions, where the last example" ]# [ doc =  " shows octal syntax." ]# [ doc =  "" ]# [ doc =  " While supporting octal syntax isn\\\'t in and of itself a problem, it does" ]# [ doc =  " make good error messages harder. That is, in PCRE based regex engines," ]# [ doc =  " syntax like `\\\\0` invokes a backreference, which is explicitly" ]# [ doc =  " unsupported in Rust\\\'s regex engine. However, many users expect it to" ]# [ doc =  " be supported. Therefore, when octal support is disabled, the error" ]# [ doc =  " message will explicitly mention that backreferences aren\\\'t supported." ]# [ doc =  "" ]# [ doc =  " Octal syntax is disabled by default." ] pub  fn  octal (&  mut  self ,  yes :  bool )-> &  mut  RegexSetBuilder { self .  0 .  octal =  yes ;  self }# [ doc =  " Set the approximate size limit of the compiled regular expression." ]# [ doc =  "" ]# [ doc =  " This roughly corresponds to the number of bytes occupied by a single" ]# [ doc =  " compiled program. If the program exceeds this number, then a" ]# [ doc =  " compilation error is returned." ] pub  fn  size_limit (&  mut  self ,  limit :  usize , )-> &  mut  RegexSetBuilder { self .  0 .  size_limit =  limit ;  self }# [ doc =  " Set the approximate size of the cache used by the DFA." ]# [ doc =  "" ]# [ doc =  " This roughly corresponds to the number of bytes that the DFA will" ]# [ doc =  " use while searching." ]# [ doc =  "" ]# [ doc =  " Note that this is a *per thread* limit. There is no way to set a global" ]# [ doc =  " limit. In particular, if a regex is used from multiple threads" ]# [ doc =  " simultaneously, then each thread may use up to the number of bytes" ]# [ doc =  " specified here." ] pub  fn  dfa_size_limit (&  mut  self ,  limit :  usize , )-> &  mut  RegexSetBuilder { self .  0 .  dfa_size_limit =  limit ;  self }# [ doc =  " Set the nesting limit for this parser." ]# [ doc =  "" ]# [ doc =  " The nesting limit controls how deep the abstract syntax tree is allowed" ]# [ doc =  " to be. If the AST exceeds the given limit (e.g., with too many nested" ]# [ doc =  " groups), then an error is returned by the parser." ]# [ doc =  "" ]# [ doc =  " The purpose of this limit is to act as a heuristic to prevent stack" ]# [ doc =  " overflow for consumers that do structural induction on an `Ast` using" ]# [ doc =  " explicit recursion. While this crate never does this (instead using" ]# [ doc =  " constant stack space and moving the call stack to the heap), other" ]# [ doc =  " crates may." ]# [ doc =  "" ]# [ doc =  " This limit is not checked until the entire Ast is parsed. Therefore," ]# [ doc =  " if callers want to put a limit on the amount of heap space used, then" ]# [ doc =  " they should impose a limit on the length, in bytes, of the concrete" ]# [ doc =  " pattern string. In particular, this is viable since this parser" ]# [ doc =  " implementation will limit itself to heap space proportional to the" ]# [ doc =  " length of the pattern string." ]# [ doc =  "" ]# [ doc =  " Note that a nest limit of `0` will return a nest limit error for most" ]# [ doc =  " patterns but not all. For example, a nest limit of `0` permits `a` but" ]# [ doc =  " not `ab`, since `ab` requires a concatenation, which results in a nest" ]# [ doc =  " depth of `1`. In general, a nest limit is not something that manifests" ]# [ doc =  " in an obvious way in the concrete syntax, therefore, it should not be" ]# [ doc =  " used in a granular way." ] pub  fn  nest_limit (&  mut  self ,  limit :  u32 , )-> &  mut  RegexSetBuilder { self .  0 .  nest_limit =  limit ;  self }}}}; }
macro_rules! __ra_macro_fixture274 {($name :  ident , $builder_mod :  ident , $text_ty :  ty , $as_bytes :  expr , $(# [$doc_regexset_example :  meta ])* )=>{ pub  mod $name { use  std ::  fmt ;  use  std ::  iter ;  use  std ::  slice ;  use  std ::  vec ;  use  error ::  Error ;  use  exec ::  Exec ;  use  re_builder ::$builder_mod ::  RegexSetBuilder ;  use  re_trait ::  RegularExpression ; # [ doc =  " Match multiple (possibly overlapping) regular expressions in a single scan." ]# [ doc =  "" ]# [ doc =  " A regex set corresponds to the union of two or more regular expressions." ]# [ doc =  " That is, a regex set will match text where at least one of its" ]# [ doc =  " constituent regular expressions matches. A regex set as its formulated here" ]# [ doc =  " provides a touch more power: it will also report *which* regular" ]# [ doc =  " expressions in the set match. Indeed, this is the key difference between" ]# [ doc =  " regex sets and a single `Regex` with many alternates, since only one" ]# [ doc =  " alternate can match at a time." ]# [ doc =  "" ]# [ doc =  " For example, consider regular expressions to match email addresses and" ]# [ doc =  " domains: `[a-z]+@[a-z]+\\\\.(com|org|net)` and `[a-z]+\\\\.(com|org|net)`. If a" ]# [ doc =  " regex set is constructed from those regexes, then searching the text" ]# [ doc =  " `foo@example.com` will report both regexes as matching. Of course, one" ]# [ doc =  " could accomplish this by compiling each regex on its own and doing two" ]# [ doc =  " searches over the text. The key advantage of using a regex set is that it" ]# [ doc =  " will report the matching regexes using a *single pass through the text*." ]# [ doc =  " If one has hundreds or thousands of regexes to match repeatedly (like a URL" ]# [ doc =  " router for a complex web application or a user agent matcher), then a regex" ]# [ doc =  " set can realize huge performance gains." ]# [ doc =  "" ]# [ doc =  " # Example" ]# [ doc =  "" ]# [ doc =  " This shows how the above two regexes (for matching email addresses and" ]# [ doc =  " domains) might work:" ]# [ doc =  "" ]$(# [$doc_regexset_example ])* # [ doc =  "" ]# [ doc =  " Note that it would be possible to adapt the above example to using `Regex`" ]# [ doc =  " with an expression like:" ]# [ doc =  "" ]# [ doc =  " ```ignore" ]# [ doc =  " (?P<email>[a-z]+@(?P<email_domain>[a-z]+[.](com|org|net)))|(?P<domain>[a-z]+[.](com|org|net))" ]# [ doc =  " ```" ]# [ doc =  "" ]# [ doc =  " After a match, one could then inspect the capture groups to figure out" ]# [ doc =  " which alternates matched. The problem is that it is hard to make this" ]# [ doc =  " approach scale when there are many regexes since the overlap between each" ]# [ doc =  " alternate isn\\\'t always obvious to reason about." ]# [ doc =  "" ]# [ doc =  " # Limitations" ]# [ doc =  "" ]# [ doc =  " Regex sets are limited to answering the following two questions:" ]# [ doc =  "" ]# [ doc =  " 1. Does any regex in the set match?" ]# [ doc =  " 2. If so, which regexes in the set match?" ]# [ doc =  "" ]# [ doc =  " As with the main `Regex` type, it is cheaper to ask (1) instead of (2)" ]# [ doc =  " since the matching engines can stop after the first match is found." ]# [ doc =  "" ]# [ doc =  " Other features like finding the location of successive matches or their" ]# [ doc =  " sub-captures aren\\\'t supported. If you need this functionality, the" ]# [ doc =  " recommended approach is to compile each regex in the set independently and" ]# [ doc =  " selectively match them based on which regexes in the set matched." ]# [ doc =  "" ]# [ doc =  " # Performance" ]# [ doc =  "" ]# [ doc =  " A `RegexSet` has the same performance characteristics as `Regex`. Namely," ]# [ doc =  " search takes `O(mn)` time, where `m` is proportional to the size of the" ]# [ doc =  " regex set and `n` is proportional to the length of the search text." ]# [ derive ( Clone )] pub  struct  RegexSet ( Exec );  impl  RegexSet {# [ doc =  " Create a new regex set with the given regular expressions." ]# [ doc =  "" ]# [ doc =  " This takes an iterator of `S`, where `S` is something that can produce" ]# [ doc =  " a `&str`. If any of the strings in the iterator are not valid regular" ]# [ doc =  " expressions, then an error is returned." ]# [ doc =  "" ]# [ doc =  " # Example" ]# [ doc =  "" ]# [ doc =  " Create a new regex set from an iterator of strings:" ]# [ doc =  "" ]# [ doc =  " ```rust" ]# [ doc =  " # use regex::RegexSet;" ]# [ doc =  " let set = RegexSet::new(&[r\\\"\\\\w+\\\", r\\\"\\\\d+\\\"]).unwrap();" ]# [ doc =  " assert!(set.is_match(\\\"foo\\\"));" ]# [ doc =  " ```" ] pub  fn  new <  I ,  S > ( exprs :  I )->  Result <  RegexSet ,  Error >  where  S :  AsRef <  str >,  I :  IntoIterator <  Item =  S >{ RegexSetBuilder ::  new ( exprs ).  build ()}# [ doc =  " Create a new empty regex set." ]# [ doc =  "" ]# [ doc =  " # Example" ]# [ doc =  "" ]# [ doc =  " ```rust" ]# [ doc =  " # use regex::RegexSet;" ]# [ doc =  " let set = RegexSet::empty();" ]# [ doc =  " assert!(set.is_empty());" ]# [ doc =  " ```" ] pub  fn  empty ()->  RegexSet { RegexSetBuilder ::  new (& [ "" ;  0 ]).  build ().  unwrap ()}# [ doc =  " Returns true if and only if one of the regexes in this set matches" ]# [ doc =  " the text given." ]# [ doc =  "" ]# [ doc =  " This method should be preferred if you only need to test whether any" ]# [ doc =  " of the regexes in the set should match, but don\\\'t care about *which*" ]# [ doc =  " regexes matched. This is because the underlying matching engine will" ]# [ doc =  " quit immediately after seeing the first match instead of continuing to" ]# [ doc =  " find all matches." ]# [ doc =  "" ]# [ doc =  " Note that as with searches using `Regex`, the expression is unanchored" ]# [ doc =  " by default. That is, if the regex does not start with `^` or `\\\\A`, or" ]# [ doc =  " end with `$` or `\\\\z`, then it is permitted to match anywhere in the" ]# [ doc =  " text." ]# [ doc =  "" ]# [ doc =  " # Example" ]# [ doc =  "" ]# [ doc =  " Tests whether a set matches some text:" ]# [ doc =  "" ]# [ doc =  " ```rust" ]# [ doc =  " # use regex::RegexSet;" ]# [ doc =  " let set = RegexSet::new(&[r\\\"\\\\w+\\\", r\\\"\\\\d+\\\"]).unwrap();" ]# [ doc =  " assert!(set.is_match(\\\"foo\\\"));" ]# [ doc =  " assert!(!set.is_match(\\\"\\u{2603}\\\"));" ]# [ doc =  " ```" ] pub  fn  is_match (&  self ,  text : $text_ty )->  bool { self .  is_match_at ( text ,  0 )}# [ doc =  " Returns the same as is_match, but starts the search at the given" ]# [ doc =  " offset." ]# [ doc =  "" ]# [ doc =  " The significance of the starting point is that it takes the surrounding" ]# [ doc =  " context into consideration. For example, the `\\\\A` anchor can only" ]# [ doc =  " match when `start == 0`." ]# [ doc ( hidden )] pub  fn  is_match_at (&  self ,  text : $text_ty ,  start :  usize )->  bool { self .  0 .  searcher ().  is_match_at ($as_bytes ( text ),  start )}# [ doc =  " Returns the set of regular expressions that match in the given text." ]# [ doc =  "" ]# [ doc =  " The set returned contains the index of each regular expression that" ]# [ doc =  " matches in the given text. The index is in correspondence with the" ]# [ doc =  " order of regular expressions given to `RegexSet`\\\'s constructor." ]# [ doc =  "" ]# [ doc =  " The set can also be used to iterate over the matched indices." ]# [ doc =  "" ]# [ doc =  " Note that as with searches using `Regex`, the expression is unanchored" ]# [ doc =  " by default. That is, if the regex does not start with `^` or `\\\\A`, or" ]# [ doc =  " end with `$` or `\\\\z`, then it is permitted to match anywhere in the" ]# [ doc =  " text." ]# [ doc =  "" ]# [ doc =  " # Example" ]# [ doc =  "" ]# [ doc =  " Tests which regular expressions match the given text:" ]# [ doc =  "" ]# [ doc =  " ```rust" ]# [ doc =  " # use regex::RegexSet;" ]# [ doc =  " let set = RegexSet::new(&[" ]# [ doc =  "     r\\\"\\\\w+\\\"," ]# [ doc =  "     r\\\"\\\\d+\\\"," ]# [ doc =  "     r\\\"\\\\pL+\\\"," ]# [ doc =  "     r\\\"foo\\\"," ]# [ doc =  "     r\\\"bar\\\"," ]# [ doc =  "     r\\\"barfoo\\\"," ]# [ doc =  "     r\\\"foobar\\\"," ]# [ doc =  " ]).unwrap();" ]# [ doc =  " let matches: Vec<_> = set.matches(\\\"foobar\\\").into_iter().collect();" ]# [ doc =  " assert_eq!(matches, vec![0, 2, 3, 4, 6]);" ]# [ doc =  "" ]# [ doc =  " // You can also test whether a particular regex matched:" ]# [ doc =  " let matches = set.matches(\\\"foobar\\\");" ]# [ doc =  " assert!(!matches.matched(5));" ]# [ doc =  " assert!(matches.matched(6));" ]# [ doc =  " ```" ] pub  fn  matches (&  self ,  text : $text_ty )->  SetMatches { let  mut  matches =  vec ! [ false ;  self .  0 .  regex_strings ().  len ()];  let  any =  self .  read_matches_at (&  mut  matches ,  text ,  0 );  SetMatches { matched_any :  any ,  matches :  matches , }}# [ doc =  " Returns the same as matches, but starts the search at the given" ]# [ doc =  " offset and stores the matches into the slice given." ]# [ doc =  "" ]# [ doc =  " The significance of the starting point is that it takes the surrounding" ]# [ doc =  " context into consideration. For example, the `\\\\A` anchor can only" ]# [ doc =  " match when `start == 0`." ]# [ doc =  "" ]# [ doc =  " `matches` must have a length that is at least the number of regexes" ]# [ doc =  " in this set." ]# [ doc =  "" ]# [ doc =  " This method returns true if and only if at least one member of" ]# [ doc =  " `matches` is true after executing the set against `text`." ]# [ doc ( hidden )] pub  fn  read_matches_at (&  self ,  matches : &  mut [ bool ],  text : $text_ty ,  start :  usize , )->  bool { self .  0 .  searcher ().  many_matches_at ( matches , $as_bytes ( text ),  start )}# [ doc =  " Returns the total number of regular expressions in this set." ] pub  fn  len (&  self )->  usize { self .  0 .  regex_strings ().  len ()}# [ doc =  " Returns `true` if this set contains no regular expressions." ] pub  fn  is_empty (&  self )->  bool { self .  0 .  regex_strings ().  is_empty ()}# [ doc =  " Returns the patterns that this set will match on." ]# [ doc =  "" ]# [ doc =  " This function can be used to determine the pattern for a match. The" ]# [ doc =  " slice returned has exactly as many patterns givens to this regex set," ]# [ doc =  " and the order of the slice is the same as the order of the patterns" ]# [ doc =  " provided to the set." ]# [ doc =  "" ]# [ doc =  " # Example" ]# [ doc =  "" ]# [ doc =  " ```rust" ]# [ doc =  " # use regex::RegexSet;" ]# [ doc =  " let set = RegexSet::new(&[" ]# [ doc =  "     r\\\"\\\\w+\\\"," ]# [ doc =  "     r\\\"\\\\d+\\\"," ]# [ doc =  "     r\\\"\\\\pL+\\\"," ]# [ doc =  "     r\\\"foo\\\"," ]# [ doc =  "     r\\\"bar\\\"," ]# [ doc =  "     r\\\"barfoo\\\"," ]# [ doc =  "     r\\\"foobar\\\"," ]# [ doc =  " ]).unwrap();" ]# [ doc =  " let matches: Vec<_> = set" ]# [ doc =  "     .matches(\\\"foobar\\\")" ]# [ doc =  "     .into_iter()" ]# [ doc =  "     .map(|match_idx| &set.patterns()[match_idx])" ]# [ doc =  "     .collect();" ]# [ doc =  " assert_eq!(matches, vec![r\\\"\\\\w+\\\", r\\\"\\\\pL+\\\", r\\\"foo\\\", r\\\"bar\\\", r\\\"foobar\\\"]);" ]# [ doc =  " ```" ] pub  fn  patterns (&  self )-> & [ String ]{ self .  0 .  regex_strings ()}}# [ doc =  " A set of matches returned by a regex set." ]# [ derive ( Clone ,  Debug )] pub  struct  SetMatches { matched_any :  bool ,  matches :  Vec <  bool >, } impl  SetMatches {# [ doc =  " Whether this set contains any matches." ] pub  fn  matched_any (&  self )->  bool { self .  matched_any }# [ doc =  " Whether the regex at the given index matched." ]# [ doc =  "" ]# [ doc =  " The index for a regex is determined by its insertion order upon the" ]# [ doc =  " initial construction of a `RegexSet`, starting at `0`." ]# [ doc =  "" ]# [ doc =  " # Panics" ]# [ doc =  "" ]# [ doc =  " If `regex_index` is greater than or equal to `self.len()`." ] pub  fn  matched (&  self ,  regex_index :  usize )->  bool { self .  matches [ regex_index ]}# [ doc =  " The total number of regexes in the set that created these matches." ] pub  fn  len (&  self )->  usize { self .  matches .  len ()}# [ doc =  " Returns an iterator over indexes in the regex that matched." ]# [ doc =  "" ]# [ doc =  " This will always produces matches in ascending order of index, where" ]# [ doc =  " the index corresponds to the index of the regex that matched with" ]# [ doc =  " respect to its position when initially building the set." ] pub  fn  iter (&  self )->  SetMatchesIter { SetMatchesIter ((&*  self .  matches ).  into_iter ().  enumerate ())}} impl  IntoIterator  for  SetMatches { type  IntoIter =  SetMatchesIntoIter ;  type  Item =  usize ;  fn  into_iter ( self )->  Self ::  IntoIter { SetMatchesIntoIter ( self .  matches .  into_iter ().  enumerate ())}} impl < 'a >  IntoIterator  for & 'a  SetMatches { type  IntoIter =  SetMatchesIter < 'a >;  type  Item =  usize ;  fn  into_iter ( self )->  Self ::  IntoIter { self .  iter ()}}# [ doc =  " An owned iterator over the set of matches from a regex set." ]# [ doc =  "" ]# [ doc =  " This will always produces matches in ascending order of index, where the" ]# [ doc =  " index corresponds to the index of the regex that matched with respect to" ]# [ doc =  " its position when initially building the set." ]# [ derive ( Debug )] pub  struct  SetMatchesIntoIter ( iter ::  Enumerate <  vec ::  IntoIter <  bool >>);  impl  Iterator  for  SetMatchesIntoIter { type  Item =  usize ;  fn  next (&  mut  self )->  Option <  usize > { loop { match  self .  0 .  next (){ None => return  None ,  Some ((_,  false ))=>{} Some (( i ,  true ))=> return  Some ( i ), }}} fn  size_hint (&  self )-> ( usize ,  Option <  usize >){ self .  0 .  size_hint ()}} impl  DoubleEndedIterator  for  SetMatchesIntoIter { fn  next_back (&  mut  self )->  Option <  usize > { loop { match  self .  0 .  next_back (){ None => return  None ,  Some ((_,  false ))=>{} Some (( i ,  true ))=> return  Some ( i ), }}}} impl  iter ::  FusedIterator  for  SetMatchesIntoIter {}# [ doc =  " A borrowed iterator over the set of matches from a regex set." ]# [ doc =  "" ]# [ doc =  " The lifetime `\\\'a` refers to the lifetime of a `SetMatches` value." ]# [ doc =  "" ]# [ doc =  " This will always produces matches in ascending order of index, where the" ]# [ doc =  " index corresponds to the index of the regex that matched with respect to" ]# [ doc =  " its position when initially building the set." ]# [ derive ( Clone ,  Debug )] pub  struct  SetMatchesIter < 'a > ( iter ::  Enumerate <  slice ::  Iter < 'a ,  bool >>);  impl < 'a >  Iterator  for  SetMatchesIter < 'a > { type  Item =  usize ;  fn  next (&  mut  self )->  Option <  usize > { loop { match  self .  0 .  next (){ None => return  None ,  Some ((_, &  false ))=>{} Some (( i , &  true ))=> return  Some ( i ), }}} fn  size_hint (&  self )-> ( usize ,  Option <  usize >){ self .  0 .  size_hint ()}} impl < 'a >  DoubleEndedIterator  for  SetMatchesIter < 'a > { fn  next_back (&  mut  self )->  Option <  usize > { loop { match  self .  0 .  next_back (){ None => return  None ,  Some ((_, &  false ))=>{} Some (( i , &  true ))=> return  Some ( i ), }}}} impl < 'a >  iter ::  FusedIterator  for  SetMatchesIter < 'a > {}# [ doc ( hidden )] impl  From <  Exec >  for  RegexSet { fn  from ( exec :  Exec )->  Self { RegexSet ( exec )}} impl  fmt ::  Debug  for  RegexSet { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter )->  fmt ::  Result { write ! ( f ,  "RegexSet({:?})" ,  self .  0 .  regex_strings ())}}# [ allow ( dead_code )] fn  as_bytes_str ( text : &  str )-> & [ u8 ]{ text .  as_bytes ()}# [ allow ( dead_code )] fn  as_bytes_bytes ( text : & [ u8 ])-> & [ u8 ]{ text }}}}
macro_rules! __ra_macro_fixture275 {($($max_len :  expr =>$t :  ident ),*  as $conv_fn :  ident )=>{$(impl_IntegerCommon ! ($max_len , $t );  impl  IntegerPrivate < [ u8 ; $max_len ]>  for $t {# [ allow ( unused_comparisons )]# [ inline ] fn  write_to ( self ,  buf : &  mut [ u8 ; $max_len ])-> & [ u8 ]{ let  is_nonnegative =  self >=  0 ;  let  mut  n =  if  is_nonnegative { self  as $conv_fn } else {(! ( self  as $conv_fn )).  wrapping_add ( 1 )};  let  mut  curr =  buf .  len () as  isize ;  let  buf_ptr =  buf .  as_mut_ptr ();  let  lut_ptr =  DEC_DIGITS_LUT .  as_ptr ();  unsafe { if  mem ::  size_of ::<$t > ()>=  2 { while  n >=  10000 { let  rem = ( n %  10000 ) as  isize ;  n /=  10000 ;  let  d1 = ( rem /  100 )<<  1 ;  let  d2 = ( rem %  100 )<<  1 ;  curr -=  4 ;  ptr ::  copy_nonoverlapping ( lut_ptr .  offset ( d1 ),  buf_ptr .  offset ( curr ),  2 );  ptr ::  copy_nonoverlapping ( lut_ptr .  offset ( d2 ),  buf_ptr .  offset ( curr +  2 ),  2 ); }} let  mut  n =  n  as  isize ;  if  n >=  100 { let  d1 = ( n %  100 )<<  1 ;  n /=  100 ;  curr -=  2 ;  ptr ::  copy_nonoverlapping ( lut_ptr .  offset ( d1 ),  buf_ptr .  offset ( curr ),  2 ); } if  n <  10 { curr -=  1 ; *  buf_ptr .  offset ( curr )= ( n  as  u8 )+  b'0' ; } else { let  d1 =  n <<  1 ;  curr -=  2 ;  ptr ::  copy_nonoverlapping ( lut_ptr .  offset ( d1 ),  buf_ptr .  offset ( curr ),  2 ); } if !  is_nonnegative { curr -=  1 ; *  buf_ptr .  offset ( curr )=  b'-' ; }} let  len =  buf .  len ()-  curr  as  usize ;  unsafe { slice ::  from_raw_parts ( buf_ptr .  offset ( curr ),  len )}}})*}; }
macro_rules! __ra_macro_fixture276 {($max_len :  expr , $t :  ident )=>{ impl  Integer  for $t {# [ inline ] fn  write ( self ,  buf : &  mut  Buffer )-> &  str { unsafe { debug_assert ! ($max_len <=  I128_MAX_LEN );  let  buf =  mem ::  transmute ::<&  mut [ u8 ;  I128_MAX_LEN ], &  mut [ u8 ; $max_len ]> (&  mut  buf .  bytes , );  let  bytes =  self .  write_to ( buf );  str ::  from_utf8_unchecked ( bytes )}}} impl  private ::  Sealed  for $t {}}; }
macro_rules! __ra_macro_fixture277 {(($name :  ident $($generics :  tt )*)=>$item :  ty )=>{ impl $($generics )*  Iterator  for $name $($generics )* { type  Item = $item ; # [ inline ] fn  next (&  mut  self )->  Option <  Self ::  Item > { self .  iter .  next ()}# [ inline ] fn  size_hint (&  self )-> ( usize ,  Option <  usize >){ self .  iter .  size_hint ()}} impl $($generics )*  DoubleEndedIterator  for $name $($generics )* {# [ inline ] fn  next_back (&  mut  self )->  Option <  Self ::  Item > { self .  iter .  next_back ()}} impl $($generics )*  ExactSizeIterator  for $name $($generics )* {# [ inline ] fn  len (&  self )->  usize { self .  iter .  len ()}} impl $($generics )*  FusedIterator  for $name $($generics )* {}}}
macro_rules! __ra_macro_fixture278 {($($ty :  ident )*)=>{$(impl  From <$ty >  for  Value { fn  from ( n : $ty )->  Self { Value ::  Number ( n .  into ())}})* }; }
macro_rules! __ra_macro_fixture279 {($($eq :  ident [$($ty :  ty )*])*)=>{$($(impl  PartialEq <$ty >  for  Value { fn  eq (&  self ,  other : &$ty )->  bool {$eq ( self , *  other  as _)}} impl  PartialEq <  Value >  for $ty { fn  eq (&  self ,  other : &  Value )->  bool {$eq ( other , *  self  as _)}} impl < 'a >  PartialEq <$ty >  for & 'a  Value { fn  eq (&  self ,  other : &$ty )->  bool {$eq (*  self , *  other  as _)}} impl < 'a >  PartialEq <$ty >  for & 'a  mut  Value { fn  eq (&  self ,  other : &$ty )->  bool {$eq (*  self , *  other  as _)}})*)* }}
macro_rules! __ra_macro_fixture280 {($($ty :  ty ),* )=>{$(impl  From <$ty >  for  Number {# [ inline ] fn  from ( u : $ty )->  Self { let  n = {# [ cfg ( not ( feature =  "arbitrary_precision" ))]{ N ::  PosInt ( u  as  u64 )}# [ cfg ( feature =  "arbitrary_precision" )]{ itoa ::  Buffer ::  new ().  format ( u ).  to_owned ()}};  Number { n }}})* }; }
macro_rules! __ra_macro_fixture281 {($($ty :  ty ),* )=>{$(impl  From <$ty >  for  Number {# [ inline ] fn  from ( i : $ty )->  Self { let  n = {# [ cfg ( not ( feature =  "arbitrary_precision" ))]{ if  i <  0 { N ::  NegInt ( i  as  i64 )} else { N ::  PosInt ( i  as  u64 )}}# [ cfg ( feature =  "arbitrary_precision" )]{ itoa ::  Buffer ::  new ().  format ( i ).  to_owned ()}};  Number { n }}})* }; }
macro_rules! __ra_macro_fixture282 (($($size :  expr ),+)=>{$(unsafe  impl <  T >  Array  for [ T ; $size ]{ type  Item =  T ;  fn  size ()->  usize {$size }})+ });
macro_rules! __ra_macro_fixture283 {($($name :  ident ( repeats : $repeats :  expr ,  latches : $latches :  expr ,  delay : $delay :  expr ,  threads : $threads :  expr ,  single_unparks : $single_unparks :  expr ); )* )=>{$(# [ test ] fn $name (){ let  delay =  Duration ::  from_micros ($delay );  for _  in  0 ..$repeats { run_parking_test ($latches ,  delay , $threads , $single_unparks ); }})* }; }
macro_rules! __ra_macro_fixture284 {($C :  ident $P :  ident ; $A :  ident , $($I :  ident ),* ; $($X :  ident )*)=>(# [ derive ( Clone ,  Debug )] pub  struct $C <  I :  Iterator > { item :  Option <  I ::  Item >,  iter :  I ,  c : $P <  I >, } impl <  I :  Iterator +  Clone >  From <  I >  for $C <  I > { fn  from ( mut  iter :  I )->  Self {$C { item :  iter .  next (),  iter :  iter .  clone (),  c : $P ::  from ( iter ), }}} impl <  I :  Iterator +  Clone >  From <  I >  for $C <  Fuse <  I >> { fn  from ( iter :  I )->  Self { let  mut  iter =  iter .  fuse (); $C { item :  iter .  next (),  iter :  iter .  clone (),  c : $P ::  from ( iter ), }}} impl <  I , $A >  Iterator  for $C <  I >  where  I :  Iterator <  Item = $A > +  Clone ,  I ::  Item :  Clone { type  Item = ($($I ),*);  fn  next (&  mut  self )->  Option <  Self ::  Item > { if  let  Some (($($X ),*,))=  self .  c .  next (){ let  z =  self .  item .  clone ().  unwrap ();  Some (( z , $($X ),*))} else { self .  item =  self .  iter .  next ();  self .  item .  clone ().  and_then (|  z | { self .  c = $P ::  from ( self .  iter .  clone ());  self .  c .  next ().  map (| ($($X ),*,)| ( z , $($X ),*))})}}} impl <  I , $A >  HasCombination <  I >  for ($($I ),*) where  I :  Iterator <  Item = $A > +  Clone ,  I ::  Item :  Clone { type  Combination = $C <  Fuse <  I >>; })}
macro_rules! __ra_macro_fixture285 (($_A :  ident , $_B :  ident , )=>(); ($A :  ident , $($B :  ident ,)*)=>( impl_cons_iter ! ($($B ,)*); # [ allow ( non_snake_case )] impl <  X ,  Iter , $($B ),*>  Iterator  for  ConsTuples <  Iter , (($($B ,)*),  X )>  where  Iter :  Iterator <  Item = (($($B ,)*),  X )>, { type  Item = ($($B ,)*  X , );  fn  next (&  mut  self )->  Option <  Self ::  Item > { self .  iter .  next ().  map (| (($($B ,)*),  x )| ($($B ,)*  x , ))} fn  size_hint (&  self )-> ( usize ,  Option <  usize >){ self .  iter .  size_hint ()} fn  fold <  Acc ,  Fold > ( self ,  accum :  Acc ,  mut  f :  Fold )->  Acc  where  Fold :  FnMut ( Acc ,  Self ::  Item )->  Acc , { self .  iter .  fold ( accum ,  move |  acc , (($($B ,)*),  x )|  f ( acc , ($($B ,)*  x , )))}}# [ allow ( non_snake_case )] impl <  X ,  Iter , $($B ),*>  DoubleEndedIterator  for  ConsTuples <  Iter , (($($B ,)*),  X )>  where  Iter :  DoubleEndedIterator <  Item = (($($B ,)*),  X )>, { fn  next_back (&  mut  self )->  Option <  Self ::  Item > { self .  iter .  next ().  map (| (($($B ,)*),  x )| ($($B ,)*  x , ))}}); );
macro_rules! __ra_macro_fixture286 {($($fmt_trait :  ident )*)=>{$(impl < 'a ,  I >  fmt ::$fmt_trait  for  Format < 'a ,  I >  where  I :  Iterator ,  I ::  Item :  fmt ::$fmt_trait , { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter )->  fmt ::  Result { self .  format ( f ,  fmt ::$fmt_trait ::  fmt )}})* }}
macro_rules! __ra_macro_fixture287 {([$($typarm :  tt )*]$type_ :  ty )=>{ impl <$($typarm )*>  PeekingNext  for $type_ { fn  peeking_next <  F > (&  mut  self ,  accept :  F )->  Option <  Self ::  Item >  where  F :  FnOnce (&  Self ::  Item )->  bool { let  saved_state =  self .  clone ();  if  let  Some ( r )=  self .  next (){ if !  accept (&  r ){*  self =  saved_state ; } else { return  Some ( r )}} None }}}}
macro_rules! __ra_macro_fixture288 {()=>(); ($N :  expr ; $A :  ident ; $($X :  ident ),* ; $($Y :  ident ),* ; $($Y_rev :  ident ),*)=>( impl <$A >  TupleCollect  for ($($X ),*,){ type  Item = $A ;  type  Buffer = [ Option <$A >; $N -  1 ]; # [ allow ( unused_assignments ,  unused_mut )] fn  collect_from_iter <  I > ( iter :  I ,  buf : &  mut  Self ::  Buffer )->  Option <  Self >  where  I :  IntoIterator <  Item = $A > { let  mut  iter =  iter .  into_iter (); $(let  mut $Y =  None ; )*  loop {$($Y =  iter .  next ();  if $Y .  is_none (){ break })*  return  Some (($($Y .  unwrap ()),*,))} let  mut  i =  0 ;  let  mut  s =  buf .  as_mut (); $(if  i <  s .  len (){ s [ i ]= $Y ;  i +=  1 ; })*  return  None ; }# [ allow ( unused_assignments )] fn  collect_from_iter_no_buf <  I > ( iter :  I )->  Option <  Self >  where  I :  IntoIterator <  Item = $A > { let  mut  iter =  iter .  into_iter ();  loop {$(let $Y =  if  let  Some ($Y )=  iter .  next (){$Y } else { break ; }; )*  return  Some (($($Y ),*,))} return  None ; } fn  num_items ()->  usize {$N } fn  left_shift_push (&  mut  self ,  item : $A ){ use  std ::  mem ::  replace ;  let &  mut ($(ref  mut $Y ),*,)=  self ;  let  tmp =  item ; $(let  tmp =  replace ($Y_rev ,  tmp ); )*  drop ( tmp ); }})}
macro_rules! __ra_macro_fixture289 {($($B :  ident ),*)=>(# [ allow ( non_snake_case )] impl <$($B :  IntoIterator ),*>  From < ($($B ,)*)>  for  Zip < ($($B ::  IntoIter ,)*)> { fn  from ( t : ($($B ,)*))->  Self { let ($($B ,)*)=  t ;  Zip { t : ($($B .  into_iter (),)*)}}}# [ allow ( non_snake_case )]# [ allow ( unused_assignments )] impl <$($B ),*>  Iterator  for  Zip < ($($B ,)*)>  where $($B :  Iterator , )* { type  Item = ($($B ::  Item ,)*);  fn  next (&  mut  self )->  Option <  Self ::  Item > { let ($(ref  mut $B ,)*)=  self .  t ; $(let $B =  match $B .  next (){ None => return  None ,  Some ( elt )=> elt }; )*  Some (($($B ,)*))} fn  size_hint (&  self )-> ( usize ,  Option <  usize >){ let  sh = (::  std ::  usize ::  MAX ,  None );  let ($(ref $B ,)*)=  self .  t ; $(let  sh =  size_hint ::  min ($B .  size_hint (),  sh ); )*  sh }}# [ allow ( non_snake_case )] impl <$($B ),*>  ExactSizeIterator  for  Zip < ($($B ,)*)>  where $($B :  ExactSizeIterator , )* {}); }
macro_rules! __ra_macro_fixture290 {( impl $Op :  ident  for  TextRange  by  fn $f :  ident = $op :  tt )=>{ impl $Op <&  TextSize >  for  TextRange { type  Output =  TextRange ; # [ inline ] fn $f ( self ,  other : &  TextSize )->  TextRange { self $op *  other }} impl <  T > $Op <  T >  for &  TextRange  where  TextRange : $Op <  T ,  Output =  TextRange >, { type  Output =  TextRange ; # [ inline ] fn $f ( self ,  other :  T )->  TextRange {*  self $op  other }}}; }
macro_rules! __ra_macro_fixture291 {( impl $Op :  ident  for  TextSize  by  fn $f :  ident = $op :  tt )=>{ impl $Op <  TextSize >  for  TextSize { type  Output =  TextSize ; # [ inline ] fn $f ( self ,  other :  TextSize )->  TextSize { TextSize { raw :  self .  raw $op  other .  raw }}} impl $Op <&  TextSize >  for  TextSize { type  Output =  TextSize ; # [ inline ] fn $f ( self ,  other : &  TextSize )->  TextSize { self $op *  other }} impl <  T > $Op <  T >  for &  TextSize  where  TextSize : $Op <  T ,  Output =  TextSize >, { type  Output =  TextSize ; # [ inline ] fn $f ( self ,  other :  T )->  TextSize {*  self $op  other }}}; }
macro_rules! __ra_macro_fixture292 {($expr :  expr )=>{ const _:  i32 =  0 / $expr  as  i32 ; }; }
macro_rules! __ra_macro_fixture293 {($index_type :  ty , )=>(); ($index_type :  ty , $($len :  expr ,)*)=>($(fix_array_impl ! ($index_type , $len );)* ); }
macro_rules! __ra_macro_fixture294 {($index_type :  ty , $len :  expr )=>( unsafe  impl <  T >  Array  for [ T ; $len ]{ type  Item =  T ;  type  Index = $index_type ;  const  CAPACITY :  usize = $len ; # [ doc ( hidden )] fn  as_slice (&  self )-> & [ Self ::  Item ]{ self }# [ doc ( hidden )] fn  as_mut_slice (&  mut  self )-> &  mut [ Self ::  Item ]{ self }})}
macro_rules! __ra_macro_fixture295 {($($variant :  ident $(($($sub_variant :  ident ),*))?),*  for $enum :  ident )=>{$(impl  From <$variant >  for $enum { fn  from ( it : $variant )-> $enum {$enum ::$variant ( it )}}$($(impl  From <$sub_variant >  for $enum { fn  from ( it : $sub_variant )-> $enum {$enum ::$variant ($variant ::$sub_variant ( it ))}})*)? )* }}
macro_rules! __ra_macro_fixture296 {($name :  ident )=>{ impl $name { pub ( crate ) fn  expand_tt (&  self ,  invocation : &  str )->  tt ::  Subtree { self .  try_expand_tt ( invocation ).  unwrap ()} fn  try_expand_tt (&  self ,  invocation : &  str )->  Result <  tt ::  Subtree ,  ExpandError > { let  source_file =  ast ::  SourceFile ::  parse ( invocation ).  tree ();  let  macro_invocation =  source_file .  syntax ().  descendants ().  find_map ( ast ::  MacroCall ::  cast ).  unwrap ();  let ( invocation_tt , _)=  ast_to_token_tree (&  macro_invocation .  token_tree ().  unwrap ()).  ok_or_else (||  ExpandError ::  ConversionError )?;  self .  rules .  expand (&  invocation_tt ).  result ()}# [ allow ( unused )] fn  assert_expand_err (&  self ,  invocation : &  str ,  err : &  ExpandError ){ assert_eq ! ( self .  try_expand_tt ( invocation ).  as_ref (),  Err ( err )); }# [ allow ( unused )] fn  expand_items (&  self ,  invocation : &  str )->  SyntaxNode { let  expanded =  self .  expand_tt ( invocation );  token_tree_to_syntax_node (&  expanded ,  FragmentKind ::  Items ).  unwrap ().  0 .  syntax_node ()}# [ allow ( unused )] fn  expand_statements (&  self ,  invocation : &  str )->  SyntaxNode { let  expanded =  self .  expand_tt ( invocation );  token_tree_to_syntax_node (&  expanded ,  FragmentKind ::  Statements ).  unwrap ().  0 .  syntax_node ()}# [ allow ( unused )] fn  expand_expr (&  self ,  invocation : &  str )->  SyntaxNode { let  expanded =  self .  expand_tt ( invocation );  token_tree_to_syntax_node (&  expanded ,  FragmentKind ::  Expr ).  unwrap ().  0 .  syntax_node ()}# [ allow ( unused )] fn  assert_expand_tt (&  self ,  invocation : &  str ,  expected : &  str ){ let  expansion =  self .  expand_tt ( invocation );  assert_eq ! ( expansion .  to_string (),  expected ); }# [ allow ( unused )] fn  assert_expand (&  self ,  invocation : &  str ,  expected : &  str ){ let  expansion =  self .  expand_tt ( invocation );  let  actual =  format ! ( "{:?}" ,  expansion );  test_utils ::  assert_eq_text ! (&  expected .  trim (), &  actual .  trim ()); } fn  assert_expand_items (&  self ,  invocation : &  str ,  expected : &  str )-> &$name { self .  assert_expansion ( FragmentKind ::  Items ,  invocation ,  expected );  self }# [ allow ( unused )] fn  assert_expand_statements (&  self ,  invocation : &  str ,  expected : &  str )-> &$name { self .  assert_expansion ( FragmentKind ::  Statements ,  invocation ,  expected );  self } fn  assert_expansion (&  self ,  kind :  FragmentKind ,  invocation : &  str ,  expected : &  str ){ let  expanded =  self .  expand_tt ( invocation );  assert_eq ! ( expanded .  to_string (),  expected );  let  expected =  expected .  replace ( "$crate" ,  "C_C__C" );  let  expected = { let  wrapped =  format ! ( "wrap_macro!( {} )" ,  expected );  let  wrapped =  ast ::  SourceFile ::  parse (&  wrapped );  let  wrapped =  wrapped .  tree ().  syntax ().  descendants ().  find_map ( ast ::  TokenTree ::  cast ).  unwrap ();  let  mut  wrapped =  ast_to_token_tree (&  wrapped ).  unwrap ().  0 ;  wrapped .  delimiter =  None ;  wrapped };  let  expanded_tree =  token_tree_to_syntax_node (&  expanded ,  kind ).  unwrap ().  0 .  syntax_node ();  let  expanded_tree =  debug_dump_ignore_spaces (&  expanded_tree ).  trim ().  to_string ();  let  expected_tree =  token_tree_to_syntax_node (&  expected ,  kind ).  unwrap ().  0 .  syntax_node ();  let  expected_tree =  debug_dump_ignore_spaces (&  expected_tree ).  trim ().  to_string ();  let  expected_tree =  expected_tree .  replace ( "C_C__C" ,  "$crate" );  assert_eq ! ( expanded_tree ,  expected_tree ,  "\nleft:\n{}\nright:\n{}" ,  expanded_tree ,  expected_tree , ); }}}; }
macro_rules! __ra_macro_fixture297 {($($name :  ident ( num_producers : $num_producers :  expr ,  num_consumers : $num_consumers :  expr ,  max_queue_size : $max_queue_size :  expr ,  messages_per_producer : $messages_per_producer :  expr ,  notification_style : $notification_style :  expr ,  timeout : $timeout :  expr ,  delay_seconds : $delay_seconds :  expr ); )* )=>{$(# [ test ] fn $name (){ let  delay =  Duration ::  from_secs ($delay_seconds );  run_queue_test ($num_producers , $num_consumers , $max_queue_size , $messages_per_producer , $notification_style , $timeout ,  delay , ); })* }; }
macro_rules! __ra_macro_fixture298 {($t :  ident : $s1 :  expr =>$s2 :  expr )=>{# [ test ] fn $t (){ assert_eq ! ($s1 .  to_camel_case (), $s2 )}}}
macro_rules! __ra_macro_fixture299 {($t :  ident : $s1 :  expr =>$s2 :  expr )=>{# [ test ] fn $t (){ assert_eq ! ($s1 .  to_kebab_case (), $s2 )}}}
macro_rules! __ra_macro_fixture300 {($t :  ident : $s1 :  expr =>$s2 :  expr )=>{# [ test ] fn $t (){ assert_eq ! ($s1 .  to_mixed_case (), $s2 )}}}
macro_rules! __ra_macro_fixture301 {($t :  ident : $s1 :  expr =>$s2 :  expr )=>{# [ test ] fn $t (){ assert_eq ! ($s1 .  to_shouty_kebab_case (), $s2 )}}}
macro_rules! __ra_macro_fixture302 {($t :  ident : $s1 :  expr =>$s2 :  expr )=>{# [ test ] fn $t (){ assert_eq ! ($s1 .  to_shouty_snake_case (), $s2 )}}}
macro_rules! __ra_macro_fixture303 {($t :  ident : $s1 :  expr =>$s2 :  expr )=>{# [ test ] fn $t (){ assert_eq ! ($s1 .  to_snake_case (), $s2 )}}}
macro_rules! __ra_macro_fixture304 {($t :  ident : $s1 :  expr =>$s2 :  expr )=>{# [ test ] fn $t (){ assert_eq ! ($s1 .  to_title_case (), $s2 )}}}
macro_rules! __ra_macro_fixture305 {($($struct_name :  ident ),+ $(,)?)=>{$(unsafe  impl <  E :  Endian >  Pod  for $struct_name <  E > {})+ }}
macro_rules! __ra_macro_fixture306 {($($struct_name :  ident ),+ $(,)?)=>{$(unsafe  impl  Pod  for $struct_name {})+ }}
macro_rules! __ra_macro_fixture307 {($name :  ident , {$($in :  tt )* })=>{# [ test ] fn $name (){ syn ::  parse_file ( stringify ! ($($in )*)).  unwrap (); }}}
macro_rules! __ra_macro_fixture308 {($name :  ident , $op :  ident )=>{ fn $name ( sets :  Vec <  Vec <&  str >>)->  Vec <  String > { let  fsts :  Vec <  Fst <_>> =  sets .  into_iter ().  map ( fst_set ).  collect ();  let  op :  OpBuilder =  fsts .  iter ().  collect ();  let  mut  stream =  op .$op ().  into_stream ();  let  mut  keys =  vec ! [];  while  let  Some (( key , _))=  stream .  next (){ keys .  push ( String ::  from_utf8 ( key .  to_vec ()).  unwrap ()); } keys }}; }
macro_rules! __ra_macro_fixture309 {($name :  ident , $op :  ident )=>{ fn $name ( sets :  Vec <  Vec < (&  str ,  u64 )>>)->  Vec < ( String ,  u64 )> { let  fsts :  Vec <  Fst <_>> =  sets .  into_iter ().  map ( fst_map ).  collect ();  let  op :  OpBuilder =  fsts .  iter ().  collect ();  let  mut  stream =  op .$op ().  into_stream ();  let  mut  keys =  vec ! [];  while  let  Some (( key ,  outs ))=  stream .  next (){ let  merged =  outs .  iter ().  fold ( 0 , |  a ,  b |  a +  b .  value );  let  s =  String ::  from_utf8 ( key .  to_vec ()).  unwrap ();  keys .  push (( s ,  merged )); } keys }}; }
macro_rules! __ra_macro_fixture310 {($name :  ident , $($s :  expr ),+)=>{# [ test ] fn $name (){ let  mut  items =  vec ! [$($s ),*];  let  fst =  fst_set (&  items );  let  mut  rdr =  fst .  stream ();  items .  sort ();  items .  dedup ();  for  item  in &  items { assert_eq ! ( rdr .  next ().  unwrap ().  0 ,  item .  as_bytes ()); } assert_eq ! ( rdr .  next (),  None );  for  item  in &  items { assert ! ( fst .  get ( item ).  is_some ()); }}}}
macro_rules! __ra_macro_fixture311 {($name :  ident , $($s :  expr ),+)=>{# [ test ]# [ should_panic ] fn $name (){ let  mut  bfst =  Builder ::  memory (); $(bfst .  add ($s ).  unwrap ();)* }}}
macro_rules! __ra_macro_fixture312 {($name :  ident , $($s :  expr , $o :  expr ),+)=>{# [ test ] fn $name (){ let  fst =  fst_map ( vec ! [$(($s , $o )),*]);  let  mut  rdr =  fst .  stream (); $({let ( s ,  o )=  rdr .  next ().  unwrap ();  assert_eq ! (( s ,  o .  value ()), ($s .  as_bytes (), $o )); })*  assert_eq ! ( rdr .  next (),  None ); $({assert_eq ! ( fst .  get ($s .  as_bytes ()),  Some ( Output ::  new ($o ))); })* }}}
macro_rules! __ra_macro_fixture313 {($name :  ident , $($s :  expr , $o :  expr ),+)=>{# [ test ]# [ should_panic ] fn $name (){ let  mut  bfst =  Builder ::  memory (); $(bfst .  insert ($s , $o ).  unwrap ();)* }}}
macro_rules! __ra_macro_fixture314 {($name :  ident ,  min : $min :  expr ,  max : $max :  expr ,  imin : $imin :  expr ,  imax : $imax :  expr , $($s :  expr ),* )=>{# [ test ] fn $name (){ let  items :  Vec <& 'static  str > =  vec ! [$($s ),*];  let  items :  Vec <_> =  items .  into_iter ().  enumerate ().  map (| ( i ,  k )| ( k ,  i  as  u64 )).  collect ();  let  fst =  fst_map ( items .  clone ());  let  mut  rdr =  Stream ::  new ( fst .  as_ref (),  AlwaysMatch , $min , $max );  for  i  in $imin ..$imax { assert_eq ! ( rdr .  next ().  unwrap (), ( items [ i ].  0 .  as_bytes (),  Output ::  new ( items [ i ].  1 )), ); } assert_eq ! ( rdr .  next (),  None ); }}}
macro_rules! __ra_macro_fixture315 {($ty :  ty , $tag :  ident )=>{ impl  TryFrom <  Response >  for $ty { type  Error = & 'static  str ;  fn  try_from ( value :  Response )->  Result <  Self ,  Self ::  Error > { match  value { Response ::$tag ( res )=> Ok ( res ), _ => Err ( concat ! ( "Failed to convert response to " ,  stringify ! ($tag ))), }}}}; }
macro_rules! __ra_macro_fixture316 {( CloneAny )=>{# [ doc =  " A type to emulate dynamic typing." ]# [ doc =  "" ]# [ doc =  " Every type with no non-`\\\'static` references implements `Any`." ] define ! ( CloneAny  remainder ); }; ( Any )=>{# [ doc =  " A type to emulate dynamic typing with cloning." ]# [ doc =  "" ]# [ doc =  " Every type with no non-`\\\'static` references that implements `Clone` implements `Any`." ] define ! ( Any  remainder ); }; ($t :  ident  remainder )=>{# [ doc =  " See the [`std::any` documentation](https://doc.rust-lang.org/std/any/index.html) for" ]# [ doc =  " more details on `Any` in general." ]# [ doc =  "" ]# [ doc =  " This trait is not `std::any::Any` but rather a type extending that for this library\\u{2019}s" ]# [ doc =  " purposes so that it can be combined with marker traits like " ]# [ doc =  " <code><a class=trait title=core::marker::Send" ]# [ doc =  " href=http://doc.rust-lang.org/std/marker/trait.Send.html>Send</a></code> and" ]# [ doc =  " <code><a class=trait title=core::marker::Sync" ]# [ doc =  " href=http://doc.rust-lang.org/std/marker/trait.Sync.html>Sync</a></code>." ]# [ doc =  "" ] define ! ($t  trait ); }; ( CloneAny  trait )=>{# [ doc =  " See also [`Any`](trait.Any.html) for a version without the `Clone` requirement." ] pub  trait  CloneAny :  Any +  CloneToAny {} impl <  T :  StdAny +  Clone >  CloneAny  for  T {}}; ( Any  trait )=>{# [ doc =  " See also [`CloneAny`](trait.CloneAny.html) for a cloneable version of this trait." ] pub  trait  Any :  StdAny {} impl <  T :  StdAny >  Any  for  T {}}; }
macro_rules! __ra_macro_fixture317 {($base :  ident , $(+ $bounds :  ident )*)=>{ impl  fmt ::  Debug  for $base $(+ $bounds )* {# [ inline ] fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter )->  fmt ::  Result { f .  pad ( stringify ! ($base $(+ $bounds )*))}} impl  UncheckedAnyExt  for $base $(+ $bounds )* {# [ inline ] unsafe  fn  downcast_ref_unchecked <  T : 'static > (&  self )-> &  T {&* ( self  as *  const  Self  as *  const  T )}# [ inline ] unsafe  fn  downcast_mut_unchecked <  T : 'static > (&  mut  self )-> &  mut  T {&  mut * ( self  as *  mut  Self  as *  mut  T )}# [ inline ] unsafe  fn  downcast_unchecked <  T : 'static > ( self :  Box <  Self >)->  Box <  T > { Box ::  from_raw ( Box ::  into_raw ( self ) as *  mut  T )}} impl <  T : $base $(+ $bounds )*>  IntoBox <$base $(+ $bounds )*>  for  T {# [ inline ] fn  into_box ( self )->  Box <$base $(+ $bounds )*> { Box ::  new ( self )}}}}
macro_rules! __ra_macro_fixture318 {($t :  ty , $method :  ident )=>{ impl  Clone  for  Box <$t > {# [ inline ] fn  clone (&  self )->  Box <$t > {(**  self ).$method ()}}}}
macro_rules! __ra_macro_fixture319 {( field : $t :  ident .$field :  ident ;  new ()=>$new :  expr ;  with_capacity ($with_capacity_arg :  ident )=>$with_capacity :  expr ; )=>{ impl <  A : ?  Sized +  UncheckedAnyExt > $t <  A > {# [ doc =  " Create an empty collection." ]# [ inline ] pub  fn  new ()-> $t <  A > {$t {$field : $new , }}# [ doc =  " Creates an empty collection with the given initial capacity." ]# [ inline ] pub  fn  with_capacity ($with_capacity_arg :  usize )-> $t <  A > {$t {$field : $with_capacity , }}# [ doc =  " Returns the number of elements the collection can hold without reallocating." ]# [ inline ] pub  fn  capacity (&  self )->  usize { self .$field .  capacity ()}# [ doc =  " Reserves capacity for at least `additional` more elements to be inserted" ]# [ doc =  " in the collection. The collection may reserve more space to avoid" ]# [ doc =  " frequent reallocations." ]# [ doc =  "" ]# [ doc =  " # Panics" ]# [ doc =  "" ]# [ doc =  " Panics if the new allocation size overflows `usize`." ]# [ inline ] pub  fn  reserve (&  mut  self ,  additional :  usize ){ self .$field .  reserve ( additional )}# [ doc =  " Shrinks the capacity of the collection as much as possible. It will drop" ]# [ doc =  " down as much as possible while maintaining the internal rules" ]# [ doc =  " and possibly leaving some space in accordance with the resize policy." ]# [ inline ] pub  fn  shrink_to_fit (&  mut  self ){ self .$field .  shrink_to_fit ()}# [ doc =  " Returns the number of items in the collection." ]# [ inline ] pub  fn  len (&  self )->  usize { self .$field .  len ()}# [ doc =  " Returns true if there are no items in the collection." ]# [ inline ] pub  fn  is_empty (&  self )->  bool { self .$field .  is_empty ()}# [ doc =  " Removes all items from the collection. Keeps the allocated memory for reuse." ]# [ inline ] pub  fn  clear (&  mut  self ){ self .$field .  clear ()}}}}
macro_rules! __ra_macro_fixture320 {($name :  ident , $init :  ty )=>{# [ test ] fn $name (){ let  mut  map = <$init >::  new ();  assert_eq ! ( map .  insert ( A ( 10 )),  None );  assert_eq ! ( map .  insert ( B ( 20 )),  None );  assert_eq ! ( map .  insert ( C ( 30 )),  None );  assert_eq ! ( map .  insert ( D ( 40 )),  None );  assert_eq ! ( map .  insert ( E ( 50 )),  None );  assert_eq ! ( map .  insert ( F ( 60 )),  None );  match  map .  entry ::<  A > (){ Entry ::  Vacant (_)=> unreachable ! (),  Entry ::  Occupied ( mut  view )=>{ assert_eq ! ( view .  get (), &  A ( 10 ));  assert_eq ! ( view .  insert ( A ( 100 )),  A ( 10 )); }} assert_eq ! ( map .  get ::<  A > ().  unwrap (), &  A ( 100 ));  assert_eq ! ( map .  len (),  6 );  match  map .  entry ::<  B > (){ Entry ::  Vacant (_)=> unreachable ! (),  Entry ::  Occupied ( mut  view )=>{ let  v =  view .  get_mut ();  let  new_v =  B ( v .  0 *  10 ); *  v =  new_v ; }} assert_eq ! ( map .  get ::<  B > ().  unwrap (), &  B ( 200 ));  assert_eq ! ( map .  len (),  6 );  match  map .  entry ::<  C > (){ Entry ::  Vacant (_)=> unreachable ! (),  Entry ::  Occupied ( view )=>{ assert_eq ! ( view .  remove (),  C ( 30 )); }} assert_eq ! ( map .  get ::<  C > (),  None );  assert_eq ! ( map .  len (),  5 );  match  map .  entry ::<  J > (){ Entry ::  Occupied (_)=> unreachable ! (),  Entry ::  Vacant ( view )=>{ assert_eq ! (*  view .  insert ( J ( 1000 )),  J ( 1000 )); }} assert_eq ! ( map .  get ::<  J > ().  unwrap (), &  J ( 1000 ));  assert_eq ! ( map .  len (),  6 );  map .  entry ::<  B > ().  or_insert ( B ( 71 )).  0 +=  1 ;  assert_eq ! ( map .  get ::<  B > ().  unwrap (), &  B ( 201 ));  assert_eq ! ( map .  len (),  6 );  map .  entry ::<  C > ().  or_insert ( C ( 300 )).  0 +=  1 ;  assert_eq ! ( map .  get ::<  C > ().  unwrap (), &  C ( 301 ));  assert_eq ! ( map .  len (),  7 ); }}}
macro_rules! __ra_macro_fixture321 {($(# [$outer :  meta ])*  pub  struct $BitFlags :  ident : $T :  ty {$($(# [$inner :  ident $($args :  tt )*])*  const $Flag :  ident = $value :  expr ; )+ })=>{ __bitflags ! {$(# [$outer ])* ( pub )$BitFlags : $T {$($(# [$inner $($args )*])* $Flag = $value ; )+ }}}; ($(# [$outer :  meta ])*  struct $BitFlags :  ident : $T :  ty {$($(# [$inner :  ident $($args :  tt )*])*  const $Flag :  ident = $value :  expr ; )+ })=>{ __bitflags ! {$(# [$outer ])* ()$BitFlags : $T {$($(# [$inner $($args )*])* $Flag = $value ; )+ }}}; ($(# [$outer :  meta ])*  pub ($($vis :  tt )+) struct $BitFlags :  ident : $T :  ty {$($(# [$inner :  ident $($args :  tt )*])*  const $Flag :  ident = $value :  expr ; )+ })=>{ __bitflags ! {$(# [$outer ])* ( pub ($($vis )+))$BitFlags : $T {$($(# [$inner $($args )*])* $Flag = $value ; )+ }}}; }
macro_rules! __ra_macro_fixture322 {($(# [$outer :  meta ])* ($($vis :  tt )*)$BitFlags :  ident : $T :  ty {$($(# [$inner :  ident $($args :  tt )*])* $Flag :  ident = $value :  expr ; )+ })=>{$(# [$outer ])* # [ derive ( Copy ,  PartialEq ,  Eq ,  Clone ,  PartialOrd ,  Ord ,  Hash )]$($vis )*  struct $BitFlags { bits : $T , } __impl_bitflags ! {$BitFlags : $T {$($(# [$inner $($args )*])* $Flag = $value ; )+ }}}; }
macro_rules! __ra_macro_fixture323 {($BitFlags :  ident : $T :  ty {$($(# [$attr :  ident $($args :  tt )*])* $Flag :  ident = $value :  expr ; )+ })=>{ impl $crate ::  _core ::  fmt ::  Debug  for $BitFlags { fn  fmt (&  self ,  f : &  mut $crate ::  _core ::  fmt ::  Formatter )-> $crate ::  _core ::  fmt ::  Result {# [ allow ( non_snake_case )] trait  __BitFlags {$(# [ inline ] fn $Flag (&  self )->  bool { false })+ } impl  __BitFlags  for $BitFlags {$(__impl_bitflags ! {# [ allow ( deprecated )]# [ inline ]$(? # [$attr $($args )*])*  fn $Flag (&  self )->  bool { if  Self ::$Flag .  bits ==  0 &&  self .  bits !=  0 { false } else { self .  bits &  Self ::$Flag .  bits ==  Self ::$Flag .  bits }}})+ } let  mut  first =  true ; $(if <$BitFlags  as  __BitFlags >::$Flag ( self ){ if !  first { f .  write_str ( " | " )?; } first =  false ;  f .  write_str ( __bitflags_stringify ! ($Flag ))?; })+  let  extra_bits =  self .  bits & !$BitFlags ::  all ().  bits ();  if  extra_bits !=  0 { if !  first { f .  write_str ( " | " )?; } first =  false ;  f .  write_str ( "0x" )?; $crate ::  _core ::  fmt ::  LowerHex ::  fmt (&  extra_bits ,  f )?; } if  first { f .  write_str ( "(empty)" )?; } Ok (())}} impl $crate ::  _core ::  fmt ::  Binary  for $BitFlags { fn  fmt (&  self ,  f : &  mut $crate ::  _core ::  fmt ::  Formatter )-> $crate ::  _core ::  fmt ::  Result {$crate ::  _core ::  fmt ::  Binary ::  fmt (&  self .  bits ,  f )}} impl $crate ::  _core ::  fmt ::  Octal  for $BitFlags { fn  fmt (&  self ,  f : &  mut $crate ::  _core ::  fmt ::  Formatter )-> $crate ::  _core ::  fmt ::  Result {$crate ::  _core ::  fmt ::  Octal ::  fmt (&  self .  bits ,  f )}} impl $crate ::  _core ::  fmt ::  LowerHex  for $BitFlags { fn  fmt (&  self ,  f : &  mut $crate ::  _core ::  fmt ::  Formatter )-> $crate ::  _core ::  fmt ::  Result {$crate ::  _core ::  fmt ::  LowerHex ::  fmt (&  self .  bits ,  f )}} impl $crate ::  _core ::  fmt ::  UpperHex  for $BitFlags { fn  fmt (&  self ,  f : &  mut $crate ::  _core ::  fmt ::  Formatter )-> $crate ::  _core ::  fmt ::  Result {$crate ::  _core ::  fmt ::  UpperHex ::  fmt (&  self .  bits ,  f )}}# [ allow ( dead_code )] impl $BitFlags {$($(# [$attr $($args )*])*  pub  const $Flag : $BitFlags = $BitFlags { bits : $value }; )+  __fn_bitflags ! {# [ doc =  " Returns an empty set of flags" ]# [ inline ] pub  const  fn  empty ()-> $BitFlags {$BitFlags { bits :  0 }}} __fn_bitflags ! {# [ doc =  " Returns the set containing all flags." ]# [ inline ] pub  const  fn  all ()-> $BitFlags {# [ allow ( non_snake_case )] trait  __BitFlags {$(const $Flag : $T =  0 ; )+ } impl  __BitFlags  for $BitFlags {$(__impl_bitflags ! {# [ allow ( deprecated )]$(? # [$attr $($args )*])*  const $Flag : $T =  Self ::$Flag .  bits ; })+ }$BitFlags { bits : $(<$BitFlags  as  __BitFlags >::$Flag )|+ }}} __fn_bitflags ! {# [ doc =  " Returns the raw value of the flags currently stored." ]# [ inline ] pub  const  fn  bits (&  self )-> $T { self .  bits }}# [ doc =  " Convert from underlying bit representation, unless that" ]# [ doc =  " representation contains bits that do not correspond to a flag." ]# [ inline ] pub  fn  from_bits ( bits : $T )-> $crate ::  _core ::  option ::  Option <$BitFlags > { if ( bits & !$BitFlags ::  all ().  bits ())==  0 {$crate ::  _core ::  option ::  Option ::  Some ($BitFlags { bits })} else {$crate ::  _core ::  option ::  Option ::  None }} __fn_bitflags ! {# [ doc =  " Convert from underlying bit representation, dropping any bits" ]# [ doc =  " that do not correspond to flags." ]# [ inline ] pub  const  fn  from_bits_truncate ( bits : $T )-> $BitFlags {$BitFlags { bits :  bits & $BitFlags ::  all ().  bits }}} __fn_bitflags ! {# [ doc =  " Convert from underlying bit representation, preserving all" ]# [ doc =  " bits (even those not corresponding to a defined flag)." ]# [ inline ] pub  const  unsafe  fn  from_bits_unchecked ( bits : $T )-> $BitFlags {$BitFlags { bits }}} __fn_bitflags ! {# [ doc =  " Returns `true` if no flags are currently stored." ]# [ inline ] pub  const  fn  is_empty (&  self )->  bool { self .  bits ()== $BitFlags ::  empty ().  bits ()}} __fn_bitflags ! {# [ doc =  " Returns `true` if all flags are currently set." ]# [ inline ] pub  const  fn  is_all (&  self )->  bool { self .  bits == $BitFlags ::  all ().  bits }} __fn_bitflags ! {# [ doc =  " Returns `true` if there are flags common to both `self` and `other`." ]# [ inline ] pub  const  fn  intersects (&  self ,  other : $BitFlags )->  bool {!$BitFlags { bits :  self .  bits &  other .  bits }.  is_empty ()}} __fn_bitflags ! {# [ doc =  " Returns `true` all of the flags in `other` are contained within `self`." ]# [ inline ] pub  const  fn  contains (&  self ,  other : $BitFlags )->  bool {( self .  bits &  other .  bits )==  other .  bits }}# [ doc =  " Inserts the specified flags in-place." ]# [ inline ] pub  fn  insert (&  mut  self ,  other : $BitFlags ){ self .  bits |=  other .  bits ; }# [ doc =  " Removes the specified flags in-place." ]# [ inline ] pub  fn  remove (&  mut  self ,  other : $BitFlags ){ self .  bits &= !  other .  bits ; }# [ doc =  " Toggles the specified flags in-place." ]# [ inline ] pub  fn  toggle (&  mut  self ,  other : $BitFlags ){ self .  bits ^=  other .  bits ; }# [ doc =  " Inserts or removes the specified flags depending on the passed value." ]# [ inline ] pub  fn  set (&  mut  self ,  other : $BitFlags ,  value :  bool ){ if  value { self .  insert ( other ); } else { self .  remove ( other ); }}} impl $crate ::  _core ::  ops ::  BitOr  for $BitFlags { type  Output = $BitFlags ; # [ doc =  " Returns the union of the two sets of flags." ]# [ inline ] fn  bitor ( self ,  other : $BitFlags )-> $BitFlags {$BitFlags { bits :  self .  bits |  other .  bits }}} impl $crate ::  _core ::  ops ::  BitOrAssign  for $BitFlags {# [ doc =  " Adds the set of flags." ]# [ inline ] fn  bitor_assign (&  mut  self ,  other : $BitFlags ){ self .  bits |=  other .  bits ; }} impl $crate ::  _core ::  ops ::  BitXor  for $BitFlags { type  Output = $BitFlags ; # [ doc =  " Returns the left flags, but with all the right flags toggled." ]# [ inline ] fn  bitxor ( self ,  other : $BitFlags )-> $BitFlags {$BitFlags { bits :  self .  bits ^  other .  bits }}} impl $crate ::  _core ::  ops ::  BitXorAssign  for $BitFlags {# [ doc =  " Toggles the set of flags." ]# [ inline ] fn  bitxor_assign (&  mut  self ,  other : $BitFlags ){ self .  bits ^=  other .  bits ; }} impl $crate ::  _core ::  ops ::  BitAnd  for $BitFlags { type  Output = $BitFlags ; # [ doc =  " Returns the intersection between the two sets of flags." ]# [ inline ] fn  bitand ( self ,  other : $BitFlags )-> $BitFlags {$BitFlags { bits :  self .  bits &  other .  bits }}} impl $crate ::  _core ::  ops ::  BitAndAssign  for $BitFlags {# [ doc =  " Disables all flags disabled in the set." ]# [ inline ] fn  bitand_assign (&  mut  self ,  other : $BitFlags ){ self .  bits &=  other .  bits ; }} impl $crate ::  _core ::  ops ::  Sub  for $BitFlags { type  Output = $BitFlags ; # [ doc =  " Returns the set difference of the two sets of flags." ]# [ inline ] fn  sub ( self ,  other : $BitFlags )-> $BitFlags {$BitFlags { bits :  self .  bits & !  other .  bits }}} impl $crate ::  _core ::  ops ::  SubAssign  for $BitFlags {# [ doc =  " Disables all flags enabled in the set." ]# [ inline ] fn  sub_assign (&  mut  self ,  other : $BitFlags ){ self .  bits &= !  other .  bits ; }} impl $crate ::  _core ::  ops ::  Not  for $BitFlags { type  Output = $BitFlags ; # [ doc =  " Returns the complement of this set of flags." ]# [ inline ] fn  not ( self )-> $BitFlags {$BitFlags { bits : !  self .  bits }& $BitFlags ::  all ()}} impl $crate ::  _core ::  iter ::  Extend <$BitFlags >  for $BitFlags { fn  extend <  T : $crate ::  _core ::  iter ::  IntoIterator <  Item =$BitFlags >> (&  mut  self ,  iterator :  T ){ for  item  in  iterator { self .  insert ( item )}}} impl $crate ::  _core ::  iter ::  FromIterator <$BitFlags >  for $BitFlags { fn  from_iter <  T : $crate ::  _core ::  iter ::  IntoIterator <  Item =$BitFlags >> ( iterator :  T )-> $BitFlags { let  mut  result =  Self ::  empty ();  result .  extend ( iterator );  result }}}; ($(# [$filtered :  meta ])* ? # [ cfg $($cfgargs :  tt )*]$(? # [$rest :  ident $($restargs :  tt )*])*  fn $($item :  tt )* )=>{ __impl_bitflags ! {$(# [$filtered ])* # [ cfg $($cfgargs )*]$(? # [$rest $($restargs )*])*  fn $($item )* }}; ($(# [$filtered :  meta ])* ? # [$next :  ident $($nextargs :  tt )*]$(? # [$rest :  ident $($restargs :  tt )*])*  fn $($item :  tt )* )=>{ __impl_bitflags ! {$(# [$filtered ])* $(? # [$rest $($restargs )*])*  fn $($item )* }}; ($(# [$filtered :  meta ])*  fn $($item :  tt )* )=>{$(# [$filtered ])*  fn $($item )* }; ($(# [$filtered :  meta ])* ? # [ cfg $($cfgargs :  tt )*]$(? # [$rest :  ident $($restargs :  tt )*])*  const $($item :  tt )* )=>{ __impl_bitflags ! {$(# [$filtered ])* # [ cfg $($cfgargs )*]$(? # [$rest $($restargs )*])*  const $($item )* }}; ($(# [$filtered :  meta ])* ? # [$next :  ident $($nextargs :  tt )*]$(? # [$rest :  ident $($restargs :  tt )*])*  const $($item :  tt )* )=>{ __impl_bitflags ! {$(# [$filtered ])* $(? # [$rest $($restargs )*])*  const $($item )* }}; ($(# [$filtered :  meta ])*  const $($item :  tt )* )=>{$(# [$filtered ])*  const $($item )* }; }
macro_rules! __ra_macro_fixture324 {($($item :  item )*)=>{$(# [ cfg ( feature =  "os-poll" )]# [ cfg_attr ( docsrs ,  doc ( cfg ( feature =  "os-poll" )))]$item )* }}
macro_rules! __ra_macro_fixture325 {($($item :  item )*)=>{$(# [ cfg ( not ( feature =  "os-poll" ))]$item )* }}
macro_rules! __ra_macro_fixture326 {($($item :  item )*)=>{$(# [ cfg ( any ( feature =  "net" ,  all ( unix ,  feature =  "os-ext" )))]# [ cfg_attr ( docsrs ,  doc ( any ( feature =  "net" ,  all ( unix ,  feature =  "os-ext" ))))]$item )* }}
macro_rules! __ra_macro_fixture327 {($($item :  item )*)=>{$(# [ cfg ( feature =  "net" )]# [ cfg_attr ( docsrs ,  doc ( cfg ( feature =  "net" )))]$item )* }}
macro_rules! __ra_macro_fixture328 {($($item :  item )*)=>{$(# [ cfg ( feature =  "os-ext" )]# [ cfg_attr ( docsrs ,  doc ( cfg ( feature =  "os-ext" )))]$item )* }}
macro_rules! __ra_macro_fixture329 {($name :  ident , $read :  ident , $bytes :  expr , $data :  expr )=>{ mod $name { use  byteorder :: { BigEndian ,  ByteOrder ,  LittleEndian ,  NativeEndian , };  use  test ::  black_box  as  bb ;  use  test ::  Bencher ;  const  NITER :  usize =  100_000 ; # [ bench ] fn  read_big_endian ( b : &  mut  Bencher ){ let  buf = $data ;  b .  iter (|| { for _  in  0 ..  NITER { bb ( BigEndian ::$read (&  buf , $bytes )); }}); }# [ bench ] fn  read_little_endian ( b : &  mut  Bencher ){ let  buf = $data ;  b .  iter (|| { for _  in  0 ..  NITER { bb ( LittleEndian ::$read (&  buf , $bytes )); }}); }# [ bench ] fn  read_native_endian ( b : &  mut  Bencher ){ let  buf = $data ;  b .  iter (|| { for _  in  0 ..  NITER { bb ( NativeEndian ::$read (&  buf , $bytes )); }}); }}}; ($ty :  ident , $max :  ident , $read :  ident , $write :  ident , $size :  expr , $data :  expr )=>{ mod $ty { use  byteorder :: { BigEndian ,  ByteOrder ,  LittleEndian ,  NativeEndian , };  use  std ::$ty ;  use  test ::  black_box  as  bb ;  use  test ::  Bencher ;  const  NITER :  usize =  100_000 ; # [ bench ] fn  read_big_endian ( b : &  mut  Bencher ){ let  buf = $data ;  b .  iter (|| { for _  in  0 ..  NITER { bb ( BigEndian ::$read (&  buf )); }}); }# [ bench ] fn  read_little_endian ( b : &  mut  Bencher ){ let  buf = $data ;  b .  iter (|| { for _  in  0 ..  NITER { bb ( LittleEndian ::$read (&  buf )); }}); }# [ bench ] fn  read_native_endian ( b : &  mut  Bencher ){ let  buf = $data ;  b .  iter (|| { for _  in  0 ..  NITER { bb ( NativeEndian ::$read (&  buf )); }}); }# [ bench ] fn  write_big_endian ( b : &  mut  Bencher ){ let  mut  buf = $data ;  let  n = $ty ::$max ;  b .  iter (|| { for _  in  0 ..  NITER { bb ( BigEndian ::$write (&  mut  buf ,  n )); }}); }# [ bench ] fn  write_little_endian ( b : &  mut  Bencher ){ let  mut  buf = $data ;  let  n = $ty ::$max ;  b .  iter (|| { for _  in  0 ..  NITER { bb ( LittleEndian ::$write (&  mut  buf ,  n )); }}); }# [ bench ] fn  write_native_endian ( b : &  mut  Bencher ){ let  mut  buf = $data ;  let  n = $ty ::$max ;  b .  iter (|| { for _  in  0 ..  NITER { bb ( NativeEndian ::$write (&  mut  buf ,  n )); }}); }}}; }
macro_rules! __ra_macro_fixture330 {($name :  ident , $numty :  ty , $read :  ident , $write :  ident )=>{ mod $name { use  std ::  mem ::  size_of ;  use  byteorder :: { BigEndian ,  ByteOrder ,  LittleEndian };  use  rand ::  distributions ;  use  rand :: { self ,  Rng };  use  test ::  Bencher ; # [ bench ] fn  read_big_endian ( b : &  mut  Bencher ){ let  mut  numbers :  Vec <$numty > =  rand ::  thread_rng ().  sample_iter (&  distributions ::  Standard ).  take ( 100000 ).  collect ();  let  mut  bytes =  vec ! [ 0 ;  numbers .  len ()*  size_of ::<$numty > ()];  BigEndian ::$write (&  numbers , &  mut  bytes );  b .  bytes =  bytes .  len () as  u64 ;  b .  iter (|| { BigEndian ::$read (&  bytes , &  mut  numbers ); }); }# [ bench ] fn  read_little_endian ( b : &  mut  Bencher ){ let  mut  numbers :  Vec <$numty > =  rand ::  thread_rng ().  sample_iter (&  distributions ::  Standard ).  take ( 100000 ).  collect ();  let  mut  bytes =  vec ! [ 0 ;  numbers .  len ()*  size_of ::<$numty > ()];  LittleEndian ::$write (&  numbers , &  mut  bytes );  b .  bytes =  bytes .  len () as  u64 ;  b .  iter (|| { LittleEndian ::$read (&  bytes , &  mut  numbers ); }); }# [ bench ] fn  write_big_endian ( b : &  mut  Bencher ){ let  numbers :  Vec <$numty > =  rand ::  thread_rng ().  sample_iter (&  distributions ::  Standard ).  take ( 100000 ).  collect ();  let  mut  bytes =  vec ! [ 0 ;  numbers .  len ()*  size_of ::<$numty > ()];  b .  bytes =  bytes .  len () as  u64 ;  b .  iter (|| { BigEndian ::$write (&  numbers , &  mut  bytes ); }); }# [ bench ] fn  write_little_endian ( b : &  mut  Bencher ){ let  numbers :  Vec <$numty > =  rand ::  thread_rng ().  sample_iter (&  distributions ::  Standard ).  take ( 100000 ).  collect ();  let  mut  bytes =  vec ! [ 0 ;  numbers .  len ()*  size_of ::<$numty > ()];  b .  bytes =  bytes .  len () as  u64 ;  b .  iter (|| { LittleEndian ::$write (&  numbers , &  mut  bytes ); }); }}}; }
macro_rules! __ra_macro_fixture331 {{$($(#$attr :  tt )*  fn $fn_name :  ident ($($arg :  tt )*)-> $ret :  ty {$($code :  tt )* })*}=>($(# [ test ]$(#$attr )*  fn $fn_name (){ fn  prop ($($arg )*)-> $ret {$($code )* }::  quickcheck ::  quickcheck ( quickcheck ! (@  fn  prop []$($arg )*)); })* ); (@  fn $f :  ident [$($t :  tt )*])=>{$f  as  fn ($($t ),*)-> _ }; (@  fn $f :  ident [$($p :  tt )*]: $($tail :  tt )*)=>{ quickcheck ! (@  fn $f [$($p )* _]$($tail )*)}; (@  fn $f :  ident [$($p :  tt )*]$t :  tt $($tail :  tt )*)=>{ quickcheck ! (@  fn $f [$($p )*]$($tail )*)}; }
macro_rules! __ra_macro_fixture332 {($from :  ty =>$to :  ty ; $by :  ident )=>( impl < 'a >  From <$from >  for  UniCase <$to > { fn  from ( s : $from )->  Self { UniCase ::  unicode ( s .$by ())}}); ($from :  ty =>$to :  ty )=>( from_impl ! ($from =>$to ;  into ); )}
macro_rules! __ra_macro_fixture333 {($to :  ty )=>( impl < 'a >  Into <$to >  for  UniCase <$to > { fn  into ( self )-> $to { self .  into_inner ()}}); }
macro_rules! __ra_macro_fixture334 {($name :  ident , $ty :  ident )=>{ fn $name ()->  usize { let  mut  rng =  rand_xorshift ::  XorShiftRng ::  from_seed ([ 123u8 ;  16 ]);  let  mut  mv =  MeanAndVariance ::  new ();  let  mut  throwaway =  0 ;  for _  in  0 ..  SAMPLES { let  f =  loop { let  f = $ty ::  from_bits ( rng .  gen ());  if  f .  is_finite (){ break  f ; }};  let  t1 =  std ::  time ::  SystemTime ::  now ();  for _  in  0 ..  ITERATIONS { throwaway +=  ryu ::  Buffer ::  new ().  format_finite ( f ).  len (); } let  duration =  t1 .  elapsed ().  unwrap ();  let  nanos =  duration .  as_secs ()*  1_000_000_000 +  duration .  subsec_nanos () as  u64 ;  mv .  update ( nanos  as  f64 /  ITERATIONS  as  f64 ); } println ! ( "{:12} {:8.3} {:8.3}" ,  concat ! ( stringify ! ($name ),  ":" ),  mv .  mean ,  mv .  stddev (), );  throwaway }}; }
macro_rules! __ra_macro_fixture335 {($(# [$doc :  meta ])*  pub  trait $name :  ident $($methods :  tt )*)=>{ macro_rules ! $name {($m :  ident $extra :  tt )=>{$m ! {$extra  pub  trait $name $($methods )* }}} remove_sections ! {[]$(# [$doc ])*  pub  trait $name $($methods )* }}}
macro_rules! __ra_macro_fixture336 {($name :  ident <$($typarm :  tt ),*>  where {$($bounds :  tt )* } item : $item :  ty ,  iter : $iter :  ty , )=>( pub  struct $name <$($typarm ),*>  where $($bounds )* { iter : $iter , } impl <$($typarm ),*>  Iterator  for $name <$($typarm ),*>  where $($bounds )* { type  Item = $item ; # [ inline ] fn  next (&  mut  self )->  Option <  Self ::  Item > { self .  iter .  next ()}# [ inline ] fn  size_hint (&  self )-> ( usize ,  Option <  usize >){ self .  iter .  size_hint ()}}); }
macro_rules! __ra_macro_fixture337 {($($fmt_trait :  ident )*)=>{$(impl < 'a ,  I >  fmt ::$fmt_trait  for  Format < 'a ,  I >  where  I :  Iterator ,  I ::  Item :  fmt ::$fmt_trait , { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter )->  fmt ::  Result { self .  format ( f ,  fmt ::$fmt_trait ::  fmt )}})* }}
macro_rules! __ra_macro_fixture338 {($($t :  ty ),*)=>{$(not_zero_impl ! ($t ,  0 ); )* }}
macro_rules! __ra_macro_fixture339 {($name :  ident )=>{ impl  Clone  for $name {# [ inline ] fn  clone (&  self )->  Self {*  self }}}; }
macro_rules! __ra_macro_fixture340 {([$($stack :  tt )*])=>{$($stack )* }; ([$($stack :  tt )*]{$($tail :  tt )* })=>{$($stack )* { remove_sections_inner ! ([]$($tail )*); }}; ([$($stack :  tt )*]$t :  tt $($tail :  tt )*)=>{ remove_sections ! ([$($stack )* $t ]$($tail )*); }; }
macro_rules! __ra_macro_fixture341 {($t :  ty ,$z :  expr )=>{ impl  Zero  for $t { fn  zero ()->  Self {$z  as $t } fn  is_zero (&  self )->  bool { self == &  Self ::  zero ()}}}; }
macro_rules! __ra_macro_fixture342 {($($ident :  ident ),* $(,)?)=>{$(# [ allow ( bad_style )] pub  const $ident :  super ::  Name =  super ::  Name ::  new_inline ( stringify ! ($ident )); )* }; }
macro_rules! __ra_macro_fixture343 {($($trait :  ident =>$expand :  ident ),* )=>{# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  BuiltinDeriveExpander {$($trait ),* } impl  BuiltinDeriveExpander { pub  fn  expand (&  self ,  db : &  dyn  ExpandDatabase ,  id :  LazyMacroId ,  tt : &  tt ::  Subtree , )->  Result <  tt ::  Subtree ,  mbe ::  ExpandError > { let  expander =  match *  self {$(BuiltinDeriveExpander ::$trait =>$expand , )* };  expander ( db ,  id ,  tt )} fn  find_by_name ( name : &  name ::  Name )->  Option <  Self > { match  name {$(id  if  id == &  name ::  name ! [$trait ]=> Some ( BuiltinDeriveExpander ::$trait ), )* _ => None , }}}}; }
macro_rules! __ra_macro_fixture344 {( LAZY : $(($name :  ident , $kind :  ident )=>$expand :  ident ),* ,  EAGER : $(($e_name :  ident , $e_kind :  ident )=>$e_expand :  ident ),* )=>{# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  BuiltinFnLikeExpander {$($kind ),* }# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  EagerExpander {$($e_kind ),* } impl  BuiltinFnLikeExpander { pub  fn  expand (&  self ,  db : &  dyn  ExpandDatabase ,  id :  LazyMacroId ,  tt : &  tt ::  Subtree , )->  ExpandResult <  tt ::  Subtree > { let  expander =  match *  self {$(BuiltinFnLikeExpander ::$kind =>$expand , )* };  expander ( db ,  id ,  tt )}} impl  EagerExpander { pub  fn  expand (&  self ,  db : &  dyn  ExpandDatabase ,  arg_id :  EagerMacroId ,  tt : &  tt ::  Subtree , )->  ExpandResult <  Option < ( tt ::  Subtree ,  FragmentKind )>> { let  expander =  match *  self {$(EagerExpander ::$e_kind =>$e_expand , )* };  expander ( db ,  arg_id ,  tt )}} fn  find_by_name ( ident : &  name ::  Name )->  Option <  Either <  BuiltinFnLikeExpander ,  EagerExpander >> { match  ident {$(id  if  id == &  name ::  name ! [$name ]=> Some ( Either ::  Left ( BuiltinFnLikeExpander ::$kind )), )* $(id  if  id == &  name ::  name ! [$e_name ]=> Some ( Either ::  Right ( EagerExpander ::$e_kind )), )* _ => return  None , }}}; }
macro_rules! __ra_macro_fixture345 {($($ty :  ty =>$this :  ident $im :  block );*)=>{$(impl  ToTokenTree  for $ty { fn  to_token ($this )->  tt ::  TokenTree { let  leaf :  tt ::  Leaf = $im .  into ();  leaf .  into ()}} impl  ToTokenTree  for &$ty { fn  to_token ($this )->  tt ::  TokenTree { let  leaf :  tt ::  Leaf = $im .  clone ().  into ();  leaf .  into ()}})* }}
macro_rules! __ra_macro_fixture346 {($name :  ident )=>{ impl $crate ::  salsa ::  InternKey  for $name { fn  from_intern_id ( v : $crate ::  salsa ::  InternId )->  Self {$name ( v )} fn  as_intern_id (&  self )-> $crate ::  salsa ::  InternId { self .  0 }}}; }
macro_rules! __ra_macro_fixture347 {($($var :  ident ($t :  ty )),+ )=>{$(impl  From <$t >  for  AttrOwner { fn  from ( t : $t )->  AttrOwner { AttrOwner ::$var ( t )}})+ }; }
macro_rules! __ra_macro_fixture348 {($($typ :  ident  in $fld :  ident -> $ast :  ty ),+ $(,)? )=>{# [ derive ( Debug ,  Copy ,  Clone ,  Eq ,  PartialEq ,  Hash )] pub  enum  ModItem {$($typ ( FileItemTreeId <$typ >), )+ }$(impl  From <  FileItemTreeId <$typ >>  for  ModItem { fn  from ( id :  FileItemTreeId <$typ >)->  ModItem { ModItem ::$typ ( id )}})+ $(impl  ItemTreeNode  for $typ { type  Source = $ast ;  fn  ast_id (&  self )->  FileAstId <  Self ::  Source > { self .  ast_id } fn  lookup ( tree : &  ItemTree ,  index :  Idx <  Self >)-> &  Self {&  tree .  data ().$fld [ index ]} fn  id_from_mod_item ( mod_item :  ModItem )->  Option <  FileItemTreeId <  Self >> { if  let  ModItem ::$typ ( id )=  mod_item { Some ( id )} else { None }} fn  id_to_mod_item ( id :  FileItemTreeId <  Self >)->  ModItem { ModItem ::$typ ( id )}} impl  Index <  Idx <$typ >>  for  ItemTree { type  Output = $typ ;  fn  index (&  self ,  index :  Idx <$typ >)-> &  Self ::  Output {&  self .  data ().$fld [ index ]}})+ }; }
macro_rules! __ra_macro_fixture349 {($($fld :  ident : $t :  ty ),+ $(,)? )=>{$(impl  Index <  Idx <$t >>  for  ItemTree { type  Output = $t ;  fn  index (&  self ,  index :  Idx <$t >)-> &  Self ::  Output {&  self .  data ().$fld [ index ]}})+ }; }
macro_rules! __ra_macro_fixture350 {($e :  ident {$($v :  ident ($t :  ty )),* $(,)? })=>{$(impl  From <$t >  for $e { fn  from ( it : $t )-> $e {$e ::$v ( it )}})* }}
macro_rules! __ra_macro_fixture351 {($id :  ident , $loc :  ident , $intern :  ident , $lookup :  ident )=>{ impl_intern_key ! ($id );  impl  Intern  for $loc { type  ID = $id ;  fn  intern ( self ,  db : &  dyn  db ::  DefDatabase )-> $id { db .$intern ( self )}} impl  Lookup  for $id { type  Data = $loc ;  fn  lookup (&  self ,  db : &  dyn  db ::  DefDatabase )-> $loc { db .$lookup (*  self )}}}; }
macro_rules! __ra_macro_fixture352 {([$derives :  ident $($derive_t :  tt )*]=>$(# [$($attrs :  tt )*])* $inner :  path )=>{# [ proc_macro_derive ($derives $($derive_t )*)]# [ allow ( non_snake_case )]$(# [$($attrs )*])*  pub  fn $derives ( i : $crate ::  macros ::  TokenStream )-> $crate ::  macros ::  TokenStream { match $crate ::  macros ::  parse ::<$crate ::  macros ::  DeriveInput > ( i ){ Ok ( p )=>{ match $crate ::  Structure ::  try_new (&  p ){ Ok ( s )=>$crate ::  MacroResult ::  into_stream ($inner ( s )),  Err ( e )=> e .  to_compile_error ().  into (), }} Err ( e )=> e .  to_compile_error ().  into (), }}}; }
macro_rules! __ra_macro_fixture353 {($I :  ident =>$t :  ty )=>{ impl <$I :  Interner >  Zip <$I >  for $t { fn  zip_with < 'i ,  Z :  Zipper < 'i , $I >> ( _zipper : &  mut  Z ,  _variance :  Variance ,  a : &  Self ,  b : &  Self , )->  Fallible < ()>  where  I : 'i , { if  a !=  b { return  Err ( NoSolution ); } Ok (())}}}; }
macro_rules! __ra_macro_fixture354 {($($n :  ident ),*)=>{ impl <$($n :  Fold <  I >,)*  I :  Interner >  Fold <  I >  for ($($n ,)*){ type  Result = ($($n ::  Result ,)*);  fn  fold_with < 'i > ( self ,  folder : &  mut  dyn  Folder < 'i ,  I >,  outer_binder :  DebruijnIndex )->  Fallible <  Self ::  Result >  where  I : 'i , {# [ allow ( non_snake_case )] let ($($n ),*)=  self ;  Ok (($($n .  fold_with ( folder ,  outer_binder )?,)*))}}}}
macro_rules! __ra_macro_fixture355 {($t :  ty )=>{ impl <  I :  Interner > $crate ::  fold ::  Fold <  I >  for $t { type  Result =  Self ;  fn  fold_with < 'i > ( self ,  _folder : &  mut  dyn ($crate ::  fold ::  Folder < 'i ,  I >),  _outer_binder :  DebruijnIndex , )-> ::  chalk_ir ::  Fallible <  Self ::  Result >  where  I : 'i , { Ok ( self )}}}; }
macro_rules! __ra_macro_fixture356 {($t :  ident )=>{ impl <  I :  Interner > $crate ::  fold ::  Fold <  I >  for $t <  I > { type  Result = $t <  I >;  fn  fold_with < 'i > ( self ,  _folder : &  mut  dyn ($crate ::  fold ::  Folder < 'i ,  I >),  _outer_binder :  DebruijnIndex , )-> ::  chalk_ir ::  Fallible <  Self ::  Result >  where  I : 'i , { Ok ( self )}}}; }
macro_rules! __ra_macro_fixture357 {($($n :  ident ),*)=>{ impl <$($n :  Visit <  I >,)*  I :  Interner >  Visit <  I >  for ($($n ,)*){ fn  visit_with < 'i ,  BT > (&  self ,  visitor : &  mut  dyn  Visitor < 'i ,  I ,  BreakTy =  BT >,  outer_binder :  DebruijnIndex )->  ControlFlow <  BT >  where  I : 'i {# [ allow ( non_snake_case )] let & ($(ref $n ),*)=  self ; $(try_break ! ($n .  visit_with ( visitor ,  outer_binder )); )*  ControlFlow ::  CONTINUE }}}}
macro_rules! __ra_macro_fixture358 {($t :  ty )=>{ impl <  I :  Interner > $crate ::  visit ::  Visit <  I >  for $t { fn  visit_with < 'i ,  B > (&  self ,  _visitor : &  mut  dyn ($crate ::  visit ::  Visitor < 'i ,  I ,  BreakTy =  B >),  _outer_binder :  DebruijnIndex , )->  ControlFlow <  B >  where  I : 'i , { ControlFlow ::  CONTINUE }}}; }
macro_rules! __ra_macro_fixture359 {($t :  ident )=>{ impl <  I :  Interner > $crate ::  visit ::  Visit <  I >  for $t <  I > { fn  visit_with < 'i ,  B > (&  self ,  _visitor : &  mut  dyn ($crate ::  visit ::  Visitor < 'i ,  I ,  BreakTy =  B >),  _outer_binder :  DebruijnIndex , )->  ControlFlow <  B >  where  I : 'i , { ControlFlow ::  CONTINUE }}}; }
macro_rules! __ra_macro_fixture360 {( for ($($t :  tt )*)$u :  ty )=>{ impl <$($t )*>  CastTo <$u >  for $u { fn  cast_to ( self ,  _interner : &<$u  as  HasInterner >::  Interner )-> $u { self }}}; ($u :  ty )=>{ impl  CastTo <$u >  for $u { fn  cast_to ( self ,  interner : &<$u  as  HasInterner >::  Interner )-> $u { self }}}; }
macro_rules! __ra_macro_fixture361 {($($id :  ident ), *)=>{$(impl <  I :  Interner >  std ::  fmt ::  Debug  for $id <  I > { fn  fmt (&  self ,  fmt : &  mut  std ::  fmt ::  Formatter < '_ >)->  Result < (),  std ::  fmt ::  Error > { write ! ( fmt ,  "{}({:?})" ,  stringify ! ($id ),  self .  0 )}})* }; }
macro_rules! __ra_macro_fixture362 {($seq :  ident , $data :  ident =>$elem :  ty , $intern :  ident =>$interned :  ident )=>{ interned_slice_common ! ($seq , $data =>$elem , $intern =>$interned );  impl <  I :  Interner > $seq <  I > {# [ doc =  " Tries to create a sequence using an iterator of element-like things." ] pub  fn  from_fallible <  E > ( interner : &  I ,  elements :  impl  IntoIterator <  Item =  Result <  impl  CastTo <$elem >,  E >>, )->  Result <  Self ,  E > { Ok ( Self { interned :  I ::$intern ( interner ,  elements .  into_iter ().  casted ( interner ))?, })}# [ doc =  " Create a sequence from elements" ] pub  fn  from_iter ( interner : &  I ,  elements :  impl  IntoIterator <  Item =  impl  CastTo <$elem >>, )->  Self { Self ::  from_fallible ( interner ,  elements .  into_iter ().  map (|  el | ->  Result <$elem , ()> { Ok ( el .  cast ( interner ))}), ).  unwrap ()}# [ doc =  " Create a sequence from a single element." ] pub  fn  from1 ( interner : &  I ,  element :  impl  CastTo <$elem >)->  Self { Self ::  from_iter ( interner ,  Some ( element ))}}}; }
macro_rules! __ra_macro_fixture363 {($seq :  ident , $data :  ident =>$elem :  ty , $intern :  ident =>$interned :  ident )=>{# [ doc =  " List of interned elements." ]# [ derive ( Copy ,  Clone ,  PartialEq ,  Eq ,  Hash ,  PartialOrd ,  Ord ,  HasInterner )] pub  struct $seq <  I :  Interner > { interned :  I ::$interned , } impl <  I :  Interner > $seq <  I > {# [ doc =  " Get the interned elements." ] pub  fn  interned (&  self )-> &  I ::$interned {&  self .  interned }# [ doc =  " Returns a slice containing the elements." ] pub  fn  as_slice (&  self ,  interner : &  I )-> & [$elem ]{ Interner ::$data ( interner , &  self .  interned )}# [ doc =  " Index into the sequence." ] pub  fn  at (&  self ,  interner : &  I ,  index :  usize )-> &$elem {&  self .  as_slice ( interner )[ index ]}# [ doc =  " Create an empty sequence." ] pub  fn  empty ( interner : &  I )->  Self { Self ::  from_iter ( interner ,  None ::<$elem >)}# [ doc =  " Check whether this is an empty sequence." ] pub  fn  is_empty (&  self ,  interner : &  I )->  bool { self .  as_slice ( interner ).  is_empty ()}# [ doc =  " Get an iterator over the elements of the sequence." ] pub  fn  iter (&  self ,  interner : &  I )->  std ::  slice ::  Iter < '_ , $elem > { self .  as_slice ( interner ).  iter ()}# [ doc =  " Get the length of the sequence." ] pub  fn  len (&  self ,  interner : &  I )->  usize { self .  as_slice ( interner ).  len ()}}}; }
macro_rules! __ra_macro_fixture364 {($(# [$attrs :  meta ])* $vis :  vis  static $name :  ident : $ty :  ty )=>($(# [$attrs ])* $vis  static $name : $crate ::  ScopedKey <$ty > = $crate ::  ScopedKey { inner : { thread_local ! ( static  FOO : ::  std ::  cell ::  Cell <  usize > = {::  std ::  cell ::  Cell ::  new ( 0 )}); &  FOO },  _marker : ::  std ::  marker ::  PhantomData , }; )}
macro_rules! __ra_macro_fixture365 {($(($def :  path , $ast :  path , $meth :  ident )),* ,)=>{$(impl  ToDef  for $ast { type  Def = $def ;  fn  to_def ( sema : &  SemanticsImpl ,  src :  InFile <  Self >)->  Option <  Self ::  Def > { sema .  with_ctx (|  ctx |  ctx .$meth ( src )).  map (<$def >::  from )}})*}}
macro_rules! __ra_macro_fixture366 {($(($id :  path , $ty :  path )),*)=>{$(impl  From <$id >  for $ty { fn  from ( id : $id )-> $ty {$ty { id }}} impl  From <$ty >  for $id { fn  from ( ty : $ty )-> $id { ty .  id }})*}}
macro_rules! __ra_macro_fixture367 {($(($def :  ident , $def_id :  ident ),)*)=>{$(impl  HasAttrs  for $def { fn  attrs ( self ,  db : &  dyn  HirDatabase )->  Attrs { let  def =  AttrDefId ::$def_id ( self .  into ());  db .  attrs ( def )} fn  docs ( self ,  db : &  dyn  HirDatabase )->  Option <  Documentation > { let  def =  AttrDefId ::$def_id ( self .  into ());  db .  attrs ( def ).  docs ()} fn  resolve_doc_path ( self ,  db : &  dyn  HirDatabase ,  link : &  str ,  ns :  Option <  Namespace >)->  Option <  ModuleDef > { let  def =  AttrDefId ::$def_id ( self .  into ());  resolve_doc_path ( db ,  def ,  link ,  ns ).  map ( ModuleDef ::  from )}})*}; }
macro_rules! __ra_macro_fixture368 {($($variant :  ident ),*  for $enum :  ident )=>{$(impl  HasAttrs  for $variant { fn  attrs ( self ,  db : &  dyn  HirDatabase )->  Attrs {$enum ::$variant ( self ).  attrs ( db )} fn  docs ( self ,  db : &  dyn  HirDatabase )->  Option <  Documentation > {$enum ::$variant ( self ).  docs ( db )} fn  resolve_doc_path ( self ,  db : &  dyn  HirDatabase ,  link : &  str ,  ns :  Option <  Namespace >)->  Option <  ModuleDef > {$enum ::$variant ( self ).  resolve_doc_path ( db ,  link ,  ns )}})*}; }
macro_rules! __ra_macro_fixture369 {{$($(#$attr :  tt )*  fn $fn_name :  ident ($($arg :  tt )*)-> $ret :  ty {$($code :  tt )* })*}=>($(# [ test ]$(#$attr )*  fn $fn_name (){ fn  prop ($($arg )*)-> $ret {$($code )* }::  quickcheck ::  quickcheck ( quickcheck ! (@  fn  prop []$($arg )*)); })* ); (@  fn $f :  ident [$($t :  tt )*])=>{$f  as  fn ($($t ),*)-> _ }; (@  fn $f :  ident [$($p :  tt )*]: $($tail :  tt )*)=>{ quickcheck ! (@  fn $f [$($p )* _]$($tail )*)}; (@  fn $f :  ident [$($p :  tt )*]$t :  tt $($tail :  tt )*)=>{ quickcheck ! (@  fn $f [$($p )*]$($tail )*)}; }
macro_rules! __ra_macro_fixture370 {($($bool :  expr , )+)=>{ fn  _static_assert (){$(let _ =  std ::  mem ::  transmute ::< [ u8 ; $bool  as  usize ],  u8 >; )+ }}}
macro_rules! __ra_macro_fixture371 {($ty :  ident  is $($marker :  ident ) and +)=>{# [ test ]# [ allow ( non_snake_case )] fn $ty (){ fn  assert_implemented <  T : $($marker +)+> (){} assert_implemented ::<$ty > (); }}; ($ty :  ident  is  not $($marker :  ident ) or +)=>{# [ test ]# [ allow ( non_snake_case )] fn $ty (){$({trait  IsNotImplemented { fn  assert_not_implemented (){}} impl <  T : $marker >  IsNotImplemented  for  T {} trait  IsImplemented { fn  assert_not_implemented (){}} impl  IsImplemented  for $ty {}<$ty >::  assert_not_implemented (); })+ }}; }
macro_rules! __ra_macro_fixture372 {($($types :  ident )*)=>{$(assert_impl ! ($types  is  UnwindSafe  and  RefUnwindSafe ); )* }; }
macro_rules! __ra_macro_fixture373 {($($(# [$attr :  meta ])* $name :  ident ($value :  expr , $expected :  expr )),* )=>{$($(# [$attr ])* # [ test ] fn $name (){# [ cfg ( feature =  "std" )]{ let  mut  buf = [ b'\0' ;  40 ];  let  len =  itoa ::  write (&  mut  buf [..], $value ).  unwrap ();  assert_eq ! (&  buf [ 0 ..  len ], $expected .  as_bytes ()); } let  mut  s =  String ::  new ();  itoa ::  fmt (&  mut  s , $value ).  unwrap ();  assert_eq ! ( s , $expected ); })* }}
macro_rules! __ra_macro_fixture374 {($($name :  ident =>$description :  expr ,)+)=>{# [ doc =  " Errors that can occur during parsing." ]# [ doc =  "" ]# [ doc =  " This may be extended in the future so exhaustive matching is" ]# [ doc =  " discouraged with an unused variant." ]# [ allow ( clippy ::  manual_non_exhaustive )]# [ derive ( PartialEq ,  Eq ,  Clone ,  Copy ,  Debug )] pub  enum  ParseError {$($name , )+ # [ doc =  " Unused variant enable non-exhaustive matching" ]# [ doc ( hidden )] __FutureProof , } impl  fmt ::  Display  for  ParseError { fn  fmt (&  self ,  fmt : &  mut  Formatter < '_ >)->  fmt ::  Result { match *  self {$(ParseError ::$name => fmt .  write_str ($description ), )+  ParseError ::  __FutureProof =>{ unreachable ! ( "Don't abuse the FutureProof!" ); }}}}}}
macro_rules! __ra_macro_fixture375 {($($name :  ident =>$description :  expr ,)+)=>{# [ doc =  " Non-fatal syntax violations that can occur during parsing." ]# [ doc =  "" ]# [ doc =  " This may be extended in the future so exhaustive matching is" ]# [ doc =  " discouraged with an unused variant." ]# [ allow ( clippy ::  manual_non_exhaustive )]# [ derive ( PartialEq ,  Eq ,  Clone ,  Copy ,  Debug )] pub  enum  SyntaxViolation {$($name , )+ # [ doc =  " Unused variant enable non-exhaustive matching" ]# [ doc ( hidden )] __FutureProof , } impl  SyntaxViolation { pub  fn  description (&  self )-> & 'static  str { match *  self {$(SyntaxViolation ::$name =>$description , )+  SyntaxViolation ::  __FutureProof =>{ unreachable ! ( "Don't abuse the FutureProof!" ); }}}}}}
macro_rules! __ra_macro_fixture376 {('owned : $($oty :  ident ,)* 'interned : $($ity :  ident ,)* )=>{# [ repr ( C )]# [ allow ( non_snake_case )] pub  struct  HandleCounters {$($oty :  AtomicUsize ,)* $($ity :  AtomicUsize ,)* } impl  HandleCounters { extern  "C"  fn  get ()-> & 'static  Self { static  COUNTERS :  HandleCounters =  HandleCounters {$($oty :  AtomicUsize ::  new ( 1 ),)* $($ity :  AtomicUsize ::  new ( 1 ),)* }; &  COUNTERS }}# [ repr ( C )]# [ allow ( non_snake_case )] pub ( super ) struct  HandleStore <  S :  server ::  Types > {$($oty :  handle ::  OwnedStore <  S ::$oty >,)* $($ity :  handle ::  InternedStore <  S ::$ity >,)* } impl <  S :  server ::  Types >  HandleStore <  S > { pub ( super ) fn  new ( handle_counters : & 'static  HandleCounters )->  Self { HandleStore {$($oty :  handle ::  OwnedStore ::  new (&  handle_counters .$oty ),)* $($ity :  handle ::  InternedStore ::  new (&  handle_counters .$ity ),)* }}}$(# [ repr ( C )] pub  struct $oty ( pub ( crate ) handle ::  Handle );  impl  Drop  for $oty { fn  drop (&  mut  self ){$oty ( self .  0 ).  drop (); }} impl <  S >  Encode <  S >  for $oty { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  S ){ let  handle =  self .  0 ;  mem ::  forget ( self );  handle .  encode ( w ,  s ); }} impl <  S :  server ::  Types >  DecodeMut < '_ , '_ ,  HandleStore <  server ::  MarkedTypes <  S >>>  for  Marked <  S ::$oty , $oty > { fn  decode ( r : &  mut  Reader < '_ >,  s : &  mut  HandleStore <  server ::  MarkedTypes <  S >>)->  Self { s .$oty .  take ( handle ::  Handle ::  decode ( r , &  mut ()))}} impl <  S >  Encode <  S >  for &$oty { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  S ){ self .  0 .  encode ( w ,  s ); }} impl < 's ,  S :  server ::  Types ,>  Decode < '_ , 's ,  HandleStore <  server ::  MarkedTypes <  S >>>  for & 's  Marked <  S ::$oty , $oty > { fn  decode ( r : &  mut  Reader < '_ >,  s : & 's  HandleStore <  server ::  MarkedTypes <  S >>)->  Self {&  s .$oty [ handle ::  Handle ::  decode ( r , &  mut ())]}} impl <  S >  Encode <  S >  for &  mut $oty { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  S ){ self .  0 .  encode ( w ,  s ); }} impl < 's ,  S :  server ::  Types >  DecodeMut < '_ , 's ,  HandleStore <  server ::  MarkedTypes <  S >>>  for & 's  mut  Marked <  S ::$oty , $oty > { fn  decode ( r : &  mut  Reader < '_ >,  s : & 's  mut  HandleStore <  server ::  MarkedTypes <  S >> )->  Self {&  mut  s .$oty [ handle ::  Handle ::  decode ( r , &  mut ())]}} impl <  S :  server ::  Types >  Encode <  HandleStore <  server ::  MarkedTypes <  S >>>  for  Marked <  S ::$oty , $oty > { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  HandleStore <  server ::  MarkedTypes <  S >>){ s .$oty .  alloc ( self ).  encode ( w ,  s ); }} impl <  S >  DecodeMut < '_ , '_ ,  S >  for $oty { fn  decode ( r : &  mut  Reader < '_ >,  s : &  mut  S )->  Self {$oty ( handle ::  Handle ::  decode ( r ,  s ))}})* $(# [ repr ( C )]# [ derive ( Copy ,  Clone ,  PartialEq ,  Eq ,  Hash )] pub ( crate ) struct $ity ( handle ::  Handle );  impl <  S >  Encode <  S >  for $ity { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  S ){ self .  0 .  encode ( w ,  s ); }} impl <  S :  server ::  Types >  DecodeMut < '_ , '_ ,  HandleStore <  server ::  MarkedTypes <  S >>>  for  Marked <  S ::$ity , $ity > { fn  decode ( r : &  mut  Reader < '_ >,  s : &  mut  HandleStore <  server ::  MarkedTypes <  S >>)->  Self { s .$ity .  copy ( handle ::  Handle ::  decode ( r , &  mut ()))}} impl <  S :  server ::  Types >  Encode <  HandleStore <  server ::  MarkedTypes <  S >>>  for  Marked <  S ::$ity , $ity > { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  HandleStore <  server ::  MarkedTypes <  S >>){ s .$ity .  alloc ( self ).  encode ( w ,  s ); }} impl <  S >  DecodeMut < '_ , '_ ,  S >  for $ity { fn  decode ( r : &  mut  Reader < '_ >,  s : &  mut  S )->  Self {$ity ( handle ::  Handle ::  decode ( r ,  s ))}})* }}
macro_rules! __ra_macro_fixture377 {($S :  ident , $self :  ident , $m :  ident )=>{$m ! { FreeFunctions { fn  drop ($self : $S ::  FreeFunctions );  fn  track_env_var ( var : &  str ,  value :  Option <&  str >); },  TokenStream { fn  drop ($self : $S ::  TokenStream );  fn  clone ($self : &$S ::  TokenStream )-> $S ::  TokenStream ;  fn  new ()-> $S ::  TokenStream ;  fn  is_empty ($self : &$S ::  TokenStream )->  bool ;  fn  from_str ( src : &  str )-> $S ::  TokenStream ;  fn  to_string ($self : &$S ::  TokenStream )->  String ;  fn  from_token_tree ( tree :  TokenTree <$S ::  Group , $S ::  Punct , $S ::  Ident , $S ::  Literal >, )-> $S ::  TokenStream ;  fn  into_iter ($self : $S ::  TokenStream )-> $S ::  TokenStreamIter ; },  TokenStreamBuilder { fn  drop ($self : $S ::  TokenStreamBuilder );  fn  new ()-> $S ::  TokenStreamBuilder ;  fn  push ($self : &  mut $S ::  TokenStreamBuilder ,  stream : $S ::  TokenStream );  fn  build ($self : $S ::  TokenStreamBuilder )-> $S ::  TokenStream ; },  TokenStreamIter { fn  drop ($self : $S ::  TokenStreamIter );  fn  clone ($self : &$S ::  TokenStreamIter )-> $S ::  TokenStreamIter ;  fn  next ($self : &  mut $S ::  TokenStreamIter , )->  Option <  TokenTree <$S ::  Group , $S ::  Punct , $S ::  Ident , $S ::  Literal >>; },  Group { fn  drop ($self : $S ::  Group );  fn  clone ($self : &$S ::  Group )-> $S ::  Group ;  fn  new ( delimiter :  Delimiter ,  stream : $S ::  TokenStream )-> $S ::  Group ;  fn  delimiter ($self : &$S ::  Group )->  Delimiter ;  fn  stream ($self : &$S ::  Group )-> $S ::  TokenStream ;  fn  span ($self : &$S ::  Group )-> $S ::  Span ;  fn  span_open ($self : &$S ::  Group )-> $S ::  Span ;  fn  span_close ($self : &$S ::  Group )-> $S ::  Span ;  fn  set_span ($self : &  mut $S ::  Group ,  span : $S ::  Span ); },  Punct { fn  new ( ch :  char ,  spacing :  Spacing )-> $S ::  Punct ;  fn  as_char ($self : $S ::  Punct )->  char ;  fn  spacing ($self : $S ::  Punct )->  Spacing ;  fn  span ($self : $S ::  Punct )-> $S ::  Span ;  fn  with_span ($self : $S ::  Punct ,  span : $S ::  Span )-> $S ::  Punct ; },  Ident { fn  new ( string : &  str ,  span : $S ::  Span ,  is_raw :  bool )-> $S ::  Ident ;  fn  span ($self : $S ::  Ident )-> $S ::  Span ;  fn  with_span ($self : $S ::  Ident ,  span : $S ::  Span )-> $S ::  Ident ; },  Literal { fn  drop ($self : $S ::  Literal );  fn  clone ($self : &$S ::  Literal )-> $S ::  Literal ;  fn  debug_kind ($self : &$S ::  Literal )->  String ;  fn  symbol ($self : &$S ::  Literal )->  String ;  fn  suffix ($self : &$S ::  Literal )->  Option <  String >;  fn  integer ( n : &  str )-> $S ::  Literal ;  fn  typed_integer ( n : &  str ,  kind : &  str )-> $S ::  Literal ;  fn  float ( n : &  str )-> $S ::  Literal ;  fn  f32 ( n : &  str )-> $S ::  Literal ;  fn  f64 ( n : &  str )-> $S ::  Literal ;  fn  string ( string : &  str )-> $S ::  Literal ;  fn  character ( ch :  char )-> $S ::  Literal ;  fn  byte_string ( bytes : & [ u8 ])-> $S ::  Literal ;  fn  span ($self : &$S ::  Literal )-> $S ::  Span ;  fn  set_span ($self : &  mut $S ::  Literal ,  span : $S ::  Span );  fn  subspan ($self : &$S ::  Literal ,  start :  Bound <  usize >,  end :  Bound <  usize >, )->  Option <$S ::  Span >; },  SourceFile { fn  drop ($self : $S ::  SourceFile );  fn  clone ($self : &$S ::  SourceFile )-> $S ::  SourceFile ;  fn  eq ($self : &$S ::  SourceFile ,  other : &$S ::  SourceFile )->  bool ;  fn  path ($self : &$S ::  SourceFile )->  String ;  fn  is_real ($self : &$S ::  SourceFile )->  bool ; },  MultiSpan { fn  drop ($self : $S ::  MultiSpan );  fn  new ()-> $S ::  MultiSpan ;  fn  push ($self : &  mut $S ::  MultiSpan ,  span : $S ::  Span ); },  Diagnostic { fn  drop ($self : $S ::  Diagnostic );  fn  new ( level :  Level ,  msg : &  str ,  span : $S ::  MultiSpan )-> $S ::  Diagnostic ;  fn  sub ($self : &  mut $S ::  Diagnostic ,  level :  Level ,  msg : &  str ,  span : $S ::  MultiSpan , );  fn  emit ($self : $S ::  Diagnostic ); },  Span { fn  debug ($self : $S ::  Span )->  String ;  fn  def_site ()-> $S ::  Span ;  fn  call_site ()-> $S ::  Span ;  fn  mixed_site ()-> $S ::  Span ;  fn  source_file ($self : $S ::  Span )-> $S ::  SourceFile ;  fn  parent ($self : $S ::  Span )->  Option <$S ::  Span >;  fn  source ($self : $S ::  Span )-> $S ::  Span ;  fn  start ($self : $S ::  Span )->  LineColumn ;  fn  end ($self : $S ::  Span )->  LineColumn ;  fn  join ($self : $S ::  Span ,  other : $S ::  Span )->  Option <$S ::  Span >;  fn  resolved_at ($self : $S ::  Span ,  at : $S ::  Span )-> $S ::  Span ;  fn  source_text ($self : $S ::  Span )->  Option <  String >; }, }}; }
macro_rules! __ra_macro_fixture378 {( le $ty :  ty )=>{ impl <  S >  Encode <  S >  for $ty { fn  encode ( self ,  w : &  mut  Writer , _: &  mut  S ){ w .  write_all (&  self .  to_le_bytes ()).  unwrap (); }} impl <  S >  DecodeMut < '_ , '_ ,  S >  for $ty { fn  decode ( r : &  mut  Reader < '_ >, _: &  mut  S )->  Self { const  N :  usize = ::  std ::  mem ::  size_of ::<$ty > ();  let  mut  bytes = [ 0 ;  N ];  bytes .  copy_from_slice (&  r [..  N ]); *  r = &  r [ N ..];  Self ::  from_le_bytes ( bytes )}}}; ( struct $name :  ident {$($field :  ident ),* $(,)? })=>{ impl <  S >  Encode <  S >  for $name { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  S ){$(self .$field .  encode ( w ,  s );)* }} impl <  S >  DecodeMut < '_ , '_ ,  S >  for $name { fn  decode ( r : &  mut  Reader < '_ >,  s : &  mut  S )->  Self {$name {$($field :  DecodeMut ::  decode ( r ,  s )),* }}}}; ( enum $name :  ident $(<$($T :  ident ),+>)? {$($variant :  ident $(($field :  ident ))*),* $(,)? })=>{ impl <  S , $($($T :  Encode <  S >),+)?>  Encode <  S >  for $name $(<$($T ),+>)? { fn  encode ( self ,  w : &  mut  Writer ,  s : &  mut  S ){# [ allow ( non_upper_case_globals )] mod  tag {# [ repr ( u8 )] enum  Tag {$($variant ),* }$(pub  const $variant :  u8 =  Tag ::$variant  as  u8 ;)* } match  self {$($name ::$variant $(($field ))* =>{ tag ::$variant .  encode ( w ,  s ); $($field .  encode ( w ,  s );)* })* }}} impl < 'a ,  S , $($($T :  for < 's >  DecodeMut < 'a , 's ,  S >),+)?>  DecodeMut < 'a , '_ ,  S >  for $name $(<$($T ),+>)? { fn  decode ( r : &  mut  Reader < 'a >,  s : &  mut  S )->  Self {# [ allow ( non_upper_case_globals )] mod  tag {# [ repr ( u8 )] enum  Tag {$($variant ),* }$(pub  const $variant :  u8 =  Tag ::$variant  as  u8 ;)* } match  u8 ::  decode ( r ,  s ){$(tag ::$variant =>{$(let $field =  DecodeMut ::  decode ( r ,  s );)* $name ::$variant $(($field ))* })* _ => unreachable ! (), }}}}}
macro_rules! __ra_macro_fixture379 {($($ty :  ty ),* $(,)?)=>{$(impl  Mark  for $ty { type  Unmarked =  Self ;  fn  mark ( unmarked :  Self ::  Unmarked )->  Self { unmarked }} impl  Unmark  for $ty { type  Unmarked =  Self ;  fn  unmark ( self )->  Self ::  Unmarked { self }})* }}
macro_rules! __ra_macro_fixture380 {($($name :  ident {$(fn $method :  ident ($($arg :  ident : $arg_ty :  ty ),* $(,)?)$(-> $ret_ty :  ty )*;)* }),* $(,)?)=>{$(impl $name {# [ allow ( unused )]$(pub ( crate ) fn $method ($($arg : $arg_ty ),*)$(-> $ret_ty )* { panic ! ( "hello" ); })* })* }}
macro_rules! __ra_macro_fixture381 {($($name :  ident {$(fn $method :  ident ($($arg :  ident : $arg_ty :  ty ),* $(,)?)$(-> $ret_ty :  ty )?;)* }),* $(,)?)=>{ pub  trait  Types {$(associated_item ! ( type $name );)* }$(pub  trait $name :  Types {$(associated_item ! ( fn $method (&  mut  self , $($arg : $arg_ty ),*)$(-> $ret_ty )?);)* })*  pub  trait  Server :  Types $(+ $name )* {} impl <  S :  Types $(+ $name )*>  Server  for  S {}}}
macro_rules! __ra_macro_fixture382 {($($name :  ident {$(fn $method :  ident ($($arg :  ident : $arg_ty :  ty ),* $(,)?)$(-> $ret_ty :  ty )?;)* }),* $(,)?)=>{ impl <  S :  Types >  Types  for  MarkedTypes <  S > {$(type $name =  Marked <  S ::$name ,  client ::$name >;)* }$(impl <  S : $name > $name  for  MarkedTypes <  S > {$(fn $method (&  mut  self , $($arg : $arg_ty ),*)$(-> $ret_ty )? {<_>::  mark ($name ::$method (&  mut  self .  0 , $($arg .  unmark ()),*))})* })* }}
macro_rules! __ra_macro_fixture383 {($($name :  ident {$(fn $method :  ident ($($arg :  ident : $arg_ty :  ty ),* $(,)?)$(-> $ret_ty :  ty )?;)* }),* $(,)?)=>{ pub  trait  DispatcherTrait {$(type $name ;)*  fn  dispatch (&  mut  self ,  b :  Buffer <  u8 >)->  Buffer <  u8 >; } impl <  S :  Server >  DispatcherTrait  for  Dispatcher <  MarkedTypes <  S >> {$(type $name = <  MarkedTypes <  S >  as  Types >::$name ;)*  fn  dispatch (&  mut  self ,  mut  b :  Buffer <  u8 >)->  Buffer <  u8 > { let  Dispatcher { handle_store ,  server }=  self ;  let  mut  reader = &  b [..];  match  api_tags ::  Method ::  decode (&  mut  reader , &  mut ()){$(api_tags ::  Method ::$name ( m )=> match  m {$(api_tags ::$name ::$method =>{ let  mut  call_method = || { reverse_decode ! ( reader ,  handle_store ; $($arg : $arg_ty ),*); $name ::$method ( server , $($arg ),*)};  let  r =  if  thread ::  panicking (){ Ok ( call_method ())} else { panic ::  catch_unwind ( panic ::  AssertUnwindSafe ( call_method )).  map_err ( PanicMessage ::  from )};  b .  clear ();  r .  encode (&  mut  b ,  handle_store ); })* }),* } b }}}}
macro_rules! __ra_macro_fixture384 {($($name :  ident {$(fn $method :  ident ($($arg :  ident : $arg_ty :  ty ),* $(,)?)$(-> $ret_ty :  ty )*;)* }),* $(,)?)=>{$(pub ( super ) enum $name {$($method ),* } rpc_encode_decode ! ( enum $name {$($method ),* }); )*  pub ( super ) enum  Method {$($name ($name )),* } rpc_encode_decode ! ( enum  Method {$($name ( m )),* }); }}
macro_rules! __ra_macro_fixture385 {($(($ident :  ident , $string :  literal )),*$(,)?)=>{$(pub ( crate ) const $ident :  SemanticTokenType =  SemanticTokenType ::  new ($string );)*  pub ( crate ) const  SUPPORTED_TYPES : & [ SemanticTokenType ]= & [ SemanticTokenType ::  COMMENT ,  SemanticTokenType ::  KEYWORD ,  SemanticTokenType ::  STRING ,  SemanticTokenType ::  NUMBER ,  SemanticTokenType ::  REGEXP ,  SemanticTokenType ::  OPERATOR ,  SemanticTokenType ::  NAMESPACE ,  SemanticTokenType ::  TYPE ,  SemanticTokenType ::  STRUCT ,  SemanticTokenType ::  CLASS ,  SemanticTokenType ::  INTERFACE ,  SemanticTokenType ::  ENUM ,  SemanticTokenType ::  ENUM_MEMBER ,  SemanticTokenType ::  TYPE_PARAMETER ,  SemanticTokenType ::  FUNCTION ,  SemanticTokenType ::  METHOD ,  SemanticTokenType ::  PROPERTY ,  SemanticTokenType ::  MACRO ,  SemanticTokenType ::  VARIABLE ,  SemanticTokenType ::  PARAMETER , $($ident ),* ]; }; }
macro_rules! __ra_macro_fixture386 {($(($ident :  ident , $string :  literal )),*$(,)?)=>{$(pub ( crate ) const $ident :  SemanticTokenModifier =  SemanticTokenModifier ::  new ($string );)*  pub ( crate ) const  SUPPORTED_MODIFIERS : & [ SemanticTokenModifier ]= & [ SemanticTokenModifier ::  DOCUMENTATION ,  SemanticTokenModifier ::  DECLARATION ,  SemanticTokenModifier ::  DEFINITION ,  SemanticTokenModifier ::  STATIC ,  SemanticTokenModifier ::  ABSTRACT ,  SemanticTokenModifier ::  DEPRECATED ,  SemanticTokenModifier ::  READONLY , $($ident ),* ]; }; }
macro_rules! __ra_macro_fixture387 {( struct $name :  ident {$($(# [ doc =$doc :  literal ])* $field :  ident $(| $alias :  ident )?: $ty :  ty = $default :  expr , )* })=>{# [ allow ( non_snake_case )]# [ derive ( Debug ,  Clone )] struct $name {$($field : $ty ,)* } impl $name { fn  from_json ( mut  json :  serde_json ::  Value )-> $name {$name {$($field :  get_field (&  mut  json ,  stringify ! ($field ),  None $(.  or ( Some ( stringify ! ($alias ))))?, $default , ), )*}} fn  json_schema ()->  serde_json ::  Value { schema (& [$({let  field =  stringify ! ($field );  let  ty =  stringify ! ($ty ); ( field ,  ty , & [$($doc ),*], $default )},)* ])}# [ cfg ( test )] fn  manual ()->  String { manual (& [$({let  field =  stringify ! ($field );  let  ty =  stringify ! ($ty ); ( field ,  ty , & [$($doc ),*], $default )},)* ])}}}; }
macro_rules! __ra_macro_fixture388 {($($name :  ident ($value :  expr ),)*)=>{ mod  bench_ryu { use  super ::*; $(# [ bench ] fn $name ( b : &  mut  Bencher ){ let  mut  buf =  ryu ::  Buffer ::  new ();  b .  iter ( move || { let  value =  black_box ($value );  let  formatted =  buf .  format_finite ( value );  black_box ( formatted ); }); })* } mod  bench_std_fmt { use  super ::*; $(# [ bench ] fn $name ( b : &  mut  Bencher ){ let  mut  buf =  Vec ::  with_capacity ( 20 );  b .  iter (|| { buf .  clear ();  let  value =  black_box ($value );  write ! (&  mut  buf ,  "{}" ,  value ).  unwrap ();  black_box ( buf .  as_slice ()); }); })* }}; }
macro_rules! __ra_macro_fixture389 {($($T :  ident ),*)=>{$(mod $T { use  test ::  Bencher ;  use  num_integer :: { Average ,  Integer };  use  super :: { UncheckedAverage ,  NaiveAverage ,  ModuloAverage };  use  super :: { bench_ceil ,  bench_floor ,  bench_unchecked };  naive_average ! ($T );  unchecked_average ! ($T );  modulo_average ! ($T );  const  SIZE : $T =  30 ;  fn  overflowing ()->  Vec < ($T , $T )> {(($T ::  max_value ()-  SIZE )..$T ::  max_value ()).  flat_map (|  x | ->  Vec <_> {(($T ::  max_value ()-  100 ).. ($T ::  max_value ()-  100 +  SIZE )).  map (|  y | ( x ,  y )).  collect ()}).  collect ()} fn  small ()->  Vec < ($T , $T )> {( 0 ..  SIZE ).  flat_map (|  x | ->  Vec <_> {( 0 ..  SIZE ).  map (|  y | ( x ,  y )).  collect ()}).  collect ()} fn  rand ()->  Vec < ($T , $T )> { small ().  into_iter ().  map (| ( x ,  y )| ( super ::  lcg ( x ),  super ::  lcg ( y ))).  collect ()} mod  ceil { use  super ::*;  mod  small { use  super ::*; # [ bench ] fn  optimized ( b : &  mut  Bencher ){ let  v =  small ();  bench_ceil ( b , &  v , |  x : &$T ,  y : &$T |  x .  average_ceil ( y )); }# [ bench ] fn  naive ( b : &  mut  Bencher ){ let  v =  small ();  bench_ceil ( b , &  v , |  x : &$T ,  y : &$T |  x .  naive_average_ceil ( y )); }# [ bench ] fn  unchecked ( b : &  mut  Bencher ){ let  v =  small ();  bench_unchecked ( b , &  v , |  x : &$T ,  y : &$T |  x .  unchecked_average_ceil ( y )); }# [ bench ] fn  modulo ( b : &  mut  Bencher ){ let  v =  small ();  bench_ceil ( b , &  v , |  x : &$T ,  y : &$T |  x .  modulo_average_ceil ( y )); }} mod  overflowing { use  super ::*; # [ bench ] fn  optimized ( b : &  mut  Bencher ){ let  v =  overflowing ();  bench_ceil ( b , &  v , |  x : &$T ,  y : &$T |  x .  average_ceil ( y )); }# [ bench ] fn  naive ( b : &  mut  Bencher ){ let  v =  overflowing ();  bench_ceil ( b , &  v , |  x : &$T ,  y : &$T |  x .  naive_average_ceil ( y )); }# [ bench ] fn  unchecked ( b : &  mut  Bencher ){ let  v =  overflowing ();  bench_unchecked ( b , &  v , |  x : &$T ,  y : &$T |  x .  unchecked_average_ceil ( y )); }# [ bench ] fn  modulo ( b : &  mut  Bencher ){ let  v =  overflowing ();  bench_ceil ( b , &  v , |  x : &$T ,  y : &$T |  x .  modulo_average_ceil ( y )); }} mod  rand { use  super ::*; # [ bench ] fn  optimized ( b : &  mut  Bencher ){ let  v =  rand ();  bench_ceil ( b , &  v , |  x : &$T ,  y : &$T |  x .  average_ceil ( y )); }# [ bench ] fn  naive ( b : &  mut  Bencher ){ let  v =  rand ();  bench_ceil ( b , &  v , |  x : &$T ,  y : &$T |  x .  naive_average_ceil ( y )); }# [ bench ] fn  unchecked ( b : &  mut  Bencher ){ let  v =  rand ();  bench_unchecked ( b , &  v , |  x : &$T ,  y : &$T |  x .  unchecked_average_ceil ( y )); }# [ bench ] fn  modulo ( b : &  mut  Bencher ){ let  v =  rand ();  bench_ceil ( b , &  v , |  x : &$T ,  y : &$T |  x .  modulo_average_ceil ( y )); }}} mod  floor { use  super ::*;  mod  small { use  super ::*; # [ bench ] fn  optimized ( b : &  mut  Bencher ){ let  v =  small ();  bench_floor ( b , &  v , |  x : &$T ,  y : &$T |  x .  average_floor ( y )); }# [ bench ] fn  naive ( b : &  mut  Bencher ){ let  v =  small ();  bench_floor ( b , &  v , |  x : &$T ,  y : &$T |  x .  naive_average_floor ( y )); }# [ bench ] fn  unchecked ( b : &  mut  Bencher ){ let  v =  small ();  bench_unchecked ( b , &  v , |  x : &$T ,  y : &$T |  x .  unchecked_average_floor ( y )); }# [ bench ] fn  modulo ( b : &  mut  Bencher ){ let  v =  small ();  bench_floor ( b , &  v , |  x : &$T ,  y : &$T |  x .  modulo_average_floor ( y )); }} mod  overflowing { use  super ::*; # [ bench ] fn  optimized ( b : &  mut  Bencher ){ let  v =  overflowing ();  bench_floor ( b , &  v , |  x : &$T ,  y : &$T |  x .  average_floor ( y )); }# [ bench ] fn  naive ( b : &  mut  Bencher ){ let  v =  overflowing ();  bench_floor ( b , &  v , |  x : &$T ,  y : &$T |  x .  naive_average_floor ( y )); }# [ bench ] fn  unchecked ( b : &  mut  Bencher ){ let  v =  overflowing ();  bench_unchecked ( b , &  v , |  x : &$T ,  y : &$T |  x .  unchecked_average_floor ( y )); }# [ bench ] fn  modulo ( b : &  mut  Bencher ){ let  v =  overflowing ();  bench_floor ( b , &  v , |  x : &$T ,  y : &$T |  x .  modulo_average_floor ( y )); }} mod  rand { use  super ::*; # [ bench ] fn  optimized ( b : &  mut  Bencher ){ let  v =  rand ();  bench_floor ( b , &  v , |  x : &$T ,  y : &$T |  x .  average_floor ( y )); }# [ bench ] fn  naive ( b : &  mut  Bencher ){ let  v =  rand ();  bench_floor ( b , &  v , |  x : &$T ,  y : &$T |  x .  naive_average_floor ( y )); }# [ bench ] fn  unchecked ( b : &  mut  Bencher ){ let  v =  rand ();  bench_unchecked ( b , &  v , |  x : &$T ,  y : &$T |  x .  unchecked_average_floor ( y )); }# [ bench ] fn  modulo ( b : &  mut  Bencher ){ let  v =  rand ();  bench_floor ( b , &  v , |  x : &$T ,  y : &$T |  x .  modulo_average_floor ( y )); }}}})*}}
macro_rules! __ra_macro_fixture390 {($T :  ident )=>{ impl  super ::  NaiveAverage  for $T { fn  naive_average_floor (&  self ,  other : &$T )-> $T { match  self .  checked_add (*  other ){ Some ( z )=> z .  div_floor (&  2 ),  None =>{ if  self >  other { let  diff =  self -  other ;  other +  diff .  div_floor (&  2 )} else { let  diff =  other -  self ;  self +  diff .  div_floor (&  2 )}}}} fn  naive_average_ceil (&  self ,  other : &$T )-> $T { match  self .  checked_add (*  other ){ Some ( z )=> z .  div_ceil (&  2 ),  None =>{ if  self >  other { let  diff =  self -  other ;  self -  diff .  div_floor (&  2 )} else { let  diff =  other -  self ;  other -  diff .  div_floor (&  2 )}}}}}}; }
macro_rules! __ra_macro_fixture391 {($T :  ident )=>{ impl  super ::  UncheckedAverage  for $T { fn  unchecked_average_floor (&  self ,  other : &$T )-> $T { self .  wrapping_add (*  other )/  2 } fn  unchecked_average_ceil (&  self ,  other : &$T )-> $T {( self .  wrapping_add (*  other )/  2 ).  wrapping_add ( 1 )}}}; }
macro_rules! __ra_macro_fixture392 {($T :  ident )=>{ impl  super ::  ModuloAverage  for $T { fn  modulo_average_ceil (&  self ,  other : &$T )-> $T { let ( q1 ,  r1 )=  self .  div_mod_floor (&  2 );  let ( q2 ,  r2 )=  other .  div_mod_floor (&  2 );  q1 +  q2 + ( r1 |  r2 )} fn  modulo_average_floor (&  self ,  other : &$T )-> $T { let ( q1 ,  r1 )=  self .  div_mod_floor (&  2 );  let ( q2 ,  r2 )=  other .  div_mod_floor (&  2 );  q1 +  q2 + ( r1 *  r2 )}}}; }
macro_rules! __ra_macro_fixture393 {($N :  expr , $FUN :  ident , $BENCH_NAME :  ident , )=>( mod $BENCH_NAME { use  super ::*;  pub  fn  sum ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 .. $N ).  collect ();  c .  bench_function (& ( stringify ! ($BENCH_NAME ).  replace ( '_' ,  " " )+  " sum" ),  move |  b | { b .  iter (|| { cloned (&  v ).$FUN (|  x ,  y |  x +  y )})}); } pub  fn  complex_iter ( c : &  mut  Criterion ){ let  u = ( 3 ..).  take ($N /  2 );  let  v = ( 5 ..).  take ($N /  2 );  let  it =  u .  chain ( v );  c .  bench_function (& ( stringify ! ($BENCH_NAME ).  replace ( '_' ,  " " )+  " complex iter" ),  move |  b | { b .  iter (|| { it .  clone ().  map (|  x |  x  as  f32 ).$FUN ( f32 ::  atan2 )})}); } pub  fn  string_format ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 .. ($N /  4 )).  collect ();  c .  bench_function (& ( stringify ! ($BENCH_NAME ).  replace ( '_' ,  " " )+  " string format" ),  move |  b | { b .  iter (|| { cloned (&  v ).  map (|  x |  x .  to_string ()).$FUN (|  x ,  y |  format ! ( "{} + {}" ,  x ,  y ))})}); }} criterion_group ! ($BENCH_NAME , $BENCH_NAME ::  sum , $BENCH_NAME ::  complex_iter , $BENCH_NAME ::  string_format , ); )}
macro_rules! __ra_macro_fixture394 {($ast :  ident , $kind :  ident )=>{# [ derive ( PartialEq ,  Eq ,  Hash )]# [ repr ( transparent )] struct $ast ( SyntaxNode );  impl $ast {# [ allow ( unused )] fn  cast ( node :  SyntaxNode )->  Option <  Self > { if  node .  kind ()== $kind { Some ( Self ( node ))} else { None }}}}; }
macro_rules! __ra_macro_fixture395 {($I :  ident , $U :  ident )=>{ mod $I { mod  ceil { use  num_integer ::  Average ; # [ test ] fn  same_sign (){ assert_eq ! (( 14  as $I ).  average_ceil (&  16 ),  15  as $I );  assert_eq ! (( 14  as $I ).  average_ceil (&  17 ),  16  as $I );  let  max = $crate ::  std ::$I ::  MAX ;  assert_eq ! (( max -  3 ).  average_ceil (& ( max -  1 )),  max -  2 );  assert_eq ! (( max -  3 ).  average_ceil (& ( max -  2 )),  max -  2 ); }# [ test ] fn  different_sign (){ assert_eq ! (( 14  as $I ).  average_ceil (&-  4 ),  5  as $I );  assert_eq ! (( 14  as $I ).  average_ceil (&-  5 ),  5  as $I );  let  min = $crate ::  std ::$I ::  MIN ;  let  max = $crate ::  std ::$I ::  MAX ;  assert_eq ! ( min .  average_ceil (&  max ),  0  as $I ); }} mod  floor { use  num_integer ::  Average ; # [ test ] fn  same_sign (){ assert_eq ! (( 14  as $I ).  average_floor (&  16 ),  15  as $I );  assert_eq ! (( 14  as $I ).  average_floor (&  17 ),  15  as $I );  let  max = $crate ::  std ::$I ::  MAX ;  assert_eq ! (( max -  3 ).  average_floor (& ( max -  1 )),  max -  2 );  assert_eq ! (( max -  3 ).  average_floor (& ( max -  2 )),  max -  3 ); }# [ test ] fn  different_sign (){ assert_eq ! (( 14  as $I ).  average_floor (&-  4 ),  5  as $I );  assert_eq ! (( 14  as $I ).  average_floor (&-  5 ),  4  as $I );  let  min = $crate ::  std ::$I ::  MIN ;  let  max = $crate ::  std ::$I ::  MAX ;  assert_eq ! ( min .  average_floor (&  max ), -  1  as $I ); }}} mod $U { mod  ceil { use  num_integer ::  Average ; # [ test ] fn  bounded (){ assert_eq ! (( 14  as $U ).  average_ceil (&  16 ),  15  as $U );  assert_eq ! (( 14  as $U ).  average_ceil (&  17 ),  16  as $U ); }# [ test ] fn  overflow (){ let  max = $crate ::  std ::$U ::  MAX ;  assert_eq ! (( max -  3 ).  average_ceil (& ( max -  1 )),  max -  2 );  assert_eq ! (( max -  3 ).  average_ceil (& ( max -  2 )),  max -  2 ); }} mod  floor { use  num_integer ::  Average ; # [ test ] fn  bounded (){ assert_eq ! (( 14  as $U ).  average_floor (&  16 ),  15  as $U );  assert_eq ! (( 14  as $U ).  average_floor (&  17 ),  15  as $U ); }# [ test ] fn  overflow (){ let  max = $crate ::  std ::$U ::  MAX ;  assert_eq ! (( max -  3 ).  average_floor (& ( max -  1 )),  max -  2 );  assert_eq ! (( max -  3 ).  average_floor (& ( max -  2 )),  max -  3 ); }}}}; }
macro_rules! __ra_macro_fixture396 {($N :  expr ; $BENCH_GROUP :  ident , $TUPLE_FUN :  ident , $TUPLES :  ident , $TUPLE_WINDOWS :  ident ; $SLICE_FUN :  ident , $CHUNKS :  ident , $WINDOWS :  ident ; $FOR_CHUNKS :  ident , $FOR_WINDOWS :  ident )=>( fn $FOR_CHUNKS ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 .. $N *  1_000 ).  collect ();  let  mut  s =  0 ;  c .  bench_function (&  stringify ! ($FOR_CHUNKS ).  replace ( '_' ,  " " ),  move |  b | { b .  iter (|| { let  mut  j =  0 ;  for _  in  0 ..  1_000 { s += $SLICE_FUN (&  v [ j .. ( j + $N )]);  j += $N ; } s })}); } fn $FOR_WINDOWS ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 ..  1_000 ).  collect ();  let  mut  s =  0 ;  c .  bench_function (&  stringify ! ($FOR_WINDOWS ).  replace ( '_' ,  " " ),  move |  b | { b .  iter (|| { for  i  in  0 .. ( 1_000 - $N ){ s += $SLICE_FUN (&  v [ i .. ( i + $N )]); } s })}); } fn $TUPLES ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 .. $N *  1_000 ).  collect ();  let  mut  s =  0 ;  c .  bench_function (&  stringify ! ($TUPLES ).  replace ( '_' ,  " " ),  move |  b | { b .  iter (|| { for  x  in  v .  iter ().  tuples (){ s += $TUPLE_FUN (&  x ); } s })}); } fn $CHUNKS ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 .. $N *  1_000 ).  collect ();  let  mut  s =  0 ;  c .  bench_function (&  stringify ! ($CHUNKS ).  replace ( '_' ,  " " ),  move |  b | { b .  iter (|| { for  x  in  v .  chunks ($N ){ s += $SLICE_FUN ( x ); } s })}); } fn $TUPLE_WINDOWS ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 ..  1_000 ).  collect ();  let  mut  s =  0 ;  c .  bench_function (&  stringify ! ($TUPLE_WINDOWS ).  replace ( '_' ,  " " ),  move |  b | { b .  iter (|| { for  x  in  v .  iter ().  tuple_windows (){ s += $TUPLE_FUN (&  x ); } s })}); } fn $WINDOWS ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 ..  1_000 ).  collect ();  let  mut  s =  0 ;  c .  bench_function (&  stringify ! ($WINDOWS ).  replace ( '_' ,  " " ),  move |  b | { b .  iter (|| { for  x  in  v .  windows ($N ){ s += $SLICE_FUN ( x ); } s })}); } criterion_group ! ($BENCH_GROUP , $FOR_CHUNKS , $FOR_WINDOWS , $TUPLES , $CHUNKS , $TUPLE_WINDOWS , $WINDOWS , ); )}
macro_rules! __ra_macro_fixture397 {($N :  expr , $FUN :  ident , $BENCH_NAME :  ident , )=>( mod $BENCH_NAME { use  super ::*;  pub  fn  sum ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 .. $N ).  collect ();  c .  bench_function (& ( stringify ! ($BENCH_NAME ).  replace ( '_' ,  " " )+  " sum" ),  move |  b | { b .  iter (|| { cloned (&  v ).$FUN (|  x ,  y |  x +  y )})}); } pub  fn  complex_iter ( c : &  mut  Criterion ){ let  u = ( 3 ..).  take ($N /  2 );  let  v = ( 5 ..).  take ($N /  2 );  let  it =  u .  chain ( v );  c .  bench_function (& ( stringify ! ($BENCH_NAME ).  replace ( '_' ,  " " )+  " complex iter" ),  move |  b | { b .  iter (|| { it .  clone ().  map (|  x |  x  as  f32 ).$FUN ( f32 ::  atan2 )})}); } pub  fn  string_format ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 .. ($N /  4 )).  collect ();  c .  bench_function (& ( stringify ! ($BENCH_NAME ).  replace ( '_' ,  " " )+  " string format" ),  move |  b | { b .  iter (|| { cloned (&  v ).  map (|  x |  x .  to_string ()).$FUN (|  x ,  y |  format ! ( "{} + {}" ,  x ,  y ))})}); }} criterion_group ! ($BENCH_NAME , $BENCH_NAME ::  sum , $BENCH_NAME ::  complex_iter , $BENCH_NAME ::  string_format , ); )}
macro_rules! __ra_macro_fixture398 {($N :  expr ; $BENCH_GROUP :  ident , $TUPLE_FUN :  ident , $TUPLES :  ident , $TUPLE_WINDOWS :  ident ; $SLICE_FUN :  ident , $CHUNKS :  ident , $WINDOWS :  ident ; $FOR_CHUNKS :  ident , $FOR_WINDOWS :  ident )=>( fn $FOR_CHUNKS ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 .. $N *  1_000 ).  collect ();  let  mut  s =  0 ;  c .  bench_function (&  stringify ! ($FOR_CHUNKS ).  replace ( '_' ,  " " ),  move |  b | { b .  iter (|| { let  mut  j =  0 ;  for _  in  0 ..  1_000 { s += $SLICE_FUN (&  v [ j .. ( j + $N )]);  j += $N ; } s })}); } fn $FOR_WINDOWS ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 ..  1_000 ).  collect ();  let  mut  s =  0 ;  c .  bench_function (&  stringify ! ($FOR_WINDOWS ).  replace ( '_' ,  " " ),  move |  b | { b .  iter (|| { for  i  in  0 .. ( 1_000 - $N ){ s += $SLICE_FUN (&  v [ i .. ( i + $N )]); } s })}); } fn $TUPLES ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 .. $N *  1_000 ).  collect ();  let  mut  s =  0 ;  c .  bench_function (&  stringify ! ($TUPLES ).  replace ( '_' ,  " " ),  move |  b | { b .  iter (|| { for  x  in  v .  iter ().  tuples (){ s += $TUPLE_FUN (&  x ); } s })}); } fn $CHUNKS ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 .. $N *  1_000 ).  collect ();  let  mut  s =  0 ;  c .  bench_function (&  stringify ! ($CHUNKS ).  replace ( '_' ,  " " ),  move |  b | { b .  iter (|| { for  x  in  v .  chunks ($N ){ s += $SLICE_FUN ( x ); } s })}); } fn $TUPLE_WINDOWS ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 ..  1_000 ).  collect ();  let  mut  s =  0 ;  c .  bench_function (&  stringify ! ($TUPLE_WINDOWS ).  replace ( '_' ,  " " ),  move |  b | { b .  iter (|| { for  x  in  v .  iter ().  tuple_windows (){ s += $TUPLE_FUN (&  x ); } s })}); } fn $WINDOWS ( c : &  mut  Criterion ){ let  v :  Vec <  u32 > = ( 0 ..  1_000 ).  collect ();  let  mut  s =  0 ;  c .  bench_function (&  stringify ! ($WINDOWS ).  replace ( '_' ,  " " ),  move |  b | { b .  iter (|| { for  x  in  v .  windows ($N ){ s += $SLICE_FUN ( x ); } s })}); } criterion_group ! ($BENCH_GROUP , $FOR_CHUNKS , $FOR_WINDOWS , $TUPLES , $CHUNKS , $TUPLE_WINDOWS , $WINDOWS , ); )}
macro_rules! __ra_macro_fixture399 {($name :  ident : $e :  expr )=>{# [ cfg_attr ( target_arch =  "wasm32" ,  wasm_bindgen_test ::  wasm_bindgen_test )]# [ test ] fn $name (){ let ( subscriber ,  handle )=  subscriber ::  mock ().  event ( event ::  mock ().  with_fields ( field ::  mock ( "answer" ).  with_value (&  42 ).  and ( field ::  mock ( "to_question" ).  with_value (&  "life, the universe, and everything" ), ).  only (), ), ).  done ().  run_with_handle ();  with_default ( subscriber , || { info ! ( answer = $e ,  to_question =  "life, the universe, and everything" ); });  handle .  assert_finished (); }}; }
macro_rules! __ra_macro_fixture400 {($T :  ty )=>{ impl  GcdOld  for $T {# [ doc =  " Calculates the Greatest Common Divisor (GCD) of the number and" ]# [ doc =  " `other`. The result is always positive." ]# [ inline ] fn  gcd_old (&  self ,  other : &  Self )->  Self { let  mut  m = *  self ;  let  mut  n = *  other ;  if  m ==  0 ||  n ==  0 { return ( m |  n ).  abs (); } let  shift = ( m |  n ).  trailing_zeros ();  if  m ==  Self ::  min_value ()||  n ==  Self ::  min_value (){ return ( 1 <<  shift ).  abs (); } m =  m .  abs ();  n =  n .  abs ();  n >>=  n .  trailing_zeros ();  while  m !=  0 { m >>=  m .  trailing_zeros ();  if  n >  m { std ::  mem ::  swap (&  mut  n , &  mut  m )} m -=  n ; } n <<  shift }}}; }
macro_rules! __ra_macro_fixture401 {($T :  ty )=>{ impl  GcdOld  for $T {# [ doc =  " Calculates the Greatest Common Divisor (GCD) of the number and" ]# [ doc =  " `other`. The result is always positive." ]# [ inline ] fn  gcd_old (&  self ,  other : &  Self )->  Self { let  mut  m = *  self ;  let  mut  n = *  other ;  if  m ==  0 ||  n ==  0 { return  m |  n ; } let  shift = ( m |  n ).  trailing_zeros ();  n >>=  n .  trailing_zeros ();  while  m !=  0 { m >>=  m .  trailing_zeros ();  if  n >  m { std ::  mem ::  swap (&  mut  n , &  mut  m )} m -=  n ; } n <<  shift }}}; }
macro_rules! __ra_macro_fixture402 {($T :  ident )=>{ mod $T { use  crate :: { run_bench ,  GcdOld };  use  num_integer ::  Integer ;  use  test ::  Bencher ; # [ bench ] fn  bench_gcd ( b : &  mut  Bencher ){ run_bench ( b , $T ::  gcd ); }# [ bench ] fn  bench_gcd_old ( b : &  mut  Bencher ){ run_bench ( b , $T ::  gcd_old ); }}}; }
macro_rules! __ra_macro_fixture403 {($f :  ident , $($t :  ty ),+)=>{$(paste ::  item ! { qc ::  quickcheck ! { fn [< $f _ $t >]( i :  RandIter <$t >,  k :  u16 )-> (){$f ( i ,  k )}}})+ }; }
macro_rules! __ra_macro_fixture404 {($name :  ident )=>{# [ derive ( Debug )] struct $name { message : & 'static  str ,  drop :  DetectDrop , } impl  Display  for $name { fn  fmt (&  self ,  f : &  mut  fmt ::  Formatter )->  fmt ::  Result { f .  write_str ( self .  message )}}}; }
macro_rules! __ra_macro_fixture405 {($($(# [$attr :  meta ])* $name :  ident ($value :  expr )),* )=>{ mod  bench_itoa_write { use  test :: { Bencher ,  black_box }; $($(# [$attr ])* # [ bench ] fn $name ( b : &  mut  Bencher ){ use  itoa ;  let  mut  buf =  Vec ::  with_capacity ( 40 );  b .  iter (|| { buf .  clear ();  itoa ::  write (&  mut  buf ,  black_box ($value )).  unwrap ()}); })* } mod  bench_itoa_fmt { use  test :: { Bencher ,  black_box }; $($(# [$attr ])* # [ bench ] fn $name ( b : &  mut  Bencher ){ use  itoa ;  let  mut  buf =  String ::  with_capacity ( 40 );  b .  iter (|| { buf .  clear ();  itoa ::  fmt (&  mut  buf ,  black_box ($value )).  unwrap ()}); })* } mod  bench_std_fmt { use  test :: { Bencher ,  black_box }; $($(# [$attr ])* # [ bench ] fn $name ( b : &  mut  Bencher ){ use  std ::  io ::  Write ;  let  mut  buf =  Vec ::  with_capacity ( 40 );  b .  iter (|| { buf .  clear ();  write ! (&  mut  buf ,  "{}" ,  black_box ($value )).  unwrap ()}); })* }}}
macro_rules! __ra_macro_fixture406 {($typ :  ty {$($b_name :  ident =>$g_name :  ident ($($args :  expr ),*),)* })=>{$(# [ bench ] fn $b_name ( b : &  mut  Bencher ){$g_name ::<$typ > ($($args ,)*  b )})* }}
macro_rules! __ra_macro_fixture407 {($($T :  ident ),*)=>{$(mod $T { use  test ::  Bencher ;  use  num_integer ::  Roots ; # [ bench ] fn  sqrt_rand ( b : &  mut  Bencher ){::  bench_rand_pos ( b , $T ::  sqrt ,  2 ); }# [ bench ] fn  sqrt_small ( b : &  mut  Bencher ){::  bench_small_pos ( b , $T ::  sqrt ,  2 ); }# [ bench ] fn  cbrt_rand ( b : &  mut  Bencher ){::  bench_rand ( b , $T ::  cbrt ,  3 ); }# [ bench ] fn  cbrt_small ( b : &  mut  Bencher ){::  bench_small ( b , $T ::  cbrt ,  3 ); }# [ bench ] fn  fourth_root_rand ( b : &  mut  Bencher ){::  bench_rand_pos ( b , |  x : &$T |  x .  nth_root ( 4 ),  4 ); }# [ bench ] fn  fourth_root_small ( b : &  mut  Bencher ){::  bench_small_pos ( b , |  x : &$T |  x .  nth_root ( 4 ),  4 ); }# [ bench ] fn  fifth_root_rand ( b : &  mut  Bencher ){::  bench_rand ( b , |  x : &$T |  x .  nth_root ( 5 ),  5 ); }# [ bench ] fn  fifth_root_small ( b : &  mut  Bencher ){::  bench_small ( b , |  x : &$T |  x .  nth_root ( 5 ),  5 ); }})*}}
macro_rules! __ra_macro_fixture408 {($name :  ident , $level :  expr )=>{# [ doc =  " Creates a new `Diagnostic` with the given `message` at the span" ]# [ doc =  " `self`." ] pub  fn $name <  T :  Into <  String >> ( self ,  message :  T )->  Diagnostic { Diagnostic ::  spanned ( self , $level ,  message )}}; }
macro_rules! __ra_macro_fixture409 {($($name :  ident =>$kind :  ident ,)*)=>($(# [ doc =  " Creates a new suffixed integer literal with the specified value." ]# [ doc =  "" ]# [ doc =  " This function will create an integer like `1u32` where the integer" ]# [ doc =  " value specified is the first part of the token and the integral is" ]# [ doc =  " also suffixed at the end." ]# [ doc =  " Literals created from negative numbers may not survive round-trips through" ]# [ doc =  " `TokenStream` or strings and may be broken into two tokens (`-` and positive literal)." ]# [ doc =  "" ]# [ doc =  " Literals created through this method have the `Span::call_site()`" ]# [ doc =  " span by default, which can be configured with the `set_span` method" ]# [ doc =  " below." ] pub  fn $name ( n : $kind )->  Literal { Literal ( bridge ::  client ::  Literal ::  typed_integer (&  n .  to_string (),  stringify ! ($kind )))})*)}
macro_rules! __ra_macro_fixture410 {($($name :  ident =>$kind :  ident ,)*)=>($(# [ doc =  " Creates a new unsuffixed integer literal with the specified value." ]# [ doc =  "" ]# [ doc =  " This function will create an integer like `1` where the integer" ]# [ doc =  " value specified is the first part of the token. No suffix is" ]# [ doc =  " specified on this token, meaning that invocations like" ]# [ doc =  " `Literal::i8_unsuffixed(1)` are equivalent to" ]# [ doc =  " `Literal::u32_unsuffixed(1)`." ]# [ doc =  " Literals created from negative numbers may not survive rountrips through" ]# [ doc =  " `TokenStream` or strings and may be broken into two tokens (`-` and positive literal)." ]# [ doc =  "" ]# [ doc =  " Literals created through this method have the `Span::call_site()`" ]# [ doc =  " span by default, which can be configured with the `set_span` method" ]# [ doc =  " below." ] pub  fn $name ( n : $kind )->  Literal { Literal ( bridge ::  client ::  Literal ::  integer (&  n .  to_string ()))})*)}
macro_rules! __ra_macro_fixture411 {($spanned :  ident , $regular :  ident , $level :  expr )=>{# [ doc =  " Adds a new child diagnostic message to `self` with the level" ]# [ doc =  " identified by this method\\\'s name with the given `spans` and" ]# [ doc =  " `message`." ] pub  fn $spanned <  S ,  T > ( mut  self ,  spans :  S ,  message :  T )->  Diagnostic  where  S :  MultiSpan ,  T :  Into <  String >, { self .  children .  push ( Diagnostic ::  spanned ( spans , $level ,  message ));  self }# [ doc =  " Adds a new child diagnostic message to `self` with the level" ]# [ doc =  " identified by this method\\\'s name with the given `message`." ] pub  fn $regular <  T :  Into <  String >> ( mut  self ,  message :  T )->  Diagnostic { self .  children .  push ( Diagnostic ::  new ($level ,  message ));  self }}; }
macro_rules! __ra_macro_fixture412 {($($arg :  tt )*)=>{{ let  res = $crate ::  fmt ::  format ($crate ::  __export ::  format_args ! ($($arg )*));  res }}}
macro_rules! __ra_macro_fixture413 {($dst :  expr , $($arg :  tt )*)=>($dst .  write_fmt ($crate ::  format_args ! ($($arg )*)))}
macro_rules! __ra_macro_fixture414 {($dst :  expr $(,)?)=>($crate ::  write ! ($dst ,  "\n" )); ($dst :  expr , $($arg :  tt )*)=>($dst .  write_fmt ($crate ::  format_args_nl ! ($($arg )*))); }
macro_rules! __ra_macro_fixture415 {($($name :  ident =>$kind :  ident ,)*)=>($(# [ doc =  " Creates a new suffixed integer literal with the specified value." ]# [ doc =  "" ]# [ doc =  " This function will create an integer like `1u32` where the integer" ]# [ doc =  " value specified is the first part of the token and the integral is" ]# [ doc =  " also suffixed at the end. Literals created from negative numbers may" ]# [ doc =  " not survive rountrips through `TokenStream` or strings and may be" ]# [ doc =  " broken into two tokens (`-` and positive literal)." ]# [ doc =  "" ]# [ doc =  " Literals created through this method have the `Span::call_site()`" ]# [ doc =  " span by default, which can be configured with the `set_span` method" ]# [ doc =  " below." ] pub  fn $name ( n : $kind )->  Literal { Literal ::  _new ( imp ::  Literal ::$name ( n ))})*)}
macro_rules! __ra_macro_fixture416 {($($name :  ident =>$kind :  ident ,)*)=>($(# [ doc =  " Creates a new unsuffixed integer literal with the specified value." ]# [ doc =  "" ]# [ doc =  " This function will create an integer like `1` where the integer" ]# [ doc =  " value specified is the first part of the token. No suffix is" ]# [ doc =  " specified on this token, meaning that invocations like" ]# [ doc =  " `Literal::i8_unsuffixed(1)` are equivalent to" ]# [ doc =  " `Literal::u32_unsuffixed(1)`. Literals created from negative numbers" ]# [ doc =  " may not survive rountrips through `TokenStream` or strings and may" ]# [ doc =  " be broken into two tokens (`-` and positive literal)." ]# [ doc =  "" ]# [ doc =  " Literals created through this method have the `Span::call_site()`" ]# [ doc =  " span by default, which can be configured with the `set_span` method" ]# [ doc =  " below." ] pub  fn $name ( n : $kind )->  Literal { Literal ::  _new ( imp ::  Literal ::$name ( n ))})*)}
macro_rules! __ra_macro_fixture417 {($($name :  ident =>$kind :  ident ,)*)=>($(pub  fn $name ( n : $kind )->  Literal { Literal ::  _new ( format ! ( concat ! ( "{}" ,  stringify ! ($kind )),  n ))})*)}
macro_rules! __ra_macro_fixture418 {($($name :  ident =>$kind :  ident ,)*)=>($(pub  fn $name ( n : $kind )->  Literal { Literal ::  _new ( n .  to_string ())})*)}
macro_rules! __ra_macro_fixture419 {(<$visitor :  ident :  Visitor <$lifetime :  tt >> $($func :  ident )*)=>{$(forward_to_deserialize_any_helper ! {$func <$lifetime , $visitor >})* }; ($($func :  ident )*)=>{$(forward_to_deserialize_any_helper ! {$func < 'de ,  V >})* }; }
macro_rules! __ra_macro_fixture420 {( bool <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_bool <$l , $v > ()}}; ( i8 <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_i8 <$l , $v > ()}}; ( i16 <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_i16 <$l , $v > ()}}; ( i32 <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_i32 <$l , $v > ()}}; ( i64 <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_i64 <$l , $v > ()}}; ( i128 <$l :  tt , $v :  ident >)=>{ serde_if_integer128 ! { forward_to_deserialize_any_method ! { deserialize_i128 <$l , $v > ()}}}; ( u8 <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_u8 <$l , $v > ()}}; ( u16 <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_u16 <$l , $v > ()}}; ( u32 <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_u32 <$l , $v > ()}}; ( u64 <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_u64 <$l , $v > ()}}; ( u128 <$l :  tt , $v :  ident >)=>{ serde_if_integer128 ! { forward_to_deserialize_any_method ! { deserialize_u128 <$l , $v > ()}}}; ( f32 <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_f32 <$l , $v > ()}}; ( f64 <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_f64 <$l , $v > ()}}; ( char <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_char <$l , $v > ()}}; ( str <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_str <$l , $v > ()}}; ( string <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_string <$l , $v > ()}}; ( bytes <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_bytes <$l , $v > ()}}; ( byte_buf <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_byte_buf <$l , $v > ()}}; ( option <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_option <$l , $v > ()}}; ( unit <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_unit <$l , $v > ()}}; ( unit_struct <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_unit_struct <$l , $v > ( name : & 'static  str )}}; ( newtype_struct <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_newtype_struct <$l , $v > ( name : & 'static  str )}}; ( seq <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_seq <$l , $v > ()}}; ( tuple <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_tuple <$l , $v > ( len :  usize )}}; ( tuple_struct <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_tuple_struct <$l , $v > ( name : & 'static  str ,  len :  usize )}}; ( map <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_map <$l , $v > ()}}; ( struct <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_struct <$l , $v > ( name : & 'static  str ,  fields : & 'static [& 'static  str ])}}; ( enum <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_enum <$l , $v > ( name : & 'static  str ,  variants : & 'static [& 'static  str ])}}; ( identifier <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_identifier <$l , $v > ()}}; ( ignored_any <$l :  tt , $v :  ident >)=>{ forward_to_deserialize_any_method ! { deserialize_ignored_any <$l , $v > ()}}; }
macro_rules! __ra_macro_fixture421 {($func :  ident <$l :  tt , $v :  ident > ($($arg :  ident : $ty :  ty ),*))=>{# [ inline ] fn $func <$v > ( self , $($arg : $ty ,)*  visitor : $v )-> $crate ::  __private ::  Result <$v ::  Value ,  Self ::  Error >  where $v : $crate ::  de ::  Visitor <$l >, {$(let _ = $arg ; )*  self .  deserialize_any ( visitor )}}; }
macro_rules! __ra_macro_fixture422 {($($f :  ident : $t :  ty ,)*)=>{$(fn $f ( self ,  v : $t )->  fmt ::  Result { Display ::  fmt (&  v ,  self )})* }; }
macro_rules! __ra_macro_fixture423 {($name :  ident , $level :  expr )=>{# [ doc =  " Creates a new `Diagnostic` with the given `message` at the span" ]# [ doc =  " `self`." ]# [ unstable ( feature =  "proc_macro_diagnostic" ,  issue =  "54140" )] pub  fn $name <  T :  Into <  String >> ( self ,  message :  T )->  Diagnostic { Diagnostic ::  spanned ( self , $level ,  message )}}; }
macro_rules! __ra_macro_fixture424 {($($name :  ident =>$kind :  ident ,)*)=>($(# [ doc =  " Creates a new suffixed integer literal with the specified value." ]# [ doc =  "" ]# [ doc =  " This function will create an integer like `1u32` where the integer" ]# [ doc =  " value specified is the first part of the token and the integral is" ]# [ doc =  " also suffixed at the end." ]# [ doc =  " Literals created from negative numbers may not survive round-trips through" ]# [ doc =  " `TokenStream` or strings and may be broken into two tokens (`-` and positive literal)." ]# [ doc =  "" ]# [ doc =  " Literals created through this method have the `Span::call_site()`" ]# [ doc =  " span by default, which can be configured with the `set_span` method" ]# [ doc =  " below." ]# [ stable ( feature =  "proc_macro_lib2" ,  since =  "1.29.0" )] pub  fn $name ( n : $kind )->  Literal { Literal ( bridge ::  client ::  Literal ::  typed_integer (&  n .  to_string (),  stringify ! ($kind )))})*)}
macro_rules! __ra_macro_fixture425 {($($name :  ident =>$kind :  ident ,)*)=>($(# [ doc =  " Creates a new unsuffixed integer literal with the specified value." ]# [ doc =  "" ]# [ doc =  " This function will create an integer like `1` where the integer" ]# [ doc =  " value specified is the first part of the token. No suffix is" ]# [ doc =  " specified on this token, meaning that invocations like" ]# [ doc =  " `Literal::i8_unsuffixed(1)` are equivalent to" ]# [ doc =  " `Literal::u32_unsuffixed(1)`." ]# [ doc =  " Literals created from negative numbers may not survive rountrips through" ]# [ doc =  " `TokenStream` or strings and may be broken into two tokens (`-` and positive literal)." ]# [ doc =  "" ]# [ doc =  " Literals created through this method have the `Span::call_site()`" ]# [ doc =  " span by default, which can be configured with the `set_span` method" ]# [ doc =  " below." ]# [ stable ( feature =  "proc_macro_lib2" ,  since =  "1.29.0" )] pub  fn $name ( n : $kind )->  Literal { Literal ( bridge ::  client ::  Literal ::  integer (&  n .  to_string ()))})*)}
macro_rules! __ra_macro_fixture426 {( type  FreeFunctions )=>( type  FreeFunctions : 'static ;); ( type  TokenStream )=>( type  TokenStream : 'static +  Clone ;); ( type  TokenStreamBuilder )=>( type  TokenStreamBuilder : 'static ;); ( type  TokenStreamIter )=>( type  TokenStreamIter : 'static +  Clone ;); ( type  Group )=>( type  Group : 'static +  Clone ;); ( type  Punct )=>( type  Punct : 'static +  Copy +  Eq +  Hash ;); ( type  Ident )=>( type  Ident : 'static +  Copy +  Eq +  Hash ;); ( type  Literal )=>( type  Literal : 'static +  Clone ;); ( type  SourceFile )=>( type  SourceFile : 'static +  Clone ;); ( type  MultiSpan )=>( type  MultiSpan : 'static ;); ( type  Diagnostic )=>( type  Diagnostic : 'static ;); ( type  Span )=>( type  Span : 'static +  Copy +  Eq +  Hash ;); ( fn  drop (&  mut  self , $arg :  ident : $arg_ty :  ty ))=>( fn  drop (&  mut  self , $arg : $arg_ty ){ mem ::  drop ($arg )}); ( fn  clone (&  mut  self , $arg :  ident : $arg_ty :  ty )-> $ret_ty :  ty )=>( fn  clone (&  mut  self , $arg : $arg_ty )-> $ret_ty {$arg .  clone ()}); ($($item :  tt )*)=>($($item )*;)}
macro_rules! __ra_macro_fixture427 {($spanned :  ident , $regular :  ident , $level :  expr )=>{# [ doc =  " Adds a new child diagnostic message to `self` with the level" ]# [ doc =  " identified by this method\\\'s name with the given `spans` and" ]# [ doc =  " `message`." ]# [ unstable ( feature =  "proc_macro_diagnostic" ,  issue =  "54140" )] pub  fn $spanned <  S ,  T > ( mut  self ,  spans :  S ,  message :  T )->  Diagnostic  where  S :  MultiSpan ,  T :  Into <  String >, { self .  children .  push ( Diagnostic ::  spanned ( spans , $level ,  message ));  self }# [ doc =  " Adds a new child diagnostic message to `self` with the level" ]# [ doc =  " identified by this method\\\'s name with the given `message`." ]# [ unstable ( feature =  "proc_macro_diagnostic" ,  issue =  "54140" )] pub  fn $regular <  T :  Into <  String >> ( mut  self ,  message :  T )->  Diagnostic { self .  children .  push ( Diagnostic ::  new ($level ,  message ));  self }}; }
macro_rules! __ra_macro_fixture428 {($SelfT :  ty , $ActualT :  ident , $UnsignedT :  ty , $BITS :  expr , $Min :  expr , $Max :  expr , $Feature :  expr , $EndFeature :  expr , $rot :  expr , $rot_op :  expr , $rot_result :  expr , $swap_op :  expr , $swapped :  expr , $reversed :  expr , $le_bytes :  expr , $be_bytes :  expr , $to_xe_bytes_doc :  expr , $from_xe_bytes_doc :  expr )=>{ doc_comment ! { concat ! ( "The smallest value that can be represented by this integer type.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(" ,  stringify ! ($SelfT ),  "::MIN, " ,  stringify ! ($Min ),  ");" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "assoc_int_consts" ,  since =  "1.43.0" )] pub  const  MIN :  Self = !  0 ^ ((!  0  as $UnsignedT )>>  1 ) as  Self ; } doc_comment ! { concat ! ( "The largest value that can be represented by this integer type.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(" ,  stringify ! ($SelfT ),  "::MAX, " ,  stringify ! ($Max ),  ");" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "assoc_int_consts" ,  since =  "1.43.0" )] pub  const  MAX :  Self = !  Self ::  MIN ; } doc_comment ! { concat ! ( "The size of this integer type in bits.\n\n# Examples\n\n```\n" , $Feature ,  "#![feature(int_bits_const)]\nassert_eq!(" ,  stringify ! ($SelfT ),  "::BITS, " ,  stringify ! ($BITS ),  ");" , $EndFeature ,  "\n```" ), # [ unstable ( feature =  "int_bits_const" ,  issue =  "76904" )] pub  const  BITS :  u32 = $BITS ; } doc_comment ! { concat ! ( "Converts a string slice in a given base to an integer.\n\nThe string is expected to be an optional `+` or `-` sign followed by digits.\nLeading and trailing whitespace represent an error. Digits are a subset of these characters,\ndepending on `radix`:\n\n * `0-9`\n * `a-z`\n * `A-Z`\n\n# Panics\n\nThis function panics if `radix` is not in the range from 2 to 36.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(" ,  stringify ! ($SelfT ),  "::from_str_radix(\"A\", 16), Ok(10));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] pub  fn  from_str_radix ( src : &  str ,  radix :  u32 )->  Result <  Self ,  ParseIntError > { from_str_radix ( src ,  radix )}} doc_comment ! { concat ! ( "Returns the number of ones in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = 0b100_0000" ,  stringify ! ($SelfT ),  ";\n\nassert_eq!(n.count_ones(), 1);" , $EndFeature ,  "\n```\n" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  count_ones ( self )->  u32 {( self  as $UnsignedT ).  count_ones ()}} doc_comment ! { concat ! ( "Returns the number of zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.count_zeros(), 1);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  count_zeros ( self )->  u32 {(!  self ).  count_ones ()}} doc_comment ! { concat ! ( "Returns the number of leading zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = -1" ,  stringify ! ($SelfT ),  ";\n\nassert_eq!(n.leading_zeros(), 0);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  leading_zeros ( self )->  u32 {( self  as $UnsignedT ).  leading_zeros ()}} doc_comment ! { concat ! ( "Returns the number of trailing zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = -4" ,  stringify ! ($SelfT ),  ";\n\nassert_eq!(n.trailing_zeros(), 2);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  trailing_zeros ( self )->  u32 {( self  as $UnsignedT ).  trailing_zeros ()}} doc_comment ! { concat ! ( "Returns the number of leading ones in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = -1" ,  stringify ! ($SelfT ),  ";\n\nassert_eq!(n.leading_ones(), " ,  stringify ! ($BITS ),  ");" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "leading_trailing_ones" ,  since =  "1.46.0" )]# [ rustc_const_stable ( feature =  "leading_trailing_ones" ,  since =  "1.46.0" )]# [ inline ] pub  const  fn  leading_ones ( self )->  u32 {( self  as $UnsignedT ).  leading_ones ()}} doc_comment ! { concat ! ( "Returns the number of trailing ones in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = 3" ,  stringify ! ($SelfT ),  ";\n\nassert_eq!(n.trailing_ones(), 2);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "leading_trailing_ones" ,  since =  "1.46.0" )]# [ rustc_const_stable ( feature =  "leading_trailing_ones" ,  since =  "1.46.0" )]# [ inline ] pub  const  fn  trailing_ones ( self )->  u32 {( self  as $UnsignedT ).  trailing_ones ()}} doc_comment ! { concat ! ( "Shifts the bits to the left by a specified amount, `n`,\nwrapping the truncated bits to the end of the resulting integer.\n\nPlease note this isn't the same operation as the `<<` shifting operator!\n\n# Examples\n\nBasic usage:\n\n```\nlet n = " , $rot_op ,  stringify ! ($SelfT ),  ";\nlet m = " , $rot_result ,  ";\n\nassert_eq!(n.rotate_left(" , $rot ,  "), m);\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  rotate_left ( self ,  n :  u32 )->  Self {( self  as $UnsignedT ).  rotate_left ( n ) as  Self }} doc_comment ! { concat ! ( "Shifts the bits to the right by a specified amount, `n`,\nwrapping the truncated bits to the beginning of the resulting\ninteger.\n\nPlease note this isn't the same operation as the `>>` shifting operator!\n\n# Examples\n\nBasic usage:\n\n```\nlet n = " , $rot_result ,  stringify ! ($SelfT ),  ";\nlet m = " , $rot_op ,  ";\n\nassert_eq!(n.rotate_right(" , $rot ,  "), m);\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  rotate_right ( self ,  n :  u32 )->  Self {( self  as $UnsignedT ).  rotate_right ( n ) as  Self }} doc_comment ! { concat ! ( "Reverses the byte order of the integer.\n\n# Examples\n\nBasic usage:\n\n```\nlet n = " , $swap_op ,  stringify ! ($SelfT ),  ";\n\nlet m = n.swap_bytes();\n\nassert_eq!(m, " , $swapped ,  ");\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  swap_bytes ( self )->  Self {( self  as $UnsignedT ).  swap_bytes () as  Self }} doc_comment ! { concat ! ( "Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n                second least-significant bit becomes second most-significant bit, etc.\n\n# Examples\n\nBasic usage:\n\n```\nlet n = " , $swap_op ,  stringify ! ($SelfT ),  ";\nlet m = n.reverse_bits();\n\nassert_eq!(m, " , $reversed ,  ");\nassert_eq!(0, 0" ,  stringify ! ($SelfT ),  ".reverse_bits());\n```" ), # [ stable ( feature =  "reverse_bits" ,  since =  "1.37.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ inline ]# [ must_use ] pub  const  fn  reverse_bits ( self )->  Self {( self  as $UnsignedT ).  reverse_bits () as  Self }} doc_comment ! { concat ! ( "Converts an integer from big endian to the target's endianness.\n\nOn big endian this is a no-op. On little endian the bytes are swapped.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = 0x1A" ,  stringify ! ($SelfT ),  ";\n\nif cfg!(target_endian = \"big\") {\n    assert_eq!(" ,  stringify ! ($SelfT ),  "::from_be(n), n)\n} else {\n    assert_eq!(" ,  stringify ! ($SelfT ),  "::from_be(n), n.swap_bytes())\n}" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_conversions" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  from_be ( x :  Self )->  Self {# [ cfg ( target_endian =  "big" )]{ x }# [ cfg ( not ( target_endian =  "big" ))]{ x .  swap_bytes ()}}} doc_comment ! { concat ! ( "Converts an integer from little endian to the target's endianness.\n\nOn little endian this is a no-op. On big endian the bytes are swapped.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = 0x1A" ,  stringify ! ($SelfT ),  ";\n\nif cfg!(target_endian = \"little\") {\n    assert_eq!(" ,  stringify ! ($SelfT ),  "::from_le(n), n)\n} else {\n    assert_eq!(" ,  stringify ! ($SelfT ),  "::from_le(n), n.swap_bytes())\n}" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_conversions" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  from_le ( x :  Self )->  Self {# [ cfg ( target_endian =  "little" )]{ x }# [ cfg ( not ( target_endian =  "little" ))]{ x .  swap_bytes ()}}} doc_comment ! { concat ! ( "Converts `self` to big endian from the target's endianness.\n\nOn big endian this is a no-op. On little endian the bytes are swapped.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = 0x1A" ,  stringify ! ($SelfT ),  ";\n\nif cfg!(target_endian = \"big\") {\n    assert_eq!(n.to_be(), n)\n} else {\n    assert_eq!(n.to_be(), n.swap_bytes())\n}" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_conversions" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  to_be ( self )->  Self {# [ cfg ( target_endian =  "big" )]{ self }# [ cfg ( not ( target_endian =  "big" ))]{ self .  swap_bytes ()}}} doc_comment ! { concat ! ( "Converts `self` to little endian from the target's endianness.\n\nOn little endian this is a no-op. On big endian the bytes are swapped.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = 0x1A" ,  stringify ! ($SelfT ),  ";\n\nif cfg!(target_endian = \"little\") {\n    assert_eq!(n.to_le(), n)\n} else {\n    assert_eq!(n.to_le(), n.swap_bytes())\n}" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_conversions" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  to_le ( self )->  Self {# [ cfg ( target_endian =  "little" )]{ self }# [ cfg ( not ( target_endian =  "little" ))]{ self .  swap_bytes ()}}} doc_comment ! { concat ! ( "Checked integer addition. Computes `self + rhs`, returning `None`\nif overflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!((" ,  stringify ! ($SelfT ),  "::MAX - 2).checked_add(1), Some(" ,  stringify ! ($SelfT ),  "::MAX - 1));\nassert_eq!((" ,  stringify ! ($SelfT ),  "::MAX - 2).checked_add(3), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_checked_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_add ( self ,  rhs :  Self )->  Option <  Self > { let ( a ,  b )=  self .  overflowing_add ( rhs );  if  unlikely ! ( b ){ None } else { Some ( a )}}} doc_comment ! { concat ! ( "Unchecked integer addition. Computes `self + rhs`, assuming overflow\ncannot occur. This results in undefined behavior when `self + rhs > " ,  stringify ! ($SelfT ),  "::MAX` or `self + rhs < " ,  stringify ! ($SelfT ),  "::MIN`." ), # [ unstable ( feature =  "unchecked_math" ,  reason =  "niche optimization path" ,  issue =  "none" , )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  unsafe  fn  unchecked_add ( self ,  rhs :  Self )->  Self { unsafe { intrinsics ::  unchecked_add ( self ,  rhs )}}} doc_comment ! { concat ! ( "Checked integer subtraction. Computes `self - rhs`, returning `None` if\noverflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!((" ,  stringify ! ($SelfT ),  "::MIN + 2).checked_sub(1), Some(" ,  stringify ! ($SelfT ),  "::MIN + 1));\nassert_eq!((" ,  stringify ! ($SelfT ),  "::MIN + 2).checked_sub(3), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_checked_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_sub ( self ,  rhs :  Self )->  Option <  Self > { let ( a ,  b )=  self .  overflowing_sub ( rhs );  if  unlikely ! ( b ){ None } else { Some ( a )}}} doc_comment ! { concat ! ( "Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\ncannot occur. This results in undefined behavior when `self - rhs > " ,  stringify ! ($SelfT ),  "::MAX` or `self - rhs < " ,  stringify ! ($SelfT ),  "::MIN`." ), # [ unstable ( feature =  "unchecked_math" ,  reason =  "niche optimization path" ,  issue =  "none" , )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  unsafe  fn  unchecked_sub ( self ,  rhs :  Self )->  Self { unsafe { intrinsics ::  unchecked_sub ( self ,  rhs )}}} doc_comment ! { concat ! ( "Checked integer multiplication. Computes `self * rhs`, returning `None` if\noverflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.checked_mul(1), Some(" ,  stringify ! ($SelfT ),  "::MAX));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.checked_mul(2), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_checked_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_mul ( self ,  rhs :  Self )->  Option <  Self > { let ( a ,  b )=  self .  overflowing_mul ( rhs );  if  unlikely ! ( b ){ None } else { Some ( a )}}} doc_comment ! { concat ! ( "Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\ncannot occur. This results in undefined behavior when `self * rhs > " ,  stringify ! ($SelfT ),  "::MAX` or `self * rhs < " ,  stringify ! ($SelfT ),  "::MIN`." ), # [ unstable ( feature =  "unchecked_math" ,  reason =  "niche optimization path" ,  issue =  "none" , )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  unsafe  fn  unchecked_mul ( self ,  rhs :  Self )->  Self { unsafe { intrinsics ::  unchecked_mul ( self ,  rhs )}}} doc_comment ! { concat ! ( "Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`\nor the division results in overflow.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!((" ,  stringify ! ($SelfT ),  "::MIN + 1).checked_div(-1), Some(" ,  stringify ! ($Max ),  "));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.checked_div(-1), None);\nassert_eq!((1" ,  stringify ! ($SelfT ),  ").checked_div(0), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_unstable ( feature =  "const_checked_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_div ( self ,  rhs :  Self )->  Option <  Self > { if  unlikely ! ( rhs ==  0 || ( self ==  Self ::  MIN &&  rhs == -  1 )){ None } else { Some ( unsafe { intrinsics ::  unchecked_div ( self ,  rhs )})}}} doc_comment ! { concat ! ( "Checked Euclidean division. Computes `self.div_euclid(rhs)`,\nreturning `None` if `rhs == 0` or the division results in overflow.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!((" ,  stringify ! ($SelfT ),  "::MIN + 1).checked_div_euclid(-1), Some(" ,  stringify ! ($Max ),  "));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.checked_div_euclid(-1), None);\nassert_eq!((1" ,  stringify ! ($SelfT ),  ").checked_div_euclid(0), None);\n```" ), # [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_div_euclid ( self ,  rhs :  Self )->  Option <  Self > { if  unlikely ! ( rhs ==  0 || ( self ==  Self ::  MIN &&  rhs == -  1 )){ None } else { Some ( self .  div_euclid ( rhs ))}}} doc_comment ! { concat ! ( "Checked integer remainder. Computes `self % rhs`, returning `None` if\n`rhs == 0` or the division results in overflow.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".checked_rem(2), Some(1));\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".checked_rem(0), None);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.checked_rem(-1), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_unstable ( feature =  "const_checked_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_rem ( self ,  rhs :  Self )->  Option <  Self > { if  unlikely ! ( rhs ==  0 || ( self ==  Self ::  MIN &&  rhs == -  1 )){ None } else { Some ( unsafe { intrinsics ::  unchecked_rem ( self ,  rhs )})}}} doc_comment ! { concat ! ( "Checked Euclidean remainder. Computes `self.rem_euclid(rhs)`, returning `None`\nif `rhs == 0` or the division results in overflow.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".checked_rem_euclid(2), Some(1));\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".checked_rem_euclid(0), None);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.checked_rem_euclid(-1), None);\n```" ), # [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_rem_euclid ( self ,  rhs :  Self )->  Option <  Self > { if  unlikely ! ( rhs ==  0 || ( self ==  Self ::  MIN &&  rhs == -  1 )){ None } else { Some ( self .  rem_euclid ( rhs ))}}} doc_comment ! { concat ! ( "Checked negation. Computes `-self`, returning `None` if `self == MIN`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".checked_neg(), Some(-5));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.checked_neg(), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_checked_int_methods" ,  since =  "1.47.0" )]# [ inline ] pub  const  fn  checked_neg ( self )->  Option <  Self > { let ( a ,  b )=  self .  overflowing_neg ();  if  unlikely ! ( b ){ None } else { Some ( a )}}} doc_comment ! { concat ! ( "Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger\nthan or equal to the number of bits in `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(0x1" ,  stringify ! ($SelfT ),  ".checked_shl(4), Some(0x10));\nassert_eq!(0x1" ,  stringify ! ($SelfT ),  ".checked_shl(129), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_checked_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_shl ( self ,  rhs :  u32 )->  Option <  Self > { let ( a ,  b )=  self .  overflowing_shl ( rhs );  if  unlikely ! ( b ){ None } else { Some ( a )}}} doc_comment ! { concat ! ( "Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is\nlarger than or equal to the number of bits in `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(0x10" ,  stringify ! ($SelfT ),  ".checked_shr(4), Some(0x1));\nassert_eq!(0x10" ,  stringify ! ($SelfT ),  ".checked_shr(128), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_checked_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_shr ( self ,  rhs :  u32 )->  Option <  Self > { let ( a ,  b )=  self .  overflowing_shr ( rhs );  if  unlikely ! ( b ){ None } else { Some ( a )}}} doc_comment ! { concat ! ( "Checked absolute value. Computes `self.abs()`, returning `None` if\n`self == MIN`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "\nassert_eq!((-5" ,  stringify ! ($SelfT ),  ").checked_abs(), Some(5));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.checked_abs(), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "no_panic_abs" ,  since =  "1.13.0" )]# [ rustc_const_stable ( feature =  "const_checked_int_methods" ,  since =  "1.47.0" )]# [ inline ] pub  const  fn  checked_abs ( self )->  Option <  Self > { if  self .  is_negative (){ self .  checked_neg ()} else { Some ( self )}}} doc_comment ! { concat ! ( "Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\noverflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(8" ,  stringify ! ($SelfT ),  ".checked_pow(2), Some(64));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.checked_pow(2), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "no_panic_pow" ,  since =  "1.34.0" )]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_pow ( self ,  mut  exp :  u32 )->  Option <  Self > { if  exp ==  0 { return  Some ( 1 ); } let  mut  base =  self ;  let  mut  acc :  Self =  1 ;  while  exp >  1 { if ( exp &  1 )==  1 { acc =  try_opt ! ( acc .  checked_mul ( base )); } exp /=  2 ;  base =  try_opt ! ( base .  checked_mul ( base )); } Some ( try_opt ! ( acc .  checked_mul ( base )))}} doc_comment ! { concat ! ( "Saturating integer addition. Computes `self + rhs`, saturating at the numeric\nbounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".saturating_add(1), 101);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.saturating_add(100), " ,  stringify ! ($SelfT ),  "::MAX);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.saturating_add(-1), " ,  stringify ! ($SelfT ),  "::MIN);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_saturating_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  saturating_add ( self ,  rhs :  Self )->  Self { intrinsics ::  saturating_add ( self ,  rhs )}} doc_comment ! { concat ! ( "Saturating integer subtraction. Computes `self - rhs`, saturating at the\nnumeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".saturating_sub(127), -27);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.saturating_sub(100), " ,  stringify ! ($SelfT ),  "::MIN);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.saturating_sub(-1), " ,  stringify ! ($SelfT ),  "::MAX);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_saturating_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  saturating_sub ( self ,  rhs :  Self )->  Self { intrinsics ::  saturating_sub ( self ,  rhs )}} doc_comment ! { concat ! ( "Saturating integer negation. Computes `-self`, returning `MAX` if `self == MIN`\ninstead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".saturating_neg(), -100);\nassert_eq!((-100" ,  stringify ! ($SelfT ),  ").saturating_neg(), 100);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.saturating_neg(), " ,  stringify ! ($SelfT ),  "::MAX);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.saturating_neg(), " ,  stringify ! ($SelfT ),  "::MIN + 1);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "saturating_neg" ,  since =  "1.45.0" )]# [ rustc_const_stable ( feature =  "const_saturating_int_methods" ,  since =  "1.47.0" )]# [ inline ] pub  const  fn  saturating_neg ( self )->  Self { intrinsics ::  saturating_sub ( 0 ,  self )}} doc_comment ! { concat ! ( "Saturating absolute value. Computes `self.abs()`, returning `MAX` if `self ==\nMIN` instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".saturating_abs(), 100);\nassert_eq!((-100" ,  stringify ! ($SelfT ),  ").saturating_abs(), 100);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.saturating_abs(), " ,  stringify ! ($SelfT ),  "::MAX);\nassert_eq!((" ,  stringify ! ($SelfT ),  "::MIN + 1).saturating_abs(), " ,  stringify ! ($SelfT ),  "::MAX);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "saturating_neg" ,  since =  "1.45.0" )]# [ rustc_const_stable ( feature =  "const_saturating_int_methods" ,  since =  "1.47.0" )]# [ inline ] pub  const  fn  saturating_abs ( self )->  Self { if  self .  is_negative (){ self .  saturating_neg ()} else { self }}} doc_comment ! { concat ! ( "Saturating integer multiplication. Computes `self * rhs`, saturating at the\nnumeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "\nassert_eq!(10" ,  stringify ! ($SelfT ),  ".saturating_mul(12), 120);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.saturating_mul(10), " ,  stringify ! ($SelfT ),  "::MAX);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.saturating_mul(10), " ,  stringify ! ($SelfT ),  "::MIN);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_saturating_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  saturating_mul ( self ,  rhs :  Self )->  Self { match  self .  checked_mul ( rhs ){ Some ( x )=> x ,  None => if ( self <  0 )== ( rhs <  0 ){ Self ::  MAX } else { Self ::  MIN }}}} doc_comment ! { concat ! ( "Saturating integer exponentiation. Computes `self.pow(exp)`,\nsaturating at the numeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "\nassert_eq!((-4" ,  stringify ! ($SelfT ),  ").saturating_pow(3), -64);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.saturating_pow(2), " ,  stringify ! ($SelfT ),  "::MAX);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.saturating_pow(3), " ,  stringify ! ($SelfT ),  "::MIN);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "no_panic_pow" ,  since =  "1.34.0" )]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  saturating_pow ( self ,  exp :  u32 )->  Self { match  self .  checked_pow ( exp ){ Some ( x )=> x ,  None  if  self <  0 &&  exp %  2 ==  1 => Self ::  MIN ,  None => Self ::  MAX , }}} doc_comment ! { concat ! ( "Wrapping (modular) addition. Computes `self + rhs`, wrapping around at the\nboundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".wrapping_add(27), 127);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.wrapping_add(2), " ,  stringify ! ($SelfT ),  "::MIN + 1);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_add ( self ,  rhs :  Self )->  Self { intrinsics ::  wrapping_add ( self ,  rhs )}} doc_comment ! { concat ! ( "Wrapping (modular) subtraction. Computes `self - rhs`, wrapping around at the\nboundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(0" ,  stringify ! ($SelfT ),  ".wrapping_sub(127), -127);\nassert_eq!((-2" ,  stringify ! ($SelfT ),  ").wrapping_sub(" ,  stringify ! ($SelfT ),  "::MAX), " ,  stringify ! ($SelfT ),  "::MAX);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_sub ( self ,  rhs :  Self )->  Self { intrinsics ::  wrapping_sub ( self ,  rhs )}} doc_comment ! { concat ! ( "Wrapping (modular) multiplication. Computes `self * rhs`, wrapping around at\nthe boundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(10" ,  stringify ! ($SelfT ),  ".wrapping_mul(12), 120);\nassert_eq!(11i8.wrapping_mul(12), -124);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_mul ( self ,  rhs :  Self )->  Self { intrinsics ::  wrapping_mul ( self ,  rhs )}} doc_comment ! { concat ! ( "Wrapping (modular) division. Computes `self / rhs`, wrapping around at the\nboundary of the type.\n\nThe only case where such wrapping can occur is when one divides `MIN / -1` on a signed type (where\n`MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\nthat is too large to represent in the type. In such a case, this function returns `MIN` itself.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".wrapping_div(10), 10);\nassert_eq!((-128i8).wrapping_div(-1), -128);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "num_wrapping" ,  since =  "1.2.0" )]# [ rustc_const_unstable ( feature =  "const_wrapping_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_div ( self ,  rhs :  Self )->  Self { self .  overflowing_div ( rhs ).  0 }} doc_comment ! { concat ! ( "Wrapping Euclidean division. Computes `self.div_euclid(rhs)`,\nwrapping around at the boundary of the type.\n\nWrapping will only occur in `MIN / -1` on a signed type (where `MIN` is the negative minimal value\nfor the type). This is equivalent to `-MIN`, a positive value that is too large to represent in the\ntype. In this case, this method returns `MIN` itself.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(100" ,  stringify ! ($SelfT ),  ".wrapping_div_euclid(10), 10);\nassert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n```" ), # [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_div_euclid ( self ,  rhs :  Self )->  Self { self .  overflowing_div_euclid ( rhs ).  0 }} doc_comment ! { concat ! ( "Wrapping (modular) remainder. Computes `self % rhs`, wrapping around at the\nboundary of the type.\n\nSuch wrap-around never actually occurs mathematically; implementation artifacts make `x % y`\ninvalid for `MIN / -1` on a signed type (where `MIN` is the negative minimal value). In such a case,\nthis function returns `0`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".wrapping_rem(10), 0);\nassert_eq!((-128i8).wrapping_rem(-1), 0);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "num_wrapping" ,  since =  "1.2.0" )]# [ rustc_const_unstable ( feature =  "const_wrapping_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_rem ( self ,  rhs :  Self )->  Self { self .  overflowing_rem ( rhs ).  0 }} doc_comment ! { concat ! ( "Wrapping Euclidean remainder. Computes `self.rem_euclid(rhs)`, wrapping around\nat the boundary of the type.\n\nWrapping will only occur in `MIN % -1` on a signed type (where `MIN` is the negative minimal value\nfor the type). In this case, this method returns 0.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(100" ,  stringify ! ($SelfT ),  ".wrapping_rem_euclid(10), 0);\nassert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n```" ), # [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_rem_euclid ( self ,  rhs :  Self )->  Self { self .  overflowing_rem_euclid ( rhs ).  0 }} doc_comment ! { concat ! ( "Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\nof the type.\n\nThe only case where such wrapping can occur is when one negates `MIN` on a signed type (where `MIN`\nis the negative minimal value for the type); this is a positive value that is too large to represent\nin the type. In such a case, this function returns `MIN` itself.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".wrapping_neg(), -100);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.wrapping_neg(), " ,  stringify ! ($SelfT ),  "::MIN);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "num_wrapping" ,  since =  "1.2.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  wrapping_neg ( self )->  Self { self .  overflowing_neg ().  0 }} doc_comment ! { concat ! ( "Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes\nany high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n\nNote that this is *not* the same as a rotate-left; the RHS of a wrapping shift-left is restricted to\nthe range of the type, rather than the bits shifted out of the LHS being returned to the other end.\nThe primitive integer types all implement a `[`rotate_left`](#method.rotate_left) function,\nwhich may be what you want instead.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!((-1" ,  stringify ! ($SelfT ),  ").wrapping_shl(7), -128);\nassert_eq!((-1" ,  stringify ! ($SelfT ),  ").wrapping_shl(128), -1);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "num_wrapping" ,  since =  "1.2.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_shl ( self ,  rhs :  u32 )->  Self { unsafe { intrinsics ::  unchecked_shl ( self , ( rhs & ($BITS -  1 )) as $SelfT )}}} doc_comment ! { concat ! ( "Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask`\nremoves any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n\nNote that this is *not* the same as a rotate-right; the RHS of a wrapping shift-right is restricted\nto the range of the type, rather than the bits shifted out of the LHS being returned to the other\nend. The primitive integer types all implement a [`rotate_right`](#method.rotate_right) function,\nwhich may be what you want instead.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!((-128" ,  stringify ! ($SelfT ),  ").wrapping_shr(7), -1);\nassert_eq!((-128i16).wrapping_shr(64), -128);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "num_wrapping" ,  since =  "1.2.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_shr ( self ,  rhs :  u32 )->  Self { unsafe { intrinsics ::  unchecked_shr ( self , ( rhs & ($BITS -  1 )) as $SelfT )}}} doc_comment ! { concat ! ( "Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\nthe boundary of the type.\n\nThe only case where such wrapping can occur is when one takes the absolute value of the negative\nminimal value for the type; this is a positive value that is too large to represent in the type. In\nsuch a case, this function returns `MIN` itself.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".wrapping_abs(), 100);\nassert_eq!((-100" ,  stringify ! ($SelfT ),  ").wrapping_abs(), 100);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.wrapping_abs(), " ,  stringify ! ($SelfT ),  "::MIN);\nassert_eq!((-128i8).wrapping_abs() as u8, 128);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "no_panic_abs" ,  since =  "1.13.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ allow ( unused_attributes )]# [ inline ] pub  const  fn  wrapping_abs ( self )->  Self { if  self .  is_negative (){ self .  wrapping_neg ()} else { self }}} doc_comment ! { concat ! ( "Computes the absolute value of `self` without any wrapping\nor panicking.\n\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "#![feature(unsigned_abs)]\nassert_eq!(100" ,  stringify ! ($SelfT ),  ".unsigned_abs(), 100" ,  stringify ! ($UnsignedT ),  ");\nassert_eq!((-100" ,  stringify ! ($SelfT ),  ").unsigned_abs(), 100" ,  stringify ! ($UnsignedT ),  ");\nassert_eq!((-128i8).unsigned_abs(), 128u8);" , $EndFeature ,  "\n```" ), # [ unstable ( feature =  "unsigned_abs" ,  issue =  "74913" )]# [ inline ] pub  const  fn  unsigned_abs ( self )-> $UnsignedT { self .  wrapping_abs () as $UnsignedT }} doc_comment ! { concat ! ( "Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\nwrapping around at the boundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(3" ,  stringify ! ($SelfT ),  ".wrapping_pow(4), 81);\nassert_eq!(3i8.wrapping_pow(5), -13);\nassert_eq!(3i8.wrapping_pow(6), -39);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "no_panic_pow" ,  since =  "1.34.0" )]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_pow ( self ,  mut  exp :  u32 )->  Self { if  exp ==  0 { return  1 ; } let  mut  base =  self ;  let  mut  acc :  Self =  1 ;  while  exp >  1 { if ( exp &  1 )==  1 { acc =  acc .  wrapping_mul ( base ); } exp /=  2 ;  base =  base .  wrapping_mul ( base ); } acc .  wrapping_mul ( base )}} doc_comment ! { concat ! ( "Calculates `self` + `rhs`\n\nReturns a tuple of the addition along with a boolean indicating whether an arithmetic overflow would\noccur. If an overflow would have occurred then the wrapped value is returned.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".overflowing_add(2), (7, false));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.overflowing_add(1), (" ,  stringify ! ($SelfT ),  "::MIN, true));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  overflowing_add ( self ,  rhs :  Self )-> ( Self ,  bool ){ let ( a ,  b )=  intrinsics ::  add_with_overflow ( self  as $ActualT ,  rhs  as $ActualT ); ( a  as  Self ,  b )}} doc_comment ! { concat ! ( "Calculates `self` - `rhs`\n\nReturns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\nwould occur. If an overflow would have occurred then the wrapped value is returned.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".overflowing_sub(2), (3, false));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.overflowing_sub(1), (" ,  stringify ! ($SelfT ),  "::MAX, true));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  overflowing_sub ( self ,  rhs :  Self )-> ( Self ,  bool ){ let ( a ,  b )=  intrinsics ::  sub_with_overflow ( self  as $ActualT ,  rhs  as $ActualT ); ( a  as  Self ,  b )}} doc_comment ! { concat ! ( "Calculates the multiplication of `self` and `rhs`.\n\nReturns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow\nwould occur. If an overflow would have occurred then the wrapped value is returned.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(5" ,  stringify ! ($SelfT ),  ".overflowing_mul(2), (10, false));\nassert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  overflowing_mul ( self ,  rhs :  Self )-> ( Self ,  bool ){ let ( a ,  b )=  intrinsics ::  mul_with_overflow ( self  as $ActualT ,  rhs  as $ActualT ); ( a  as  Self ,  b )}} doc_comment ! { concat ! ( "Calculates the divisor when `self` is divided by `rhs`.\n\nReturns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\noccur. If an overflow would occur then self is returned.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".overflowing_div(2), (2, false));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.overflowing_div(-1), (" ,  stringify ! ($SelfT ),  "::MIN, true));" , $EndFeature ,  "\n```" ), # [ inline ]# [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_unstable ( feature =  "const_overflowing_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ] pub  const  fn  overflowing_div ( self ,  rhs :  Self )-> ( Self ,  bool ){ if  unlikely ! ( self ==  Self ::  MIN &&  rhs == -  1 ){( self ,  true )} else {( self /  rhs ,  false )}}} doc_comment ! { concat ! ( "Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n\nReturns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\noccur. If an overflow would occur then `self` is returned.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".overflowing_div_euclid(2), (2, false));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.overflowing_div_euclid(-1), (" ,  stringify ! ($SelfT ),  "::MIN, true));\n```" ), # [ inline ]# [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ] pub  const  fn  overflowing_div_euclid ( self ,  rhs :  Self )-> ( Self ,  bool ){ if  unlikely ! ( self ==  Self ::  MIN &&  rhs == -  1 ){( self ,  true )} else {( self .  div_euclid ( rhs ),  false )}}} doc_comment ! { concat ! ( "Calculates the remainder when `self` is divided by `rhs`.\n\nReturns a tuple of the remainder after dividing along with a boolean indicating whether an\narithmetic overflow would occur. If an overflow would occur then 0 is returned.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".overflowing_rem(2), (1, false));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.overflowing_rem(-1), (0, true));" , $EndFeature ,  "\n```" ), # [ inline ]# [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_unstable ( feature =  "const_overflowing_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ] pub  const  fn  overflowing_rem ( self ,  rhs :  Self )-> ( Self ,  bool ){ if  unlikely ! ( self ==  Self ::  MIN &&  rhs == -  1 ){( 0 ,  true )} else {( self %  rhs ,  false )}}} doc_comment ! { concat ! ( "Overflowing Euclidean remainder. Calculates `self.rem_euclid(rhs)`.\n\nReturns a tuple of the remainder after dividing along with a boolean indicating whether an\narithmetic overflow would occur. If an overflow would occur then 0 is returned.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".overflowing_rem_euclid(2), (1, false));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.overflowing_rem_euclid(-1), (0, true));\n```" ), # [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  overflowing_rem_euclid ( self ,  rhs :  Self )-> ( Self ,  bool ){ if  unlikely ! ( self ==  Self ::  MIN &&  rhs == -  1 ){( 0 ,  true )} else {( self .  rem_euclid ( rhs ),  false )}}} doc_comment ! { concat ! ( "Negates self, overflowing if this is equal to the minimum value.\n\nReturns a tuple of the negated version of self along with a boolean indicating whether an overflow\nhappened. If `self` is the minimum value (e.g., `i32::MIN` for values of type `i32`), then the\nminimum value will be returned again and `true` will be returned for an overflow happening.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(2" ,  stringify ! ($SelfT ),  ".overflowing_neg(), (-2, false));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MIN.overflowing_neg(), (" ,  stringify ! ($SelfT ),  "::MIN, true));" , $EndFeature ,  "\n```" ), # [ inline ]# [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ allow ( unused_attributes )] pub  const  fn  overflowing_neg ( self )-> ( Self ,  bool ){ if  unlikely ! ( self ==  Self ::  MIN ){( Self ::  MIN ,  true )} else {(-  self ,  false )}}} doc_comment ! { concat ! ( "Shifts self left by `rhs` bits.\n\nReturns a tuple of the shifted version of self along with a boolean indicating whether the shift\nvalue was larger than or equal to the number of bits. If the shift value is too large, then value is\nmasked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(0x1" ,  stringify ! ($SelfT ),  ".overflowing_shl(4), (0x10, false));\nassert_eq!(0x1i32.overflowing_shl(36), (0x10, true));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  overflowing_shl ( self ,  rhs :  u32 )-> ( Self ,  bool ){( self .  wrapping_shl ( rhs ), ( rhs > ($BITS -  1 )))}} doc_comment ! { concat ! ( "Shifts self right by `rhs` bits.\n\nReturns a tuple of the shifted version of self along with a boolean indicating whether the shift\nvalue was larger than or equal to the number of bits. If the shift value is too large, then value is\nmasked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(0x10" ,  stringify ! ($SelfT ),  ".overflowing_shr(4), (0x1, false));\nassert_eq!(0x10i32.overflowing_shr(36), (0x1, true));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  overflowing_shr ( self ,  rhs :  u32 )-> ( Self ,  bool ){( self .  wrapping_shr ( rhs ), ( rhs > ($BITS -  1 )))}} doc_comment ! { concat ! ( "Computes the absolute value of `self`.\n\nReturns a tuple of the absolute version of self along with a boolean indicating whether an overflow\nhappened. If self is the minimum value (e.g., " ,  stringify ! ($SelfT ),  "::MIN for values of type\n " ,  stringify ! ($SelfT ),  "), then the minimum value will be returned again and true will be returned\nfor an overflow happening.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(10" ,  stringify ! ($SelfT ),  ".overflowing_abs(), (10, false));\nassert_eq!((-10" ,  stringify ! ($SelfT ),  ").overflowing_abs(), (10, false));\nassert_eq!((" ,  stringify ! ($SelfT ),  "::MIN).overflowing_abs(), (" ,  stringify ! ($SelfT ),  "::MIN, true));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "no_panic_abs" ,  since =  "1.13.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  overflowing_abs ( self )-> ( Self ,  bool ){( self .  wrapping_abs (),  self ==  Self ::  MIN )}} doc_comment ! { concat ! ( "Raises self to the power of `exp`, using exponentiation by squaring.\n\nReturns a tuple of the exponentiation along with a bool indicating\nwhether an overflow happened.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(3" ,  stringify ! ($SelfT ),  ".overflowing_pow(4), (81, false));\nassert_eq!(3i8.overflowing_pow(5), (-13, true));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "no_panic_pow" ,  since =  "1.34.0" )]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  overflowing_pow ( self ,  mut  exp :  u32 )-> ( Self ,  bool ){ if  exp ==  0 { return ( 1 ,  false ); } let  mut  base =  self ;  let  mut  acc :  Self =  1 ;  let  mut  overflown =  false ;  let  mut  r ;  while  exp >  1 { if ( exp &  1 )==  1 { r =  acc .  overflowing_mul ( base );  acc =  r .  0 ;  overflown |=  r .  1 ; } exp /=  2 ;  r =  base .  overflowing_mul ( base );  base =  r .  0 ;  overflown |=  r .  1 ; } r =  acc .  overflowing_mul ( base );  r .  1 |=  overflown ;  r }} doc_comment ! { concat ! ( "Raises self to the power of `exp`, using exponentiation by squaring.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let x: " ,  stringify ! ($SelfT ),  " = 2; // or any other integer type\n\nassert_eq!(x.pow(5), 32);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ]# [ rustc_inherit_overflow_checks ] pub  const  fn  pow ( self ,  mut  exp :  u32 )->  Self { if  exp ==  0 { return  1 ; } let  mut  base =  self ;  let  mut  acc =  1 ;  while  exp >  1 { if ( exp &  1 )==  1 { acc =  acc *  base ; } exp /=  2 ;  base =  base *  base ; } acc *  base }} doc_comment ! { concat ! ( "Calculates the quotient of Euclidean division of `self` by `rhs`.\n\nThis computes the integer `n` such that `self = n * rhs + self.rem_euclid(rhs)`,\nwith `0 <= self.rem_euclid(rhs) < rhs`.\n\nIn other words, the result is `self / rhs` rounded to the integer `n`\nsuch that `self >= n * rhs`.\nIf `self > 0`, this is equal to round towards zero (the default in Rust);\nif `self < 0`, this is equal to round towards +/- infinity.\n\n# Panics\n\nThis function will panic if `rhs` is 0 or the division results in overflow.\n\n# Examples\n\nBasic usage:\n\n```\nlet a: " ,  stringify ! ($SelfT ),  " = 7; // or any other integer type\nlet b = 4;\n\nassert_eq!(a.div_euclid(b), 1); // 7 >= 4 * 1\nassert_eq!(a.div_euclid(-b), -1); // 7 >= -4 * -1\nassert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\nassert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n```" ), # [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ]# [ rustc_inherit_overflow_checks ] pub  const  fn  div_euclid ( self ,  rhs :  Self )->  Self { let  q =  self /  rhs ;  if  self %  rhs <  0 { return  if  rhs >  0 { q -  1 } else { q +  1 }} q }} doc_comment ! { concat ! ( "Calculates the least nonnegative remainder of `self (mod rhs)`.\n\nThis is done as if by the Euclidean division algorithm -- given\n`r = self.rem_euclid(rhs)`, `self = rhs * self.div_euclid(rhs) + r`, and\n`0 <= r < abs(rhs)`.\n\n# Panics\n\nThis function will panic if `rhs` is 0 or the division results in overflow.\n\n# Examples\n\nBasic usage:\n\n```\nlet a: " ,  stringify ! ($SelfT ),  " = 7; // or any other integer type\nlet b = 4;\n\nassert_eq!(a.rem_euclid(b), 3);\nassert_eq!((-a).rem_euclid(b), 1);\nassert_eq!(a.rem_euclid(-b), 3);\nassert_eq!((-a).rem_euclid(-b), 1);\n```" ), # [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ]# [ rustc_inherit_overflow_checks ] pub  const  fn  rem_euclid ( self ,  rhs :  Self )->  Self { let  r =  self %  rhs ;  if  r <  0 { if  rhs <  0 { r -  rhs } else { r +  rhs }} else { r }}} doc_comment ! { concat ! ( "Computes the absolute value of `self`.\n\n# Overflow behavior\n\nThe absolute value of `" ,  stringify ! ($SelfT ),  "::MIN` cannot be represented as an\n`" ,  stringify ! ($SelfT ),  "`, and attempting to calculate it will cause an overflow. This means that\ncode in debug mode will trigger a panic on this case and optimized code will return `" ,  stringify ! ($SelfT ),  "::MIN` without a panic.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(10" ,  stringify ! ($SelfT ),  ".abs(), 10);\nassert_eq!((-10" ,  stringify ! ($SelfT ),  ").abs(), 10);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ allow ( unused_attributes )]# [ inline ]# [ rustc_inherit_overflow_checks ] pub  const  fn  abs ( self )->  Self { if  self .  is_negative (){-  self } else { self }}} doc_comment ! { concat ! ( "Returns a number representing sign of `self`.\n\n - `0` if the number is zero\n - `1` if the number is positive\n - `-1` if the number is negative\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(10" ,  stringify ! ($SelfT ),  ".signum(), 1);\nassert_eq!(0" ,  stringify ! ($SelfT ),  ".signum(), 0);\nassert_eq!((-10" ,  stringify ! ($SelfT ),  ").signum(), -1);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_sign" ,  since =  "1.47.0" )]# [ inline ] pub  const  fn  signum ( self )->  Self { match  self { n  if  n >  0 => 1 ,  0 => 0 , _ =>-  1 , }}} doc_comment ! { concat ! ( "Returns `true` if `self` is positive and `false` if the number is zero or\nnegative.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert!(10" ,  stringify ! ($SelfT ),  ".is_positive());\nassert!(!(-10" ,  stringify ! ($SelfT ),  ").is_positive());" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  is_positive ( self )->  bool { self >  0 }} doc_comment ! { concat ! ( "Returns `true` if `self` is negative and `false` if the number is zero or\npositive.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert!((-10" ,  stringify ! ($SelfT ),  ").is_negative());\nassert!(!10" ,  stringify ! ($SelfT ),  ".is_negative());" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_int_methods" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  is_negative ( self )->  bool { self <  0 }} doc_comment ! { concat ! ( "Return the memory representation of this integer as a byte array in\nbig-endian (network) byte order.\n" , $to_xe_bytes_doc ,  "\n# Examples\n\n```\nlet bytes = " , $swap_op ,  stringify ! ($SelfT ),  ".to_be_bytes();\nassert_eq!(bytes, " , $be_bytes ,  ");\n```" ), # [ stable ( feature =  "int_to_from_bytes" ,  since =  "1.32.0" )]# [ rustc_const_stable ( feature =  "const_int_conversion" ,  since =  "1.44.0" )]# [ inline ] pub  const  fn  to_be_bytes ( self )-> [ u8 ;  mem ::  size_of ::<  Self > ()]{ self .  to_be ().  to_ne_bytes ()}} doc_comment ! { concat ! ( "Return the memory representation of this integer as a byte array in\nlittle-endian byte order.\n" , $to_xe_bytes_doc ,  "\n# Examples\n\n```\nlet bytes = " , $swap_op ,  stringify ! ($SelfT ),  ".to_le_bytes();\nassert_eq!(bytes, " , $le_bytes ,  ");\n```" ), # [ stable ( feature =  "int_to_from_bytes" ,  since =  "1.32.0" )]# [ rustc_const_stable ( feature =  "const_int_conversion" ,  since =  "1.44.0" )]# [ inline ] pub  const  fn  to_le_bytes ( self )-> [ u8 ;  mem ::  size_of ::<  Self > ()]{ self .  to_le ().  to_ne_bytes ()}} doc_comment ! { concat ! ( "\nReturn the memory representation of this integer as a byte array in\nnative byte order.\n\nAs the target platform's native endianness is used, portable code\nshould use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\ninstead.\n" , $to_xe_bytes_doc ,  "\n[`to_be_bytes`]: #method.to_be_bytes\n[`to_le_bytes`]: #method.to_le_bytes\n\n# Examples\n\n```\nlet bytes = " , $swap_op ,  stringify ! ($SelfT ),  ".to_ne_bytes();\nassert_eq!(\n    bytes,\n    if cfg!(target_endian = \"big\") {\n        " , $be_bytes ,  "\n    } else {\n        " , $le_bytes ,  "\n    }\n);\n```" ), # [ stable ( feature =  "int_to_from_bytes" ,  since =  "1.32.0" )]# [ rustc_const_stable ( feature =  "const_int_conversion" ,  since =  "1.44.0" )]# [ cfg_attr ( not ( bootstrap ),  rustc_allow_const_fn_unstable ( const_fn_transmute ))]# [ cfg_attr ( bootstrap ,  allow_internal_unstable ( const_fn_transmute ))]# [ inline ] pub  const  fn  to_ne_bytes ( self )-> [ u8 ;  mem ::  size_of ::<  Self > ()]{ unsafe { mem ::  transmute ( self )}}} doc_comment ! { concat ! ( "\nReturn the memory representation of this integer as a byte array in\nnative byte order.\n\n[`to_ne_bytes`] should be preferred over this whenever possible.\n\n[`to_ne_bytes`]: #method.to_ne_bytes\n" ,  "\n# Examples\n\n```\n#![feature(num_as_ne_bytes)]\nlet num = " , $swap_op ,  stringify ! ($SelfT ),  ";\nlet bytes = num.as_ne_bytes();\nassert_eq!(\n    bytes,\n    if cfg!(target_endian = \"big\") {\n        &" , $be_bytes ,  "\n    } else {\n        &" , $le_bytes ,  "\n    }\n);\n```" ), # [ unstable ( feature =  "num_as_ne_bytes" ,  issue =  "76976" )]# [ inline ] pub  fn  as_ne_bytes (&  self )-> & [ u8 ;  mem ::  size_of ::<  Self > ()]{ unsafe {&* ( self  as *  const  Self  as *  const _)}}} doc_comment ! { concat ! ( "Create an integer value from its representation as a byte array in\nbig endian.\n" , $from_xe_bytes_doc ,  "\n# Examples\n\n```\nlet value = " ,  stringify ! ($SelfT ),  "::from_be_bytes(" , $be_bytes ,  ");\nassert_eq!(value, " , $swap_op ,  ");\n```\n\nWhen starting from a slice rather than an array, fallible conversion APIs can be used:\n\n```\nuse std::convert::TryInto;\n\nfn read_be_" ,  stringify ! ($SelfT ),  "(input: &mut &[u8]) -> " ,  stringify ! ($SelfT ),  " {\n    let (int_bytes, rest) = input.split_at(std::mem::size_of::<" ,  stringify ! ($SelfT ),  ">());\n    *input = rest;\n    " ,  stringify ! ($SelfT ),  "::from_be_bytes(int_bytes.try_into().unwrap())\n}\n```" ), # [ stable ( feature =  "int_to_from_bytes" ,  since =  "1.32.0" )]# [ rustc_const_stable ( feature =  "const_int_conversion" ,  since =  "1.44.0" )]# [ inline ] pub  const  fn  from_be_bytes ( bytes : [ u8 ;  mem ::  size_of ::<  Self > ()])->  Self { Self ::  from_be ( Self ::  from_ne_bytes ( bytes ))}} doc_comment ! { concat ! ( "\nCreate an integer value from its representation as a byte array in\nlittle endian.\n" , $from_xe_bytes_doc ,  "\n# Examples\n\n```\nlet value = " ,  stringify ! ($SelfT ),  "::from_le_bytes(" , $le_bytes ,  ");\nassert_eq!(value, " , $swap_op ,  ");\n```\n\nWhen starting from a slice rather than an array, fallible conversion APIs can be used:\n\n```\nuse std::convert::TryInto;\n\nfn read_le_" ,  stringify ! ($SelfT ),  "(input: &mut &[u8]) -> " ,  stringify ! ($SelfT ),  " {\n    let (int_bytes, rest) = input.split_at(std::mem::size_of::<" ,  stringify ! ($SelfT ),  ">());\n    *input = rest;\n    " ,  stringify ! ($SelfT ),  "::from_le_bytes(int_bytes.try_into().unwrap())\n}\n```" ), # [ stable ( feature =  "int_to_from_bytes" ,  since =  "1.32.0" )]# [ rustc_const_stable ( feature =  "const_int_conversion" ,  since =  "1.44.0" )]# [ inline ] pub  const  fn  from_le_bytes ( bytes : [ u8 ;  mem ::  size_of ::<  Self > ()])->  Self { Self ::  from_le ( Self ::  from_ne_bytes ( bytes ))}} doc_comment ! { concat ! ( "Create an integer value from its memory representation as a byte\narray in native endianness.\n\nAs the target platform's native endianness is used, portable code\nlikely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\nappropriate instead.\n\n[`from_be_bytes`]: #method.from_be_bytes\n[`from_le_bytes`]: #method.from_le_bytes\n" , $from_xe_bytes_doc ,  "\n# Examples\n\n```\nlet value = " ,  stringify ! ($SelfT ),  "::from_ne_bytes(if cfg!(target_endian = \"big\") {\n    " , $be_bytes ,  "\n} else {\n    " , $le_bytes ,  "\n});\nassert_eq!(value, " , $swap_op ,  ");\n```\n\nWhen starting from a slice rather than an array, fallible conversion APIs can be used:\n\n```\nuse std::convert::TryInto;\n\nfn read_ne_" ,  stringify ! ($SelfT ),  "(input: &mut &[u8]) -> " ,  stringify ! ($SelfT ),  " {\n    let (int_bytes, rest) = input.split_at(std::mem::size_of::<" ,  stringify ! ($SelfT ),  ">());\n    *input = rest;\n    " ,  stringify ! ($SelfT ),  "::from_ne_bytes(int_bytes.try_into().unwrap())\n}\n```" ), # [ stable ( feature =  "int_to_from_bytes" ,  since =  "1.32.0" )]# [ rustc_const_stable ( feature =  "const_int_conversion" ,  since =  "1.44.0" )]# [ cfg_attr ( not ( bootstrap ),  rustc_allow_const_fn_unstable ( const_fn_transmute ))]# [ cfg_attr ( bootstrap ,  allow_internal_unstable ( const_fn_transmute ))]# [ inline ] pub  const  fn  from_ne_bytes ( bytes : [ u8 ;  mem ::  size_of ::<  Self > ()])->  Self { unsafe { mem ::  transmute ( bytes )}}} doc_comment ! { concat ! ( "**This method is soft-deprecated.**\n\nAlthough using it wont cause a compilation warning,\nnew code should use [`" ,  stringify ! ($SelfT ),  "::MIN" ,  "`](#associatedconstant.MIN) instead.\n\nReturns the smallest value that can be represented by this integer type." ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ inline ( always )]# [ rustc_promotable ]# [ rustc_const_stable ( feature =  "const_min_value" ,  since =  "1.32.0" )] pub  const  fn  min_value ()->  Self { Self ::  MIN }} doc_comment ! { concat ! ( "**This method is soft-deprecated.**\n\nAlthough using it wont cause a compilation warning,\nnew code should use [`" ,  stringify ! ($SelfT ),  "::MAX" ,  "`](#associatedconstant.MAX) instead.\n\nReturns the largest value that can be represented by this integer type." ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ inline ( always )]# [ rustc_promotable ]# [ rustc_const_stable ( feature =  "const_max_value" ,  since =  "1.32.0" )] pub  const  fn  max_value ()->  Self { Self ::  MAX }}}}
macro_rules! __ra_macro_fixture429 {($x :  expr , $($tt :  tt )*)=>{# [ doc = $x ]$($tt )* }; }
macro_rules! __ra_macro_fixture430 {()=>{ "\n\n**Note**: This function returns an array of length 2, 4 or 8 bytes\ndepending on the target pointer size.\n\n" }; }
macro_rules! __ra_macro_fixture431 {()=>{ "\n\n**Note**: This function takes an array of length 2, 4 or 8 bytes\ndepending on the target pointer size.\n\n" }; }
macro_rules! __ra_macro_fixture432 {($SelfT :  ty , $ActualT :  ty , $BITS :  expr , $MaxV :  expr , $Feature :  expr , $EndFeature :  expr , $rot :  expr , $rot_op :  expr , $rot_result :  expr , $swap_op :  expr , $swapped :  expr , $reversed :  expr , $le_bytes :  expr , $be_bytes :  expr , $to_xe_bytes_doc :  expr , $from_xe_bytes_doc :  expr )=>{ doc_comment ! { concat ! ( "The smallest value that can be represented by this integer type.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(" ,  stringify ! ($SelfT ),  "::MIN, 0);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "assoc_int_consts" ,  since =  "1.43.0" )] pub  const  MIN :  Self =  0 ; } doc_comment ! { concat ! ( "The largest value that can be represented by this integer type.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(" ,  stringify ! ($SelfT ),  "::MAX, " ,  stringify ! ($MaxV ),  ");" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "assoc_int_consts" ,  since =  "1.43.0" )] pub  const  MAX :  Self = !  0 ; } doc_comment ! { concat ! ( "The size of this integer type in bits.\n\n# Examples\n\n```\n" , $Feature ,  "#![feature(int_bits_const)]\nassert_eq!(" ,  stringify ! ($SelfT ),  "::BITS, " ,  stringify ! ($BITS ),  ");" , $EndFeature ,  "\n```" ), # [ unstable ( feature =  "int_bits_const" ,  issue =  "76904" )] pub  const  BITS :  u32 = $BITS ; } doc_comment ! { concat ! ( "Converts a string slice in a given base to an integer.\n\nThe string is expected to be an optional `+` sign\nfollowed by digits.\nLeading and trailing whitespace represent an error.\nDigits are a subset of these characters, depending on `radix`:\n\n* `0-9`\n* `a-z`\n* `A-Z`\n\n# Panics\n\nThis function panics if `radix` is not in the range from 2 to 36.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(" ,  stringify ! ($SelfT ),  "::from_str_radix(\"A\", 16), Ok(10));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )] pub  fn  from_str_radix ( src : &  str ,  radix :  u32 )->  Result <  Self ,  ParseIntError > { from_str_radix ( src ,  radix )}} doc_comment ! { concat ! ( "Returns the number of ones in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = 0b01001100" ,  stringify ! ($SelfT ),  ";\n\nassert_eq!(n.count_ones(), 3);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_math" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  count_ones ( self )->  u32 { intrinsics ::  ctpop ( self  as $ActualT ) as  u32 }} doc_comment ! { concat ! ( "Returns the number of zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.count_zeros(), 0);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_math" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  count_zeros ( self )->  u32 {(!  self ).  count_ones ()}} doc_comment ! { concat ! ( "Returns the number of leading zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = " ,  stringify ! ($SelfT ),  "::MAX >> 2;\n\nassert_eq!(n.leading_zeros(), 2);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_math" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  leading_zeros ( self )->  u32 { intrinsics ::  ctlz ( self  as $ActualT ) as  u32 }} doc_comment ! { concat ! ( "Returns the number of trailing zeros in the binary representation\nof `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = 0b0101000" ,  stringify ! ($SelfT ),  ";\n\nassert_eq!(n.trailing_zeros(), 3);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_math" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  trailing_zeros ( self )->  u32 { intrinsics ::  cttz ( self ) as  u32 }} doc_comment ! { concat ! ( "Returns the number of leading ones in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = !(" ,  stringify ! ($SelfT ),  "::MAX >> 2);\n\nassert_eq!(n.leading_ones(), 2);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "leading_trailing_ones" ,  since =  "1.46.0" )]# [ rustc_const_stable ( feature =  "leading_trailing_ones" ,  since =  "1.46.0" )]# [ inline ] pub  const  fn  leading_ones ( self )->  u32 {(!  self ).  leading_zeros ()}} doc_comment ! { concat ! ( "Returns the number of trailing ones in the binary representation\nof `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = 0b1010111" ,  stringify ! ($SelfT ),  ";\n\nassert_eq!(n.trailing_ones(), 3);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "leading_trailing_ones" ,  since =  "1.46.0" )]# [ rustc_const_stable ( feature =  "leading_trailing_ones" ,  since =  "1.46.0" )]# [ inline ] pub  const  fn  trailing_ones ( self )->  u32 {(!  self ).  trailing_zeros ()}} doc_comment ! { concat ! ( "Shifts the bits to the left by a specified amount, `n`,\nwrapping the truncated bits to the end of the resulting integer.\n\nPlease note this isn't the same operation as the `<<` shifting operator!\n\n# Examples\n\nBasic usage:\n\n```\nlet n = " , $rot_op ,  stringify ! ($SelfT ),  ";\nlet m = " , $rot_result ,  ";\n\nassert_eq!(n.rotate_left(" , $rot ,  "), m);\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_math" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  rotate_left ( self ,  n :  u32 )->  Self { intrinsics ::  rotate_left ( self ,  n  as $SelfT )}} doc_comment ! { concat ! ( "Shifts the bits to the right by a specified amount, `n`,\nwrapping the truncated bits to the beginning of the resulting\ninteger.\n\nPlease note this isn't the same operation as the `>>` shifting operator!\n\n# Examples\n\nBasic usage:\n\n```\nlet n = " , $rot_result ,  stringify ! ($SelfT ),  ";\nlet m = " , $rot_op ,  ";\n\nassert_eq!(n.rotate_right(" , $rot ,  "), m);\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_math" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  rotate_right ( self ,  n :  u32 )->  Self { intrinsics ::  rotate_right ( self ,  n  as $SelfT )}} doc_comment ! { concat ! ( "\nReverses the byte order of the integer.\n\n# Examples\n\nBasic usage:\n\n```\nlet n = " , $swap_op ,  stringify ! ($SelfT ),  ";\nlet m = n.swap_bytes();\n\nassert_eq!(m, " , $swapped ,  ");\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_math" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  swap_bytes ( self )->  Self { intrinsics ::  bswap ( self  as $ActualT ) as  Self }} doc_comment ! { concat ! ( "Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n                second least-significant bit becomes second most-significant bit, etc.\n\n# Examples\n\nBasic usage:\n\n```\nlet n = " , $swap_op ,  stringify ! ($SelfT ),  ";\nlet m = n.reverse_bits();\n\nassert_eq!(m, " , $reversed ,  ");\nassert_eq!(0, 0" ,  stringify ! ($SelfT ),  ".reverse_bits());\n```" ), # [ stable ( feature =  "reverse_bits" ,  since =  "1.37.0" )]# [ rustc_const_stable ( feature =  "const_math" ,  since =  "1.32.0" )]# [ inline ]# [ must_use ] pub  const  fn  reverse_bits ( self )->  Self { intrinsics ::  bitreverse ( self  as $ActualT ) as  Self }} doc_comment ! { concat ! ( "Converts an integer from big endian to the target's endianness.\n\nOn big endian this is a no-op. On little endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = 0x1A" ,  stringify ! ($SelfT ),  ";\n\nif cfg!(target_endian = \"big\") {\n    assert_eq!(" ,  stringify ! ($SelfT ),  "::from_be(n), n)\n} else {\n    assert_eq!(" ,  stringify ! ($SelfT ),  "::from_be(n), n.swap_bytes())\n}" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_math" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  from_be ( x :  Self )->  Self {# [ cfg ( target_endian =  "big" )]{ x }# [ cfg ( not ( target_endian =  "big" ))]{ x .  swap_bytes ()}}} doc_comment ! { concat ! ( "Converts an integer from little endian to the target's endianness.\n\nOn little endian this is a no-op. On big endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = 0x1A" ,  stringify ! ($SelfT ),  ";\n\nif cfg!(target_endian = \"little\") {\n    assert_eq!(" ,  stringify ! ($SelfT ),  "::from_le(n), n)\n} else {\n    assert_eq!(" ,  stringify ! ($SelfT ),  "::from_le(n), n.swap_bytes())\n}" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_math" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  from_le ( x :  Self )->  Self {# [ cfg ( target_endian =  "little" )]{ x }# [ cfg ( not ( target_endian =  "little" ))]{ x .  swap_bytes ()}}} doc_comment ! { concat ! ( "Converts `self` to big endian from the target's endianness.\n\nOn big endian this is a no-op. On little endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = 0x1A" ,  stringify ! ($SelfT ),  ";\n\nif cfg!(target_endian = \"big\") {\n    assert_eq!(n.to_be(), n)\n} else {\n    assert_eq!(n.to_be(), n.swap_bytes())\n}" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_math" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  to_be ( self )->  Self {# [ cfg ( target_endian =  "big" )]{ self }# [ cfg ( not ( target_endian =  "big" ))]{ self .  swap_bytes ()}}} doc_comment ! { concat ! ( "Converts `self` to little endian from the target's endianness.\n\nOn little endian this is a no-op. On big endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "let n = 0x1A" ,  stringify ! ($SelfT ),  ";\n\nif cfg!(target_endian = \"little\") {\n    assert_eq!(n.to_le(), n)\n} else {\n    assert_eq!(n.to_le(), n.swap_bytes())\n}" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_math" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  to_le ( self )->  Self {# [ cfg ( target_endian =  "little" )]{ self }# [ cfg ( not ( target_endian =  "little" ))]{ self .  swap_bytes ()}}} doc_comment ! { concat ! ( "Checked integer addition. Computes `self + rhs`, returning `None`\nif overflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!((" ,  stringify ! ($SelfT ),  "::MAX - 2).checked_add(1), " ,  "Some(" ,  stringify ! ($SelfT ),  "::MAX - 1));\nassert_eq!((" ,  stringify ! ($SelfT ),  "::MAX - 2).checked_add(3), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_checked_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_add ( self ,  rhs :  Self )->  Option <  Self > { let ( a ,  b )=  self .  overflowing_add ( rhs );  if  unlikely ! ( b ){ None } else { Some ( a )}}} doc_comment ! { concat ! ( "Unchecked integer addition. Computes `self + rhs`, assuming overflow\ncannot occur. This results in undefined behavior when `self + rhs > " ,  stringify ! ($SelfT ),  "::MAX` or `self + rhs < " ,  stringify ! ($SelfT ),  "::MIN`." ), # [ unstable ( feature =  "unchecked_math" ,  reason =  "niche optimization path" ,  issue =  "none" , )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  unsafe  fn  unchecked_add ( self ,  rhs :  Self )->  Self { unsafe { intrinsics ::  unchecked_add ( self ,  rhs )}}} doc_comment ! { concat ! ( "Checked integer subtraction. Computes `self - rhs`, returning\n`None` if overflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(1" ,  stringify ! ($SelfT ),  ".checked_sub(1), Some(0));\nassert_eq!(0" ,  stringify ! ($SelfT ),  ".checked_sub(1), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_checked_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_sub ( self ,  rhs :  Self )->  Option <  Self > { let ( a ,  b )=  self .  overflowing_sub ( rhs );  if  unlikely ! ( b ){ None } else { Some ( a )}}} doc_comment ! { concat ! ( "Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\ncannot occur. This results in undefined behavior when `self - rhs > " ,  stringify ! ($SelfT ),  "::MAX` or `self - rhs < " ,  stringify ! ($SelfT ),  "::MIN`." ), # [ unstable ( feature =  "unchecked_math" ,  reason =  "niche optimization path" ,  issue =  "none" , )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  unsafe  fn  unchecked_sub ( self ,  rhs :  Self )->  Self { unsafe { intrinsics ::  unchecked_sub ( self ,  rhs )}}} doc_comment ! { concat ! ( "Checked integer multiplication. Computes `self * rhs`, returning\n`None` if overflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(5" ,  stringify ! ($SelfT ),  ".checked_mul(1), Some(5));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.checked_mul(2), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_checked_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_mul ( self ,  rhs :  Self )->  Option <  Self > { let ( a ,  b )=  self .  overflowing_mul ( rhs );  if  unlikely ! ( b ){ None } else { Some ( a )}}} doc_comment ! { concat ! ( "Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\ncannot occur. This results in undefined behavior when `self * rhs > " ,  stringify ! ($SelfT ),  "::MAX` or `self * rhs < " ,  stringify ! ($SelfT ),  "::MIN`." ), # [ unstable ( feature =  "unchecked_math" ,  reason =  "niche optimization path" ,  issue =  "none" , )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  unsafe  fn  unchecked_mul ( self ,  rhs :  Self )->  Self { unsafe { intrinsics ::  unchecked_mul ( self ,  rhs )}}} doc_comment ! { concat ! ( "Checked integer division. Computes `self / rhs`, returning `None`\nif `rhs == 0`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(128" ,  stringify ! ($SelfT ),  ".checked_div(2), Some(64));\nassert_eq!(1" ,  stringify ! ($SelfT ),  ".checked_div(0), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_unstable ( feature =  "const_checked_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_div ( self ,  rhs :  Self )->  Option <  Self > { if  unlikely ! ( rhs ==  0 ){ None } else { Some ( unsafe { intrinsics ::  unchecked_div ( self ,  rhs )})}}} doc_comment ! { concat ! ( "Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\nif `rhs == 0`.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(128" ,  stringify ! ($SelfT ),  ".checked_div_euclid(2), Some(64));\nassert_eq!(1" ,  stringify ! ($SelfT ),  ".checked_div_euclid(0), None);\n```" ), # [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_div_euclid ( self ,  rhs :  Self )->  Option <  Self > { if  unlikely ! ( rhs ==  0 ){ None } else { Some ( self .  div_euclid ( rhs ))}}} doc_comment ! { concat ! ( "Checked integer remainder. Computes `self % rhs`, returning `None`\nif `rhs == 0`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(5" ,  stringify ! ($SelfT ),  ".checked_rem(2), Some(1));\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".checked_rem(0), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_unstable ( feature =  "const_checked_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_rem ( self ,  rhs :  Self )->  Option <  Self > { if  unlikely ! ( rhs ==  0 ){ None } else { Some ( unsafe { intrinsics ::  unchecked_rem ( self ,  rhs )})}}} doc_comment ! { concat ! ( "Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\nif `rhs == 0`.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".checked_rem_euclid(2), Some(1));\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".checked_rem_euclid(0), None);\n```" ), # [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_rem_euclid ( self ,  rhs :  Self )->  Option <  Self > { if  unlikely ! ( rhs ==  0 ){ None } else { Some ( self .  rem_euclid ( rhs ))}}} doc_comment ! { concat ! ( "Checked negation. Computes `-self`, returning `None` unless `self ==\n0`.\n\nNote that negating any positive integer will overflow.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(0" ,  stringify ! ($SelfT ),  ".checked_neg(), Some(0));\nassert_eq!(1" ,  stringify ! ($SelfT ),  ".checked_neg(), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_checked_int_methods" ,  since =  "1.47.0" )]# [ inline ] pub  const  fn  checked_neg ( self )->  Option <  Self > { let ( a ,  b )=  self .  overflowing_neg ();  if  unlikely ! ( b ){ None } else { Some ( a )}}} doc_comment ! { concat ! ( "Checked shift left. Computes `self << rhs`, returning `None`\nif `rhs` is larger than or equal to the number of bits in `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(0x1" ,  stringify ! ($SelfT ),  ".checked_shl(4), Some(0x10));\nassert_eq!(0x10" ,  stringify ! ($SelfT ),  ".checked_shl(129), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_checked_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_shl ( self ,  rhs :  u32 )->  Option <  Self > { let ( a ,  b )=  self .  overflowing_shl ( rhs );  if  unlikely ! ( b ){ None } else { Some ( a )}}} doc_comment ! { concat ! ( "Checked shift right. Computes `self >> rhs`, returning `None`\nif `rhs` is larger than or equal to the number of bits in `self`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(0x10" ,  stringify ! ($SelfT ),  ".checked_shr(4), Some(0x1));\nassert_eq!(0x10" ,  stringify ! ($SelfT ),  ".checked_shr(129), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_checked_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_shr ( self ,  rhs :  u32 )->  Option <  Self > { let ( a ,  b )=  self .  overflowing_shr ( rhs );  if  unlikely ! ( b ){ None } else { Some ( a )}}} doc_comment ! { concat ! ( "Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\noverflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(2" ,  stringify ! ($SelfT ),  ".checked_pow(5), Some(32));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.checked_pow(2), None);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "no_panic_pow" ,  since =  "1.34.0" )]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  checked_pow ( self ,  mut  exp :  u32 )->  Option <  Self > { if  exp ==  0 { return  Some ( 1 ); } let  mut  base =  self ;  let  mut  acc :  Self =  1 ;  while  exp >  1 { if ( exp &  1 )==  1 { acc =  try_opt ! ( acc .  checked_mul ( base )); } exp /=  2 ;  base =  try_opt ! ( base .  checked_mul ( base )); } Some ( try_opt ! ( acc .  checked_mul ( base )))}} doc_comment ! { concat ! ( "Saturating integer addition. Computes `self + rhs`, saturating at\nthe numeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".saturating_add(1), 101);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.saturating_add(127), " ,  stringify ! ($SelfT ),  "::MAX);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ rustc_const_stable ( feature =  "const_saturating_int_methods" ,  since =  "1.47.0" )]# [ inline ] pub  const  fn  saturating_add ( self ,  rhs :  Self )->  Self { intrinsics ::  saturating_add ( self ,  rhs )}} doc_comment ! { concat ! ( "Saturating integer subtraction. Computes `self - rhs`, saturating\nat the numeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".saturating_sub(27), 73);\nassert_eq!(13" ,  stringify ! ($SelfT ),  ".saturating_sub(127), 0);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ rustc_const_stable ( feature =  "const_saturating_int_methods" ,  since =  "1.47.0" )]# [ inline ] pub  const  fn  saturating_sub ( self ,  rhs :  Self )->  Self { intrinsics ::  saturating_sub ( self ,  rhs )}} doc_comment ! { concat ! ( "Saturating integer multiplication. Computes `self * rhs`,\nsaturating at the numeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "\nassert_eq!(2" ,  stringify ! ($SelfT ),  ".saturating_mul(10), 20);\nassert_eq!((" ,  stringify ! ($SelfT ),  "::MAX).saturating_mul(10), " ,  stringify ! ($SelfT ),  "::MAX);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_saturating_int_methods" ,  since =  "1.47.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  saturating_mul ( self ,  rhs :  Self )->  Self { match  self .  checked_mul ( rhs ){ Some ( x )=> x ,  None => Self ::  MAX , }}} doc_comment ! { concat ! ( "Saturating integer exponentiation. Computes `self.pow(exp)`,\nsaturating at the numeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "\nassert_eq!(4" ,  stringify ! ($SelfT ),  ".saturating_pow(3), 64);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.saturating_pow(2), " ,  stringify ! ($SelfT ),  "::MAX);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "no_panic_pow" ,  since =  "1.34.0" )]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  saturating_pow ( self ,  exp :  u32 )->  Self { match  self .  checked_pow ( exp ){ Some ( x )=> x ,  None => Self ::  MAX , }}} doc_comment ! { concat ! ( "Wrapping (modular) addition. Computes `self + rhs`,\nwrapping around at the boundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(200" ,  stringify ! ($SelfT ),  ".wrapping_add(55), 255);\nassert_eq!(200" ,  stringify ! ($SelfT ),  ".wrapping_add(" ,  stringify ! ($SelfT ),  "::MAX), 199);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_wrapping_math" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_add ( self ,  rhs :  Self )->  Self { intrinsics ::  wrapping_add ( self ,  rhs )}} doc_comment ! { concat ! ( "Wrapping (modular) subtraction. Computes `self - rhs`,\nwrapping around at the boundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".wrapping_sub(100), 0);\nassert_eq!(100" ,  stringify ! ($SelfT ),  ".wrapping_sub(" ,  stringify ! ($SelfT ),  "::MAX), 101);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_wrapping_math" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_sub ( self ,  rhs :  Self )->  Self { intrinsics ::  wrapping_sub ( self ,  rhs )}}# [ doc =  " Wrapping (modular) multiplication. Computes `self *" ]# [ doc =  " rhs`, wrapping around at the boundary of the type." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " Basic usage:" ]# [ doc =  "" ]# [ doc =  " Please note that this example is shared between integer types." ]# [ doc =  " Which explains why `u8` is used here." ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " assert_eq!(10u8.wrapping_mul(12), 120);" ]# [ doc =  " assert_eq!(25u8.wrapping_mul(12), 44);" ]# [ doc =  " ```" ]# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_wrapping_math" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_mul ( self ,  rhs :  Self )->  Self { intrinsics ::  wrapping_mul ( self ,  rhs )} doc_comment ! { concat ! ( "Wrapping (modular) division. Computes `self / rhs`.\nWrapped division on unsigned types is just normal division.\nThere's no way wrapping could ever happen.\nThis function exists, so that all operations\nare accounted for in the wrapping operations.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".wrapping_div(10), 10);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "num_wrapping" ,  since =  "1.2.0" )]# [ rustc_const_unstable ( feature =  "const_wrapping_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_div ( self ,  rhs :  Self )->  Self { self /  rhs }} doc_comment ! { concat ! ( "Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\nWrapped division on unsigned types is just normal division.\nThere's no way wrapping could ever happen.\nThis function exists, so that all operations\nare accounted for in the wrapping operations.\nSince, for the positive integers, all common\ndefinitions of division are equal, this\nis exactly equal to `self.wrapping_div(rhs)`.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(100" ,  stringify ! ($SelfT ),  ".wrapping_div_euclid(10), 10);\n```" ), # [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_div_euclid ( self ,  rhs :  Self )->  Self { self /  rhs }} doc_comment ! { concat ! ( "Wrapping (modular) remainder. Computes `self % rhs`.\nWrapped remainder calculation on unsigned types is\njust the regular remainder calculation.\nThere's no way wrapping could ever happen.\nThis function exists, so that all operations\nare accounted for in the wrapping operations.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(100" ,  stringify ! ($SelfT ),  ".wrapping_rem(10), 0);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "num_wrapping" ,  since =  "1.2.0" )]# [ rustc_const_unstable ( feature =  "const_wrapping_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_rem ( self ,  rhs :  Self )->  Self { self %  rhs }} doc_comment ! { concat ! ( "Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\nWrapped modulo calculation on unsigned types is\njust the regular remainder calculation.\nThere's no way wrapping could ever happen.\nThis function exists, so that all operations\nare accounted for in the wrapping operations.\nSince, for the positive integers, all common\ndefinitions of division are equal, this\nis exactly equal to `self.wrapping_rem(rhs)`.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(100" ,  stringify ! ($SelfT ),  ".wrapping_rem_euclid(10), 0);\n```" ), # [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_rem_euclid ( self ,  rhs :  Self )->  Self { self %  rhs }}# [ doc =  " Wrapping (modular) negation. Computes `-self`," ]# [ doc =  " wrapping around at the boundary of the type." ]# [ doc =  "" ]# [ doc =  " Since unsigned types do not have negative equivalents" ]# [ doc =  " all applications of this function will wrap (except for `-0`)." ]# [ doc =  " For values smaller than the corresponding signed type\\\'s maximum" ]# [ doc =  " the result is the same as casting the corresponding signed value." ]# [ doc =  " Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where" ]# [ doc =  " `MAX` is the corresponding signed type\\\'s maximum." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " Basic usage:" ]# [ doc =  "" ]# [ doc =  " Please note that this example is shared between integer types." ]# [ doc =  " Which explains why `i8` is used here." ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " assert_eq!(100i8.wrapping_neg(), -100);" ]# [ doc =  " assert_eq!((-128i8).wrapping_neg(), -128);" ]# [ doc =  " ```" ]# [ stable ( feature =  "num_wrapping" ,  since =  "1.2.0" )]# [ rustc_const_stable ( feature =  "const_wrapping_math" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  wrapping_neg ( self )->  Self { self .  overflowing_neg ().  0 } doc_comment ! { concat ! ( "Panic-free bitwise shift-left; yields `self << mask(rhs)`,\nwhere `mask` removes any high-order bits of `rhs` that\nwould cause the shift to exceed the bitwidth of the type.\n\nNote that this is *not* the same as a rotate-left; the\nRHS of a wrapping shift-left is restricted to the range\nof the type, rather than the bits shifted out of the LHS\nbeing returned to the other end. The primitive integer\ntypes all implement a [`rotate_left`](#method.rotate_left) function,\nwhich may be what you want instead.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(1" ,  stringify ! ($SelfT ),  ".wrapping_shl(7), 128);\nassert_eq!(1" ,  stringify ! ($SelfT ),  ".wrapping_shl(128), 1);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "num_wrapping" ,  since =  "1.2.0" )]# [ rustc_const_stable ( feature =  "const_wrapping_math" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_shl ( self ,  rhs :  u32 )->  Self { unsafe { intrinsics ::  unchecked_shl ( self , ( rhs & ($BITS -  1 )) as $SelfT )}}} doc_comment ! { concat ! ( "Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\nwhere `mask` removes any high-order bits of `rhs` that\nwould cause the shift to exceed the bitwidth of the type.\n\nNote that this is *not* the same as a rotate-right; the\nRHS of a wrapping shift-right is restricted to the range\nof the type, rather than the bits shifted out of the LHS\nbeing returned to the other end. The primitive integer\ntypes all implement a [`rotate_right`](#method.rotate_right) function,\nwhich may be what you want instead.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(128" ,  stringify ! ($SelfT ),  ".wrapping_shr(7), 1);\nassert_eq!(128" ,  stringify ! ($SelfT ),  ".wrapping_shr(128), 128);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "num_wrapping" ,  since =  "1.2.0" )]# [ rustc_const_stable ( feature =  "const_wrapping_math" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_shr ( self ,  rhs :  u32 )->  Self { unsafe { intrinsics ::  unchecked_shr ( self , ( rhs & ($BITS -  1 )) as $SelfT )}}} doc_comment ! { concat ! ( "Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\nwrapping around at the boundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(3" ,  stringify ! ($SelfT ),  ".wrapping_pow(5), 243);\nassert_eq!(3u8.wrapping_pow(6), 217);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "no_panic_pow" ,  since =  "1.34.0" )]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  wrapping_pow ( self ,  mut  exp :  u32 )->  Self { if  exp ==  0 { return  1 ; } let  mut  base =  self ;  let  mut  acc :  Self =  1 ;  while  exp >  1 { if ( exp &  1 )==  1 { acc =  acc .  wrapping_mul ( base ); } exp /=  2 ;  base =  base .  wrapping_mul ( base ); } acc .  wrapping_mul ( base )}} doc_comment ! { concat ! ( "Calculates `self` + `rhs`\n\nReturns a tuple of the addition along with a boolean indicating\nwhether an arithmetic overflow would occur. If an overflow would\nhave occurred then the wrapped value is returned.\n\n# Examples\n\nBasic usage\n\n```\n" , $Feature ,  "\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".overflowing_add(2), (7, false));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.overflowing_add(1), (0, true));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_wrapping_math" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  overflowing_add ( self ,  rhs :  Self )-> ( Self ,  bool ){ let ( a ,  b )=  intrinsics ::  add_with_overflow ( self  as $ActualT ,  rhs  as $ActualT ); ( a  as  Self ,  b )}} doc_comment ! { concat ! ( "Calculates `self` - `rhs`\n\nReturns a tuple of the subtraction along with a boolean indicating\nwhether an arithmetic overflow would occur. If an overflow would\nhave occurred then the wrapped value is returned.\n\n# Examples\n\nBasic usage\n\n```\n" , $Feature ,  "\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".overflowing_sub(2), (3, false));\nassert_eq!(0" ,  stringify ! ($SelfT ),  ".overflowing_sub(1), (" ,  stringify ! ($SelfT ),  "::MAX, true));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_wrapping_math" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  overflowing_sub ( self ,  rhs :  Self )-> ( Self ,  bool ){ let ( a ,  b )=  intrinsics ::  sub_with_overflow ( self  as $ActualT ,  rhs  as $ActualT ); ( a  as  Self ,  b )}}# [ doc =  " Calculates the multiplication of `self` and `rhs`." ]# [ doc =  "" ]# [ doc =  " Returns a tuple of the multiplication along with a boolean" ]# [ doc =  " indicating whether an arithmetic overflow would occur. If an" ]# [ doc =  " overflow would have occurred then the wrapped value is returned." ]# [ doc =  "" ]# [ doc =  " # Examples" ]# [ doc =  "" ]# [ doc =  " Basic usage:" ]# [ doc =  "" ]# [ doc =  " Please note that this example is shared between integer types." ]# [ doc =  " Which explains why `u32` is used here." ]# [ doc =  "" ]# [ doc =  " ```" ]# [ doc =  " assert_eq!(5u32.overflowing_mul(2), (10, false));" ]# [ doc =  " assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));" ]# [ doc =  " ```" ]# [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_wrapping_math" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  overflowing_mul ( self ,  rhs :  Self )-> ( Self ,  bool ){ let ( a ,  b )=  intrinsics ::  mul_with_overflow ( self  as $ActualT ,  rhs  as $ActualT ); ( a  as  Self ,  b )} doc_comment ! { concat ! ( "Calculates the divisor when `self` is divided by `rhs`.\n\nReturns a tuple of the divisor along with a boolean indicating\nwhether an arithmetic overflow would occur. Note that for unsigned\nintegers overflow never occurs, so the second value is always\n`false`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage\n\n```\n" , $Feature ,  "assert_eq!(5" ,  stringify ! ($SelfT ),  ".overflowing_div(2), (2, false));" , $EndFeature ,  "\n```" ), # [ inline ]# [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_unstable ( feature =  "const_overflowing_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ] pub  const  fn  overflowing_div ( self ,  rhs :  Self )-> ( Self ,  bool ){( self /  rhs ,  false )}} doc_comment ! { concat ! ( "Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n\nReturns a tuple of the divisor along with a boolean indicating\nwhether an arithmetic overflow would occur. Note that for unsigned\nintegers overflow never occurs, so the second value is always\n`false`.\nSince, for the positive integers, all common\ndefinitions of division are equal, this\nis exactly equal to `self.overflowing_div(rhs)`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage\n\n```\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".overflowing_div_euclid(2), (2, false));\n```" ), # [ inline ]# [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ] pub  const  fn  overflowing_div_euclid ( self ,  rhs :  Self )-> ( Self ,  bool ){( self /  rhs ,  false )}} doc_comment ! { concat ! ( "Calculates the remainder when `self` is divided by `rhs`.\n\nReturns a tuple of the remainder after dividing along with a boolean\nindicating whether an arithmetic overflow would occur. Note that for\nunsigned integers overflow never occurs, so the second value is\nalways `false`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage\n\n```\n" , $Feature ,  "assert_eq!(5" ,  stringify ! ($SelfT ),  ".overflowing_rem(2), (1, false));" , $EndFeature ,  "\n```" ), # [ inline ]# [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_unstable ( feature =  "const_overflowing_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ] pub  const  fn  overflowing_rem ( self ,  rhs :  Self )-> ( Self ,  bool ){( self %  rhs ,  false )}} doc_comment ! { concat ! ( "Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n\nReturns a tuple of the modulo after dividing along with a boolean\nindicating whether an arithmetic overflow would occur. Note that for\nunsigned integers overflow never occurs, so the second value is\nalways `false`.\nSince, for the positive integers, all common\ndefinitions of division are equal, this operation\nis exactly equal to `self.overflowing_rem(rhs)`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage\n\n```\nassert_eq!(5" ,  stringify ! ($SelfT ),  ".overflowing_rem_euclid(2), (1, false));\n```" ), # [ inline ]# [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ] pub  const  fn  overflowing_rem_euclid ( self ,  rhs :  Self )-> ( Self ,  bool ){( self %  rhs ,  false )}} doc_comment ! { concat ! ( "Negates self in an overflowing fashion.\n\nReturns `!self + 1` using wrapping operations to return the value\nthat represents the negation of this unsigned value. Note that for\npositive unsigned values overflow always occurs, but negating 0 does\nnot overflow.\n\n# Examples\n\nBasic usage\n\n```\n" , $Feature ,  "assert_eq!(0" ,  stringify ! ($SelfT ),  ".overflowing_neg(), (0, false));\nassert_eq!(2" ,  stringify ! ($SelfT ),  ".overflowing_neg(), (-2i32 as " ,  stringify ! ($SelfT ),  ", true));" , $EndFeature ,  "\n```" ), # [ inline ]# [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_wrapping_math" ,  since =  "1.32.0" )] pub  const  fn  overflowing_neg ( self )-> ( Self ,  bool ){((!  self ).  wrapping_add ( 1 ),  self !=  0 )}} doc_comment ! { concat ! ( "Shifts self left by `rhs` bits.\n\nReturns a tuple of the shifted version of self along with a boolean\nindicating whether the shift value was larger than or equal to the\nnumber of bits. If the shift value is too large, then value is\nmasked (N-1) where N is the number of bits, and this value is then\nused to perform the shift.\n\n# Examples\n\nBasic usage\n\n```\n" , $Feature ,  "assert_eq!(0x1" ,  stringify ! ($SelfT ),  ".overflowing_shl(4), (0x10, false));\nassert_eq!(0x1" ,  stringify ! ($SelfT ),  ".overflowing_shl(132), (0x10, true));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_wrapping_math" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  overflowing_shl ( self ,  rhs :  u32 )-> ( Self ,  bool ){( self .  wrapping_shl ( rhs ), ( rhs > ($BITS -  1 )))}} doc_comment ! { concat ! ( "Shifts self right by `rhs` bits.\n\nReturns a tuple of the shifted version of self along with a boolean\nindicating whether the shift value was larger than or equal to the\nnumber of bits. If the shift value is too large, then value is\nmasked (N-1) where N is the number of bits, and this value is then\nused to perform the shift.\n\n# Examples\n\nBasic usage\n\n```\n" , $Feature ,  "assert_eq!(0x10" ,  stringify ! ($SelfT ),  ".overflowing_shr(4), (0x1, false));\nassert_eq!(0x10" ,  stringify ! ($SelfT ),  ".overflowing_shr(132), (0x1, true));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "wrapping" ,  since =  "1.7.0" )]# [ rustc_const_stable ( feature =  "const_wrapping_math" ,  since =  "1.32.0" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  overflowing_shr ( self ,  rhs :  u32 )-> ( Self ,  bool ){( self .  wrapping_shr ( rhs ), ( rhs > ($BITS -  1 )))}} doc_comment ! { concat ! ( "Raises self to the power of `exp`, using exponentiation by squaring.\n\nReturns a tuple of the exponentiation along with a bool indicating\nwhether an overflow happened.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(3" ,  stringify ! ($SelfT ),  ".overflowing_pow(5), (243, false));\nassert_eq!(3u8.overflowing_pow(6), (217, true));" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "no_panic_pow" ,  since =  "1.34.0" )]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ] pub  const  fn  overflowing_pow ( self ,  mut  exp :  u32 )-> ( Self ,  bool ){ if  exp ==  0 { return ( 1 ,  false ); } let  mut  base =  self ;  let  mut  acc :  Self =  1 ;  let  mut  overflown =  false ;  let  mut  r ;  while  exp >  1 { if ( exp &  1 )==  1 { r =  acc .  overflowing_mul ( base );  acc =  r .  0 ;  overflown |=  r .  1 ; } exp /=  2 ;  r =  base .  overflowing_mul ( base );  base =  r .  0 ;  overflown |=  r .  1 ; } r =  acc .  overflowing_mul ( base );  r .  1 |=  overflown ;  r }} doc_comment ! { concat ! ( "Raises self to the power of `exp`, using exponentiation by squaring.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(2" ,  stringify ! ($SelfT ),  ".pow(5), 32);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ]# [ rustc_inherit_overflow_checks ] pub  const  fn  pow ( self ,  mut  exp :  u32 )->  Self { if  exp ==  0 { return  1 ; } let  mut  base =  self ;  let  mut  acc =  1 ;  while  exp >  1 { if ( exp &  1 )==  1 { acc =  acc *  base ; } exp /=  2 ;  base =  base *  base ; } acc *  base }} doc_comment ! { concat ! ( "Performs Euclidean division.\n\nSince, for the positive integers, all common\ndefinitions of division are equal, this\nis exactly equal to `self / rhs`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(7" ,  stringify ! ($SelfT ),  ".div_euclid(4), 1); // or any other integer type\n```" ), # [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ]# [ rustc_inherit_overflow_checks ] pub  const  fn  div_euclid ( self ,  rhs :  Self )->  Self { self /  rhs }} doc_comment ! { concat ! ( "Calculates the least remainder of `self (mod rhs)`.\n\nSince, for the positive integers, all common\ndefinitions of division are equal, this\nis exactly equal to `self % rhs`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(7" ,  stringify ! ($SelfT ),  ".rem_euclid(4), 3); // or any other integer type\n```" ), # [ stable ( feature =  "euclidean_division" ,  since =  "1.38.0" )]# [ rustc_const_unstable ( feature =  "const_euclidean_int_methods" ,  issue =  "53718" )]# [ must_use =  "this returns the result of the operation, \\n                          without modifying the original" ]# [ inline ]# [ rustc_inherit_overflow_checks ] pub  const  fn  rem_euclid ( self ,  rhs :  Self )->  Self { self %  rhs }} doc_comment ! { concat ! ( "Returns `true` if and only if `self == 2^k` for some `k`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert!(16" ,  stringify ! ($SelfT ),  ".is_power_of_two());\nassert!(!10" ,  stringify ! ($SelfT ),  ".is_power_of_two());" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_stable ( feature =  "const_is_power_of_two" ,  since =  "1.32.0" )]# [ inline ] pub  const  fn  is_power_of_two ( self )->  bool { self .  count_ones ()==  1 }}# [ inline ]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )] const  fn  one_less_than_next_power_of_two ( self )->  Self { if  self <=  1 { return  0 ; } let  p =  self -  1 ;  let  z =  unsafe { intrinsics ::  ctlz_nonzero ( p )}; <$SelfT >::  MAX >>  z } doc_comment ! { concat ! ( "Returns the smallest power of two greater than or equal to `self`.\n\nWhen return value overflows (i.e., `self > (1 << (N-1))` for type\n`uN`), it panics in debug mode and return value is wrapped to 0 in\nrelease mode (the only situation in which method can return 0).\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(2" ,  stringify ! ($SelfT ),  ".next_power_of_two(), 2);\nassert_eq!(3" ,  stringify ! ($SelfT ),  ".next_power_of_two(), 4);" , $EndFeature ,  "\n```" ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )]# [ inline ]# [ rustc_inherit_overflow_checks ] pub  const  fn  next_power_of_two ( self )->  Self { self .  one_less_than_next_power_of_two ()+  1 }} doc_comment ! { concat ! ( "Returns the smallest power of two greater than or equal to `n`. If\nthe next power of two is greater than the type's maximum value,\n`None` is returned, otherwise the power of two is wrapped in `Some`.\n\n# Examples\n\nBasic usage:\n\n```\n" , $Feature ,  "assert_eq!(2" ,  stringify ! ($SelfT ),  ".checked_next_power_of_two(), Some(2));\nassert_eq!(3" ,  stringify ! ($SelfT ),  ".checked_next_power_of_two(), Some(4));\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.checked_next_power_of_two(), None);" , $EndFeature ,  "\n```" ), # [ inline ]# [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )] pub  const  fn  checked_next_power_of_two ( self )->  Option <  Self > { self .  one_less_than_next_power_of_two ().  checked_add ( 1 )}} doc_comment ! { concat ! ( "Returns the smallest power of two greater than or equal to `n`. If\nthe next power of two is greater than the type's maximum value,\nthe return value is wrapped to `0`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_next_power_of_two)]\n" , $Feature ,  "\nassert_eq!(2" ,  stringify ! ($SelfT ),  ".wrapping_next_power_of_two(), 2);\nassert_eq!(3" ,  stringify ! ($SelfT ),  ".wrapping_next_power_of_two(), 4);\nassert_eq!(" ,  stringify ! ($SelfT ),  "::MAX.wrapping_next_power_of_two(), 0);" , $EndFeature ,  "\n```" ), # [ unstable ( feature =  "wrapping_next_power_of_two" ,  issue =  "32463" ,  reason =  "needs decision on wrapping behaviour" )]# [ rustc_const_unstable ( feature =  "const_int_pow" ,  issue =  "53718" )] pub  const  fn  wrapping_next_power_of_two ( self )->  Self { self .  one_less_than_next_power_of_two ().  wrapping_add ( 1 )}} doc_comment ! { concat ! ( "Return the memory representation of this integer as a byte array in\nbig-endian (network) byte order.\n" , $to_xe_bytes_doc ,  "\n# Examples\n\n```\nlet bytes = " , $swap_op ,  stringify ! ($SelfT ),  ".to_be_bytes();\nassert_eq!(bytes, " , $be_bytes ,  ");\n```" ), # [ stable ( feature =  "int_to_from_bytes" ,  since =  "1.32.0" )]# [ rustc_const_stable ( feature =  "const_int_conversion" ,  since =  "1.44.0" )]# [ inline ] pub  const  fn  to_be_bytes ( self )-> [ u8 ;  mem ::  size_of ::<  Self > ()]{ self .  to_be ().  to_ne_bytes ()}} doc_comment ! { concat ! ( "Return the memory representation of this integer as a byte array in\nlittle-endian byte order.\n" , $to_xe_bytes_doc ,  "\n# Examples\n\n```\nlet bytes = " , $swap_op ,  stringify ! ($SelfT ),  ".to_le_bytes();\nassert_eq!(bytes, " , $le_bytes ,  ");\n```" ), # [ stable ( feature =  "int_to_from_bytes" ,  since =  "1.32.0" )]# [ rustc_const_stable ( feature =  "const_int_conversion" ,  since =  "1.44.0" )]# [ inline ] pub  const  fn  to_le_bytes ( self )-> [ u8 ;  mem ::  size_of ::<  Self > ()]{ self .  to_le ().  to_ne_bytes ()}} doc_comment ! { concat ! ( "\nReturn the memory representation of this integer as a byte array in\nnative byte order.\n\nAs the target platform's native endianness is used, portable code\nshould use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\ninstead.\n" , $to_xe_bytes_doc ,  "\n[`to_be_bytes`]: #method.to_be_bytes\n[`to_le_bytes`]: #method.to_le_bytes\n\n# Examples\n\n```\nlet bytes = " , $swap_op ,  stringify ! ($SelfT ),  ".to_ne_bytes();\nassert_eq!(\n    bytes,\n    if cfg!(target_endian = \"big\") {\n        " , $be_bytes ,  "\n    } else {\n        " , $le_bytes ,  "\n    }\n);\n```" ), # [ stable ( feature =  "int_to_from_bytes" ,  since =  "1.32.0" )]# [ rustc_const_stable ( feature =  "const_int_conversion" ,  since =  "1.44.0" )]# [ cfg_attr ( not ( bootstrap ),  rustc_allow_const_fn_unstable ( const_fn_transmute ))]# [ cfg_attr ( bootstrap ,  allow_internal_unstable ( const_fn_transmute ))]# [ inline ] pub  const  fn  to_ne_bytes ( self )-> [ u8 ;  mem ::  size_of ::<  Self > ()]{ unsafe { mem ::  transmute ( self )}}} doc_comment ! { concat ! ( "\nReturn the memory representation of this integer as a byte array in\nnative byte order.\n\n[`to_ne_bytes`] should be preferred over this whenever possible.\n\n[`to_ne_bytes`]: #method.to_ne_bytes\n" ,  "\n# Examples\n\n```\n#![feature(num_as_ne_bytes)]\nlet num = " , $swap_op ,  stringify ! ($SelfT ),  ";\nlet bytes = num.as_ne_bytes();\nassert_eq!(\n    bytes,\n    if cfg!(target_endian = \"big\") {\n        &" , $be_bytes ,  "\n    } else {\n        &" , $le_bytes ,  "\n    }\n);\n```" ), # [ unstable ( feature =  "num_as_ne_bytes" ,  issue =  "76976" )]# [ inline ] pub  fn  as_ne_bytes (&  self )-> & [ u8 ;  mem ::  size_of ::<  Self > ()]{ unsafe {&* ( self  as *  const  Self  as *  const _)}}} doc_comment ! { concat ! ( "Create a native endian integer value from its representation\nas a byte array in big endian.\n" , $from_xe_bytes_doc ,  "\n# Examples\n\n```\nlet value = " ,  stringify ! ($SelfT ),  "::from_be_bytes(" , $be_bytes ,  ");\nassert_eq!(value, " , $swap_op ,  ");\n```\n\nWhen starting from a slice rather than an array, fallible conversion APIs can be used:\n\n```\nuse std::convert::TryInto;\n\nfn read_be_" ,  stringify ! ($SelfT ),  "(input: &mut &[u8]) -> " ,  stringify ! ($SelfT ),  " {\n    let (int_bytes, rest) = input.split_at(std::mem::size_of::<" ,  stringify ! ($SelfT ),  ">());\n    *input = rest;\n    " ,  stringify ! ($SelfT ),  "::from_be_bytes(int_bytes.try_into().unwrap())\n}\n```" ), # [ stable ( feature =  "int_to_from_bytes" ,  since =  "1.32.0" )]# [ rustc_const_stable ( feature =  "const_int_conversion" ,  since =  "1.44.0" )]# [ inline ] pub  const  fn  from_be_bytes ( bytes : [ u8 ;  mem ::  size_of ::<  Self > ()])->  Self { Self ::  from_be ( Self ::  from_ne_bytes ( bytes ))}} doc_comment ! { concat ! ( "\nCreate a native endian integer value from its representation\nas a byte array in little endian.\n" , $from_xe_bytes_doc ,  "\n# Examples\n\n```\nlet value = " ,  stringify ! ($SelfT ),  "::from_le_bytes(" , $le_bytes ,  ");\nassert_eq!(value, " , $swap_op ,  ");\n```\n\nWhen starting from a slice rather than an array, fallible conversion APIs can be used:\n\n```\nuse std::convert::TryInto;\n\nfn read_le_" ,  stringify ! ($SelfT ),  "(input: &mut &[u8]) -> " ,  stringify ! ($SelfT ),  " {\n    let (int_bytes, rest) = input.split_at(std::mem::size_of::<" ,  stringify ! ($SelfT ),  ">());\n    *input = rest;\n    " ,  stringify ! ($SelfT ),  "::from_le_bytes(int_bytes.try_into().unwrap())\n}\n```" ), # [ stable ( feature =  "int_to_from_bytes" ,  since =  "1.32.0" )]# [ rustc_const_stable ( feature =  "const_int_conversion" ,  since =  "1.44.0" )]# [ inline ] pub  const  fn  from_le_bytes ( bytes : [ u8 ;  mem ::  size_of ::<  Self > ()])->  Self { Self ::  from_le ( Self ::  from_ne_bytes ( bytes ))}} doc_comment ! { concat ! ( "Create a native endian integer value from its memory representation\nas a byte array in native endianness.\n\nAs the target platform's native endianness is used, portable code\nlikely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\nappropriate instead.\n\n[`from_be_bytes`]: #method.from_be_bytes\n[`from_le_bytes`]: #method.from_le_bytes\n" , $from_xe_bytes_doc ,  "\n# Examples\n\n```\nlet value = " ,  stringify ! ($SelfT ),  "::from_ne_bytes(if cfg!(target_endian = \"big\") {\n    " , $be_bytes ,  "\n} else {\n    " , $le_bytes ,  "\n});\nassert_eq!(value, " , $swap_op ,  ");\n```\n\nWhen starting from a slice rather than an array, fallible conversion APIs can be used:\n\n```\nuse std::convert::TryInto;\n\nfn read_ne_" ,  stringify ! ($SelfT ),  "(input: &mut &[u8]) -> " ,  stringify ! ($SelfT ),  " {\n    let (int_bytes, rest) = input.split_at(std::mem::size_of::<" ,  stringify ! ($SelfT ),  ">());\n    *input = rest;\n    " ,  stringify ! ($SelfT ),  "::from_ne_bytes(int_bytes.try_into().unwrap())\n}\n```" ), # [ stable ( feature =  "int_to_from_bytes" ,  since =  "1.32.0" )]# [ rustc_const_stable ( feature =  "const_int_conversion" ,  since =  "1.44.0" )]# [ cfg_attr ( not ( bootstrap ),  rustc_allow_const_fn_unstable ( const_fn_transmute ))]# [ cfg_attr ( bootstrap ,  allow_internal_unstable ( const_fn_transmute ))]# [ inline ] pub  const  fn  from_ne_bytes ( bytes : [ u8 ;  mem ::  size_of ::<  Self > ()])->  Self { unsafe { mem ::  transmute ( bytes )}}} doc_comment ! { concat ! ( "**This method is soft-deprecated.**\n\nAlthough using it wont cause compilation warning,\nnew code should use [`" ,  stringify ! ($SelfT ),  "::MIN" ,  "`](#associatedconstant.MIN) instead.\n\nReturns the smallest value that can be represented by this integer type." ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_promotable ]# [ inline ( always )]# [ rustc_const_stable ( feature =  "const_max_value" ,  since =  "1.32.0" )] pub  const  fn  min_value ()->  Self { Self ::  MIN }} doc_comment ! { concat ! ( "**This method is soft-deprecated.**\n\nAlthough using it wont cause compilation warning,\nnew code should use [`" ,  stringify ! ($SelfT ),  "::MAX" ,  "`](#associatedconstant.MAX) instead.\n\nReturns the largest value that can be represented by this integer type." ), # [ stable ( feature =  "rust1" ,  since =  "1.0.0" )]# [ rustc_promotable ]# [ inline ( always )]# [ rustc_const_stable ( feature =  "const_max_value" ,  since =  "1.32.0" )] pub  const  fn  max_value ()->  Self { Self ::  MAX }}}}
macro_rules! __ra_macro_fixture433 {($type :  ident )=>{ const  EXPLICIT_SIG_BITS :  u8 =  Self ::  SIG_BITS -  1 ;  const  MAX_EXP :  i16 = ( 1 << ( Self ::  EXP_BITS -  1 ))-  1 ;  const  MIN_EXP :  i16 = -<  Self  as  RawFloat >::  MAX_EXP +  1 ;  const  MAX_EXP_INT :  i16 = <  Self  as  RawFloat >::  MAX_EXP - ( Self ::  SIG_BITS  as  i16 -  1 );  const  MAX_ENCODED_EXP :  i16 = ( 1 <<  Self ::  EXP_BITS )-  1 ;  const  MIN_EXP_INT :  i16 = <  Self  as  RawFloat >::  MIN_EXP - ( Self ::  SIG_BITS  as  i16 -  1 );  const  MAX_SIG :  u64 = ( 1 <<  Self ::  SIG_BITS )-  1 ;  const  MIN_SIG :  u64 =  1 << ( Self ::  SIG_BITS -  1 );  const  INFINITY :  Self = $type ::  INFINITY ;  const  NAN :  Self = $type ::  NAN ;  const  ZERO :  Self =  0.0 ; }; }
macro_rules! __ra_macro_fixture434 {()=>{# [ inline ] unsafe  fn  forward_unchecked ( start :  Self ,  n :  usize )->  Self { unsafe { start .  unchecked_add ( n  as  Self )}}# [ inline ] unsafe  fn  backward_unchecked ( start :  Self ,  n :  usize )->  Self { unsafe { start .  unchecked_sub ( n  as  Self )}}# [ inline ] fn  forward ( start :  Self ,  n :  usize )->  Self { if  Self ::  forward_checked ( start ,  n ).  is_none (){ let _ =  Add ::  add ( Self ::  MAX ,  1 ); } start .  wrapping_add ( n  as  Self )}# [ inline ] fn  backward ( start :  Self ,  n :  usize )->  Self { if  Self ::  backward_checked ( start ,  n ).  is_none (){ let _ =  Sub ::  sub ( Self ::  MIN ,  1 ); } start .  wrapping_sub ( n  as  Self )}}; }
macro_rules! __ra_macro_fixture435 {( u8 , $($tt :  tt )*)=>{ "" }; ( i8 , $($tt :  tt )*)=>{ "" }; ($_:  ident , $($tt :  tt )*)=>{$($tt )* }; }
macro_rules! __ra_macro_fixture436 {( forward )=>{# [ inline ] fn  haystack (&  self )-> & 'a  str { self .  0 .  haystack ()}# [ inline ] fn  next (&  mut  self )->  SearchStep { self .  0 .  next ()}# [ inline ] fn  next_match (&  mut  self )->  Option < ( usize ,  usize )> { self .  0 .  next_match ()}# [ inline ] fn  next_reject (&  mut  self )->  Option < ( usize ,  usize )> { self .  0 .  next_reject ()}}; ( reverse )=>{# [ inline ] fn  next_back (&  mut  self )->  SearchStep { self .  0 .  next_back ()}# [ inline ] fn  next_match_back (&  mut  self )->  Option < ( usize ,  usize )> { self .  0 .  next_match_back ()}# [ inline ] fn  next_reject_back (&  mut  self )->  Option < ( usize ,  usize )> { self .  0 .  next_reject_back ()}}; }
macro_rules! __ra_macro_fixture437 {($t :  ty , $pmap :  expr , $smap :  expr )=>{ type  Searcher = $t ; # [ inline ] fn  into_searcher ( self ,  haystack : & 'a  str )-> $t {($smap )(($pmap )( self ).  into_searcher ( haystack ))}# [ inline ] fn  is_contained_in ( self ,  haystack : & 'a  str )->  bool {($pmap )( self ).  is_contained_in ( haystack )}# [ inline ] fn  is_prefix_of ( self ,  haystack : & 'a  str )->  bool {($pmap )( self ).  is_prefix_of ( haystack )}# [ inline ] fn  strip_prefix_of ( self ,  haystack : & 'a  str )->  Option <& 'a  str > {($pmap )( self ).  strip_prefix_of ( haystack )}# [ inline ] fn  is_suffix_of ( self ,  haystack : & 'a  str )->  bool  where $t :  ReverseSearcher < 'a >, {($pmap )( self ).  is_suffix_of ( haystack )}# [ inline ] fn  strip_suffix_of ( self ,  haystack : & 'a  str )->  Option <& 'a  str >  where $t :  ReverseSearcher < 'a >, {($pmap )( self ).  strip_suffix_of ( haystack )}}; }
macro_rules! __ra_macro_fixture438 {()=>{# [ inline ] fn  is_ascii (&  self )->  bool { self .  is_ascii ()}# [ inline ] fn  to_ascii_uppercase (&  self )->  Self ::  Owned { self .  to_ascii_uppercase ()}# [ inline ] fn  to_ascii_lowercase (&  self )->  Self ::  Owned { self .  to_ascii_lowercase ()}# [ inline ] fn  eq_ignore_ascii_case (&  self ,  o : &  Self )->  bool { self .  eq_ignore_ascii_case ( o )}# [ inline ] fn  make_ascii_uppercase (&  mut  self ){ self .  make_ascii_uppercase (); }# [ inline ] fn  make_ascii_lowercase (&  mut  self ){ self .  make_ascii_lowercase (); }}; }
macro_rules! __ra_macro_fixture439 {()=>($crate ::  vec ::  Vec ::  new ()); ($elem :  expr ; $n :  expr )=>($crate ::  vec ::  from_elem ($elem , $n )); ($($x :  expr ),+ $(,)?)=>(< [_]>::  into_vec ( box [$($x ),+])); }
macro_rules! __ra_macro_fixture440 {($left :  expr , $right :  expr $(,)?)=>({ match (&$left , &$right ){( left_val ,  right_val )=>{ if ! (*  left_val == *  right_val ){ panic ! ( r#"assertion failed: `(left == right)`\n  left: `{:?}`,\n right: `{:?}`"# , &*  left_val , &*  right_val )}}}}); ($left :  expr , $right :  expr , $($arg :  tt )+)=>({ match (& ($left ), & ($right )){( left_val ,  right_val )=>{ if ! (*  left_val == *  right_val ){ panic ! ( r#"assertion failed: `(left == right)`\n  left: `{:?}`,\n right: `{:?}`: {}"# , &*  left_val , &*  right_val , $crate ::  format_args ! ($($arg )+))}}}}); }
macro_rules! __ra_macro_fixture441 {()=>({$crate ::  panic ! ( "explicit panic" )}); ($msg :  expr $(,)?)=>({$crate ::  rt ::  begin_panic ($msg )}); ($fmt :  expr , $($arg :  tt )+)=>({$crate ::  rt ::  begin_panic_fmt (&$crate ::  format_args ! ($fmt , $($arg )+))}); }
macro_rules! __ra_macro_fixture442 {($expression :  expr , $($pattern :  pat )|+ $(if $guard :  expr )? $(,)?)=>{ match $expression {$($pattern )|+ $(if $guard )? => true , _ => false }}}
macro_rules! __ra_macro_fixture443 {()=>{# [ inline ] fn  load_consume (&  self )->  Self ::  Val { self .  load ( Ordering ::  Acquire )}}; }
macro_rules! __ra_macro_fixture444 {($($tt :  tt )*)=>{$($tt )* }}
macro_rules! __ra_macro_fixture445 {($tyname :  ident , $($($field :  ident ).+),*)=>{ fn  fmt (&  self ,  f : &  mut ::  std ::  fmt ::  Formatter )-> ::  std ::  fmt ::  Result { f .  debug_struct ( stringify ! ($tyname ))$(.  field ( stringify ! ($($field ).+), &  self .$($field ).+))* .  finish ()}}}
macro_rules! __ra_macro_fixture446 {($($field :  ident ),*)=>{ fn  clone (&  self )->  Self { Self {$($field :  self .$field .  clone (),)* }}}}
macro_rules! __ra_macro_fixture447 {($method :  ident )=>{ fn $method <  V > ( self ,  visitor :  V )->  Result <  V ::  Value >  where  V :  de ::  Visitor < 'de >, { self .  deserialize_number ( visitor )}}; }
macro_rules! __ra_macro_fixture448 {($method :  ident =>$visit :  ident )=>{ fn $method <  V > ( self ,  visitor :  V )->  Result <  V ::  Value >  where  V :  de ::  Visitor < 'de >, { self .  de .  eat_char ();  self .  de .  scratch .  clear ();  let  string =  tri ! ( self .  de .  read .  parse_str (&  mut  self .  de .  scratch ));  match ( string .  parse (),  string ){( Ok ( integer ), _)=> visitor .$visit ( integer ), ( Err (_),  Reference ::  Borrowed ( s ))=> visitor .  visit_borrowed_str ( s ), ( Err (_),  Reference ::  Copied ( s ))=> visitor .  visit_str ( s ), }}}; }
macro_rules! __ra_macro_fixture449 {($method :  ident )=>{# [ cfg ( not ( feature =  "arbitrary_precision" ))] fn $method <  V > ( self ,  visitor :  V )->  Result <  V ::  Value ,  Error >  where  V :  Visitor < 'de >, { match  self { Value ::  Number ( n )=> n .  deserialize_any ( visitor ), _ => Err ( self .  invalid_type (&  visitor )), }}# [ cfg ( feature =  "arbitrary_precision" )] fn $method <  V > ( self ,  visitor :  V )->  Result <  V ::  Value ,  Error >  where  V :  Visitor < 'de >, { match  self { Value ::  Number ( n )=> n .$method ( visitor ), _ => self .  deserialize_any ( visitor ), }}}; }
macro_rules! __ra_macro_fixture450 {($method :  ident )=>{# [ cfg ( not ( feature =  "arbitrary_precision" ))] fn $method <  V > ( self ,  visitor :  V )->  Result <  V ::  Value ,  Error >  where  V :  Visitor < 'de >, { match *  self { Value ::  Number ( ref  n )=> n .  deserialize_any ( visitor ), _ => Err ( self .  invalid_type (&  visitor )), }}# [ cfg ( feature =  "arbitrary_precision" )] fn $method <  V > ( self ,  visitor :  V )->  Result <  V ::  Value ,  Error >  where  V :  Visitor < 'de >, { match *  self { Value ::  Number ( ref  n )=> n .$method ( visitor ), _ => self .  deserialize_any ( visitor ), }}}; }
macro_rules! __ra_macro_fixture451 {($method :  ident =>$visit :  ident )=>{ fn $method <  V > ( self ,  visitor :  V )->  Result <  V ::  Value ,  Error >  where  V :  Visitor < 'de >, { match ( self .  key .  parse (),  self .  key ){( Ok ( integer ), _)=> visitor .$visit ( integer ), ( Err (_),  Cow ::  Borrowed ( s ))=> visitor .  visit_borrowed_str ( s ), # [ cfg ( any ( feature =  "std" ,  feature =  "alloc" ))]( Err (_),  Cow ::  Owned ( s ))=> visitor .  visit_string ( s ), }}}; }
macro_rules! __ra_macro_fixture452 {(@  expand [$($num_string :  tt )*])=>{# [ cfg ( not ( feature =  "arbitrary_precision" ))]# [ inline ] fn  deserialize_any <  V > ( self ,  visitor :  V )->  Result <  V ::  Value ,  Error >  where  V :  Visitor < 'de >, { match  self .  n { N ::  PosInt ( u )=> visitor .  visit_u64 ( u ),  N ::  NegInt ( i )=> visitor .  visit_i64 ( i ),  N ::  Float ( f )=> visitor .  visit_f64 ( f ), }}# [ cfg ( feature =  "arbitrary_precision" )]# [ inline ] fn  deserialize_any <  V > ( self ,  visitor :  V )->  Result <  V ::  Value ,  Error >  where  V :  Visitor < 'de > { if  let  Some ( u )=  self .  as_u64 (){ return  visitor .  visit_u64 ( u ); } else  if  let  Some ( i )=  self .  as_i64 (){ return  visitor .  visit_i64 ( i ); } else  if  let  Some ( f )=  self .  as_f64 (){ if  ryu ::  Buffer ::  new ().  format_finite ( f )==  self .  n ||  f .  to_string ()==  self .  n { return  visitor .  visit_f64 ( f ); }} visitor .  visit_map ( NumberDeserializer { number :  Some ( self .$($num_string )*), })}}; ( owned )=>{ deserialize_any ! (@  expand [ n ]); }; ( ref )=>{ deserialize_any ! (@  expand [ n .  clone ()]); }; }
macro_rules! __ra_macro_fixture453 {($deserialize :  ident =>$visit :  ident )=>{# [ cfg ( not ( feature =  "arbitrary_precision" ))] fn $deserialize <  V > ( self ,  visitor :  V )->  Result <  V ::  Value ,  Error >  where  V :  Visitor < 'de >, { self .  deserialize_any ( visitor )}# [ cfg ( feature =  "arbitrary_precision" )] fn $deserialize <  V > ( self ,  visitor :  V )->  Result <  V ::  Value ,  Error >  where  V :  de ::  Visitor < 'de >, { visitor .$visit ( self .  n .  parse ().  map_err (|_|  invalid_number ())?)}}; }
macro_rules! __ra_macro_fixture454 {()=>{ fn  __rayon_private__ (&  self )->  crate ::  private ::  PrivateMarker { crate ::  private ::  PrivateMarker }}; }
macro_rules! __ra_macro_fixture455 {()=>{ fn  __rayon_private__ (&  self )->  crate ::  private ::  PrivateMarker { crate ::  private ::  PrivateMarker }}; }
macro_rules! __ra_macro_fixture456 {($map_elt :  expr )=>{ fn  next (&  mut  self )->  Option <  Self ::  Item > { self .  iter .  next ().  map ($map_elt )} fn  size_hint (&  self )-> ( usize ,  Option <  usize >){ self .  iter .  size_hint ()} fn  count ( self )->  usize { self .  iter .  len ()} fn  nth (&  mut  self ,  n :  usize )->  Option <  Self ::  Item > { self .  iter .  nth ( n ).  map ($map_elt )} fn  last ( mut  self )->  Option <  Self ::  Item > { self .  next_back ()} fn  collect <  C > ( self )->  C  where  C :  FromIterator <  Self ::  Item >, { self .  iter .  map ($map_elt ).  collect ()}}; }
macro_rules! __ra_macro_fixture457 {($map_elt :  expr )=>{ fn  next_back (&  mut  self )->  Option <  Self ::  Item > { self .  iter .  next_back ().  map ($map_elt )}}; }
macro_rules! __ra_macro_fixture458 {()=>{# [ doc =  " This trait is private; this method exists to make it" ]# [ doc =  " impossible to implement outside the crate." ]# [ doc ( hidden )] fn  __rayon_private__ (&  self )->  crate ::  private ::  PrivateMarker ; }; }
macro_rules! __ra_macro_fixture459 {($ident :  ident )=>{{# [ cfg ( test )]{ extern  "C" {# [ no_mangle ] static $ident :  std ::  sync ::  atomic ::  AtomicUsize ; } unsafe {$ident .  fetch_add ( 1 ,  std ::  sync ::  atomic ::  Ordering ::  SeqCst ); }}}}; }
macro_rules! __ra_macro_fixture460 {($ident :  ident )=>{# [ no_mangle ] static $ident :  std ::  sync ::  atomic ::  AtomicUsize =  std ::  sync ::  atomic ::  AtomicUsize ::  new ( 0 );  let  _checker = $crate ::  mark ::  MarkChecker ::  new (&$ident ); }; }
macro_rules! __ra_macro_fixture461 {( target : $target :  expr , $($arg :  tt )+)=>( log ! ( target : $target , $crate ::  Level ::  Debug , $($arg )+)); ($($arg :  tt )+)=>( log ! ($crate ::  Level ::  Debug , $($arg )+))}
macro_rules! __ra_macro_fixture462 {()=>($crate ::  eprint ! ( "\n" )); ($($arg :  tt )*)=>({$crate ::  io ::  _eprint ($crate ::  format_args_nl ! ($($arg )*)); })}
macro_rules! __ra_macro_fixture463 {( target : $target :  expr , $($arg :  tt )+)=>( log ! ( target : $target , $crate ::  Level ::  Warn , $($arg )+)); ($($arg :  tt )+)=>( log ! ($crate ::  Level ::  Warn , $($arg )+))}
macro_rules! __ra_macro_fixture464 {( target : $target :  expr , $lvl :  expr , $($arg :  tt )+)=>({ let  lvl = $lvl ;  if  lvl <= $crate ::  STATIC_MAX_LEVEL &&  lvl <= $crate ::  max_level (){$crate ::  __private_api_log ( __log_format_args ! ($($arg )+),  lvl , & ($target ,  __log_module_path ! (),  __log_file ! (),  __log_line ! ()), ); }}); ($lvl :  expr , $($arg :  tt )+)=>( log ! ( target :  __log_module_path ! (), $lvl , $($arg )+))}
macro_rules! __ra_macro_fixture465 {($($args :  tt )*)=>{ format_args ! ($($args )*)}; }
macro_rules! __ra_macro_fixture466 {()=>{ module_path ! ()}; }
macro_rules! __ra_macro_fixture467 {()=>{ file ! ()}; }
macro_rules! __ra_macro_fixture468 {()=>{ line ! ()}; }
macro_rules! __ra_macro_fixture469 {($left :  expr , $right :  expr )=>{ assert_eq_text ! ($left , $right ,)}; ($left :  expr , $right :  expr , $($tt :  tt )*)=>{{ let  left = $left ;  let  right = $right ;  if  left !=  right { if  left .  trim ()==  right .  trim (){ std ::  eprintln ! ( "Left:\n{:?}\n\nRight:\n{:?}\n\nWhitespace difference\n" ,  left ,  right ); } else { let  diff = $crate ::  __diff ( left ,  right );  std ::  eprintln ! ( "Left:\n{}\n\nRight:\n{}\n\nDiff:\n{}\n" ,  left ,  right , $crate ::  format_diff ( diff )); } std ::  eprintln ! ($($tt )*);  panic ! ( "text differs" ); }}}; }
macro_rules! __ra_macro_fixture470 {($($arg :  tt )*)=>($crate ::  io ::  _eprint ($crate ::  format_args ! ($($arg )*))); }
macro_rules! __ra_macro_fixture471 {($left :  expr , $right :  expr $(,)?)=>({ match (&$left , &$right ){( left_val ,  right_val )=>{ if *  left_val == *  right_val { panic ! ( r#"assertion failed: `(left != right)`\n  left: `{:?}`,\n right: `{:?}`"# , &*  left_val , &*  right_val )}}}}); ($left :  expr , $right :  expr , $($arg :  tt )+)=>({ match (& ($left ), & ($right )){( left_val ,  right_val )=>{ if *  left_val == *  right_val { panic ! ( r#"assertion failed: `(left != right)`\n  left: `{:?}`,\n right: `{:?}`: {}"# , &*  left_val , &*  right_val , $crate ::  format_args ! ($($arg )+))}}}}); }
macro_rules! __ra_macro_fixture472 {[[$data :  literal ]]=>{$crate ::  Expect { position : $crate ::  Position { file :  file ! (),  line :  line ! (),  column :  column ! (), },  data : $data , }}; [[]]=>{$crate ::  expect ! [[ "" ]]}; }
macro_rules! __ra_macro_fixture473 {( self )=>{$crate ::  name ::  known ::  SELF_PARAM }; ( Self )=>{$crate ::  name ::  known ::  SELF_TYPE }; ('static )=>{$crate ::  name ::  known ::  STATIC_LIFETIME }; ($ident :  ident )=>{$crate ::  name ::  known ::$ident }; }
macro_rules! __ra_macro_fixture474 {()=>({ panic ! ( "internal error: entered unreachable code" )}); ($msg :  expr $(,)?)=>({$crate ::  unreachable ! ( "{}" , $msg )}); ($fmt :  expr , $($arg :  tt )*)=>({ panic ! ($crate ::  concat ! ( "internal error: entered unreachable code: " , $fmt ), $($arg )*)}); }
macro_rules! __ra_macro_fixture475 {( target : $target :  expr , $($arg :  tt )+)=>( log ! ( target : $target , $crate ::  Level ::  Error , $($arg )+)); ($($arg :  tt )+)=>( log ! ($crate ::  Level ::  Error , $($arg )+))}
macro_rules! __ra_macro_fixture476 {( target : $target :  expr , $($arg :  tt )+)=>( log ! ( target : $target , $crate ::  Level ::  Trace , $($arg )+)); ($($arg :  tt )+)=>( log ! ($crate ::  Level ::  Trace , $($arg )+))}
macro_rules! __ra_macro_fixture477 {($buf :  expr )=>(); ($buf :  expr , $lit :  literal $($arg :  tt )*)=>{{ use ::  std ::  fmt ::  Write  as _;  let _ = ::  std ::  write ! ($buf , $lit $($arg )*); }}; }
macro_rules! __ra_macro_fixture478 {( match $node :  ident {$($tt :  tt )* })=>{ match_ast ! ( match ($node ){$($tt )* })}; ( match ($node :  expr ){$(ast ::$ast :  ident ($it :  ident )=>$res :  expr , )* _ =>$catch_all :  expr $(,)? })=>{{$(if  let  Some ($it )=  ast ::$ast ::  cast ($node .  clone ()){$res } else )* {$catch_all }}}; }
macro_rules! __ra_macro_fixture479 {($start :  ident $(:: $seg :  ident )*)=>({$crate ::  __known_path ! ($start $(:: $seg )*); $crate ::  path ::  ModPath ::  from_segments ($crate ::  path ::  PathKind ::  Abs ,  vec ! [$crate ::  path ::  __name ! [$start ], $($crate ::  path ::  __name ! [$seg ],)* ])}); }
macro_rules! __ra_macro_fixture480 {( core ::  iter ::  IntoIterator )=>{}; ( core ::  iter ::  Iterator )=>{}; ( core ::  result ::  Result )=>{}; ( core ::  option ::  Option )=>{}; ( core ::  ops ::  Range )=>{}; ( core ::  ops ::  RangeFrom )=>{}; ( core ::  ops ::  RangeFull )=>{}; ( core ::  ops ::  RangeTo )=>{}; ( core ::  ops ::  RangeToInclusive )=>{}; ( core ::  ops ::  RangeInclusive )=>{}; ( core ::  future ::  Future )=>{}; ( core ::  ops ::  Try )=>{}; ($path :  path )=>{ compile_error ! ( "Please register your known path in the path module" )}; }
macro_rules! __ra_macro_fixture481 {($changed :  ident , ($this :  ident / $def :  ident ). $field :  ident , $glob_imports :  ident [$lookup :  ident ], $def_import_type :  ident )=>{{ let  existing = $this .$field .  entry ($lookup .  1 .  clone ());  match ( existing , $def .$field ){( Entry ::  Vacant ( entry ),  Some (_))=>{ match $def_import_type { ImportType ::  Glob =>{$glob_imports .$field .  insert ($lookup .  clone ()); } ImportType ::  Named =>{$glob_imports .$field .  remove (&$lookup ); }} if  let  Some ( fld )= $def .$field { entry .  insert ( fld ); }$changed =  true ; }( Entry ::  Occupied ( mut  entry ),  Some (_)) if $glob_imports .$field .  contains (&$lookup )&&  matches ! ($def_import_type ,  ImportType ::  Named )=>{ mark ::  hit ! ( import_shadowed ); $glob_imports .$field .  remove (&$lookup );  if  let  Some ( fld )= $def .$field { entry .  insert ( fld ); }$changed =  true ; }_ =>{}}}}; }
macro_rules! __ra_macro_fixture482 {($(# $attr_args :  tt )*  const  fn $($item :  tt )* )=>{$(# $attr_args )*  fn $($item )* }; ($(# $attr_args :  tt )*  pub  const  fn $($item :  tt )* )=>{$(# $attr_args )*  pub  fn $($item )* }; ($(# $attr_args :  tt )*  pub  const  unsafe  fn $($item :  tt )* )=>{$(# $attr_args )*  pub  unsafe  fn $($item )* }; }
macro_rules! __ra_macro_fixture483 {{ type  Mirror = $tinyname :  ident ; $($(# [$attr :  meta ])* $v :  vis  fn $fname :  ident ($seif :  ident : $seifty :  ty $(,$argname :  ident : $argtype :  ty )*)$(-> $ret :  ty )? ; )* }=>{$($(# [$attr ])* # [ inline ( always )]$v  fn $fname ($seif : $seifty , $($argname : $argtype ),*)$(-> $ret )? { match $seif {$tinyname ::  Inline ( i )=> i .$fname ($($argname ),*), $tinyname ::  Heap ( h )=> h .$fname ($($argname ),*), }})* }; }
macro_rules! __ra_macro_fixture484 {([$($stack :  tt )*])=>{$($stack )* }; ([$($stack :  tt )*]@  escape $_x :  tt $($t :  tt )*)=>{ remove_sections_inner ! ([$($stack )*]$($t )*); }; ([$($stack :  tt )*]@  section $x :  ident $($t :  tt )*)=>{ remove_sections_inner ! ([$($stack )*]$($t )*); }; ([$($stack :  tt )*]$t :  tt $($tail :  tt )*)=>{ remove_sections_inner ! ([$($stack )* $t ]$($tail )*); }; }
macro_rules! __ra_macro_fixture485 {($name :  ident , $($field :  ident ),+ $(,)*)=>( fn  clone (&  self )->  Self {$name {$($field :  self . $field .  clone ()),* }}); }
macro_rules! __ra_macro_fixture486 {( type  FreeFunctions )=>( type  FreeFunctions : 'static ;); ( type  TokenStream )=>( type  TokenStream : 'static +  Clone ;); ( type  TokenStreamBuilder )=>( type  TokenStreamBuilder : 'static ;); ( type  TokenStreamIter )=>( type  TokenStreamIter : 'static +  Clone ;); ( type  Group )=>( type  Group : 'static +  Clone ;); ( type  Punct )=>( type  Punct : 'static +  Copy +  Eq +  Hash ;); ( type  Ident )=>( type  Ident : 'static +  Copy +  Eq +  Hash ;); ( type  Literal )=>( type  Literal : 'static +  Clone ;); ( type  SourceFile )=>( type  SourceFile : 'static +  Clone ;); ( type  MultiSpan )=>( type  MultiSpan : 'static ;); ( type  Diagnostic )=>( type  Diagnostic : 'static ;); ( type  Span )=>( type  Span : 'static +  Copy +  Eq +  Hash ;); ( fn  drop (&  mut  self , $arg :  ident : $arg_ty :  ty ))=>( fn  drop (&  mut  self , $arg : $arg_ty ){ mem ::  drop ($arg )}); ( fn  clone (&  mut  self , $arg :  ident : $arg_ty :  ty )-> $ret_ty :  ty )=>( fn  clone (&  mut  self , $arg : $arg_ty )-> $ret_ty {$arg .  clone ()}); ($($item :  tt )*)=>($($item )*;)}
macro_rules! __ra_macro_fixture487 {($bit :  expr , $is_fn_name :  ident , $set_fn_name :  ident )=>{ fn $is_fn_name (&  self )->  bool { self .  bools & ( 0b1 << $bit )>  0 } fn $set_fn_name (&  mut  self ,  yes :  bool ){ if  yes { self .  bools |=  1 << $bit ; } else { self .  bools &= ! ( 1 << $bit ); }}}; }
macro_rules! __ra_macro_fixture488 {($($(# [$cfg :  meta ])*  fn $method :  ident -> $i :  ident ; )*)=>{$(# [ inline ]$(# [$cfg ])*  fn $method (&  self )->  Option <$i > {( self .  0 ).$method ()})*}}
macro_rules! __ra_macro_fixture489 {($($(# [$cfg :  meta ])*  fn $method :  ident ($i :  ident ); )*)=>{$(# [ inline ]$(# [$cfg ])*  fn $method ( n : $i )->  Option <  Self > { T ::$method ( n ).  map ( Wrapping )})*}}
macro_rules! __ra_macro_fixture490 {($SrcT :  ident : $($(# [$cfg :  meta ])*  fn $method :  ident -> $DstT :  ident ; )*)=>{$(# [ inline ]$(# [$cfg ])*  fn $method (&  self )->  Option <$DstT > { let  min = $DstT ::  MIN  as $SrcT ;  let  max = $DstT ::  MAX  as $SrcT ;  if  size_of ::<$SrcT > ()<=  size_of ::<$DstT > ()|| ( min <= *  self && *  self <=  max ){ Some (*  self  as $DstT )} else { None }})*}}
macro_rules! __ra_macro_fixture491 {($SrcT :  ident : $($(# [$cfg :  meta ])*  fn $method :  ident -> $DstT :  ident ; )*)=>{$(# [ inline ]$(# [$cfg ])*  fn $method (&  self )->  Option <$DstT > { let  max = $DstT ::  MAX  as $SrcT ;  if  0 <= *  self && ( size_of ::<$SrcT > ()<=  size_of ::<$DstT > ()|| *  self <=  max ){ Some (*  self  as $DstT )} else { None }})*}}
macro_rules! __ra_macro_fixture492 {($SrcT :  ident : $($(# [$cfg :  meta ])*  fn $method :  ident -> $DstT :  ident ; )*)=>{$(# [ inline ]$(# [$cfg ])*  fn $method (&  self )->  Option <$DstT > { let  max = $DstT ::  MAX  as $SrcT ;  if  size_of ::<$SrcT > ()<  size_of ::<$DstT > ()|| *  self <=  max { Some (*  self  as $DstT )} else { None }})*}}
macro_rules! __ra_macro_fixture493 {($SrcT :  ident : $($(# [$cfg :  meta ])*  fn $method :  ident -> $DstT :  ident ; )*)=>{$(# [ inline ]$(# [$cfg ])*  fn $method (&  self )->  Option <$DstT > { let  max = $DstT ::  MAX  as $SrcT ;  if  size_of ::<$SrcT > ()<=  size_of ::<$DstT > ()|| *  self <=  max { Some (*  self  as $DstT )} else { None }})*}}
macro_rules! __ra_macro_fixture494 {($f :  ident : $($(# [$cfg :  meta ])*  fn $method :  ident -> $i :  ident ; )*)=>{$(# [ inline ]$(# [$cfg ])*  fn $method (&  self )->  Option <$i > { if  size_of ::<$f > ()>  size_of ::<$i > (){ const  MIN_M1 : $f = $i ::  MIN  as $f -  1.0 ;  const  MAX_P1 : $f = $i ::  MAX  as $f +  1.0 ;  if *  self >  MIN_M1 && *  self <  MAX_P1 { return  Some ( float_to_int_unchecked ! (*  self =>$i )); }} else { const  MIN : $f = $i ::  MIN  as $f ;  const  MAX_P1 : $f = $i ::  MAX  as $f ;  if *  self >=  MIN && *  self <  MAX_P1 { return  Some ( float_to_int_unchecked ! (*  self =>$i )); }} None })*}}
macro_rules! __ra_macro_fixture495 {($f :  ident : $($(# [$cfg :  meta ])*  fn $method :  ident -> $u :  ident ; )*)=>{$(# [ inline ]$(# [$cfg ])*  fn $method (&  self )->  Option <$u > { if  size_of ::<$f > ()>  size_of ::<$u > (){ const  MAX_P1 : $f = $u ::  MAX  as $f +  1.0 ;  if *  self > -  1.0 && *  self <  MAX_P1 { return  Some ( float_to_int_unchecked ! (*  self =>$u )); }} else { const  MAX_P1 : $f = $u ::  MAX  as $f ;  if *  self > -  1.0 && *  self <  MAX_P1 { return  Some ( float_to_int_unchecked ! (*  self =>$u )); }} None })*}}
macro_rules! __ra_macro_fixture496 {($SrcT :  ident : $(fn $method :  ident -> $DstT :  ident ; )*)=>{$(# [ inline ] fn $method (&  self )->  Option <$DstT > { Some (*  self  as $DstT )})*}}
macro_rules! __ra_macro_fixture497 {($($method :  ident ()-> $ret :  expr ; )*)=>{$(# [ inline ] fn $method ()->  Self {$ret })*}; }
macro_rules! __ra_macro_fixture498 {($(Self :: $method :  ident ( self $(, $arg :  ident : $ty :  ty )* )-> $ret :  ty ; )*)=>{$(# [ inline ] fn $method ( self $(, $arg : $ty )* )-> $ret { Self ::$method ( self $(, $arg )* )})*}; ($($base :  ident :: $method :  ident ( self $(, $arg :  ident : $ty :  ty )* )-> $ret :  ty ; )*)=>{$(# [ inline ] fn $method ( self $(, $arg : $ty )* )-> $ret {<  Self  as $base >::$method ( self $(, $arg )* )})*}; ($($base :  ident :: $method :  ident ($($arg :  ident : $ty :  ty ),* )-> $ret :  ty ; )*)=>{$(# [ inline ] fn $method ($($arg : $ty ),* )-> $ret {<  Self  as $base >::$method ($($arg ),* )})*}}
macro_rules! __ra_macro_fixture499 {($tyname :  ident , $($($field :  ident ).+),*)=>{ fn  fmt (&  self ,  f : &  mut ::  std ::  fmt ::  Formatter )-> ::  std ::  fmt ::  Result { f .  debug_struct ( stringify ! ($tyname ))$(.  field ( stringify ! ($($field ).+), &  self .$($field ).+))* .  finish ()}}}
macro_rules! __ra_macro_fixture500 {($($field :  ident ),*)=>{ fn  clone (&  self )->  Self { Self {$($field :  self .$field .  clone (),)* }}}}
macro_rules! __ra_macro_fixture501 {($($json :  tt )+)=>{ json_internal ! ($($json )+)}; }
macro_rules! __ra_macro_fixture502 {(@  array [$($elems :  expr ,)*])=>{ json_internal_vec ! [$($elems ,)*]}; (@  array [$($elems :  expr ),*])=>{ json_internal_vec ! [$($elems ),*]}; (@  array [$($elems :  expr ,)*] null $($rest :  tt )*)=>{ json_internal ! (@  array [$($elems ,)*  json_internal ! ( null )]$($rest )*)}; (@  array [$($elems :  expr ,)*] true $($rest :  tt )*)=>{ json_internal ! (@  array [$($elems ,)*  json_internal ! ( true )]$($rest )*)}; (@  array [$($elems :  expr ,)*] false $($rest :  tt )*)=>{ json_internal ! (@  array [$($elems ,)*  json_internal ! ( false )]$($rest )*)}; (@  array [$($elems :  expr ,)*][$($array :  tt )*]$($rest :  tt )*)=>{ json_internal ! (@  array [$($elems ,)*  json_internal ! ([$($array )*])]$($rest )*)}; (@  array [$($elems :  expr ,)*]{$($map :  tt )*}$($rest :  tt )*)=>{ json_internal ! (@  array [$($elems ,)*  json_internal ! ({$($map )*})]$($rest )*)}; (@  array [$($elems :  expr ,)*]$next :  expr , $($rest :  tt )*)=>{ json_internal ! (@  array [$($elems ,)*  json_internal ! ($next ),]$($rest )*)}; (@  array [$($elems :  expr ,)*]$last :  expr )=>{ json_internal ! (@  array [$($elems ,)*  json_internal ! ($last )])}; (@  array [$($elems :  expr ),*], $($rest :  tt )*)=>{ json_internal ! (@  array [$($elems ,)*]$($rest )*)}; (@  array [$($elems :  expr ),*]$unexpected :  tt $($rest :  tt )*)=>{ json_unexpected ! ($unexpected )}; (@  object $object :  ident ()()())=>{}; (@  object $object :  ident [$($key :  tt )+]($value :  expr ), $($rest :  tt )*)=>{ let _ = $object .  insert (($($key )+).  into (), $value );  json_internal ! (@  object $object ()($($rest )*)($($rest )*)); }; (@  object $object :  ident [$($key :  tt )+]($value :  expr )$unexpected :  tt $($rest :  tt )*)=>{ json_unexpected ! ($unexpected ); }; (@  object $object :  ident [$($key :  tt )+]($value :  expr ))=>{ let _ = $object .  insert (($($key )+).  into (), $value ); }; (@  object $object :  ident ($($key :  tt )+)(:  null $($rest :  tt )*)$copy :  tt )=>{ json_internal ! (@  object $object [$($key )+]( json_internal ! ( null ))$($rest )*); }; (@  object $object :  ident ($($key :  tt )+)(:  true $($rest :  tt )*)$copy :  tt )=>{ json_internal ! (@  object $object [$($key )+]( json_internal ! ( true ))$($rest )*); }; (@  object $object :  ident ($($key :  tt )+)(:  false $($rest :  tt )*)$copy :  tt )=>{ json_internal ! (@  object $object [$($key )+]( json_internal ! ( false ))$($rest )*); }; (@  object $object :  ident ($($key :  tt )+)(: [$($array :  tt )*]$($rest :  tt )*)$copy :  tt )=>{ json_internal ! (@  object $object [$($key )+]( json_internal ! ([$($array )*]))$($rest )*); }; (@  object $object :  ident ($($key :  tt )+)(: {$($map :  tt )*}$($rest :  tt )*)$copy :  tt )=>{ json_internal ! (@  object $object [$($key )+]( json_internal ! ({$($map )*}))$($rest )*); }; (@  object $object :  ident ($($key :  tt )+)(: $value :  expr , $($rest :  tt )*)$copy :  tt )=>{ json_internal ! (@  object $object [$($key )+]( json_internal ! ($value )), $($rest )*); }; (@  object $object :  ident ($($key :  tt )+)(: $value :  expr )$copy :  tt )=>{ json_internal ! (@  object $object [$($key )+]( json_internal ! ($value ))); }; (@  object $object :  ident ($($key :  tt )+)(:)$copy :  tt )=>{ json_internal ! (); }; (@  object $object :  ident ($($key :  tt )+)()$copy :  tt )=>{ json_internal ! (); }; (@  object $object :  ident ()(: $($rest :  tt )*)($colon :  tt $($copy :  tt )*))=>{ json_unexpected ! ($colon ); }; (@  object $object :  ident ($($key :  tt )*)(, $($rest :  tt )*)($comma :  tt $($copy :  tt )*))=>{ json_unexpected ! ($comma ); }; (@  object $object :  ident ()(($key :  expr ): $($rest :  tt )*)$copy :  tt )=>{ json_internal ! (@  object $object ($key )(: $($rest )*)(: $($rest )*)); }; (@  object $object :  ident ($($key :  tt )*)(: $($unexpected :  tt )+)$copy :  tt )=>{ json_expect_expr_comma ! ($($unexpected )+); }; (@  object $object :  ident ($($key :  tt )*)($tt :  tt $($rest :  tt )*)$copy :  tt )=>{ json_internal ! (@  object $object ($($key )* $tt )($($rest )*)($($rest )*)); }; ( null )=>{$crate ::  Value ::  Null }; ( true )=>{$crate ::  Value ::  Bool ( true )}; ( false )=>{$crate ::  Value ::  Bool ( false )}; ([])=>{$crate ::  Value ::  Array ( json_internal_vec ! [])}; ([$($tt :  tt )+ ])=>{$crate ::  Value ::  Array ( json_internal ! (@  array []$($tt )+))}; ({})=>{$crate ::  Value ::  Object ($crate ::  Map ::  new ())}; ({$($tt :  tt )+ })=>{$crate ::  Value ::  Object ({ let  mut  object = $crate ::  Map ::  new ();  json_internal ! (@  object  object ()($($tt )+)($($tt )+));  object })}; ($other :  expr )=>{$crate ::  to_value (&$other ).  unwrap ()}; }
macro_rules! __ra_macro_fixture503 {($($content :  tt )*)=>{ vec ! [$($content )*]}; }
macro_rules! __ra_macro_fixture504 {($($cfg :  tt )*)=>{}; }
macro_rules! __ra_macro_fixture505 {($($tokens :  tt )*)=>{$crate ::  crossbeam_channel_internal ! ($($tokens )* )}; }
macro_rules! __ra_macro_fixture506 {(@  list ()($($head :  tt )*))=>{$crate ::  crossbeam_channel_internal ! (@  case ($($head )*)()())}; (@  list ( default =>$($tail :  tt )*)($($head :  tt )*))=>{$crate ::  crossbeam_channel_internal ! (@  list ( default ()=>$($tail )*)($($head )*))}; (@  list ( default -> $($tail :  tt )*)($($head :  tt )*))=>{ compile_error ! ( "expected `=>` after `default` case, found `->`" )}; (@  list ( default $args :  tt -> $($tail :  tt )*)($($head :  tt )*))=>{ compile_error ! ( "expected `=>` after `default` case, found `->`" )}; (@  list ( recv ($($args :  tt )*)=>$($tail :  tt )*)($($head :  tt )*))=>{ compile_error ! ( "expected `->` after `recv` case, found `=>`" )}; (@  list ( send ($($args :  tt )*)=>$($tail :  tt )*)($($head :  tt )*))=>{ compile_error ! ( "expected `->` after `send` operation, found `=>`" )}; (@  list ($case :  ident $args :  tt -> $res :  tt -> $($tail :  tt )*)($($head :  tt )*))=>{ compile_error ! ( "expected `=>`, found `->`" )}; (@  list ($case :  ident $args :  tt $(-> $res :  pat )* =>$body :  block ; $($tail :  tt )*)($($head :  tt )*))=>{ compile_error ! ( "did you mean to put a comma instead of the semicolon after `}`?" )}; (@  list ($case :  ident ($($args :  tt )*)$(-> $res :  pat )* =>$body :  expr , $($tail :  tt )*)($($head :  tt )*))=>{$crate ::  crossbeam_channel_internal ! (@  list ($($tail )*)($($head )* $case ($($args )*)$(-> $res )* =>{$body },))}; (@  list ($case :  ident ($($args :  tt )*)$(-> $res :  pat )* =>$body :  block $($tail :  tt )*)($($head :  tt )*))=>{$crate ::  crossbeam_channel_internal ! (@  list ($($tail )*)($($head )* $case ($($args )*)$(-> $res )* =>{$body },))}; (@  list ($case :  ident ($($args :  tt )*)$(-> $res :  pat )* =>$body :  expr )($($head :  tt )*))=>{$crate ::  crossbeam_channel_internal ! (@  list ()($($head )* $case ($($args )*)$(-> $res )* =>{$body },))}; (@  list ($case :  ident ($($args :  tt )*)$(-> $res :  pat )* =>$body :  expr ,)($($head :  tt )*))=>{$crate ::  crossbeam_channel_internal ! (@  list ()($($head )* $case ($($args )*)$(-> $res )* =>{$body },))}; (@  list ($($tail :  tt )*)($($head :  tt )*))=>{$crate ::  crossbeam_channel_internal ! (@  list_error1 $($tail )*)}; (@  list_error1  recv $($tail :  tt )*)=>{$crate ::  crossbeam_channel_internal ! (@  list_error2  recv $($tail )*)}; (@  list_error1  send $($tail :  tt )*)=>{$crate ::  crossbeam_channel_internal ! (@  list_error2  send $($tail )*)}; (@  list_error1  default $($tail :  tt )*)=>{$crate ::  crossbeam_channel_internal ! (@  list_error2  default $($tail )*)}; (@  list_error1 $t :  tt $($tail :  tt )*)=>{ compile_error ! ( concat ! ( "expected one of `recv`, `send`, or `default`, found `" ,  stringify ! ($t ),  "`" , ))}; (@  list_error1 $($tail :  tt )*)=>{$crate ::  crossbeam_channel_internal ! (@  list_error2 $($tail )*); }; (@  list_error2 $case :  ident )=>{ compile_error ! ( concat ! ( "missing argument list after `" ,  stringify ! ($case ),  "`" , ))}; (@  list_error2 $case :  ident =>$($tail :  tt )*)=>{ compile_error ! ( concat ! ( "missing argument list after `" ,  stringify ! ($case ),  "`" , ))}; (@  list_error2 $($tail :  tt )*)=>{$crate ::  crossbeam_channel_internal ! (@  list_error3 $($tail )*)}; (@  list_error3 $case :  ident ($($args :  tt )*)$(-> $r :  pat )*)=>{ compile_error ! ( concat ! ( "missing `=>` after `" ,  stringify ! ($case ),  "` case" , ))}; (@  list_error3 $case :  ident ($($args :  tt )*)$(-> $r :  pat )* =>)=>{ compile_error ! ( "expected expression after `=>`" )}; (@  list_error3 $case :  ident ($($args :  tt )*)$(-> $r :  pat )* =>$body :  expr ; $($tail :  tt )*)=>{ compile_error ! ( concat ! ( "did you mean to put a comma instead of the semicolon after `" ,  stringify ! ($body ),  "`?" , ))}; (@  list_error3 $case :  ident ($($args :  tt )*)$(-> $r :  pat )* => recv ($($a :  tt )*)$($tail :  tt )*)=>{ compile_error ! ( "expected an expression after `=>`" )}; (@  list_error3 $case :  ident ($($args :  tt )*)$(-> $r :  pat )* => send ($($a :  tt )*)$($tail :  tt )*)=>{ compile_error ! ( "expected an expression after `=>`" )}; (@  list_error3 $case :  ident ($($args :  tt )*)$(-> $r :  pat )* => default ($($a :  tt )*)$($tail :  tt )*)=>{ compile_error ! ( "expected an expression after `=>`" )}; (@  list_error3 $case :  ident ($($args :  tt )*)$(-> $r :  pat )* =>$f :  ident ($($a :  tt )*)$($tail :  tt )*)=>{ compile_error ! ( concat ! ( "did you mean to put a comma after `" ,  stringify ! ($f ),  "(" ,  stringify ! ($($a )*),  ")`?" , ))}; (@  list_error3 $case :  ident ($($args :  tt )*)$(-> $r :  pat )* =>$f :  ident ! ($($a :  tt )*)$($tail :  tt )*)=>{ compile_error ! ( concat ! ( "did you mean to put a comma after `" ,  stringify ! ($f ),  "!(" ,  stringify ! ($($a )*),  ")`?" , ))}; (@  list_error3 $case :  ident ($($args :  tt )*)$(-> $r :  pat )* =>$f :  ident ! [$($a :  tt )*]$($tail :  tt )*)=>{ compile_error ! ( concat ! ( "did you mean to put a comma after `" ,  stringify ! ($f ),  "![" ,  stringify ! ($($a )*),  "]`?" , ))}; (@  list_error3 $case :  ident ($($args :  tt )*)$(-> $r :  pat )* =>$f :  ident ! {$($a :  tt )*}$($tail :  tt )*)=>{ compile_error ! ( concat ! ( "did you mean to put a comma after `" ,  stringify ! ($f ),  "!{" ,  stringify ! ($($a )*),  "}`?" , ))}; (@  list_error3 $case :  ident ($($args :  tt )*)$(-> $r :  pat )* =>$body :  tt $($tail :  tt )*)=>{ compile_error ! ( concat ! ( "did you mean to put a comma after `" ,  stringify ! ($body ),  "`?" , ))}; (@  list_error3 $case :  ident ($($args :  tt )*)-> =>$($tail :  tt )*)=>{ compile_error ! ( "missing pattern after `->`" )}; (@  list_error3 $case :  ident ($($args :  tt )*)$t :  tt $(-> $r :  pat )* =>$($tail :  tt )*)=>{ compile_error ! ( concat ! ( "expected `->`, found `" ,  stringify ! ($t ),  "`" , ))}; (@  list_error3 $case :  ident ($($args :  tt )*)-> $t :  tt $($tail :  tt )*)=>{ compile_error ! ( concat ! ( "expected a pattern, found `" ,  stringify ! ($t ),  "`" , ))}; (@  list_error3  recv ($($args :  tt )*)$t :  tt $($tail :  tt )*)=>{ compile_error ! ( concat ! ( "expected `->`, found `" ,  stringify ! ($t ),  "`" , ))}; (@  list_error3  send ($($args :  tt )*)$t :  tt $($tail :  tt )*)=>{ compile_error ! ( concat ! ( "expected `->`, found `" ,  stringify ! ($t ),  "`" , ))}; (@  list_error3  recv $args :  tt $($tail :  tt )*)=>{ compile_error ! ( concat ! ( "expected an argument list after `recv`, found `" ,  stringify ! ($args ),  "`" , ))}; (@  list_error3  send $args :  tt $($tail :  tt )*)=>{ compile_error ! ( concat ! ( "expected an argument list after `send`, found `" ,  stringify ! ($args ),  "`" , ))}; (@  list_error3  default $args :  tt $($tail :  tt )*)=>{ compile_error ! ( concat ! ( "expected an argument list or `=>` after `default`, found `" ,  stringify ! ($args ),  "`" , ))}; (@  list_error3 $($tail :  tt )*)=>{$crate ::  crossbeam_channel_internal ! (@  list_error4 $($tail )*)}; (@  list_error4 $($tail :  tt )*)=>{ compile_error ! ( "invalid syntax" )}; (@  case ()$cases :  tt $default :  tt )=>{$crate ::  crossbeam_channel_internal ! (@  init $cases $default )}; (@  case ( recv ($r :  expr )-> $res :  pat =>$body :  tt , $($tail :  tt )*)($($cases :  tt )*)$default :  tt )=>{$crate ::  crossbeam_channel_internal ! (@  case ($($tail )*)($($cases )*  recv ($r )-> $res =>$body ,)$default )}; (@  case ( recv ($r :  expr ,)-> $res :  pat =>$body :  tt , $($tail :  tt )*)($($cases :  tt )*)$default :  tt )=>{$crate ::  crossbeam_channel_internal ! (@  case ($($tail )*)($($cases )*  recv ($r )-> $res =>$body ,)$default )}; (@  case ( recv ($($args :  tt )*)-> $res :  pat =>$body :  tt , $($tail :  tt )*)($($cases :  tt )*)$default :  tt )=>{ compile_error ! ( concat ! ( "invalid argument list in `recv(" ,  stringify ! ($($args )*),  ")`" , ))}; (@  case ( recv $t :  tt $($tail :  tt )*)($($cases :  tt )*)$default :  tt )=>{ compile_error ! ( concat ! ( "expected an argument list after `recv`, found `" ,  stringify ! ($t ),  "`" , ))}; (@  case ( send ($s :  expr , $m :  expr )-> $res :  pat =>$body :  tt , $($tail :  tt )*)($($cases :  tt )*)$default :  tt )=>{$crate ::  crossbeam_channel_internal ! (@  case ($($tail )*)($($cases )*  send ($s , $m )-> $res =>$body ,)$default )}; (@  case ( send ($s :  expr , $m :  expr ,)-> $res :  pat =>$body :  tt , $($tail :  tt )*)($($cases :  tt )*)$default :  tt )=>{$crate ::  crossbeam_channel_internal ! (@  case ($($tail )*)($($cases )*  send ($s , $m )-> $res =>$body ,)$default )}; (@  case ( send ($($args :  tt )*)-> $res :  pat =>$body :  tt , $($tail :  tt )*)($($cases :  tt )*)$default :  tt )=>{ compile_error ! ( concat ! ( "invalid argument list in `send(" ,  stringify ! ($($args )*),  ")`" , ))}; (@  case ( send $t :  tt $($tail :  tt )*)($($cases :  tt )*)$default :  tt )=>{ compile_error ! ( concat ! ( "expected an argument list after `send`, found `" ,  stringify ! ($t ),  "`" , ))}; (@  case ( default ()=>$body :  tt , $($tail :  tt )*)$cases :  tt ())=>{$crate ::  crossbeam_channel_internal ! (@  case ($($tail )*)$cases ( default ()=>$body ,))}; (@  case ( default ($timeout :  expr )=>$body :  tt , $($tail :  tt )*)$cases :  tt ())=>{$crate ::  crossbeam_channel_internal ! (@  case ($($tail )*)$cases ( default ($timeout )=>$body ,))}; (@  case ( default ($timeout :  expr ,)=>$body :  tt , $($tail :  tt )*)$cases :  tt ())=>{$crate ::  crossbeam_channel_internal ! (@  case ($($tail )*)$cases ( default ($timeout )=>$body ,))}; (@  case ( default $($tail :  tt )*)$cases :  tt ($($def :  tt )+))=>{ compile_error ! ( "there can be only one `default` case in a `select!` block" )}; (@  case ( default ($($args :  tt )*)=>$body :  tt , $($tail :  tt )*)$cases :  tt $default :  tt )=>{ compile_error ! ( concat ! ( "invalid argument list in `default(" ,  stringify ! ($($args )*),  ")`" , ))}; (@  case ( default $t :  tt $($tail :  tt )*)$cases :  tt $default :  tt )=>{ compile_error ! ( concat ! ( "expected an argument list or `=>` after `default`, found `" ,  stringify ! ($t ),  "`" , ))}; (@  case ($case :  ident $($tail :  tt )*)$cases :  tt $default :  tt )=>{ compile_error ! ( concat ! ( "expected one of `recv`, `send`, or `default`, found `" ,  stringify ! ($case ),  "`" , ))}; (@  init ( recv ($r :  expr )-> $res :  pat =>$recv_body :  tt ,)( default ()=>$default_body :  tt ,))=>{{ match $r { ref  _r =>{ let  _r : &$crate ::  Receiver <_> =  _r ;  match  _r .  try_recv (){::  std ::  result ::  Result ::  Err ($crate ::  TryRecvError ::  Empty )=>{$default_body } _res =>{ let  _res =  _res .  map_err (|_| $crate ::  RecvError );  let $res =  _res ; $recv_body }}}}}}; (@  init ( recv ($r :  expr )-> $res :  pat =>$body :  tt ,)())=>{{ match $r { ref  _r =>{ let  _r : &$crate ::  Receiver <_> =  _r ;  let  _res =  _r .  recv ();  let $res =  _res ; $body }}}}; (@  init ( recv ($r :  expr )-> $res :  pat =>$recv_body :  tt ,)( default ($timeout :  expr )=>$default_body :  tt ,))=>{{ match $r { ref  _r =>{ let  _r : &$crate ::  Receiver <_> =  _r ;  match  _r .  recv_timeout ($timeout ){::  std ::  result ::  Result ::  Err ($crate ::  RecvTimeoutError ::  Timeout )=>{$default_body } _res =>{ let  _res =  _res .  map_err (|_| $crate ::  RecvError );  let $res =  _res ; $recv_body }}}}}}; (@  init ($($cases :  tt )*)$default :  tt )=>{{ const  _LEN :  usize = $crate ::  crossbeam_channel_internal ! (@  count ($($cases )*));  let  _handle : &$crate ::  internal ::  SelectHandle = &$crate ::  never ::< ()> (); # [ allow ( unused_mut )] let  mut  _sel = [( _handle ,  0 , ::  std ::  ptr ::  null ());  _LEN ]; $crate ::  crossbeam_channel_internal ! (@  add  _sel ($($cases )*)$default (( 0usize  _oper0 )( 1usize  _oper1 )( 2usize  _oper2 )( 3usize  _oper3 )( 4usize  _oper4 )( 5usize  _oper5 )( 6usize  _oper6 )( 7usize  _oper7 )( 8usize  _oper8 )( 9usize  _oper9 )( 10usize  _oper10 )( 11usize  _oper11 )( 12usize  _oper12 )( 13usize  _oper13 )( 14usize  _oper14 )( 15usize  _oper15 )( 16usize  _oper16 )( 17usize  _oper17 )( 18usize  _oper18 )( 19usize  _oper19 )( 20usize  _oper20 )( 21usize  _oper21 )( 22usize  _oper22 )( 23usize  _oper23 )( 24usize  _oper24 )( 25usize  _oper25 )( 26usize  _oper26 )( 27usize  _oper27 )( 28usize  _oper28 )( 29usize  _oper29 )( 30usize  _oper30 )( 31usize  _oper31 ))())}}; (@  count ())=>{ 0 }; (@  count ($oper :  ident $args :  tt -> $res :  pat =>$body :  tt , $($cases :  tt )*))=>{ 1 + $crate ::  crossbeam_channel_internal ! (@  count ($($cases )*))}; (@  add $sel :  ident ()()$labels :  tt $cases :  tt )=>{{ let  _oper : $crate ::  SelectedOperation < '_ > = { let  _oper = $crate ::  internal ::  select (&  mut $sel );  unsafe {::  std ::  mem ::  transmute ( _oper )}}; $crate ::  crossbeam_channel_internal ! {@  complete $sel  _oper $cases }}}; (@  add $sel :  ident ()( default ()=>$body :  tt ,)$labels :  tt $cases :  tt )=>{{ let  _oper : ::  std ::  option ::  Option <$crate ::  SelectedOperation < '_ >> = { let  _oper = $crate ::  internal ::  try_select (&  mut $sel );  unsafe {::  std ::  mem ::  transmute ( _oper )}};  match  _oper { None =>{{$sel }; $body } Some ( _oper )=>{$crate ::  crossbeam_channel_internal ! {@  complete $sel  _oper $cases }}}}}; (@  add $sel :  ident ()( default ($timeout :  expr )=>$body :  tt ,)$labels :  tt $cases :  tt )=>{{ let  _oper : ::  std ::  option ::  Option <$crate ::  SelectedOperation < '_ >> = { let  _oper = $crate ::  internal ::  select_timeout (&  mut $sel , $timeout );  unsafe {::  std ::  mem ::  transmute ( _oper )}};  match  _oper {::  std ::  option ::  Option ::  None =>{{$sel }; $body }::  std ::  option ::  Option ::  Some ( _oper )=>{$crate ::  crossbeam_channel_internal ! {@  complete $sel  _oper $cases }}}}}; (@  add $sel :  ident $input :  tt $default :  tt ()$cases :  tt )=>{ compile_error ! ( "too many operations in a `select!` block" )}; (@  add $sel :  ident ( recv ($r :  expr )-> $res :  pat =>$body :  tt , $($tail :  tt )*)$default :  tt (($i :  tt $var :  ident )$($labels :  tt )*)($($cases :  tt )*))=>{{ match $r { ref  _r =>{ let $var : &$crate ::  Receiver <_> =  unsafe { let  _r : &$crate ::  Receiver <_> =  _r ;  unsafe  fn  unbind < 'a ,  T > ( x : &  T )-> & 'a  T {::  std ::  mem ::  transmute ( x )} unbind ( _r )}; $sel [$i ]= ($var , $i , $var  as *  const $crate ::  Receiver <_>  as *  const  u8 ); $crate ::  crossbeam_channel_internal ! (@  add $sel ($($tail )*)$default ($($labels )*)($($cases )* [$i ] recv ($var )-> $res =>$body ,))}}}}; (@  add $sel :  ident ( send ($s :  expr , $m :  expr )-> $res :  pat =>$body :  tt , $($tail :  tt )*)$default :  tt (($i :  tt $var :  ident )$($labels :  tt )*)($($cases :  tt )*))=>{{ match $s { ref  _s =>{ let $var : &$crate ::  Sender <_> =  unsafe { let  _s : &$crate ::  Sender <_> =  _s ;  unsafe  fn  unbind < 'a ,  T > ( x : &  T )-> & 'a  T {::  std ::  mem ::  transmute ( x )} unbind ( _s )}; $sel [$i ]= ($var , $i , $var  as *  const $crate ::  Sender <_>  as *  const  u8 ); $crate ::  crossbeam_channel_internal ! (@  add $sel ($($tail )*)$default ($($labels )*)($($cases )* [$i ] send ($var , $m )-> $res =>$body ,))}}}}; (@  complete $sel :  ident $oper :  ident ([$i :  tt ] recv ($r :  ident )-> $res :  pat =>$body :  tt , $($tail :  tt )*))=>{{ if $oper .  index ()== $i { let  _res = $oper .  recv ($r ); {$sel };  let $res =  _res ; $body } else {$crate ::  crossbeam_channel_internal ! {@  complete $sel $oper ($($tail )*)}}}}; (@  complete $sel :  ident $oper :  ident ([$i :  tt ] send ($s :  ident , $m :  expr )-> $res :  pat =>$body :  tt , $($tail :  tt )*))=>{{ if $oper .  index ()== $i { let  _res = $oper .  send ($s , $m ); {$sel };  let $res =  _res ; $body } else {$crate ::  crossbeam_channel_internal ! {@  complete $sel $oper ($($tail )*)}}}}; (@  complete $sel :  ident $oper :  ident ())=>{{ unreachable ! ( "internal error in crossbeam-channel: invalid case" )}}; (@$($tokens :  tt )*)=>{ compile_error ! ( concat ! ( "internal error in crossbeam-channel: " ,  stringify ! (@$($tokens )*), ))}; ()=>{ compile_error ! ( "empty `select!` block" )}; ($($case :  ident $(($($args :  tt )*))* =>$body :  expr $(,)*)*)=>{$crate ::  crossbeam_channel_internal ! (@  list ($($case $(($($args )*))* =>{$body },)*)())}; ($($tokens :  tt )*)=>{$crate ::  crossbeam_channel_internal ! (@  list ($($tokens )*)())}; }
macro_rules! __ra_macro_fixture507 {($($tokens :  tt )*)=>{ return  Err ( crate ::  errors ::  error ! ($($tokens )*))}}
macro_rules! __ra_macro_fixture508 {($fmt :  expr )=>{$crate ::  SsrError ::  new ( format ! ($fmt ))}; ($fmt :  expr , $($arg :  tt )+)=>{$crate ::  SsrError ::  new ( format ! ($fmt , $($arg )+))}}
macro_rules! __ra_macro_fixture509 {[;]=>{$crate ::  SyntaxKind ::  SEMICOLON }; [,]=>{$crate ::  SyntaxKind ::  COMMA }; [ '(' ]=>{$crate ::  SyntaxKind ::  L_PAREN }; [ ')' ]=>{$crate ::  SyntaxKind ::  R_PAREN }; [ '{' ]=>{$crate ::  SyntaxKind ::  L_CURLY }; [ '}' ]=>{$crate ::  SyntaxKind ::  R_CURLY }; [ '[' ]=>{$crate ::  SyntaxKind ::  L_BRACK }; [ ']' ]=>{$crate ::  SyntaxKind ::  R_BRACK }; [<]=>{$crate ::  SyntaxKind ::  L_ANGLE }; [>]=>{$crate ::  SyntaxKind ::  R_ANGLE }; [@]=>{$crate ::  SyntaxKind ::  AT }; [#]=>{$crate ::  SyntaxKind ::  POUND }; [~]=>{$crate ::  SyntaxKind ::  TILDE }; [?]=>{$crate ::  SyntaxKind ::  QUESTION }; [$]=>{$crate ::  SyntaxKind ::  DOLLAR }; [&]=>{$crate ::  SyntaxKind ::  AMP }; [|]=>{$crate ::  SyntaxKind ::  PIPE }; [+]=>{$crate ::  SyntaxKind ::  PLUS }; [*]=>{$crate ::  SyntaxKind ::  STAR }; [/]=>{$crate ::  SyntaxKind ::  SLASH }; [^]=>{$crate ::  SyntaxKind ::  CARET }; [%]=>{$crate ::  SyntaxKind ::  PERCENT }; [_]=>{$crate ::  SyntaxKind ::  UNDERSCORE }; [.]=>{$crate ::  SyntaxKind ::  DOT }; [..]=>{$crate ::  SyntaxKind ::  DOT2 }; [...]=>{$crate ::  SyntaxKind ::  DOT3 }; [..=]=>{$crate ::  SyntaxKind ::  DOT2EQ }; [:]=>{$crate ::  SyntaxKind ::  COLON }; [::]=>{$crate ::  SyntaxKind ::  COLON2 }; [=]=>{$crate ::  SyntaxKind ::  EQ }; [==]=>{$crate ::  SyntaxKind ::  EQ2 }; [=>]=>{$crate ::  SyntaxKind ::  FAT_ARROW }; [!]=>{$crate ::  SyntaxKind ::  BANG }; [!=]=>{$crate ::  SyntaxKind ::  NEQ }; [-]=>{$crate ::  SyntaxKind ::  MINUS }; [->]=>{$crate ::  SyntaxKind ::  THIN_ARROW }; [<=]=>{$crate ::  SyntaxKind ::  LTEQ }; [>=]=>{$crate ::  SyntaxKind ::  GTEQ }; [+=]=>{$crate ::  SyntaxKind ::  PLUSEQ }; [-=]=>{$crate ::  SyntaxKind ::  MINUSEQ }; [|=]=>{$crate ::  SyntaxKind ::  PIPEEQ }; [&=]=>{$crate ::  SyntaxKind ::  AMPEQ }; [^=]=>{$crate ::  SyntaxKind ::  CARETEQ }; [/=]=>{$crate ::  SyntaxKind ::  SLASHEQ }; [*=]=>{$crate ::  SyntaxKind ::  STAREQ }; [%=]=>{$crate ::  SyntaxKind ::  PERCENTEQ }; [&&]=>{$crate ::  SyntaxKind ::  AMP2 }; [||]=>{$crate ::  SyntaxKind ::  PIPE2 }; [<<]=>{$crate ::  SyntaxKind ::  SHL }; [>>]=>{$crate ::  SyntaxKind ::  SHR }; [<<=]=>{$crate ::  SyntaxKind ::  SHLEQ }; [>>=]=>{$crate ::  SyntaxKind ::  SHREQ }; [ as ]=>{$crate ::  SyntaxKind ::  AS_KW }; [ async ]=>{$crate ::  SyntaxKind ::  ASYNC_KW }; [ await ]=>{$crate ::  SyntaxKind ::  AWAIT_KW }; [ box ]=>{$crate ::  SyntaxKind ::  BOX_KW }; [ break ]=>{$crate ::  SyntaxKind ::  BREAK_KW }; [ const ]=>{$crate ::  SyntaxKind ::  CONST_KW }; [ continue ]=>{$crate ::  SyntaxKind ::  CONTINUE_KW }; [ crate ]=>{$crate ::  SyntaxKind ::  CRATE_KW }; [ dyn ]=>{$crate ::  SyntaxKind ::  DYN_KW }; [ else ]=>{$crate ::  SyntaxKind ::  ELSE_KW }; [ enum ]=>{$crate ::  SyntaxKind ::  ENUM_KW }; [ extern ]=>{$crate ::  SyntaxKind ::  EXTERN_KW }; [ false ]=>{$crate ::  SyntaxKind ::  FALSE_KW }; [ fn ]=>{$crate ::  SyntaxKind ::  FN_KW }; [ for ]=>{$crate ::  SyntaxKind ::  FOR_KW }; [ if ]=>{$crate ::  SyntaxKind ::  IF_KW }; [ impl ]=>{$crate ::  SyntaxKind ::  IMPL_KW }; [ in ]=>{$crate ::  SyntaxKind ::  IN_KW }; [ let ]=>{$crate ::  SyntaxKind ::  LET_KW }; [ loop ]=>{$crate ::  SyntaxKind ::  LOOP_KW }; [ macro ]=>{$crate ::  SyntaxKind ::  MACRO_KW }; [ match ]=>{$crate ::  SyntaxKind ::  MATCH_KW }; [ mod ]=>{$crate ::  SyntaxKind ::  MOD_KW }; [ move ]=>{$crate ::  SyntaxKind ::  MOVE_KW }; [ mut ]=>{$crate ::  SyntaxKind ::  MUT_KW }; [ pub ]=>{$crate ::  SyntaxKind ::  PUB_KW }; [ ref ]=>{$crate ::  SyntaxKind ::  REF_KW }; [ return ]=>{$crate ::  SyntaxKind ::  RETURN_KW }; [ self ]=>{$crate ::  SyntaxKind ::  SELF_KW }; [ static ]=>{$crate ::  SyntaxKind ::  STATIC_KW }; [ struct ]=>{$crate ::  SyntaxKind ::  STRUCT_KW }; [ super ]=>{$crate ::  SyntaxKind ::  SUPER_KW }; [ trait ]=>{$crate ::  SyntaxKind ::  TRAIT_KW }; [ true ]=>{$crate ::  SyntaxKind ::  TRUE_KW }; [ try ]=>{$crate ::  SyntaxKind ::  TRY_KW }; [ type ]=>{$crate ::  SyntaxKind ::  TYPE_KW }; [ unsafe ]=>{$crate ::  SyntaxKind ::  UNSAFE_KW }; [ use ]=>{$crate ::  SyntaxKind ::  USE_KW }; [ where ]=>{$crate ::  SyntaxKind ::  WHERE_KW }; [ while ]=>{$crate ::  SyntaxKind ::  WHILE_KW }; [ yield ]=>{$crate ::  SyntaxKind ::  YIELD_KW }; [ auto ]=>{$crate ::  SyntaxKind ::  AUTO_KW }; [ default ]=>{$crate ::  SyntaxKind ::  DEFAULT_KW }; [ existential ]=>{$crate ::  SyntaxKind ::  EXISTENTIAL_KW }; [ union ]=>{$crate ::  SyntaxKind ::  UNION_KW }; [ raw ]=>{$crate ::  SyntaxKind ::  RAW_KW }; [ macro_rules ]=>{$crate ::  SyntaxKind ::  MACRO_RULES_KW }; [ lifetime_ident ]=>{$crate ::  SyntaxKind ::  LIFETIME_IDENT }; [ ident ]=>{$crate ::  SyntaxKind ::  IDENT }; [ shebang ]=>{$crate ::  SyntaxKind ::  SHEBANG }; }
macro_rules! __ra_macro_fixture510 {($($args :  tt )*)=>{ return  Err ( match_error ! ($($args )*))}; }
macro_rules! __ra_macro_fixture511 {($e :  expr )=>{{ MatchFailed { reason :  if  recording_match_fail_reasons (){ Some ( format ! ( "{}" , $e ))} else { None }}}}; ($fmt :  expr , $($arg :  tt )+)=>{{ MatchFailed { reason :  if  recording_match_fail_reasons (){ Some ( format ! ($fmt , $($arg )+))} else { None }}}}; }
macro_rules! __ra_macro_fixture512 {()=>($crate ::  print ! ( "\n" )); ($($arg :  tt )*)=>({$crate ::  io ::  _print ($crate ::  format_args_nl ! ($($arg )*)); })}
macro_rules! __ra_macro_fixture513 {($cmd :  tt )=>{{# [ cfg ( trick_rust_analyzer_into_highlighting_interpolated_bits )] format_args ! ($cmd );  use $crate ::  Cmd  as  __CMD ;  let  cmd : $crate ::  Cmd = $crate ::  __cmd ! ( __CMD $cmd );  cmd }}; }
macro_rules! __ra_macro_fixture514 {($reader :  ident , $s :  ident ;)=>{}; ($reader :  ident , $s :  ident ; $first :  ident : $first_ty :  ty $(, $rest :  ident : $rest_ty :  ty )*)=>{ reverse_decode ! ($reader , $s ; $($rest : $rest_ty ),*);  let $first = <$first_ty >::  decode (&  mut $reader , $s ); }}
macro_rules! __ra_macro_fixture515 {($kind :  ident , $($ty :  ty ),*)=>{ match $kind {$(stringify ! ($ty )=>{ let  n : $ty =  n .  parse ().  unwrap ();  format ! ( concat ! ( "{}" ,  stringify ! ($ty )),  n )})* _ => unimplemented ! ( "unknown args for typed_integer: n {}, kind {}" ,  n , $kind ), }}}
macro_rules! __ra_macro_fixture516 {()=>( panic ! ( "not implemented" )); ($($arg :  tt )+)=>( panic ! ( "not implemented: {}" , $crate ::  format_args ! ($($arg )+))); }
macro_rules! __ra_macro_fixture517 {($cond :  expr )=>{{ let  cond = !$crate ::  always ! (!$cond );  cond }}; ($cond :  expr , $fmt :  literal $($arg :  tt )*)=>{{ let  cond = !$crate ::  always ! (!$cond , $fmt $($arg )*);  cond }}; }
macro_rules! __ra_macro_fixture518 {($cond :  expr )=>{$crate ::  always ! ($cond ,  "assertion failed: {}" ,  stringify ! ($cond ))}; ($cond :  expr , $fmt :  literal $($arg :  tt )*)=>{{ let  cond = $cond ;  if  cfg ! ( debug_assertions )|| $crate ::  __FORCE { assert ! ( cond , $fmt $($arg )*); } if !  cond {$crate ::  __log_error ! ($fmt $($arg )*); } cond }}; }
macro_rules! __ra_macro_fixture519 {($msg :  literal $(,)?)=>{ return $crate ::  private ::  Err ($crate ::  anyhow ! ($msg ))}; ($err :  expr $(,)?)=>{ return $crate ::  private ::  Err ($crate ::  anyhow ! ($err ))}; ($fmt :  expr , $($arg :  tt )*)=>{ return $crate ::  private ::  Err ($crate ::  anyhow ! ($fmt , $($arg )*))}; }
macro_rules! __ra_macro_fixture520 {($msg :  literal $(,)?)=>{$crate ::  private ::  new_adhoc ($msg )}; ($err :  expr $(,)?)=>({ use $crate ::  private ::  kind ::*;  match $err { error =>(&  error ).  anyhow_kind ().  new ( error ), }}); ($fmt :  expr , $($arg :  tt )*)=>{$crate ::  private ::  new_adhoc ( format ! ($fmt , $($arg )*))}; }
macro_rules! __ra_macro_fixture521 {( target : $target :  expr , $($arg :  tt )+)=>( log ! ( target : $target , $crate ::  Level ::  Info , $($arg )+)); ($($arg :  tt )+)=>( log ! ($crate ::  Level ::  Info , $($arg )+))}
macro_rules! __ra_macro_fixture522 {[$($sl :  expr , $sc :  expr ; $el :  expr , $ec :  expr =>$text :  expr ),+]=>{ vec ! [$(TextDocumentContentChangeEvent { range :  Some ( Range { start :  Position { line : $sl ,  character : $sc },  end :  Position { line : $el ,  character : $ec }, }),  range_length :  None ,  text :  String ::  from ($text ), }),+]}; }
macro_rules! __ra_macro_fixture523 {[$path :  expr ]=>{$crate ::  ExpectFile { path :  std ::  path ::  PathBuf ::  from ($path ),  position :  file ! (), }}; }
macro_rules! __ra_macro_fixture524 {($($key :  literal : $value :  tt ),*$(,)?)=>{{$(map .  insert ($key .  into (),  serde_json ::  json ! ($value )); )*}}; }
macro_rules! __ra_macro_fixture525 {($expr :  expr , $or :  expr )=>{ try_ ! ($expr ).  unwrap_or ($or )}; }
macro_rules! __ra_macro_fixture526 {($expr :  expr )=>{|| -> _ { Some ($expr )}()}; }
macro_rules! __ra_macro_fixture527 {($($arg :  tt )*)=>($crate ::  io ::  _print ($crate ::  format_args ! ($($arg )*))); }
macro_rules! __ra_macro_fixture528 {($fmt :  literal , $($tt :  tt ),*)=>{ mbe ::  ExpandError ::  ProcMacroError ( tt ::  ExpansionError ::  Unknown ( format ! ($fmt , $($tt ),*)))}; ($fmt :  literal )=>{ mbe ::  ExpandError ::  ProcMacroError ( tt ::  ExpansionError ::  Unknown ($fmt .  to_string ()))}}
macro_rules! __ra_macro_fixture529 {($($tt :  tt )* )=>{$crate ::  quote ::  IntoTt ::  to_subtree ($crate ::  __quote ! ($($tt )*))}}
macro_rules! __ra_macro_fixture530 {()=>{ Vec ::<  tt ::  TokenTree >::  new ()}; (@  SUBTREE $delim :  ident $($tt :  tt )* )=>{{ let  children = $crate ::  __quote ! ($($tt )*);  tt ::  Subtree { delimiter :  Some ( tt ::  Delimiter { kind :  tt ::  DelimiterKind ::$delim ,  id :  tt ::  TokenId ::  unspecified (), }),  token_trees : $crate ::  quote ::  IntoTt ::  to_tokens ( children ), }}}; (@  PUNCT $first :  literal )=>{{ vec ! [ tt ::  Leaf ::  Punct ( tt ::  Punct { char : $first ,  spacing :  tt ::  Spacing ::  Alone ,  id :  tt ::  TokenId ::  unspecified (), }).  into ()]}}; (@  PUNCT $first :  literal , $sec :  literal )=>{{ vec ! [ tt ::  Leaf ::  Punct ( tt ::  Punct { char : $first ,  spacing :  tt ::  Spacing ::  Joint ,  id :  tt ::  TokenId ::  unspecified (), }).  into (),  tt ::  Leaf ::  Punct ( tt ::  Punct { char : $sec ,  spacing :  tt ::  Spacing ::  Alone ,  id :  tt ::  TokenId ::  unspecified (), }).  into ()]}}; (# $first :  ident $($tail :  tt )* )=>{{ let  token = $crate ::  quote ::  ToTokenTree ::  to_token ($first );  let  mut  tokens =  vec ! [ token .  into ()];  let  mut  tail_tokens = $crate ::  quote ::  IntoTt ::  to_tokens ($crate ::  __quote ! ($($tail )*));  tokens .  append (&  mut  tail_tokens );  tokens }}; (# # $first :  ident $($tail :  tt )* )=>{{ let  mut  tokens = $first .  into_iter ().  map ($crate ::  quote ::  ToTokenTree ::  to_token ).  collect ::<  Vec <  tt ::  TokenTree >> ();  let  mut  tail_tokens = $crate ::  quote ::  IntoTt ::  to_tokens ($crate ::  __quote ! ($($tail )*));  tokens .  append (&  mut  tail_tokens );  tokens }}; ({$($tt :  tt )* })=>{$crate ::  __quote ! (@  SUBTREE  Brace $($tt )*)}; ([$($tt :  tt )* ])=>{$crate ::  __quote ! (@  SUBTREE  Bracket $($tt )*)}; (($($tt :  tt )* ))=>{$crate ::  __quote ! (@  SUBTREE  Parenthesis $($tt )*)}; ($tt :  literal )=>{ vec ! [$crate ::  quote ::  ToTokenTree ::  to_token ($tt ).  into ()]}; ($tt :  ident )=>{ vec ! [{ tt ::  Leaf ::  Ident ( tt ::  Ident { text :  stringify ! ($tt ).  into (),  id :  tt ::  TokenId ::  unspecified (), }).  into ()}]}; (-> )=>{$crate ::  __quote ! (@  PUNCT  '-' ,  '>' )}; (& )=>{$crate ::  __quote ! (@  PUNCT  '&' )}; (, )=>{$crate ::  __quote ! (@  PUNCT  ',' )}; (: )=>{$crate ::  __quote ! (@  PUNCT  ':' )}; (; )=>{$crate ::  __quote ! (@  PUNCT  ';' )}; (:: )=>{$crate ::  __quote ! (@  PUNCT  ':' ,  ':' )}; (. )=>{$crate ::  __quote ! (@  PUNCT  '.' )}; (< )=>{$crate ::  __quote ! (@  PUNCT  '<' )}; (> )=>{$crate ::  __quote ! (@  PUNCT  '>' )}; ($first :  tt $($tail :  tt )+ )=>{{ let  mut  tokens = $crate ::  quote ::  IntoTt ::  to_tokens ($crate ::  __quote ! ($first ));  let  mut  tail_tokens = $crate ::  quote ::  IntoTt ::  to_tokens ($crate ::  __quote ! ($($tail )*));  tokens .  append (&  mut  tail_tokens );  tokens }}; }
macro_rules! __ra_macro_fixture531 {($($name :  ident )*)=>{$(if  let  Some ( it )= &  self .$name { f .  field ( stringify ! ($name ),  it ); })*}}
macro_rules! __ra_macro_fixture532 {($fmt :  expr )=>{ RenameError ( format ! ($fmt ))}; ($fmt :  expr , $($arg :  tt )+)=>{ RenameError ( format ! ($fmt , $($arg )+))}}
macro_rules! __ra_macro_fixture533 {($($tokens :  tt )*)=>{ return  Err ( format_err ! ($($tokens )*))}}
macro_rules! __ra_macro_fixture534 {()=>{$crate ::  __private ::  TokenStream ::  new ()}; ($($tt :  tt )*)=>{{ let  mut  _s = $crate ::  __private ::  TokenStream ::  new (); $crate ::  quote_each_token ! ( _s $($tt )*);  _s }}; }
macro_rules! __ra_macro_fixture535 {($tokens :  ident $($tts :  tt )*)=>{$crate ::  quote_tokens_with_context ! ($tokens (@ @ @ @ @ @ $($tts )*)(@ @ @ @ @ $($tts )* @)(@ @ @ @ $($tts )* @ @)(@ @ @ $(($tts ))* @ @ @)(@ @ $($tts )* @ @ @ @)(@ $($tts )* @ @ @ @ @)($($tts )* @ @ @ @ @ @)); }; }
macro_rules! __ra_macro_fixture536 {($tokens :  ident ($($b3 :  tt )*)($($b2 :  tt )*)($($b1 :  tt )*)($($curr :  tt )*)($($a1 :  tt )*)($($a2 :  tt )*)($($a3 :  tt )*))=>{$($crate ::  quote_token_with_context ! ($tokens $b3 $b2 $b1 $curr $a1 $a2 $a3 ); )* }; }
macro_rules! __ra_macro_fixture537 {($tokens :  ident $b3 :  tt $b2 :  tt $b1 :  tt @ $a1 :  tt $a2 :  tt $a3 :  tt )=>{}; ($tokens :  ident $b3 :  tt $b2 :  tt $b1 :  tt (#)($($inner :  tt )* )* $a3 :  tt )=>{{ use $crate ::  __private ::  ext ::*;  let  has_iter = $crate ::  __private ::  ThereIsNoIteratorInRepetition ; $crate ::  pounded_var_names ! ( quote_bind_into_iter ! ( has_iter )()$($inner )*);  let _: $crate ::  __private ::  HasIterator =  has_iter ;  while  true {$crate ::  pounded_var_names ! ( quote_bind_next_or_break ! ()()$($inner )*); $crate ::  quote_each_token ! ($tokens $($inner )*); }}}; ($tokens :  ident $b3 :  tt $b2 :  tt # (($($inner :  tt )* ))* $a2 :  tt $a3 :  tt )=>{}; ($tokens :  ident $b3 :  tt # ($($inner :  tt )* )(*)$a1 :  tt $a2 :  tt $a3 :  tt )=>{}; ($tokens :  ident $b3 :  tt $b2 :  tt $b1 :  tt (#)($($inner :  tt )* )$sep :  tt *)=>{{ use $crate ::  __private ::  ext ::*;  let  mut  _i =  0usize ;  let  has_iter = $crate ::  __private ::  ThereIsNoIteratorInRepetition ; $crate ::  pounded_var_names ! ( quote_bind_into_iter ! ( has_iter )()$($inner )*);  let _: $crate ::  __private ::  HasIterator =  has_iter ;  while  true {$crate ::  pounded_var_names ! ( quote_bind_next_or_break ! ()()$($inner )*);  if  _i >  0 {$crate ::  quote_token ! ($tokens $sep ); } _i +=  1 ; $crate ::  quote_each_token ! ($tokens $($inner )*); }}}; ($tokens :  ident $b3 :  tt $b2 :  tt # (($($inner :  tt )* ))$sep :  tt * $a3 :  tt )=>{}; ($tokens :  ident $b3 :  tt # ($($inner :  tt )* )($sep :  tt )* $a2 :  tt $a3 :  tt )=>{}; ($tokens :  ident # ($($inner :  tt )* )* (*)$a1 :  tt $a2 :  tt $a3 :  tt )=>{$crate ::  quote_token ! ($tokens *); }; ($tokens :  ident # ($($inner :  tt )* )$sep :  tt (*)$a1 :  tt $a2 :  tt $a3 :  tt )=>{}; ($tokens :  ident $b3 :  tt $b2 :  tt $b1 :  tt (#)$var :  ident $a2 :  tt $a3 :  tt )=>{$crate ::  ToTokens ::  to_tokens (&$var , &  mut $tokens ); }; ($tokens :  ident $b3 :  tt $b2 :  tt # ($var :  ident )$a1 :  tt $a2 :  tt $a3 :  tt )=>{}; ($tokens :  ident $b3 :  tt $b2 :  tt $b1 :  tt ($curr :  tt )$a1 :  tt $a2 :  tt $a3 :  tt )=>{$crate ::  quote_token ! ($tokens $curr ); }; }
macro_rules! __ra_macro_fixture538 {($tokens :  ident ($($inner :  tt )* ))=>{$crate ::  __private ::  push_group (&  mut $tokens , $crate ::  __private ::  Delimiter ::  Parenthesis , $crate ::  quote ! ($($inner )*), ); }; ($tokens :  ident [$($inner :  tt )* ])=>{$crate ::  __private ::  push_group (&  mut $tokens , $crate ::  __private ::  Delimiter ::  Bracket , $crate ::  quote ! ($($inner )*), ); }; ($tokens :  ident {$($inner :  tt )* })=>{$crate ::  __private ::  push_group (&  mut $tokens , $crate ::  __private ::  Delimiter ::  Brace , $crate ::  quote ! ($($inner )*), ); }; ($tokens :  ident +)=>{$crate ::  __private ::  push_add (&  mut $tokens ); }; ($tokens :  ident +=)=>{$crate ::  __private ::  push_add_eq (&  mut $tokens ); }; ($tokens :  ident &)=>{$crate ::  __private ::  push_and (&  mut $tokens ); }; ($tokens :  ident &&)=>{$crate ::  __private ::  push_and_and (&  mut $tokens ); }; ($tokens :  ident &=)=>{$crate ::  __private ::  push_and_eq (&  mut $tokens ); }; ($tokens :  ident @)=>{$crate ::  __private ::  push_at (&  mut $tokens ); }; ($tokens :  ident !)=>{$crate ::  __private ::  push_bang (&  mut $tokens ); }; ($tokens :  ident ^)=>{$crate ::  __private ::  push_caret (&  mut $tokens ); }; ($tokens :  ident ^=)=>{$crate ::  __private ::  push_caret_eq (&  mut $tokens ); }; ($tokens :  ident :)=>{$crate ::  __private ::  push_colon (&  mut $tokens ); }; ($tokens :  ident ::)=>{$crate ::  __private ::  push_colon2 (&  mut $tokens ); }; ($tokens :  ident ,)=>{$crate ::  __private ::  push_comma (&  mut $tokens ); }; ($tokens :  ident /)=>{$crate ::  __private ::  push_div (&  mut $tokens ); }; ($tokens :  ident /=)=>{$crate ::  __private ::  push_div_eq (&  mut $tokens ); }; ($tokens :  ident .)=>{$crate ::  __private ::  push_dot (&  mut $tokens ); }; ($tokens :  ident ..)=>{$crate ::  __private ::  push_dot2 (&  mut $tokens ); }; ($tokens :  ident ...)=>{$crate ::  __private ::  push_dot3 (&  mut $tokens ); }; ($tokens :  ident ..=)=>{$crate ::  __private ::  push_dot_dot_eq (&  mut $tokens ); }; ($tokens :  ident =)=>{$crate ::  __private ::  push_eq (&  mut $tokens ); }; ($tokens :  ident ==)=>{$crate ::  __private ::  push_eq_eq (&  mut $tokens ); }; ($tokens :  ident >=)=>{$crate ::  __private ::  push_ge (&  mut $tokens ); }; ($tokens :  ident >)=>{$crate ::  __private ::  push_gt (&  mut $tokens ); }; ($tokens :  ident <=)=>{$crate ::  __private ::  push_le (&  mut $tokens ); }; ($tokens :  ident <)=>{$crate ::  __private ::  push_lt (&  mut $tokens ); }; ($tokens :  ident *=)=>{$crate ::  __private ::  push_mul_eq (&  mut $tokens ); }; ($tokens :  ident !=)=>{$crate ::  __private ::  push_ne (&  mut $tokens ); }; ($tokens :  ident |)=>{$crate ::  __private ::  push_or (&  mut $tokens ); }; ($tokens :  ident |=)=>{$crate ::  __private ::  push_or_eq (&  mut $tokens ); }; ($tokens :  ident ||)=>{$crate ::  __private ::  push_or_or (&  mut $tokens ); }; ($tokens :  ident #)=>{$crate ::  __private ::  push_pound (&  mut $tokens ); }; ($tokens :  ident ?)=>{$crate ::  __private ::  push_question (&  mut $tokens ); }; ($tokens :  ident ->)=>{$crate ::  __private ::  push_rarrow (&  mut $tokens ); }; ($tokens :  ident <-)=>{$crate ::  __private ::  push_larrow (&  mut $tokens ); }; ($tokens :  ident %)=>{$crate ::  __private ::  push_rem (&  mut $tokens ); }; ($tokens :  ident %=)=>{$crate ::  __private ::  push_rem_eq (&  mut $tokens ); }; ($tokens :  ident =>)=>{$crate ::  __private ::  push_fat_arrow (&  mut $tokens ); }; ($tokens :  ident ;)=>{$crate ::  __private ::  push_semi (&  mut $tokens ); }; ($tokens :  ident <<)=>{$crate ::  __private ::  push_shl (&  mut $tokens ); }; ($tokens :  ident <<=)=>{$crate ::  __private ::  push_shl_eq (&  mut $tokens ); }; ($tokens :  ident >>)=>{$crate ::  __private ::  push_shr (&  mut $tokens ); }; ($tokens :  ident >>=)=>{$crate ::  __private ::  push_shr_eq (&  mut $tokens ); }; ($tokens :  ident *)=>{$crate ::  __private ::  push_star (&  mut $tokens ); }; ($tokens :  ident -)=>{$crate ::  __private ::  push_sub (&  mut $tokens ); }; ($tokens :  ident -=)=>{$crate ::  __private ::  push_sub_eq (&  mut $tokens ); }; ($tokens :  ident $ident :  ident )=>{$crate ::  __private ::  push_ident (&  mut $tokens ,  stringify ! ($ident )); }; ($tokens :  ident $other :  tt )=>{$crate ::  __private ::  parse (&  mut $tokens ,  stringify ! ($other )); }; }
macro_rules! __ra_macro_fixture539 {($call :  ident ! $extra :  tt $($tts :  tt )*)=>{$crate ::  pounded_var_names_with_context ! ($call ! $extra (@ $($tts )*)($($tts )* @))}; }
macro_rules! __ra_macro_fixture540 {($call :  ident ! $extra :  tt ($($b1 :  tt )*)($($curr :  tt )*))=>{$($crate ::  pounded_var_with_context ! ($call ! $extra $b1 $curr ); )* }; }
macro_rules! __ra_macro_fixture541 {($call :  ident ! $extra :  tt $b1 :  tt ($($inner :  tt )* ))=>{$crate ::  pounded_var_names ! ($call ! $extra $($inner )*); }; ($call :  ident ! $extra :  tt $b1 :  tt [$($inner :  tt )* ])=>{$crate ::  pounded_var_names ! ($call ! $extra $($inner )*); }; ($call :  ident ! $extra :  tt $b1 :  tt {$($inner :  tt )* })=>{$crate ::  pounded_var_names ! ($call ! $extra $($inner )*); }; ($call :  ident ! ($($extra :  tt )*)# $var :  ident )=>{$crate ::$call ! ($($extra )* $var ); }; ($call :  ident ! $extra :  tt $b1 :  tt $curr :  tt )=>{}; }
macro_rules! __ra_macro_fixture542 {($has_iter :  ident $var :  ident )=>{# [ allow ( unused_mut )] let ( mut $var ,  i )= $var .  quote_into_iter ();  let $has_iter = $has_iter |  i ; }; }
macro_rules! __ra_macro_fixture543 {($var :  ident )=>{ let $var =  match $var .  next (){ Some ( _x )=>$crate ::  __private ::  RepInterp ( _x ),  None => break , }; }; }
macro_rules! __ra_macro_fixture544 {($fmt :  expr )=>{$crate ::  format_ident_impl ! ([::  std ::  option ::  Option ::  None , $fmt ])}; ($fmt :  expr , $($rest :  tt )*)=>{$crate ::  format_ident_impl ! ([::  std ::  option ::  Option ::  None , $fmt ]$($rest )*)}; }
macro_rules! __ra_macro_fixture545 {([$span :  expr , $($fmt :  tt )*])=>{$crate ::  __private ::  mk_ident (&  format ! ($($fmt )*), $span )}; ([$old :  expr , $($fmt :  tt )*] span = $span :  expr )=>{$crate ::  format_ident_impl ! ([$old , $($fmt )*] span = $span ,)}; ([$old :  expr , $($fmt :  tt )*] span = $span :  expr , $($rest :  tt )*)=>{$crate ::  format_ident_impl ! ([::  std ::  option ::  Option ::  Some ::<$crate ::  __private ::  Span > ($span ), $($fmt )* ]$($rest )*)}; ([$span :  expr , $($fmt :  tt )*]$name :  ident = $arg :  expr )=>{$crate ::  format_ident_impl ! ([$span , $($fmt )*]$name = $arg ,)}; ([$span :  expr , $($fmt :  tt )*]$name :  ident = $arg :  expr , $($rest :  tt )*)=>{ match $crate ::  __private ::  IdentFragmentAdapter (&$arg ){ arg =>$crate ::  format_ident_impl ! ([$span .  or ( arg .  span ()), $($fmt )*, $name =  arg ]$($rest )*), }}; ([$span :  expr , $($fmt :  tt )*]$arg :  expr )=>{$crate ::  format_ident_impl ! ([$span , $($fmt )*]$arg ,)}; ([$span :  expr , $($fmt :  tt )*]$arg :  expr , $($rest :  tt )*)=>{ match $crate ::  __private ::  IdentFragmentAdapter (&$arg ){ arg =>$crate ::  format_ident_impl ! ([$span .  or ( arg .  span ()), $($fmt )*,  arg ]$($rest )*), }}; }
macro_rules! __ra_macro_fixture546 {()=>( panic ! ( "not yet implemented" )); ($($arg :  tt )+)=>( panic ! ( "not yet implemented: {}" , $crate ::  format_args ! ($($arg )+))); }
macro_rules! __ra_macro_fixture547 {($($name :  expr ),+ $(,)?)=>{{ let  mut  v =  ArrayVec ::< [ LangItemTarget ;  2 ]>::  new (); $(v .  extend ( db .  lang_item ( cur_crate , $name .  into ())); )+  v }}; }
macro_rules! __ra_macro_fixture548 {($ctor :  pat , $param :  pat )=>{ crate ::  Ty ::  Apply ( crate ::  ApplicationTy { ctor : $ctor ,  parameters : $param })}; ($ctor :  pat )=>{ ty_app ! ($ctor , _)}; }
macro_rules! __ra_macro_fixture549 {(@  one $x :  expr )=>( 1usize ); ($elem :  expr ; $n :  expr )=>({$crate ::  SmallVec ::  from_elem ($elem , $n )}); ($($x :  expr ),*$(,)*)=>({ let  count =  0usize $(+ $crate ::  smallvec ! (@  one $x ))*; # [ allow ( unused_mut )] let  mut  vec = $crate ::  SmallVec ::  new ();  if  count <=  vec .  inline_size (){$(vec .  push ($x );)*  vec } else {$crate ::  SmallVec ::  from_vec ($crate ::  alloc ::  vec ! [$($x ,)*])}}); }
macro_rules! __ra_macro_fixture550 {($($q :  path )*)=>{$(let  before =  memory_usage ().  allocated ; $q .  in_db ( self ).  sweep ( sweep );  let  after =  memory_usage ().  allocated ;  let  q : $q =  Default ::  default ();  let  name =  format ! ( "{:?}" ,  q );  acc .  push (( name ,  before -  after ));  let  before =  memory_usage ().  allocated ; $q .  in_db ( self ).  sweep ( sweep .  discard_everything ());  let  after =  memory_usage ().  allocated ;  let  q : $q =  Default ::  default ();  let  name =  format ! ( "{:?} (deps)" ,  q );  acc .  push (( name ,  before -  after ));  let  before =  memory_usage ().  allocated ; $q .  in_db ( self ).  purge ();  let  after =  memory_usage ().  allocated ;  let  q : $q =  Default ::  default ();  let  name =  format ! ( "{:?} (purge)" ,  q );  acc .  push (( name ,  before -  after )); )*}}
macro_rules! __ra_macro_fixture551 {($($arg :  tt )*)=>( if $crate ::  cfg ! ( debug_assertions ){$crate ::  assert ! ($($arg )*); })}
macro_rules! __ra_macro_fixture552 {()=>{{ let  anchor =  match  self .  l_curly_token (){ Some ( it )=> it .  into (),  None => return  self .  clone (), };  InsertPosition ::  After ( anchor )}}; }
macro_rules! __ra_macro_fixture553 {($anchor :  expr )=>{ if  let  Some ( comma )= $anchor .  syntax ().  siblings_with_tokens ( Direction ::  Next ).  find (|  it |  it .  kind ()==  T ! [,]){ InsertPosition ::  After ( comma )} else { to_insert .  insert ( 0 ,  make ::  token ( T ! [,]).  into ());  InsertPosition ::  After ($anchor .  syntax ().  clone ().  into ())}}; }
macro_rules! __ra_macro_fixture554 {($anchor :  expr )=>{ if  let  Some ( comma )= $anchor .  syntax ().  siblings_with_tokens ( Direction ::  Next ).  find (|  it |  it .  kind ()==  T ! [,]){ InsertPosition ::  After ( comma )} else { to_insert .  insert ( 0 ,  make ::  token ( T ! [,]).  into ());  InsertPosition ::  After ($anchor .  syntax ().  clone ().  into ())}}; }
macro_rules! __ra_macro_fixture555 {()=>{{ let  anchor =  match  self .  l_angle_token (){ Some ( it )=> it .  into (),  None => return  self .  clone (), };  InsertPosition ::  After ( anchor )}}; }
macro_rules! __ra_macro_fixture556 {()=>{ for _  in  0 ..  level { buf .  push_str ( "  " ); }}; }
macro_rules! __ra_macro_fixture557 {()=>{ ExpandError ::  BindingError ( format ! ( "" ))}; ($($tt :  tt )*)=>{ ExpandError ::  BindingError ( format ! ($($tt )*))}; }
macro_rules! __ra_macro_fixture558 {($($tt :  tt )*)=>{ return  Err ( err ! ($($tt )*))}; }
macro_rules! __ra_macro_fixture559 {($($tt :  tt )*)=>{ ParseError ::  UnexpectedToken (($($tt )*).  to_string ())}; }
