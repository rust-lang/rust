error: use the question mark operator instead of an `and_then` call
  --> tests/ui/return_and_then.rs:5:9
   |
LL | /         opt.and_then(|n| {
LL | |             let mut ret = n + 1;
LL | |             ret += n;
LL | |             if n > 1 { Some(ret) } else { None }
LL | |         })
   | |__________^
   |
   = note: `-D clippy::return-and-then` implied by `-D warnings`
   = help: to override `-D warnings` add `#[allow(clippy::return_and_then)]`
help: try
   |
LL ~         let n = opt?;
LL +         let mut ret = n + 1;
LL +         ret += n;
LL +         if n > 1 { Some(ret) } else { None }
   |

error: use the question mark operator instead of an `and_then` call
  --> tests/ui/return_and_then.rs:13:9
   |
LL |         opt.and_then(|n| test_opt_block(Some(n)))
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: try
   |
LL ~         let n = opt?;
LL +         test_opt_block(Some(n))
   |

error: use the question mark operator instead of an `and_then` call
  --> tests/ui/return_and_then.rs:17:9
   |
LL |         gen_option(1).and_then(|n| test_opt_block(Some(n)))
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: try
   |
LL ~         let n = gen_option(1)?;
LL +         test_opt_block(Some(n))
   |

error: use the question mark operator instead of an `and_then` call
  --> tests/ui/return_and_then.rs:21:9
   |
LL |         opt.and_then(|n| if n > 1 { Ok(n + 1) } else { Err(n) })
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: try
   |
LL ~         let n = opt?;
LL +         if n > 1 { Ok(n + 1) } else { Err(n) }
   |

error: use the question mark operator instead of an `and_then` call
  --> tests/ui/return_and_then.rs:25:9
   |
LL |         opt.and_then(|n| test_res_block(Ok(n)))
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: try
   |
LL ~         let n = opt?;
LL +         test_res_block(Ok(n))
   |

error: use the question mark operator instead of an `and_then` call
  --> tests/ui/return_and_then.rs:30:9
   |
LL |         Some("").and_then(|x| if x.len() > 2 { Some(3) } else { None })
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: try
   |
LL ~         let x = Some("")?;
LL +         if x.len() > 2 { Some(3) } else { None }
   |

error: use the question mark operator instead of an `and_then` call
  --> tests/ui/return_and_then.rs:35:9
   |
LL | /         Some(match (vec![1, 2, 3], vec![1, 2, 4]) {
LL | |             (a, _) if a.len() > 1 => a,
LL | |             (_, b) => b,
LL | |         })
LL | |         .and_then(|x| if x.len() > 2 { Some(3) } else { None })
   | |_______________________________________________________________^
   |
help: try
   |
LL ~         let x = Some(match (vec![1, 2, 3], vec![1, 2, 4]) {
LL +             (a, _) if a.len() > 1 => a,
LL +             (_, b) => b,
LL +         })?;
LL +         if x.len() > 2 { Some(3) } else { None }
   |

error: aborting due to 7 previous errors

