#![warn(clippy::zero_repeat_side_effects)]
#![allow(clippy::unnecessary_operation)]
#![allow(clippy::useless_vec)]
#![allow(clippy::needless_late_init)]

fn f() -> i32 {
    println!("side effect");
    10
}

fn main() {
    const N: usize = 0;
    const M: usize = 1;

    // should trigger

    // on arrays
    f(); let a: [i32; 0] = [];
    f(); let a: [i32; 0] = [];
    let mut b;
    f(); b = [] as [i32; 0];
    f(); b = [] as [i32; 0];

    // on vecs
    // vecs dont support infering value of consts
    f(); let c: std::vec::Vec<i32> = vec![];
    let d;
    f(); d = vec![] as std::vec::Vec<i32>;

    // for macros
    println!("side effect"); let e: [(); 0] = [];

    // for nested calls
    { f() }; let g: [i32; 0] = [];

    // as function param
    drop({ f(); vec![] as std::vec::Vec<i32> });

    // when singled out/not part of assignment/local
    { f(); vec![] as std::vec::Vec<i32> };
    { f(); [] as [i32; 0] };
    { f(); [] as [i32; 0] };

    // should not trigger

    // on arrays with > 0 repeat
    let a = [f(); 1];
    let a = [f(); M];
    let mut b;
    b = [f(); 1];
    b = [f(); M];

    // on vecs with > 0 repeat
    let c = vec![f(); 1];
    let d;
    d = vec![f(); 1];

    // as function param
    drop(vec![f(); 1]);
}
