error: the evaluated program deadlocked
  --> RUSTLIB/std/src/sys/thread/PLATFORM.rs:LL:CC
   |
LL |         let rc = unsafe { c::WaitForSingleObject(self.handle.as_raw_handle(), c::INFINITE) };
   |                                                                                          ^ thread got stuck here
   |
   = note: this is on thread `main`
   = note: stack backtrace:
           0: std::sys::thread::PLATFORM::Thread::join
               at RUSTLIB/std/src/sys/thread/PLATFORM.rs:LL:CC
           1: std::thread::lifecycle::JoinInner::join
               at RUSTLIB/std/src/thread/lifecycle.rs:LL:CC
           2: std::thread::JoinHandle::join
               at RUSTLIB/std/src/thread/join_handle.rs:LL:CC
           3: main
               at tests/fail-dep/concurrency/windows_join_main.rs:LL:CC

error: the evaluated program deadlocked
  --> tests/fail-dep/concurrency/windows_join_main.rs:LL:CC
   |
LL |             assert_eq!(WaitForSingleObject(MAIN_THREAD, INFINITE), WAIT_OBJECT_0);
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ thread got stuck here
   |
   = note: this is on thread `unnamed-ID`
note: the current function got called indirectly due to this code
  --> tests/fail-dep/concurrency/windows_join_main.rs:LL:CC
   |
LL | /     thread::spawn(|| {
LL | |         unsafe {
LL | |             assert_eq!(WaitForSingleObject(MAIN_THREAD, INFINITE), WAIT_OBJECT_0);
LL | |         }
LL | |     })
   | |______^
   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace

error: aborting due to 2 previous errors

