# Japanese translations for Rust package
# Copyright (C) 2013 The Rust Project Developers
# This file is distributed under the same license as the Rust package.
# Automatically generated, 2013.
#
msgid ""
msgstr ""
"Project-Id-Version: Rust 0.8\n"
"POT-Creation-Date: 2014-02-03 08:13+0900\n"
"PO-Revision-Date: 2013-08-08 22:27+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: UTF-8\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Plain text
#: src/doc/guide-conditions.md:4 src/doc/guide-ffi.md:4
#: src/doc/guide-lifetimes.md:4 src/doc/guide-macros.md:4
#: src/doc/guide-tasks.md:4 src/doc/rust.md:4 src/doc/tutorial.md:4
msgid "# Introduction"
msgstr "# イントロダクション"

#. type: Plain text
#: src/doc/guide-ffi.md:168 src/doc/tutorial.md:885
msgid "# Destructors"
msgstr "# デストラクタ"

#. type: Plain text
#: src/doc/guide-lifetimes.md:72 src/doc/tutorial.md:1409
msgid "Now we can call `compute_distance()` in various ways:"
msgstr ""
"上記の `compute_distance()` 関数は、様々な方法で呼び出すことができます。"

#. type: Plain text
#: src/doc/guide-pointers.md:326 src/doc/tutorial.md:1360
#, fuzzy
msgid "# References"
msgstr "# ポインタのデリファレンス"

#. type: Plain text
#: src/doc/guide-testing.md:127 src/doc/tutorial.md:786
#, fuzzy
msgid "For example:"
msgstr "## 最小限の例"

#. type: Plain text
#: src/doc/rust.md:1391 src/doc/tutorial.md:2495
msgid "Likewise, supertrait methods may also be called on trait objects."
msgstr ""
"同様に、スーパートレイトのメソッドは、トレイトオブジェクトについても呼び出す"
"ことが可能です。"

#. type: Plain text
#: src/doc/tutorial.md:2
msgid "% The Rust Language Tutorial"
msgstr "% Rust 言語チュートリアル"

#. type: Plain text
#: src/doc/tutorial.md:13
msgid ""
"Rust is a programming language with a focus on type safety, memory safety, "
"concurrency and performance. It is intended for writing large-scale, high-"
"performance software that is free from several classes of common errors. "
"Rust has a sophisticated memory model that encourages efficient data "
"structures and safe concurrency patterns, forbidding invalid memory accesses "
"that would otherwise cause segmentation faults. It is statically typed and "
"compiled ahead of time."
msgstr ""
"Rust は、型安全性、メモリ安全性、並列性、パフォーマンスを重視したプログラミン"
"グ言語です。大規模でハイパフォーマンスなソフトウェア作成向きの、C++ 等の言語"
"でよくある誤りを犯しにくい言語仕様になっています。Rust の洗練されたメモリモデ"
"ルでは、効率的なデータ構造や安全な並行計算を実現することが可能であり、セグメ"
"ンテーション違反を引き起こす不正なメモリアクセスは起こりえません。Rust は、静"
"的型付けされた、コンパイル型の言語です。"

#. type: Plain text
#: src/doc/tutorial.md:17
msgid ""
"As a multi-paradigm language, Rust supports writing code in procedural, "
"functional and object-oriented styles. Some of its pleasant high-level "
"features include:"
msgstr ""
"Rust はマルチパラダイム言語であり、手続き型、関数型、オブジェクト指向型のプロ"
"グラミングをサポートします。Rust には、次のような素敵で高レベルな特徴がありま"
"す。"

#. type: Bullet: '* '
#: src/doc/tutorial.md:30
msgid ""
"**Type inference.** Type annotations on local variable declarations are "
"optional."
msgstr ""
"**型推論:** ローカル変数の宣言では型注釈 (type annotation) を省略できます。"

#. type: Bullet: '* '
#: src/doc/tutorial.md:30
msgid ""
"**Safe task-based concurrency.** Rust's lightweight tasks do not share "
"memory, instead communicating through messages."
msgstr ""
"**タスクベースの安全な並行計算:** Rust の軽量タスクはタスク間でメモリを共有す"
"るのではなく、メッセージを介して通信します。"

#. type: Bullet: '* '
#: src/doc/tutorial.md:30
msgid ""
"**Higher-order functions.** Efficient and flexible closures provide "
"iteration and other control structures"
msgstr ""
"**高階関数:** 効率的で柔軟なクロージャにより、イテレーションやその他の制御構"
"造を実現できます。"

#. type: Bullet: '* '
#: src/doc/tutorial.md:30
msgid ""
"**Pattern matching and algebraic data types.** Pattern matching on Rust's "
"enumeration types (a more powerful version of C's enums, similar to "
"algebraic data types in functional languages) is a compact and expressive "
"way to encode program logic."
msgstr ""
"**パターンマッチと代数的データ型:** Rust の列挙型 (C の列挙型の強化バージョ"
"ン。関数型言語における代数的データ型のようなもの) のパターンマッチにより、プ"
"ログラムの論理を、コンパクトで表現力豊かに記述することができます。"

#. type: Bullet: '* '
#: src/doc/tutorial.md:30
msgid ""
"**Polymorphism.** Rust has type-parametric functions and types, type classes "
"and OO-style interfaces."
msgstr ""
"**ポリモーフィズム:** Rust には、型パラメータをもつ関数や型、型クラスとオブ"
"ジェクト指向風のインターフェースがあります。"

#. type: Plain text
#: src/doc/tutorial.md:32
msgid "## Scope"
msgstr "## 本文書の位置づけ"

#. type: Plain text
#: src/doc/tutorial.md:38
msgid ""
"This is an introductory tutorial for the Rust programming language. It "
"covers the fundamentals of the language, including the syntax, the type "
"system and memory model, generics, and modules. [Additional tutorials](#what-"
"next) cover specific language features in greater depth."
msgstr ""
"この文章は、Rust プログラミング言語のチュートリアルです。構文、型システムとメ"
"モリモデル、ジェネリクス、モジュールなどの言語の基礎となる部分をカバーしてい"
"ます。 いくつかの言語機能の詳細については、 [その他のチュートリアル](#次のス"
"テップは) を参照してください。"

#. type: Plain text
#: src/doc/tutorial.md:42
msgid ""
"This tutorial assumes that the reader is already familiar with one or more "
"languages in the C family. Understanding of pointers and general memory "
"management techniques will help."
msgstr ""
"本チュートリアルは、読者がすでに 1 つ以上の C 系統言語 に精通していることを前"
"提としています。本書を理解する上で、ポインタやメモリ管理のテクニックに関する"
"知識が役に立つでしょう。"

#. type: Plain text
#: src/doc/tutorial.md:44
msgid "## Conventions"
msgstr "## 本書の表記について"

#. type: Plain text
#: src/doc/tutorial.md:47
msgid ""
"Throughout the tutorial, language keywords and identifiers defined in "
"example code are displayed in `code font`."
msgstr ""
"本チュートリアルでは、言語のキーワードや、サンプルコード中で定義される識別子"
"を `code font` のように示します。"

#. type: Plain text
#: src/doc/tutorial.md:53
msgid ""
"Code snippets are indented, and also shown in a monospaced font. Not all "
"snippets constitute whole programs. For brevity, we'll often show fragments "
"of programs that don't compile on their own. To try them out, you might have "
"to wrap them in `fn main() { ... }`, and make sure they don't contain "
"references to names that aren't actually defined."
msgstr ""
"コードスニペットは、インデントされ、固定幅フォントで表示されます。いくつかの"
"コードスニペットは、プログラムの一部を抜き出したものになっています。説明を簡"
"潔にするため、それだけではコンパイル不可能なプログラムの断片を掲載することが"
"あります。プログラムの動作を試す際には、全体を `fn main() { ... }` で囲んでく"
"ださい。また、プログラム中で未定義の名前を参照している箇所がないか確認してく"
"ださい。"

#. type: Plain text
#: src/doc/tutorial.md:57
msgid ""
"> ***Warning:*** Rust is a language under ongoing development. Notes > about "
"potential changes to the language, implementation > deficiencies, and other "
"caveats appear offset in blockquotes."
msgstr ""
"> ***警告:*** Rust は開発途上の言語です。将来予定されている言語への変更や、実"
"装上の不備、その他の注意事項など、 blockquote の段落 (この段落もそうです) に"
"注意してください。"

#. type: Plain text
#: src/doc/tutorial.md:59
msgid "# Getting started"
msgstr "# はじめに"

#. type: Plain text
#: src/doc/tutorial.md:67
#, fuzzy
#| msgid ""
#| "The Rust compiler currently must be built from a [tarball], unless you "
#| "are on Windows, in which case using the [installer][win-exe] is "
#| "recommended."
msgid ""
"The Rust compiler currently must be built from a [tarball] or [git], unless "
"you are on Windows, in which case using the [installer][win-exe] is "
"recommended. There is a list of community-maintained nightly builds and "
"packages [on the wiki][wiki-packages]."
msgstr ""
"Windows 以外の環境では、今のところ、Rust のコンパイラは [ソースコード]"
"[tarball] からビルドする必要があります。Windows をお使いの場合は、 [インス"
"トーラー][win-exe] の使用をおすすめします。"

#. type: Plain text
#: src/doc/tutorial.md:72
#, fuzzy
#| msgid ""
#| "Since the Rust compiler is written in Rust, it must be built by a "
#| "precompiled \"snapshot\" version of itself (made in an earlier state of "
#| "development). As such, source builds require a connection to the "
#| "Internet, to fetch snapshots, and an OS that can execute the available "
#| "snapshot binaries."
msgid ""
"Since the Rust compiler is written in Rust, it must be built by a "
"precompiled \"snapshot\" version of itself (made in an earlier state of "
"development). The source build automatically fetches these snapshots from "
"the Internet on our supported platforms."
msgstr ""
"Rust のコンパイラは Rust で書かれているため、最新版の少し前のソースからコンパ"
"イルされた「スナップショット」版コンパイラでビルドする必要があります。スナッ"
"プショットを利用してビルドするためには、スナップショットをダウンロードするた"
"めのインターネット接続と、スナップショットバイナリを実行できる OS が必要で"
"す。"

#. type: Plain text
#: src/doc/tutorial.md:74
msgid "Snapshot binaries are currently built and tested on several platforms:"
msgstr ""
"スナップショットバイナリは、現時点では以下のプラットフォーム向けのものがあり"
"ます。"

#. type: Bullet: '* '
#: src/doc/tutorial.md:78
#, fuzzy
#| msgid "Windows (7, Server 2008 R2), x86 only"
msgid "Windows (7, 8, Server 2008 R2), x86 only"
msgstr "Windows (7, Server 2008 R2), x86 のみ"

#. type: Bullet: '* '
#: src/doc/tutorial.md:78
#, fuzzy
#| msgid "Linux (various distributions), x86 and x86-64"
msgid "Linux (2.6.18 or later, various distributions), x86 and x86-64"
msgstr "Linux (各種ディストリビューション), x86 または x86-64"

#. type: Bullet: '* '
#: src/doc/tutorial.md:78
#, fuzzy
#| msgid "OSX 10.6 (\"Snow Leopard\") or greater, x86 and x86-64"
msgid "OSX 10.7 (Lion) or greater, x86 and x86-64"
msgstr "OSX 10.6 (\"Snow Leopard\") 以降, x86 または x86-64"

#. type: Plain text
#: src/doc/tutorial.md:81
msgid ""
"You may find that other platforms work, but these are our \"tier 1\" "
"supported build environments that are most likely to work."
msgstr ""
"スナップショットは他のプラットフォームでも動作するかもしれませんが、\"tier "
"1\" プラットフォームとしてサポートされているのは上記のみです。"

#. type: Plain text
#: src/doc/tutorial.md:88
msgid ""
"> ***Note:*** Windows users should read the detailed > \"[getting started]"
"[wiki-start]\" notes on the wiki. Even when using > the binary installer, "
"the Windows build requires a MinGW installation, > the precise details of "
"which are not discussed here. Finally, `rustc` may > need to be [referred to "
"as `rustc.exe`][bug-3319]. It's a bummer, we > know."
msgstr ""
"> ***注意:*** Windows ユーザーは wiki の [getting started][wiki-start] の記事"
"を読んでください。 本書では詳細を説明しませんが、インストーラを利用する場合で"
"も、MinGW のインストールなど、追加の手順が必要です。また、コンパイラは "
"`rustc` ではなく、 [`rustc.exe` として呼び出す必要がある][bug-3319] かもしれ"
"ません。このような制限があることはは、本当に残念です。"

#. type: Plain text
#: src/doc/tutorial.md:92
#, fuzzy
#| msgid ""
#| "[bug-3319]: https://github.com/mozilla/rust/issues/3319 [wiki-start]: "
#| "https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust"
msgid ""
"[bug-3319]: https://github.com/mozilla/rust/issues/3319 [wiki-start]: "
"https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust "
"[git]: https://github.com/mozilla/rust.git"
msgstr ""
"[bug-3319]: https://github.com/mozilla/rust/issues/3319\n"
"[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-"
"developing-Rust"

#. type: Plain text
#: src/doc/tutorial.md:95
msgid ""
"To build from source you will also need the following prerequisite packages:"
msgstr "ソースからビルドするためには、以下のパッケージが必要です。"

#. type: Bullet: '* '
#: src/doc/tutorial.md:101
msgid "g++ 4.4 or clang++ 3.x"
msgstr "g++ 4.4 または clang++ 3.x"

#. type: Bullet: '* '
#: src/doc/tutorial.md:101
msgid "python 2.6 or later (but not 3.x)"
msgstr "python 2.6 以降 (ただし、 3.x は除く)"

#. type: Bullet: '* '
#: src/doc/tutorial.md:101
msgid "perl 5.0 or later"
msgstr "perl 5.0 以降"

#. type: Bullet: '* '
#: src/doc/tutorial.md:101
msgid "gnu make 3.81 or later"
msgstr "gnu make 3.81 以降"

#. type: Bullet: '* '
#: src/doc/tutorial.md:101
msgid "curl"
msgstr "curl"

#. type: Plain text
#: src/doc/tutorial.md:104
msgid ""
"If you've fulfilled those prerequisites, something along these lines should "
"work."
msgstr "上記条件を満たしていれば、以下のような手順でビルド可能なはずです。"

#. type: Plain text
#: src/doc/tutorial.md:112
#, fuzzy
#| msgid ""
#| "~~~~ {.notrust} $ curl -O http://static.rust-lang.org/dist/rust-nightly.tar."
#| "gz $ tar -xzf rust-nightly.tar.gz $ cd rust-nightly $ ./configure $ make && make "
#| "install ~~~~"
msgid ""
"~~~~ {.notrust} $ curl -O http://static.rust-lang.org/dist/rust-nightly.tar.gz $ "
"tar -xzf rust-nightly.tar.gz $ cd rust-nightly $ ./configure $ make && make install "
"~~~~"
msgstr ""
"~~~~ {.notrust}\n"
"$ curl -O http://static.rust-lang.org/dist/rust-nightly.tar.gz\n"
"$ tar -xzf rust-nightly.tar.gz $ cd rust-nightly $ ./configure\n"
"$ make && make install\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:118
msgid ""
"You may need to use `sudo make install` if you do not normally have "
"permission to modify the destination directory. The install locations can be "
"adjusted by passing a `--prefix` argument to `configure`. Various other "
"options are also supported: pass `--help` for more information on them."
msgstr ""
"インストール先のディレクトリを変更する権限がない場合、 `sudo make install` を"
"実行する必要があるかもしれません。インストール先は `configure` に `--prefix` "
"引数を渡すことで変更できます。`configure` はその他いろいろなオプションをサ"
"ポートしています。詳細については、 `--help` 引数を指定して実行してください。"

#. type: Plain text
#: src/doc/tutorial.md:122
#, fuzzy
#| msgid ""
#| "When complete, `make install` will place several programs into `/usr/"
#| "local/bin`: `rustc`, the Rust compiler; `rustdoc`, the API-documentation "
#| "tool; and `rustpkg`, the Rust package manager."
msgid ""
"When complete, `make install` will place several programs into `/usr/local/"
"bin`: `rustc`, the Rust compiler, and `rustdoc`, the API-documentation tool."
msgstr ""
"ビルド完了後、`make install` を実行すると、以下のプログラムが `/usr/local/"
"bin` にインストールされます。\n"
"\n"
"* `rustc`: Rust のコンパイラ\n"
"* `rustdoc`: API ドキュメント作成ツール\n"
"* `rustpkg`: Rust のパッケージマネージャ\n"

#. type: Plain text
#: src/doc/tutorial.md:125
#, fuzzy
#| msgid ""
#| "[tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz [win-exe]: "
#| "http://static.rust-lang.org/dist/rust-nightly-install.exe"
msgid ""
"[tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz [win-exe]: "
"http://static.rust-lang.org/dist/rust-nightly-install.exe"
msgstr ""
"[tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz\n"
"[win-exe]: http://static.rust-lang.org/dist/rust-nightly-install.exe"

#. type: Plain text
#: src/doc/tutorial.md:127
msgid "## Compiling your first program"
msgstr "## 最初のプログラム"

#. type: Plain text
#: src/doc/tutorial.md:130
msgid ""
"Rust program files are, by convention, given the extension `.rs`. Say we "
"have a file `hello.rs` containing this program:"
msgstr ""
"Rust プログラムのファイルの拡張子は、慣例的に `.rs` とされています。以下の内"
"容を持つファイル、`hello.rs` が存在するとします。"

#. type: Plain text
#: src/doc/tutorial.md:136
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"~~~~\n"
"fn main() {\n"
"    println!(\"hello?\");\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:140
msgid ""
"If the Rust compiler was installed successfully, running `rustc hello.rs` "
"will produce an executable called `hello` (or `hello.exe` on Windows) which, "
"upon running, will likely do exactly what you expect."
msgstr ""
"Rust のコンパイラが正しくインストールされている場合、 `rustc hello.rs` を実行"
"することで、実行ファイル `hello` (Windows の場合 `hello.exe`) を生成すること"
"が可能です。このファイルを実行すれば、予想通りの出力が得られるでしょう。"

#. type: Plain text
#: src/doc/tutorial.md:145
#, fuzzy
#| msgid ""
#| "The Rust compiler tries to provide useful information when it encounters "
#| "an error. If you introduce an error into the program (for example, by "
#| "changing `println` to some nonexistent function), and then compile it, "
#| "you'll see an error message like this:"
msgid ""
"The Rust compiler tries to provide useful information when it encounters an "
"error. If you introduce an error into the program (for example, by changing "
"`println!` to some nonexistent macro), and then compile it, you'll see an "
"error message like this:"
msgstr ""
"コンパイルエラーが発生した場合、Rust コンパイラはエラー解決のための情報を出力"
"します。プログラム中にエラーが含まれる場合 (上記プログラムの `println` を存在"
"しない別の名前に変更した場合など)、コンパイル時に以下のようなエラーメッセージ"
"が出力されます。"

#. type: Plain text
#: src/doc/tutorial.md:158
#, fuzzy
#| msgid ""
#| "In its simplest form, a Rust program is a `.rs` file with some types and "
#| "functions defined in it. If it has a `main` function, it can be compiled "
#| "to an executable. Rust does not allow code that's not a declaration to "
#| "appear at the top level of the file: all statements must live inside a "
#| "function.  Rust programs can also be compiled as libraries, and included "
#| "in other programs."
msgid ""
"In its simplest form, a Rust program is a `.rs` file with some types and "
"functions defined in it. If it has a `main` function, it can be compiled to "
"an executable. Rust does not allow code that's not a declaration to appear "
"at the top level of the file: all statements must live inside a function.  "
"Rust programs can also be compiled as libraries, and included in other "
"programs, even ones not written in Rust."
msgstr ""
"最も単純な Rust プログラムは、いくつかの型や関数が定義された `.rs` ファイルの"
"みからなります。`.rs` ファイルをコンパイルして実行可能ファイルを作成する場"
"合、ファイル中に `main` 関数が含まれている必要があります。Rust プログラムで"
"ファイルのトップレベルに記述可能なのは宣言 (declaration) のみです。ステートメ"
"ント (statement) は、すべて関数内部に記述されます。Rust のプログラムは、他の"
"プログラムから利用するライブラリとしてコンパイルすることも可能です。"

#. type: Plain text
#: src/doc/tutorial.md:160
msgid "## Editing Rust code"
msgstr "## Rust のコードを編集する"

#. type: Plain text
#: src/doc/tutorial.md:170
msgid ""
"There are vim highlighting and indentation scripts in the Rust source "
"distribution under `src/etc/vim/`. There is an emacs mode under `src/etc/"
"emacs/` called `rust-mode`, but do read the instructions included in that "
"directory. In particular, if you are running emacs 24, then using emacs's "
"internal package manager to install `rust-mode` is the easiest way to keep "
"it up to date. There is also a package for Sublime Text 2, available both "
"[standalone][sublime] and through [Sublime Package Control][sublime-pkg], "
"and support for Kate under `src/etc/kate`."
msgstr ""
"vim のハイライトとインデント用スクリプトは、Rust のソースツリーの `src/etc/"
"vim` 以下にあります。emacs の Rust 編集用モードの `rust-mode` は、 `src/etc/"
"emacs/` 以下にありますが、当該ディレクトリに配置されているインストール手順に"
"従って操作する必要があります。 emacs 24 以降をご利用の場合、 emacs 組み込みの"
"パッケージマネージャで `rust-mode` をインストールするのが最もお手軽です。"
"Sublime Text 2 用のパッケージは、[スタンドアロン版][sublime] と、[Sublime "
"Package Control][sublime-pkg] 版の2つがあります。Kate 向けパッケージは `src/"
"etc/kate` 以下です。"

#. type: Plain text
#: src/doc/tutorial.md:177
msgid ""
"There is ctags support via `src/etc/ctags.rust`, but many other tools and "
"editors are not yet supported. If you end up writing a Rust mode for your "
"favorite editor, let us know so that we can link to it."
msgstr ""
"ctags は `src/etc/ctags.rust` を利用することで rust をサポートします。多くの"
"ツールやエディタは rust をサポートしていません。もしあなたがお気に入りのエ"
"ディタ向けのRust モードを作成した場合、リンクを貼りたいのでお知らせください。"

#. type: Plain text
#: src/doc/tutorial.md:180
msgid ""
"[sublime]: http://github.com/dbp/sublime-rust [sublime-pkg]: http://wbond."
"net/sublime_packages/package_control"
msgstr ""
"[sublime]: http://github.com/dbp/sublime-rust\n"
"[sublime-pkg]: http://wbond.net/sublime_packages/package_control"

#. type: Plain text
#: src/doc/tutorial.md:182
msgid "# Syntax basics"
msgstr "# 基本的な構文"

#. type: Plain text
#: src/doc/tutorial.md:190
msgid ""
"Assuming you've programmed in any C-family language (C++, Java, JavaScript, "
"C#, or PHP), Rust will feel familiar. Code is arranged in blocks delineated "
"by curly braces; there are control structures for branching and looping, "
"like the familiar `if` and `while`; function calls are written `myfunc(arg1, "
"arg2)`; operators are written the same and mostly have the same precedence "
"as in C; comments are again like C; module names are separated with double-"
"colon (`::`) as with C++."
msgstr ""
"あなたが C 系統の言語 (C++, Java, JavaScript, C# または PHP) でプログラミング"
"したことがあれば、Rust の構文には馴染みがあるでしょう。コードは波括弧で区切ら"
"れたブロックの中に配置され、分岐やループのための制御構文はお馴染みの `if` と "
"`while` で、関数呼び出しは `myfunc(arg1, arg2)` と書け、演算子は C のものと同"
"じで、優先順位もほとんど同じで、コメントもまた C と同じで、モジュール名のセパ"
"レータは C++ と同様 2つのコロン (`::`) です。"

#. type: Plain text
#: src/doc/tutorial.md:195
msgid ""
"The main surface difference to be aware of is that the condition at the head "
"of control structures like `if` and `while` does not require parentheses, "
"while their bodies *must* be wrapped in braces. Single-statement, unbraced "
"bodies are not allowed."
msgstr ""
"表記上の違いで注目すべき点は、`if` や `while` などの制御構造の先頭にある条件"
"句を丸括弧で囲う必要がない点と、ボディ部をで波括弧で **囲わなければならない"
"** という点です。ボディ部が単一のステートメントであっても、波括弧を省略するこ"
"とはできません。"

#. type: Plain text
#: src/doc/tutorial.md:208
#, no-wrap
msgid ""
"~~~~\n"
"# mod universe { pub fn recalibrate() -> bool { true } }\n"
"fn main() {\n"
"    /* A simple loop */\n"
"    loop {\n"
"        // A tricky calculation\n"
"        if universe::recalibrate() {\n"
"            return;\n"
"        }\n"
"    }\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"# mod universe { pub fn recalibrate() -> bool { true } }\n"
"fn main() {\n"
"    /* シンプルなループ */\n"
"    loop {\n"
"        // 複雑な計算\n"
"        if universe::recalibrate() {\n"
"            return;\n"
"        }\n"
"    }\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:212
msgid ""
"The `let` keyword introduces a local variable. Variables are immutable by "
"default. To introduce a local variable that you can re-assign later, use "
"`let mut` instead."
msgstr ""
"`let` キーワードにより、ローカル変数を定義します。変数はデフォルトでは "
"immutable (変更不可) です。再代入可能なローカル変数を定義するためには、`let "
"mut` を用います。"

#. type: Plain text
#: src/doc/tutorial.md:216
msgid "~~~~ let hi = \"hi\"; let mut count = 0;"
msgstr ""
"~~~~\n"
" let hi = \"hi\";\n"
" let mut count = 0;"

#. type: Plain text
#: src/doc/tutorial.md:222
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"while count < 10 {\n"
"    println!(\"count is {}\", count);\n"
"    count += 1;\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:226
#, fuzzy
#| msgid ""
#| "Although Rust can almost always infer the types of local variables, you "
#| "can specify a variable's type by following it with a colon, then the type "
#| "name. Static items, on the other hand, always require a type annotation."
msgid ""
"Although Rust can almost always infer the types of local variables, you can "
"specify a variable's type by following it in the `let` with a colon, then "
"the type name. Static items, on the other hand, always require a type "
"annotation."
msgstr ""
"Rust は、ほぼすべてのローカル変数の型を推論してくれますが、コロンの後に続けて"
"型名を書くことで、明示的に変数の型を指定することもできます。一方、静的な項目 "
"(static item) には、常に型注釈を指定しなければなりません。"

#. type: Plain text
#: src/doc/tutorial.md:233
msgid ""
"~~~~ static MONSTER_FACTOR: f64 = 57.8; let monster_size = MONSTER_FACTOR * "
"10.0; let monster_size: int = 50; ~~~~"
msgstr ""
"~~~~\n"
"static MONSTER_FACTOR: f64 = 57.8;\n"
"let monster_size = MONSTER_FACTOR * 10.0;\n"
"let monster_size: int = 50;\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:242
msgid ""
"Local variables may shadow earlier declarations, as in the previous example: "
"`monster_size` was first declared as a `f64`, and then a second "
"`monster_size` was declared as an `int`. If you were to actually compile "
"this example, though, the compiler would determine that the first "
"`monster_size` is unused and issue a warning (because this situation is "
"likely to indicate a programmer error). For occasions where unused variables "
"are intentional, their names may be prefixed with an underscore to silence "
"the warning, like `let _monster_size = 50;`."
msgstr ""
"ローカル変数は、先行する宣言を隠すことがあります。先の例では、1つ目の "
"`monster_size` は `f64` として宣言され、2つ目の `monster_size` は `int` とし"
"て宣言されています。このプログラムをコンパイルした場合、「1つ目の "
"`monster_size` は未使用である」という警告メッセージが出力されます (プログラマ"
"が何らかの誤りを犯している可能性があるため)。未使用変数の存在が意図的なもので"
"あった場合、未使用変数名の先頭にアンダースコアをつけることで、警告を抑制でき"
"ます (`let _monster_size = 50;`)。"

#. type: Plain text
#: src/doc/tutorial.md:248
msgid ""
"Rust identifiers start with an alphabetic character or an underscore, and "
"after that may contain any sequence of alphabetic characters, numbers, or "
"underscores. The preferred style is to write function, variable, and module "
"names with lowercase letters, using underscores where they help readability, "
"while writing types in camel case."
msgstr ""
"Rust の識別子 (identifier) は、アルファベット、数字、またはアンダースコア "
"(`_`) から構成されますが、先頭の文字は数字以外でなければなりません。関数名、"
"変数名、モジュール名はスネークケース (アルファベットは小文字にし、単語間をア"
"ンダースコアで区切る) にし、型の名前はアッパーキャメルケースにすることが推奨"
"されています。"

#. type: Plain text
#: src/doc/tutorial.md:253
#, no-wrap
msgid ""
"~~~\n"
"let my_variable = 100;\n"
"type MyType = int;     // primitive types are _not_ camel case\n"
"~~~\n"
msgstr ""
"~~~\n"
"let my_variable = 100;\n"
"type MyType = int;     // プリミティブ型はキャメルケース __ではない__\n"
"~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:255
msgid "## Expressions and semicolons"
msgstr "## 式とセミコロン"

#. type: Plain text
#: src/doc/tutorial.md:261
msgid ""
"Though it isn't apparent in all code, there is a fundamental difference "
"between Rust's syntax and predecessors like C.  Many constructs that are "
"statements in C are expressions in Rust, allowing code to be more concise. "
"For example, you might write a piece of code like this:"
msgstr ""
"コードの見た目から明らかではないのですが、Rust の構文と、C 等の先行言語の構文"
"との間の根本的な違いがとして、C ではステートメントとして扱われる多くの構文要"
"素が、Rust では式として扱われるという点があります。Rust のこの特徴により、"
"コードをより簡潔に書くことができるようになります。例えば、C 系言語では以下の"
"ようにコードを書きますが、"

#. type: Plain text
#: src/doc/tutorial.md:275
msgid "But, in Rust, you don't have to repeat the name `price`:"
msgstr "Rust では、変数名 `price` を繰り返し書く必要はありません。"

#. type: Plain text
#: src/doc/tutorial.md:293
msgid ""
"Both pieces of code are exactly equivalent: they assign a value to `price` "
"depending on the condition that holds. Note that there are no semicolons in "
"the blocks of the second snippet. This is important: the lack of a semicolon "
"after the last statement in a braced block gives the whole block the value "
"of that last expression."
msgstr ""
"どちらのコードも、全く等価です。`price` には、条件 (この場合は `item` の値) "
"に対応した値が代入されます。2つ目のコード例では、ブロックの中にセミコロンが書"
"かれていないことに注意してください。ブロック内の最後のステートメントの後にセ"
"ミコロンがない場合、**ブロック全体の値 (ブロックを式として評価した際の値) は"
"最後の式の値になります**。"

#. type: Plain text
#: src/doc/tutorial.md:299
msgid ""
"Put another way, the semicolon in Rust *ignores the value of an "
"expression*.  Thus, if the branches of the `if` had looked like `{ 4; }`, "
"the above example would simply assign `()` (nil or void) to `price`. But "
"without the semicolon, each branch has a different value, and `price` gets "
"the value of the branch that was taken."
msgstr ""
"言い換えると、Rust では、セミコロンにより **式の値が無視されます。** したがっ"
"て、上記の例で `if` のすべての節 (branch) が `{ 4; }` のように書かれていたと"
"したら、`price` には単に `()` (nil または void の意) が代入されます。しかし、"
"式にセミコロンが付けられていない場合、各節はそれぞれ異なる値を持ち、 `price` "
"には節のうち実行されたものの値が代入されます。"

#. type: Plain text
#: src/doc/tutorial.md:304
msgid ""
"In short, everything that's not a declaration (declarations are `let` for "
"variables; `fn` for functions; and any top-level named items such as [traits]"
"(#traits), [enum types](#enums), and static items) is an expression, "
"including function bodies."
msgstr ""
"まとめると、宣言 (変数の `let`, 関数の `fn`, [トレイト](#トレイト) や [列挙"
"型](#列挙型)、静的な項目などの、トップレベルで名前を持つ項目) でないものは、"
"すべてが式となります。関数のボディ部も式です。"

#. type: Plain text
#: src/doc/tutorial.md:312
#, no-wrap
msgid ""
"~~~~\n"
"fn is_four(x: int) -> bool {\n"
"   // No need for a return statement. The result of the expression\n"
"   // is used as the return value.\n"
"   x == 4\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"fn is_four(x: int) -> bool {\n"
"   // return ステートメントは省略可能。最後の式の値が戻り値となる。\n"
"   x == 4\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:314
msgid "## Primitive types and literals"
msgstr "## プリミティブ型とリテラル"

#. type: Plain text
#: src/doc/tutorial.md:321
msgid ""
"There are general signed and unsigned integer types, `int` and `uint`, as "
"well as 8-, 16-, 32-, and 64-bit variants, `i8`, `u16`, etc.  Integers can "
"be written in decimal (`144`), hexadecimal (`0x90`), octal (`0o70`), or "
"binary (`0b10010000`) base. Each integral type has a corresponding literal "
"suffix that can be used to indicate the type of a literal: `i` for `int`, "
"`u` for `uint`, `i8` for the `i8` type."
msgstr ""
"Rust には、他の言語と同様、符号付き整数の `int` と、符号なし整数の `uint` が"
"あります。同様に、8 または 16, 32, 64 ビット幅の `i8`, `u16` などもあります。"
"整数リテラルは、10進数 (`144`)、16進数 (`0x90`)、または2進数 (`0b10010000`) "
"の表記が可能です。整数リテラルの型を表すための、各整数型に対応したサフィック"
"スがあります。例えば、`i` は `int` 型、`u` は `uint` 型、`i8` は `i8` 型に対"
"応します。"

#. type: Plain text
#: src/doc/tutorial.md:327
msgid ""
"In the absence of an integer literal suffix, Rust will infer the integer "
"type based on type annotations and function signatures in the surrounding "
"program. In the absence of any type information at all, Rust will assume "
"that an unsuffixed integer literal has type `int`."
msgstr ""
"サフィックスが省略されている整数リテラルの型は、周囲にある型アノテーションや"
"関数のシグネチャから推論されます。型について一切情報が得られない場合、サ"
"フィックスなしの整数リテラルは `int` 型だとみなされます。"

#. type: Plain text
#: src/doc/tutorial.md:334
#, fuzzy, no-wrap
#| msgid ""
#| "~~~~\n"
#| "let a = 1;       // a is an int\n"
#| "let b = 10i;     // b is an int, due to the 'i' suffix\n"
#| "let c = 100u;    // c is a uint\n"
#| "let d = 1000i32; // d is an i32\n"
#| "~~~~\n"
msgid ""
"~~~~\n"
"let a = 1;       // `a` is an `int`\n"
"let b = 10i;     // `b` is an `int`, due to the `i` suffix\n"
"let c = 100u;    // `c` is a `uint`\n"
"let d = 1000i32; // `d` is an `i32`\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"let a = 1;       // a は int\n"
"let b = 10i;     // b は int (サフィックス 'i' がある)\n"
"let c = 100u;    // c は uint\n"
"let d = 1000i32; // d は i32\n"
"~~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:339
#, fuzzy
#| msgid ""
#| "There are two floating-point types: `f32`, and `f64`. Floating-point "
#| "numbers are written `0.0`, `1e6`, or `2.1e-4`. Like integers, floating-"
#| "point literals are inferred to the correct type. Suffixes `f32`, and "
#| "`f64` can be used to create literals of a specific type."
msgid ""
"There are two floating-point types: `f32`, and `f64`.  Floating-point "
"numbers are written `0.0`, `1e6`, or `2.1e-4`.  Like integers, floating-"
"point literals are inferred to the correct type.  Suffixes `f32`, and `f64` "
"can be used to create literals of a specific type."
msgstr ""
"浮動小数型は、 `f32`, `f64` の2種類があります。浮動小数リテラルは `0.0` や、 "
"`1e6`、 `2.1e-4` といった表記が可能です。整数と同じく、サフィックスが省略され"
"た浮動小数リテラルは型推論されます。浮動小数のサフィックスは `f32`、`f64` の3"
"種類で、リテラルの末尾につけることで、対応する型の値を作り出すことができま"
"す。"

#. type: Plain text
#: src/doc/tutorial.md:341
msgid "The keywords `true` and `false` produce literals of type `bool`."
msgstr "`true` キーワードと `false` キーワードは、`bool` 型のリテラルです。"

#. type: Plain text
#: src/doc/tutorial.md:348
#, fuzzy
#| msgid ""
#| "Characters, the `char` type, are four-byte Unicode codepoints, whose "
#| "literals are written between single quotes, as in `'x'`.  Just like C, "
#| "Rust understands a number of character escapes, using the backslash "
#| "character, such as `\\n`, `\\r`, and `\\t`. String literals, written "
#| "between double quotes, allow the same escape sequences.  More on strings "
#| "[later](#vectors-and-strings)."
msgid ""
"Characters, the `char` type, are four-byte Unicode codepoints, whose "
"literals are written between single quotes, as in `'x'`.  Just like C, Rust "
"understands a number of character escapes, using the backslash character, "
"such as `\\n`, `\\r`, and `\\t`. String literals, written between double "
"quotes, allow the same escape sequences, and do no other processing, unlike "
"languages such as PHP or shell."
msgstr ""
"文字は `char` 型で表され、4バイトの Unicode コードポイントに対応しています。"
"`'x'` のように、文字をシングルクオートで囲んだものが文字リテラルです。C と同"
"様、 Rust もバックスラッシュを使ったエスケープシーケンス (`\\n`, `\\r`, `"
"\\t`) に対応しています。文字列リテラル (複数の文字をダブルクオートで囲ったも"
"の) も同じエスケープシーケンスに対応しています。詳細は [ベクタと文字列](#ベク"
"タと文字列) の章で述べます。"

#. type: Plain text
#: src/doc/tutorial.md:356
msgid "The nil type, written `()`, has a single value, also written `()`."
msgstr ""
"nil 型は `()` と表記されます。 nil 型の唯一の値も `()` と表記されます。"

#. type: Plain text
#: src/doc/tutorial.md:358
msgid "## Operators"
msgstr "## 演算子"

#. type: Plain text
#: src/doc/tutorial.md:363
msgid ""
"Rust's set of operators contains very few surprises. Arithmetic is done with "
"`*`, `/`, `%`, `+`, and `-` (multiply, quotient, remainder, add, and "
"subtract). `-` is also a unary prefix operator that negates numbers. As in "
"C, the bitwise operators `>>`, `<<`, `&`, `|`, and `^` are also supported."
msgstr ""
"Rust の演算子には、あまり変わったものはありません。算術演算子は `*` (乗算)、 "
"`/` (除算), `%` (剰余), `+` (加算), `-` (減算) です。`-` は数の符号を反転する"
"単行演算子でもあります。C と同様、ビット演算子 `>>`, `<<`, `&`, `|`, `^` もサ"
"ポートされています。"

#. type: Plain text
#: src/doc/tutorial.md:366
#, fuzzy
#| msgid ""
#| "Note that, if applied to an integer value, `!` flips all the bits (like "
#| "`~` in C)."
msgid ""
"Note that, if applied to an integer value, `!` flips all the bits (bitwise "
"NOT, like `~` in C)."
msgstr ""
"整数型に対して `!` 演算子を適用すると、ビット単位での反転操作 (C の `~` と同"
"じ動作) が行われることに注意してください。"

#. type: Plain text
#: src/doc/tutorial.md:370
msgid ""
"The comparison operators are the traditional `==`, `!=`, `<`, `>`, `<=`, and "
"`>=`. Short-circuiting (lazy) boolean operators are written `&&` (and) and "
"`||` (or)."
msgstr ""
"比較演算子は、従来の言語と同じく、`==`, `!=`, `<`, `>`, `<=`, `>=` です。短絡"
"評価 (遅延評価) されるブール演算子は、 `&&` (and 演算) と `||` (or 演算) があ"
"ります。"

#. type: Plain text
#: src/doc/tutorial.md:377
#, fuzzy
#| msgid ""
#| "For type casting, Rust uses the binary `as` operator.  It takes an "
#| "expression on the left side and a type on the right side and will, if a "
#| "meaningful conversion exists, convert the result of the expression to the "
#| "given type."
msgid ""
"For compile-time type casting, Rust uses the binary `as` operator.  It takes "
"an expression on the left side and a type on the right side and will, if a "
"meaningful conversion exists, convert the result of the expression to the "
"given type. Generally, `as` is only used with the primitive numeric types or "
"pointers, and is not overloadable.  [`transmute`][transmute] can be used for "
"unsafe C-like casting of same-sized types."
msgstr ""
"Rust では、型のキャストには二項演算子 `as` を使います。`as` 演算子は、左辺に"
"式、右辺に型を取り、意味のある変換が可能な場合に限り、式の評価結果を指定され"
"た型に変換します。"

#. type: Plain text
#: src/doc/tutorial.md:383
msgid "~~~~ let x: f64 = 4.0; let y: uint = x as uint; assert!(y == 4u); ~~~~"
msgstr ""
"~~~~\n"
"let x: f64 = 4.0;\n"
"let y: uint = x as uint;\n"
"assert!(y == 4u);\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:385
#, fuzzy
#| msgid ""
#| "[tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz [win-exe]: "
#| "http://static.rust-lang.org/dist/rust-nightly-install.exe"
msgid ""
"[transmute]: http://static.rust-lang.org/doc/master/std/cast/fn.transmute."
"html"
msgstr ""
"[tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz\n"
"[win-exe]: http://static.rust-lang.org/dist/rust-nightly-install.exe"

#. type: Plain text
#: src/doc/tutorial.md:387
msgid "## Syntax extensions"
msgstr "## 構文拡張"

#. type: Plain text
#: src/doc/tutorial.md:395
#, fuzzy, no-wrap
#| msgid ""
#| "*Syntax extensions* are special forms that are not built into the language,\n"
#| "but are instead provided by the libraries. To make it clear to the reader when\n"
#| "a name refers to a syntax extension, the names of all syntax extensions end\n"
#| "with `!`. The standard library defines a few syntax extensions, the most\n"
#| "useful of which is `fmt!`, a `sprintf`-style text formatter that you will\n"
#| "often see in examples.\n"
msgid ""
"*Syntax extensions* are special forms that are not built into the language,\n"
"but are instead provided by the libraries. To make it clear to the reader when\n"
"a name refers to a syntax extension, the names of all syntax extensions end\n"
"with `!`. The standard library defines a few syntax extensions, the most\n"
"useful of which is [`format!`][fmt], a `sprintf`-like text formatter that you\n"
"will often see in examples, and its related family of macros: `print!`,\n"
"`println!`, and `write!`.\n"
msgstr "**構文拡張** *(Syntax extensions)* は言語組み込みではなく、ライブラリにより提供される特殊形式 (スペシャルフォーム) です。プログラム中に構文拡張が登場したことを外見上明確にするため、構文拡張の名前には末尾に `!` をつけますなければなりません。標準ライブラリではいくつかの構文拡張が定義されていますが、その中でも最も有用なのは `fmt!` です。`fmt!` は `sprintf`スタイルの書式整形を行うもので、後のコード例の中でも何度か見かけることになるでしょう。\n"

#. type: Plain text
#: src/doc/tutorial.md:399
#, fuzzy
#| msgid ""
#| "`fmt!` supports most of the directives that [printf][pf] supports, but "
#| "unlike printf, will give you a compile-time error when the types of the "
#| "directives don't match the types of the arguments."
msgid ""
"`format!` draws syntax from Python, but contains many of the same principles "
"that [printf][pf] has. Unlike printf, `format!` will give you a compile-time "
"error when the types of the directives don't match the types of the "
"arguments."
msgstr ""
"`fmt!` は、[`printf`][pf] がサポートするほとんどのディレクティブ (フォーマッ"
"ト指定子) をサポートしますが、`printf` とは異なり、ディレクティブと引数の型が"
"一致しない場合はコンパイルエラーとなります。"

#. type: Plain text
#: src/doc/tutorial.md:402
msgid "~~~~ # let mystery_object = ();"
msgstr ""
"~~~~\n"
"# let mystery_object = ();"

#. type: Plain text
#: src/doc/tutorial.md:409
#, fuzzy
#| msgid ""
#| "// %? will conveniently print any type println(fmt!(\"what is this thing: "
#| "%?\", mystery_object)); ~~~~"
msgid ""
"// `{:?}` will conveniently print any type println!(\"what is this thing: "
"{:?}\", mystery_object); ~~~~"
msgstr ""
"// %? は任意の型を表示できる便利なディレクティブです\n"
"println(fmt!(\"what is this thing: %?\", mystery_object));\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:412
#, fuzzy
#| msgid ""
#| "[tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz [win-exe]: "
#| "http://static.rust-lang.org/dist/rust-nightly-install.exe"
msgid ""
"[pf]: http://en.cppreference.com/w/cpp/io/c/fprintf [fmt]: http://static."
"rust-lang.org/doc/master/std/fmt/index.html"
msgstr ""
"[tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz\n"
"[win-exe]: http://static.rust-lang.org/dist/rust-nightly-install.exe"

#. type: Plain text
#: src/doc/tutorial.md:416
#, fuzzy
#| msgid ""
#| "You can define your own syntax extensions with the macro system. For "
#| "details, see the [macro tutorial][macros]."
msgid ""
"You can define your own syntax extensions with the macro system. For "
"details, see the [macro tutorial][macros]. Note that macro definition is "
"currently considered an unstable feature."
msgstr ""
"マクロシステムを利用すれば、独自に構文拡張を定義することも可能です。詳細は "
"[マクロチュートリアル][macros] を参照してください。"

#. type: Plain text
#: src/doc/tutorial.md:418
msgid "# Control structures"
msgstr "# 制御構造"

#. type: Plain text
#: src/doc/tutorial.md:420
msgid "## Conditionals"
msgstr "## 条件式"

#. type: Plain text
#: src/doc/tutorial.md:424
msgid ""
"We've seen `if` expressions a few times already. To recap, braces are "
"compulsory, an `if` can have an optional `else` clause, and multiple `if`/"
"`else` constructs can be chained together:"
msgstr ""
"`if` 式は既に何度か登場しています。これまでの説明の要点をまとめると、波括弧は"
"省略不可であり、`if` 式には省略可能な `else` 句があり、複数個の `if`/`else` "
"構文は互いに連鎖できる、ということでした。"

#. type: Plain text
#: src/doc/tutorial.md:439
msgid ""
"The condition given to an `if` construct *must* be of type `bool` (no "
"implicit conversion happens). If the arms are blocks that have a value, this "
"value must be of the same type for every arm in which control reaches the "
"end of the block:"
msgstr ""
"`if` 構文の条件式は `bool` 型ででなければなりません (暗黙的な型変換は行われま"
"せん)。同一の `if` 構文に属する arm のうち、制御がブロックの末尾まで到達し得"
"るものは、すべて同じ型の値でなければなりません。"

#. type: Plain text
#: src/doc/tutorial.md:447
#, fuzzy, no-wrap
#| msgid "~~~~ fn line(a: int, b: int, x: int) -> int { a * x + b } fn oops(a: int, b: int, x: int) -> ()  { a * x + b; }"
msgid ""
"~~~~\n"
"fn signum(x: int) -> int {\n"
"    if x < 0 { -1 }\n"
"    else if x > 0 { 1 }\n"
"    else { 0 }\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"fn line(a: int, b: int, x: int) -> int { a * x + b }\n"
"fn oops(a: int, b: int, x: int) -> ()  { a * x + b; }"

#. type: Plain text
#: src/doc/tutorial.md:449
msgid "## Pattern matching"
msgstr "## パターンマッチ"

#. type: Plain text
#: src/doc/tutorial.md:455
msgid ""
"Rust's `match` construct is a generalized, cleaned-up version of C's "
"`switch` construct. You provide it with a value and a number of *arms*, each "
"labelled with a pattern, and the code compares the value against each "
"pattern in order until one matches. The matching pattern executes its "
"corresponding arm."
msgstr ""
"Rust の `match` 構文は、C の `switch` 構文を整理・一般化したものです。"
"`match` 構文は、パターンマッチの対象となる値と、いくつかの、 **arm**  (**訳"
"注:** 分岐条件と、条件を満たした場合に実行される式の組のこと。`match` の場合"
"はパターンと式の組) から構成されます。`match` 構文では、指定された値とパター"
"ンの比較をコード内で記述された順番通りに行います。比較の結果、値とパターンが"
"マッチした場合、対応する式が実行されます。マッチしたパターンの後に現れるパ"
"ターンとの比較は行われません。"

#. type: Plain text
#: src/doc/tutorial.md:469
msgid ""
"Unlike in C, there is no \"falling through\" between arms: only one arm "
"executes, and it doesn't have to explicitly `break` out of the construct "
"when it is finished."
msgstr ""
"C とは異なり、Rust では arm 間での「フォールスルー」はないため、1つの arm の"
"みが実行されます。 そのため、 `match` 構文から抜ける箇所を `break` により明示"
"する必要はありません。"

#. type: Plain text
#: src/doc/tutorial.md:478
#, fuzzy
#| msgid ""
#| "A `match` arm consists of a *pattern*, then an arrow `=>`, followed by an "
#| "*action* (expression). Literals are valid patterns and match only their "
#| "own value. A single arm may match multiple different patterns by "
#| "combining them with the pipe operator (`|`), so long as every pattern "
#| "binds the same set of variables. Ranges of numeric literal patterns can "
#| "be expressed with two dots, as in `M..N`. The underscore (`_`) is a "
#| "wildcard pattern that matches any single value. The asterisk (`*`)  is a "
#| "different wildcard that can match one or more fields in an `enum` variant."
msgid ""
"A `match` arm consists of a *pattern*, then an arrow `=>`, followed by an "
"*action* (expression). Literals are valid patterns and match only their own "
"value. A single arm may match multiple different patterns by combining them "
"with the pipe operator (`|`), so long as every pattern binds the same set of "
"variables. Ranges of numeric literal patterns can be expressed with two "
"dots, as in `M..N`. The underscore (`_`) is a wildcard pattern that matches "
"any single value. (`..`) is a different wildcard that can match one or more "
"fields in an `enum` variant."
msgstr ""
"`match` の arm は、 **パターン** および矢印 `=>` と、それらに続く **アクショ"
"ン** (式) から構成されます。リテラルはパターンとして利用可能で、リテラル自身"
"の値のみとマッチするパターンを意味します。複数のパターンをパイプ演算子 (`|`) "
"で結合させることで、複数の異なるパターンにマッチする単一の arm を作ることがで"
"きます。ただし、変数の束縛を行うパターンをパイプ演算子で結合する場合は、すべ"
"てのパータンで束縛する変数の名前・数が一致している必要があります (**訳注:** "
"変数の束縛については、本節の後半で説明します)。指定した範囲に含まれる任意の数"
"値にマッチするパターンは、2つのドットで `M..N` のように表記します。アンダース"
"コア (`_`) は任意の値1つにマッチするワイルドカードパターンです。アスタリスク "
"(`*`) は任意の値をもつ、`enum` バリアントの複数のフィールドにマッチする、ワイ"
"ルドカードです (**訳注** `enum` については、[列挙型](#列挙型) の節で説明しま"
"す)。"

#. type: Plain text
#: src/doc/tutorial.md:483
msgid ""
"The patterns in a match arm are followed by a fat arrow, `=>`, then an "
"expression to evaluate. Each case is separated by commas. It's often "
"convenient to use a block expression for each case, in which case the commas "
"are optional."
msgstr ""
"`match` の各 arm はカンマ (`,`) は区切ります。 arm のアクションとしてブロック"
"を記述することも可能で、その場合は arm 末尾のカンマを省略することが可能です。"

#. type: Plain text
#: src/doc/tutorial.md:496
msgid ""
"`match` constructs must be *exhaustive*: they must have an arm covering "
"every possible case. For example, the typechecker would reject the previous "
"example if the arm with the wildcard pattern was omitted."
msgstr ""
"`match` 構文は **網羅的** でなければなりません。すなわち、`match` 対象の値と"
"同じ型を持つ任意の値に対し、少なくとも 1 つ以上のパターンがマッチするだけの "
"arm を含んでいなければなりません。例えば、上記コード例のワイルドカードパター"
"ンの arm を削除した場合、型検査によりコンパイルエラーとされます。"

#. type: Plain text
#: src/doc/tutorial.md:500
msgid ""
"A powerful application of pattern matching is *destructuring*: matching in "
"order to bind names to the contents of data types."
msgstr ""
"パターンマッチの応用として、 **destructuring** という強力な機能があります。構"
"造化代入とは、データ型内部の値を名前に束縛 (bind) することです。"

#. type: Plain text
#: src/doc/tutorial.md:504
msgid ""
"> ***Note:*** The following code makes use of tuples (`(f64, f64)`) which > "
"are explained in section 5.3. For now you can think of tuples as a list of > "
"items."
msgstr ""
"> ***注意:*** 以下のコード例では5.3 節で説明されるタプル (`(f64, f64)`) を"
"使っています。現時点では、タプルは項目のリストのようなものだとみなしてくださ"
"い。"

#. type: Plain text
#: src/doc/tutorial.md:525
#, fuzzy
#| msgid ""
#| "A variable name in a pattern matches any value, *and* binds that name to "
#| "the value of the matched value inside of the arm's action. Thus, `(0f, "
#| "y)` matches any tuple whose first element is zero, and binds `y` to the "
#| "second element. `(x, y)` matches any two-element tuple, and binds both "
#| "elements to variables."
msgid ""
"A variable name in a pattern matches any value, *and* binds that name to the "
"value of the matched value inside of the arm's action. Thus, `(0.0, y)` "
"matches any tuple whose first element is zero, and binds `y` to the second "
"element. `(x, y)` matches any two-element tuple, and binds both elements to "
"variables.  A subpattern can also be bound to a variable, using `variable @ "
"pattern`. For example:"
msgstr ""
"パターン内に登場する変数は、任意の値にマッチ **するだけでなく**、arm のアク"
"ション内ではマッチした値が変数の名前に束縛されます。従って、 `(0f, y)` は1つ"
"目の要素が 0 である任意のタプルにマッチし、 `y` には2つ目の要素の値が束縛され"
"ます。`(x, y)` は任意の2要素のタプルにマッチし、タプルの各要素がそれぞれの変"
"数に束縛されます。"

#. type: Plain text
#: src/doc/tutorial.md:540
msgid ""
"Any `match` arm can have a guard clause (written `if EXPR`), called a "
"*pattern guard*, which is an expression of type `bool` that determines, "
"after the pattern is found to match, whether the arm is taken or not. The "
"variables bound by the pattern are in scope in this guard expression. The "
"first arm in the `angle` example shows an example of a pattern guard."
msgstr ""
"`match` の任意の arm は **パターンガード** と呼ばれる、ガード節 (`if EXPR` と"
"書かれる) を持つことができます。パターンガードは、 `bool` 型の値をもつ式で、"
"値にマッチするパターンが見つかった後に評価され、arm が実行されるかどうかを決"
"定します。パターンにより束縛される変数は、ガード式からも参照可能 (ガード式の"
"スコープに含まれる) です。`angle` 関数の例の最初の arm に、パターンガードの使"
"用例が示されています。"

#. type: Plain text
#: src/doc/tutorial.md:545
msgid ""
"You've already seen simple `let` bindings, but `let` is a little fancier "
"than you've been led to believe. It, too, supports destructuring patterns. "
"For example, you can write this to extract the fields from a tuple, "
"introducing two variables at once: `a` and `b`."
msgstr ""
"`let` は単純な変数束縛だけではなく、パターンによる destructuring をサポートし"
"ています。例えば、タプルからフィールドを抽出し、1度に2つの変数 `a` と `b` を"
"定義することが可能です。"

#. type: Plain text
#: src/doc/tutorial.md:550
msgid ""
"~~~~ # fn get_tuple_of_two_ints() -> (int, int) { (1, 1) } let (a, b) = "
"get_tuple_of_two_ints(); ~~~~"
msgstr ""
"~~~~\n"
"# fn get_tuple_of_two_ints() -> (int, int) { (1, 1) }\n"
"let (a, b) = get_tuple_of_two_ints();\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:554
msgid ""
"Let bindings only work with _irrefutable_ patterns: that is, patterns that "
"can never fail to match. This excludes `let` from matching literals and most "
"`enum` variants."
msgstr ""
"let による変数定義が可能なのは、パターンが __不可反駁__ (iefutable; 必ず値に"
"マッチする) な場合のみです。この制限により、`let` を用いた destructuring で、"
"リテラルやほとんどの `enum` バリアントをパターンとして用いることはできませ"
"ん。"

#. type: Plain text
#: src/doc/tutorial.md:556
msgid "## Loops"
msgstr "## ループ"

#. type: Plain text
#: src/doc/tutorial.md:561
#, fuzzy
#| msgid ""
#| "`while` denotes a loop that iterates as long as its given condition "
#| "(which must have type `bool`) evaluates to `true`. Inside a loop, the "
#| "keyword `break` aborts the loop, and `loop` aborts the current iteration "
#| "and continues with the next."
msgid ""
"`while` denotes a loop that iterates as long as its given condition (which "
"must have type `bool`) evaluates to `true`. Inside a loop, the keyword "
"`break` aborts the loop, and `continue` aborts the current iteration and "
"continues with the next."
msgstr ""
"`while` は、与えられた条件 (`bool` 型の値でなければならない) が `true` と評価"
"されている間、繰り返し実行されるループを表します。`break` キーワードは、ルー"
"プの実行を中断させます。`loop` キーワードは、現在実行中の繰り返し (イテレー"
"ション) を中断し、次の繰り返しを実行します。"

#. type: Plain text
#: src/doc/tutorial.md:570
msgid ""
"`loop` denotes an infinite loop, and is the preferred way of writing `while "
"true`:"
msgstr ""
"`loop` は無限ループを表します。 `while true` と書く代わりに `loop` と書くこと"
"が推奨されています。"

#. type: Plain text
#: src/doc/tutorial.md:582
msgid ""
"This code prints out a weird sequence of numbers and stops as soon as it "
"finds one that can be divided by five."
msgstr "このコードは 5 で割り切れる数値が現れるまで、数値を出力し続けます。"

#. type: Plain text
#: src/doc/tutorial.md:584
msgid "# Data structures"
msgstr "# データ構造"

#. type: Plain text
#: src/doc/tutorial.md:586
msgid "## Structs"
msgstr "## 構造体"

#. type: Plain text
#: src/doc/tutorial.md:591
msgid ""
"Rust struct types must be declared before they are used using the `struct` "
"syntax: `struct Name { field1: T1, field2: T2 [, ...] }`, where `T1`, "
"`T2`, ... denote types. To construct a struct, use the same syntax, but "
"leave off the `struct`: for example: `Point { x: 1.0, y: 2.0 }`."
msgstr ""
"Rust の構造体 (struct) 型を利用するためには、`struct Name { field1: T1, "
"field2: T2 [, ...] }` (`T1`, `T2`, .. は型を意味する) のように、 `struct` 構"
"文を使った型の宣言が必要です。構造体型の値は、`Point { x: 1.0, y: 2.0 }` のよ"
"うに、構造体宣言から `struct` を取り除いたものと同じ構文で作成します。"

#. type: Plain text
#: src/doc/tutorial.md:595
msgid ""
"Structs are quite similar to C structs and are even laid out the same way in "
"memory (so you can read from a Rust struct in C, and vice-versa). Use the "
"dot operator to access struct fields, as in `mypoint.x`."
msgstr ""
"Rust の構造体は C の構造体とよく似ており、メモリ上のレイアウトも C と同じで"
"す (そのため、Rust と C で相互に構造体を読み込むことが可能です)。構造体の"
"フィールドにアクセスするには、 `mypoint.x` のように、ドット演算子を用います。"

#. type: Plain text
#: src/doc/tutorial.md:602
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"~~~~\n"
"struct Point {\n"
"    x: f64,\n"
"    y: f64\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:605
#, fuzzy
#| msgid ""
#| "Inherited mutability means that any field of a struct may be mutable, if "
#| "the struct is in a mutable slot (or a field of a struct in a mutable "
#| "slot, and so forth)."
msgid ""
"Structs have \"inherited mutability\", which means that any field of a "
"struct may be mutable, if the struct is in a mutable slot."
msgstr ""
"継承ミュータビリティ (inherited mutability) とは、構造体自体がミュータブルな"
"スロットに配置されている場合、構造体のすべてのフィールドもミュータブルになる"
"という性質を意味する言葉です (ミュータブルなスロットに配置された構造体の"
"フィールドに配置された構造体のフィールドもまた、ミュータブルになります) 。"

#. type: Plain text
#: src/doc/tutorial.md:609
msgid ""
"With a value (say, `mypoint`) of such a type in a mutable location, you can "
"do `mypoint.y += 1.0`. But in an immutable location, such an assignment to a "
"struct without inherited mutability would result in a type error."
msgstr ""
"ある構造体の値 (仮に `mypoint` とします) がミュータブルな場所に配置された場"
"合、 `mypoint.y += 1.0` というような操作を行うことができます。しかし、構造体"
"がイミュータブルな場所に配置された場合、ミュータビリティは継承されないため、"
"このような代入操作は型エラーとなります。"

#. type: Plain text
#: src/doc/tutorial.md:614
msgid ""
"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point "
"{ x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };"
msgstr ""
"~~~~ {.ignore}\n"
"# struct Point { x: f64, y: f64 }\n"
"let mut mypoint = Point { x: 1.0, y: 1.0 };\n"
"let origin = Point { x: 0.0, y: 0.0 };"

#. type: Plain text
#: src/doc/tutorial.md:618
#, fuzzy
#| msgid ""
#| "mypoint.y += 1.0; // mypoint is mutable, and its fields as well origin.y "
#| "+= 1.0; // ERROR: assigning to immutable field ~~~~"
msgid ""
"mypoint.y += 1.0; // `mypoint` is mutable, and its fields as well origin.y "
"+= 1.0; // ERROR: assigning to immutable field ~~~~"
msgstr ""
"mypoint.y += 1.0;\n"
"// mypoint はミュータブル\n"
"origin.y += 1.0; // ERROR: assigning to immutable field\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:621
msgid ""
"`match` patterns destructure structs. The basic syntax is `Name { fieldname: "
"pattern, ... }`:"
msgstr ""
"`match` のパターンで構造体の destructuring を行うことも可能です。パターン"
"は、 `Name { fieldname: pattern, ... }` という構文を持ちます。"

#. type: Plain text
#: src/doc/tutorial.md:630
#, fuzzy, no-wrap
#| msgid "~~~ # struct Point { x: f64, y: f64 } let point = &@~Point { x: 10f, y: 20f }; println(fmt!(\"%f\", point.x)); ~~~"
msgid ""
"~~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"# let mypoint = Point { x: 0.0, y: 0.0 };\n"
"match mypoint {\n"
"    Point { x: 0.0, y: yy } => println!(\"{}\", yy),\n"
"    Point { x: xx,  y: yy } => println!(\"{} {}\", xx, yy),\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"let point = &@~Point { x: 10f, y: 20f };\n"
"println(fmt!(\"%f\", point.x));\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:637
#, fuzzy
#| msgid ""
#| "In general, the field names of a struct do not have to appear in the same "
#| "order they appear in the type. When you are not interested in all the "
#| "fields of a struct, a struct pattern may end with `, _` (as in `Name "
#| "{ field1, _ }`) to indicate that you're ignoring all other fields.  "
#| "Additionally, struct fields have a shorthand matching form that simply "
#| "reuses the field name as the binding name."
msgid ""
"In general, the field names of a struct do not have to appear in the same "
"order they appear in the type. When you are not interested in all the fields "
"of a struct, a struct pattern may end with `, ..` (as in `Name { field1, .. }"
"`) to indicate that you're ignoring all other fields.  Additionally, struct "
"fields have a shorthand matching form that simply reuses the field name as "
"the binding name."
msgstr ""
"構造体のフィールド名の並び順は、型定義での並び順と同じにする必要はありませ"
"ん。構造体のパターンマッチで、すべてのフィールドについて考える必要がない場合"
"は、`Name { field1, _ }` のように、末尾に `, _` をつけることで、他のすべての"
"フィールドを無視することができます。"

#. type: Plain text
#: src/doc/tutorial.md:645
#, fuzzy, no-wrap
#| msgid "~~~ # struct Point { x: f64, y: f64 } let point = &@~Point { x: 10f, y: 20f }; println(fmt!(\"%f\", point.x)); ~~~"
msgid ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"# let mypoint = Point { x: 0.0, y: 0.0 };\n"
"match mypoint {\n"
"    Point { x, .. } => println!(\"{}\", x),\n"
"}\n"
"~~~\n"
msgstr ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"let point = &@~Point { x: 10f, y: 20f };\n"
"println(fmt!(\"%f\", point.x));\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:647
msgid "## Enums"
msgstr "## 列挙型"

#. type: Plain text
#: src/doc/tutorial.md:650
#, fuzzy
#| msgid ""
#| "Enums are datatypes that have several alternate representations. For "
#| "example, consider the type shown earlier:"
msgid ""
"Enums are datatypes that have several alternate representations. For "
"example, consider the following type:"
msgstr ""
"列挙型 (enum) は、いくつかの代替表現を持つデータ型です。例えば、以下の型につ"
"いて考えます。"

#. type: Plain text
#: src/doc/tutorial.md:664
#, fuzzy
#| msgid ""
#| "A value of this type is either a `Circle`, in which case it contains a "
#| "`Point` struct and a `f64`, or a `Rectangle`, in which case it contains "
#| "two `Point` structs. The run-time representation of such a value includes "
#| "an identifier of the actual form that it holds, much like the \"tagged "
#| "union\" pattern in C, but with better static guarantees."
msgid ""
"A value of this type is either a `Circle`, in which case it contains a "
"`Point` struct and a f64, or a `Rectangle`, in which case it contains two "
"`Point` structs. The run-time representation of such a value includes an "
"identifier of the actual form that it holds, much like the \"tagged union\" "
"pattern in C, but with better static guarantees."
msgstr ""
"この型の値は、`Point` 構造体と `f64` を含む `Circle` か、2つの `Point` 構造体"
"を含む `Rectangle` のどちらかになります。列挙型の値の実行時表現には、値がどの"
"形式をとっているのか示す識別子が含まれます。この表現方法は C の \"タグ付き共"
"用体\" と非常によく似ていますが、Rust の列挙型はコンパイラにより値の正当性が"
"静的に保証されるという点でより良いものとなっています。"

#. type: Plain text
#: src/doc/tutorial.md:670
#, fuzzy
#| msgid ""
#| "The above declaration will define a type `Shape` that can refer to such "
#| "shapes, and two functions, `Circle` and `Rectangle`, which can be used to "
#| "construct values of the type (taking arguments of the specified types). "
#| "So `Circle(Point { x: 0f, y: 0f }, 10f)` is the way to create a new "
#| "circle."
msgid ""
"The above declaration will define a type `Shape` that can refer to such "
"shapes, and two functions, `Circle` and `Rectangle`, which can be used to "
"construct values of the type (taking arguments of the specified types). So "
"`Circle(Point { x: 0.0, y: 0.0 }, 10.0)` is the way to create a new circle."
msgstr ""
"上記の宣言は `Shape` 型と `Circle` と `Rectangle` という2つの関数も同時に定義"
"します。これらの関数により、関数名に対応した `Shape` 型の値を構築することがで"
"きます (引数の型も列挙型宣言時に指定されたものをとります)。例えば、"
"`Circle(Point { x: 0f, y: 0f }, 10f)` という記述により、新しい circle を作る"
"ことができます。"

#. type: Plain text
#: src/doc/tutorial.md:673
msgid ""
"Enum variants need not have parameters. This `enum` declaration, for "
"example, is equivalent to a C enum:"
msgstr ""
"列挙型のバリアントはパラメータを省略することもできます。以下の例の `enum` 宣"
"言は C の列挙型と等価です。"

#. type: Plain text
#: src/doc/tutorial.md:685
msgid ""
"This declaration defines `North`, `East`, `South`, and `West` as constants, "
"all of which have type `Direction`."
msgstr ""
"この宣言は `Direction` 型の定数 `North`, `East`, `South`, `West` を定義しま"
"す。"

#. type: Plain text
#: src/doc/tutorial.md:689
msgid ""
"When an enum is C-like (that is, when none of the variants have parameters), "
"it is possible to explicitly set the discriminator values to a constant "
"value:"
msgstr ""
"列挙型が Cライクな (すべてのバリアントがパラメータを持たない) 場合、各定数の"
"識別値 (discriminator value) を明示的に指定することも可能です。"

#. type: Plain text
#: src/doc/tutorial.md:702
msgid ""
"If an explicit discriminator is not specified for a variant, the value "
"defaults to the value of the previous variant plus one. If the first variant "
"does not have a discriminator, it defaults to 0. For example, the value of "
"`North` is 0, `East` is 1, `South` is 2, and `West` is 3."
msgstr ""
"バリアントの識別値が明に指定されていない場合、1つ前のバリアントの値に1を足し"
"たものが設定されます。また、最初のバリアントの場合は0が設定されます。上記の例"
"で言うと、 `North` は 0、 `East` は 1、 `South` は 2、`West` は3となります。"

#. type: Plain text
#: src/doc/tutorial.md:705
msgid ""
"When an enum is C-like, you can apply the `as` cast operator to convert it "
"to its discriminator value as an `int`."
msgstr ""
"C ライクな列挙型の値は、キャスト演算子 `as` を適用することで、`int` 型の識別"
"値へ変換することができます。"

#. type: Plain text
#: src/doc/tutorial.md:709
msgid ""
"For enum types with multiple variants, destructuring is the only way to get "
"at their contents. All variant constructors can be used as patterns, as in "
"this definition of `area`:"
msgstr ""
"複数のバリアントを持つ列挙型で、列挙型値の内部のデータを取得するには、 "
"destructuring を使う必要があります。以下の `area` 関数の例のように、バリアン"
"トのコンストラクタは、パターンとして用いることもできます。"

#. type: Plain text
#: src/doc/tutorial.md:726
#, fuzzy
#| msgid ""
#| "You can write a lone `_` to ignore an individual field, and can ignore "
#| "all fields of a variant like: `Circle(*)`. As in their introduction form, "
#| "nullary enum patterns are written without parentheses."
msgid ""
"You can write a lone `_` to ignore an individual field, and can ignore all "
"fields of a variant like: `Circle(..)`. As in their introduction form, "
"nullary enum patterns are written without parentheses."
msgstr ""
"パターンマッチの際に、特定のフィールドに対するマッチングが不要な場合、無視し"
"たいフィールドの場所に `_` を書くことで、個々のフィールドを無視することができ"
"ます。また、 `Circle(*)` のように書くことで、すべてのフィールドを無視すること"
"も可能です。引数をとらない列挙型のパターンは、定義時の形式と同様、丸括弧の無"
"い形式で記述します。"

#. type: Plain text
#: src/doc/tutorial.md:741
msgid "Enum variants may also be structs. For example:"
msgstr "以下の例のように、列挙型バリアントを構造体にすることも可能です。"

#. type: Plain text
#: src/doc/tutorial.md:765
msgid "## Tuples"
msgstr "## タプル"

#. type: Plain text
#: src/doc/tutorial.md:770
#, fuzzy
#| msgid ""
#| "Tuples in Rust behave exactly like structs, except that their fields do "
#| "not have names. Thus, you cannot access their fields with dot notation.  "
#| "Tuples can have any arity except for 0 (though you may consider unit, "
#| "`()`, as the empty tuple if you like)."
msgid ""
"Tuples in Rust behave exactly like structs, except that their fields do not "
"have names. Thus, you cannot access their fields with dot notation.  Tuples "
"can have any arity (number of elements) except for 0 (though you may "
"consider unit, `()`, as the empty tuple if you like)."
msgstr ""
"Rust のタプルは、フィールドが名前を持たないという点以外は、構造体と同じように"
"振る舞います。フィールド名が存在しないため、ドット記法を使ってタプルのフィー"
"ルドにアクセスすることはできません。タプルは 1 個以上の要素を持つことができま"
"す (必要ならば、ユニット型 `()` を 0 要素のタプルと見なすことはできます。)"

#. type: Plain text
#: src/doc/tutorial.md:777
#, fuzzy, no-wrap
#| msgid ""
#| "For example:\n"
#| "~~~~\n"
#| "struct MyTup(int, int, f64);\n"
#| "let mytup: MyTup = MyTup(10, 20, 30.0);\n"
#| "match mytup {\n"
#| "  MyTup(a, b, c) => info!(a + b + (c as int))\n"
#| "}\n"
#| "~~~~\n"
msgid ""
"~~~~\n"
"let mytup: (int, int, f64) = (10, 20, 30.0);\n"
"match mytup {\n"
"  (a, b, c) => info!(\"{}\", a + b + (c as int))\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"struct MyTup(int, int, f64);\n"
"let mytup: MyTup = MyTup(10, 20, 30.0);\n"
"match mytup {\n"
"  MyTup(a, b, c) => info!(a + b + (c as int))\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:779
msgid "## Tuple structs"
msgstr "## タプル構造体"

#. type: Plain text
#: src/doc/tutorial.md:784
msgid ""
"Rust also has _tuple structs_, which behave like both structs and tuples, "
"except that, unlike tuples, tuple structs have names (so `Foo(1, 2)` has a "
"different type from `Bar(1, 2)`), and tuple structs' _fields_ do not have "
"names."
msgstr ""
"Rust には __タプル構造体__ と呼ばれる、構造体とタプルの両者の特徴を併せ持つも"
"のが存在します。タプルと異なり、タプル構造体自体は名前を持ちます (従って、"
"`Foo(1, 2)` と `Bar(1, 2)` は異なる型になります。) しかし、タプル構造体の __"
"フィールド__ は名前を持ちません。"

#. type: Plain text
#: src/doc/tutorial.md:794
#, fuzzy, no-wrap
#| msgid ""
#| "For example:\n"
#| "~~~~\n"
#| "struct MyTup(int, int, f64);\n"
#| "let mytup: MyTup = MyTup(10, 20, 30.0);\n"
#| "match mytup {\n"
#| "  MyTup(a, b, c) => info!(a + b + (c as int))\n"
#| "}\n"
#| "~~~~\n"
msgid ""
"~~~~\n"
"struct MyTup(int, int, f64);\n"
"let mytup: MyTup = MyTup(10, 20, 30.0);\n"
"match mytup {\n"
"  MyTup(a, b, c) => info!(\"{}\", a + b + (c as int))\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"struct MyTup(int, int, f64);\n"
"let mytup: MyTup = MyTup(10, 20, 30.0);\n"
"match mytup {\n"
"  MyTup(a, b, c) => info!(a + b + (c as int))\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:801
msgid ""
"There is a special case for tuple structs with a single field, which are "
"sometimes called \"newtypes\" (after Haskell's \"newtype\" feature). These "
"are used to define new types in such a way that the new name is not just a "
"synonym for an existing type but is rather its own distinct type."
msgstr ""
"タプル構造体がフィールドを 1 つしか持たない場合、 \"newtype\" と呼ばれること"
"があります (Haskell の \"newtype\" 機能に由来しています)。 このようなタプル構"
"造体を使うことで、既存の型の別名 (シノニム) となる新しい型を定義することがで"
"きます。この新しい型は、元にした型とは異なった型として扱われます。"

#. type: Plain text
#: src/doc/tutorial.md:805
msgid "~~~~ struct GizmoId(int); ~~~~"
msgstr ""
"~~~~\n"
"struct GizmoId(int);\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:808
#, fuzzy
#| msgid ""
#| "Types like this can be useful to differentiate between data that have the "
#| "same type but must be used in different ways."
msgid ""
"Types like this can be useful to differentiate between data that have the "
"same underlying type but must be used in different ways."
msgstr ""
"このような型は、型は同一でも、それぞれ全く異なる扱い方をしなければならない"
"データを扱う場合に用いると便利です。"

#. type: Plain text
#: src/doc/tutorial.md:813
msgid "~~~~ struct Inches(int); struct Centimeters(int); ~~~~"
msgstr ""
"~~~~\n"
"struct Inches(int);\n"
"struct Centimeters(int);\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:817
#, fuzzy
#| msgid ""
#| "The above definitions allow for a simple way for programs to avoid "
#| "confusing numbers that correspond to different units."
msgid ""
"The above definitions allow for a simple way for programs to avoid confusing "
"numbers that correspond to different units. Their integer values can be "
"extracted with pattern matching:"
msgstr ""
"上記のような単純な定義により、異なる単位を持つ数値を混同することなく扱うこと"
"が可能になります。"

#. type: Plain text
#: src/doc/tutorial.md:820
#, fuzzy
#| msgid "~~~~ struct GizmoId(int); ~~~~"
msgid "~~~ # struct Inches(int);"
msgstr ""
"~~~~\n"
"struct GizmoId(int);\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:827
msgid "# Functions"
msgstr "# 関数"

#. type: Plain text
#: src/doc/tutorial.md:835
#, fuzzy
#| msgid ""
#| "We've already seen several function definitions. Like all other static "
#| "declarations, such as `type`, functions can be declared both at the top "
#| "level and inside other functions (or in modules, which we'll come back to "
#| "[later](#modules-and-crates)). The `fn` keyword introduces a function. A "
#| "function has an argument list, which is a parenthesized list of `expr: "
#| "type` pairs separated by commas. An arrow `->` separates the argument "
#| "list and the function's return type."
msgid ""
"We've already seen several function definitions. Like all other static "
"declarations, such as `type`, functions can be declared both at the top "
"level and inside other functions (or in modules, which we'll come back to "
"[later](#crates-and-the-module-system)). The `fn` keyword introduces a "
"function. A function has an argument list, which is a parenthesized list of "
"`name: type` pairs separated by commas. An arrow `->` separates the argument "
"list and the function's return type."
msgstr ""
"関数定義はこれまでに何度か登場しています。他の静的な宣言 (`type` など)と同様"
"に、関数はトップレベルまたは、他の関数の内部、モジュールの内部で定義すること"
"ができます (モジュールについては、[後述](#モジュールとクレート)します) 。"

#. type: Plain text
#: src/doc/tutorial.md:841
#, fuzzy, no-wrap
#| msgid "~~~~ fn line(a: int, b: int, x: int) -> int { a * x + b } fn oops(a: int, b: int, x: int) -> ()  { a * x + b; }"
msgid ""
"~~~~\n"
"fn line(a: int, b: int, x: int) -> int {\n"
"    return a * x + b;\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"fn line(a: int, b: int, x: int) -> int { a * x + b }\n"
"fn oops(a: int, b: int, x: int) -> ()  { a * x + b; }"

#. type: Plain text
#: src/doc/tutorial.md:846
msgid ""
"The `return` keyword immediately returns from the body of a function. It is "
"optionally followed by an expression to return. A function can also return a "
"value by having its top-level block produce an expression."
msgstr ""
"`return` キーワードにより、呼び出し中の関数を即座に復帰させることができます。"
"`return` の後に式を書くことで、呼び出し元へ戻り値として返すことも可能です。ま"
"た、関数トップレベルのブロックを式と解釈した場合の値 (ブロック内最後の式の"
"値) も関数の戻り値になります。"

#. type: Plain text
#: src/doc/tutorial.md:852
#, fuzzy, no-wrap
#| msgid "~~~~ fn line(a: int, b: int, x: int) -> int { a * x + b } fn oops(a: int, b: int, x: int) -> ()  { a * x + b; }"
msgid ""
"~~~~\n"
"fn line(a: int, b: int, x: int) -> int {\n"
"    a * x + b\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"fn line(a: int, b: int, x: int) -> int { a * x + b }\n"
"fn oops(a: int, b: int, x: int) -> ()  { a * x + b; }"

#. type: Plain text
#: src/doc/tutorial.md:859
msgid ""
"It's better Rust style to write a return value this way instead of writing "
"an explicit `return`. The utility of `return` comes in when returning early "
"from a function. Functions that do not return a value are said to return "
"nil, `()`, and both the return type and the return value may be omitted from "
"the definition. The following two functions are equivalent."
msgstr ""
"Rust では、明示的に `return` を書くのではなく、上記のような方法で戻り値を返す"
"スタイルが推奨されています。 `return` は、関数を途中で復帰させたい場合に使い"
"ます。値を返さない関数は、 nil `()` を返す関数として取り扱われ、関数の戻り値"
"の型や、戻り値を返す処理を省略することが可能です。以下の2つの関数は等価です。"

#. type: Plain text
#: src/doc/tutorial.md:862
msgid "~~~~ fn do_nothing_the_hard_way() -> () { return (); }"
msgstr ""
"~~~~\n"
"fn do_nothing_the_hard_way() -> () { return (); }"

#. type: Plain text
#: src/doc/tutorial.md:865
msgid "fn do_nothing_the_easy_way() { } ~~~~"
msgstr ""
"fn do_nothing_the_easy_way() { }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:867
msgid ""
"Ending the function with a semicolon like so is equivalent to returning `()`."
msgstr "以下のように、セミコロンで終わる関数は `()` を返す関数と等価です。"

#. type: Plain text
#: src/doc/tutorial.md:871
msgid ""
"~~~~ fn line(a: int, b: int, x: int) -> int { a * x + b } fn oops(a: int, b: "
"int, x: int) -> ()  { a * x + b; }"
msgstr ""
"~~~~\n"
"fn line(a: int, b: int, x: int) -> int { a * x + b }\n"
"fn oops(a: int, b: int, x: int) -> ()  { a * x + b; }"

#. type: Plain text
#: src/doc/tutorial.md:875
msgid "assert!(8 == line(5, 3, 1)); assert!(() == oops(5, 3, 1)); ~~~~"
msgstr ""
"assert!(8 == line(5, 3, 1));\n"
"assert!(() == oops(5, 3, 1));\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:879
msgid ""
"As with `match` expressions and `let` bindings, function arguments support "
"pattern destructuring. Like `let`, argument patterns must be irrefutable, as "
"in this example that unpacks the first value from a tuple and returns it."
msgstr ""
"`match` 式や `let` による変数定義のように、関数の引数もパターンによる "
"destructuring をサポートしています。`let` と同様、引数のパターンは 不可反駁 "
"(irrefutable) でなければなりません。以下の例では、タプルの最初の要素を取得"
"し、呼び出し元へ返します。"

#. type: Plain text
#: src/doc/tutorial.md:883
msgid "~~~ fn first((value, _): (int, f64)) -> int { value } ~~~"
msgstr ""
"~~~\n"
"fn first((value, _): (int, f64)) -> int { value }\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:889
msgid ""
"A *destructor* is a function responsible for cleaning up the resources used "
"by an object when it is no longer accessible. Destructors can be defined to "
"handle the release of resources like files, sockets and heap memory."
msgstr ""
"**デストラクタ** はアクセスできなくなったオブジェクトから利用されていたリソー"
"スを解放する役割を持つ関数です。デストラクタはファイルやソケット、ヒープメモ"
"リのようなリソースの解放を処理するために定義することができます。"

#. type: Plain text
#: src/doc/tutorial.md:893
#, fuzzy
#| msgid ""
#| "Objects are never accessible after their destructor has been called, so "
#| "there are no dynamic failures from accessing freed resources. When a task "
#| "fails, the destructors of all objects in the task are called."
msgid ""
"Objects are never accessible after their destructor has been called, so no "
"dynamic failures are possible from accessing freed resources. When a task "
"fails, destructors of all objects in the task are called."
msgstr ""
"オブジェクトは、デストラクタが呼び出された後にアクセス不能になります。そのた"
"め、解放済みリソースへアクセスしたことによる動的なエラーは発生しません。タス"
"クの実行に失敗した場合、タスクに属するすべてのオブジェクトのデストラクタが呼"
"び出されます。"

#. type: Plain text
#: src/doc/tutorial.md:895
msgid ""
"The `~` sigil represents a unique handle for a memory allocation on the heap:"
msgstr ""
"シジル `~` はヒープに獲得されたメモリへのユニークな (唯一の) ハンドルを表しま"
"す。"

#. type: Plain text
#: src/doc/tutorial.md:907
msgid ""
"Rust includes syntax for heap memory allocation in the language since it's "
"commonly used, but the same semantics can be implemented by a type with a "
"custom destructor."
msgstr ""
"Rust はヒープメモリ獲得のための構文を持っています。これは、ヒープメモリ獲得が"
"よく利用されるというのが理由ですが、同じ動作は独自のデストラクタを持つ型によ"
"り実装することが可能です。"

#. type: Plain text
#: src/doc/tutorial.md:909
msgid "# Ownership"
msgstr "# 所有権"

#. type: Plain text
#: src/doc/tutorial.md:914
msgid ""
"Rust formalizes the concept of object ownership to delegate management of an "
"object's lifetime to either a variable or a task-local garbage collector. An "
"object's owner is responsible for managing the lifetime of the object by "
"calling the destructor, and the owner determines whether the object is "
"mutable."
msgstr ""
"Rust は、オブジェクトの寿命の管理を変数またはタスクローカルのガベージコレクタ"
"に委譲するために、オブジェクトの所有権という考え方を取り入れています。オブ"
"ジェクトの所有者はデストラクタを呼び出すことにより、オブジェクトの寿命を管理"
"する責任を負っています。また、所有者はオブジェクトがミュータブルかどうかも判"
"断します。"

#. type: Plain text
#: src/doc/tutorial.md:918
#, fuzzy
#| msgid ""
#| "Ownership is recursive, so mutability is inherited recursively and a "
#| "destructor destroys the contained tree of owned objects. Variables are "
#| "top-level owners and destroy the contained object when they go out of "
#| "scope. A box managed by the garbage collector starts a new ownership "
#| "tree, and the destructor is called when it is collected."
msgid ""
"Ownership is recursive, so mutability is inherited recursively and a "
"destructor destroys the contained tree of owned objects. Variables are top-"
"level owners and destroy the contained object when they go out of scope."
msgstr ""
"所有権は再帰的であるため、ミュータビリティは再帰的に継承され、デストラクタは"
"所有しているオブジェクトの含まれているツリーを破壊します。変数はトップレベル"
"の所有者です。変数の存在しているスコープを抜けるタイミングで、変数は所有して"
"いるオブジェクトを破棄します。ガベージコレクタによって管理されるボックスは、"
"新しい所有権ツリーを生成し、ガベージコレクタによりオブジェクトが回収されると"
"きにデストラクタが呼び出されます。"

#. type: Plain text
#: src/doc/tutorial.md:922
msgid ""
"~~~~ // the struct owns the objects contained in the `x` and `y` fields "
"struct Foo { x: int, y: ~int }"
msgstr ""
"~~~~\n"
"// この構造体はフィールド `x` と `y` に含まれるオブジェクトを所有している\n"
"struct Foo { x: int, y: ~int }"

#. type: Plain text
#: src/doc/tutorial.md:929
#, no-wrap
msgid ""
"{\n"
"    // `a` is the owner of the struct, and thus the owner of the struct's fields\n"
"    let a = Foo { x: 5, y: ~10 };\n"
"}\n"
"// when `a` goes out of scope, the destructor for the `~int` in the struct's\n"
"// field is called\n"
msgstr ""
"{\n"
"    // `a` は構造体の所有者であり、構造体のフィールドの所有者でもある\n"
"    let a = Foo { x: 5, y: ~10 };\n"
"}\n"
"// `a` の含まれているスコープから抜けるとき、 構造体のフィールドの `~int` のデストラクタが呼ばれる\n"

#. type: Plain text
#: src/doc/tutorial.md:934
msgid ""
"// `b` is mutable, and the mutability is inherited by the objects it owns "
"let mut b = Foo { x: 5, y: ~10 }; b.x = 10; ~~~~"
msgstr ""
"// `b` はミュータブルなので、所有しているオブジェクトにもミュターブル性が継承"
"される\n"
"let mut b = Foo { x: 5, y: ~10 };\n"
"b.x = 10;\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:941
#, fuzzy
#| msgid ""
#| "If an object doesn't contain garbage-collected boxes, it consists of a "
#| "single ownership tree and is given the `Owned` trait which allows it to "
#| "be sent between tasks. Custom destructors can only be implemented "
#| "directly on types that are `Owned`, but garbage-collected boxes can still "
#| "*contain* types with custom destructors."
msgid ""
"If an object doesn't contain any non-Send types, it consists of a single "
"ownership tree and is itself given the `Send` trait which allows it to be "
"sent between tasks. Custom destructors can only be implemented directly on "
"types that are `Send`, but non-`Send` types can still *contain* types with "
"custom destructors. Example of types which are not `Send` are [`Gc<T>`][gc] "
"and [`Rc<T>`][rc], the shared-ownership types."
msgstr ""
"オブジェクトにガベージコレクトされるボックスが含まれていない場合、オブジェク"
"トは単一の継承ツリーからの構成され、`Owned` トレイトが付与されます。`Owned` "
"トレイトが付与されたデータは、タスク間を跨いで受け渡すことが可能です。独自の"
"デストラクタは、`Owned` トレイトを満たす型に対して直接実装されなければなりま"
"せんが、ガベージコレクトされるボックスが独自のデストラクタをもつ型を **含む"
"** ことは依然可能です。"

#. type: Plain text
#: src/doc/tutorial.md:944
#, fuzzy
#| msgid ""
#| "[tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz [win-exe]: "
#| "http://static.rust-lang.org/dist/rust-nightly-install.exe"
msgid ""
"[gc]: http://static.rust-lang.org/doc/master/std/gc/struct.Gc.html [rc]: "
"http://static.rust-lang.org/doc/master/std/rc/struct.Rc.html"
msgstr ""
"[tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz\n"
"[win-exe]: http://static.rust-lang.org/dist/rust-nightly-install.exe"

#. type: Plain text
#: src/doc/tutorial.md:946
#, fuzzy
#| msgid "# Introduction"
msgid "# Implementing a linked list"
msgstr "# イントロダクション"

#. type: Plain text
#: src/doc/tutorial.md:973
#, fuzzy
#| msgid "# Boxes"
msgid "## Boxes"
msgstr "# ボックス"

#. type: Plain text
#: src/doc/tutorial.md:986
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"struct Foo {\n"
"    a: u32,\n"
"    b: u32,\n"
"    c: u32,\n"
"    d: u32\n"
"}\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:1047
#, fuzzy
#| msgid "# Move semantics"
msgid "## Move semantics"
msgstr "# ムーブセマンティクス"

#. type: Plain text
#: src/doc/tutorial.md:1091
#, fuzzy
#| msgid ""
#| "~~~~ let x = ~5; let y = x.clone(); // y is a newly allocated box let z = "
#| "x; // no new memory allocated, x can no longer be used ~~~~"
msgid ""
"~~~~ let x = ~5; let y = x.clone(); // `y` is a newly allocated box let z = "
"x; // no new memory allocated, `x` can no longer be used ~~~~"
msgstr ""
"~~~~\n"
"let x = ~5;\n"
"let y = x.clone();\n"
"// y は新しく獲得されるボックス\n"
"let z = x; // 新たなメモリの獲得は行われない。x を使うことはできなくなる\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:1120
msgid ""
"~~~~ let r = ~13; let mut s = r; // box becomes mutable *s += 1; let t = "
"s; // box becomes immutable ~~~~"
msgstr ""
"~~~~\n"
"let r = ~13;\n"
"let mut s = r; // ボックスはミュータブルになる\n"
"*s += 1;\n"
"let t = s; // ボックスはイミュータブルになる\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:1144
#, fuzzy
msgid "## References"
msgstr "# ポインタのデリファレンス"

#. type: Plain text
#: src/doc/tutorial.md:1190
#, fuzzy
#| msgid "## Using other crates"
msgid "## Lists of other types"
msgstr "## 他のクレートの利用"

#. type: Plain text
#: src/doc/tutorial.md:1322
#, fuzzy
#| msgid "## Managed boxes"
msgid "# More on boxes"
msgstr "## マネージドボックス"

#. type: Plain text
#: src/doc/tutorial.md:1353
msgid "~~~~ let x = 5; // immutable let mut y = 5; // mutable y += 2;"
msgstr ""
"~~~~\n"
"let x = 5; // イミュータブル\n"
"let mut y = 5; // ミュータブル\n"
"y += 2;"

#. type: Plain text
#: src/doc/tutorial.md:1358
#, fuzzy
#| msgid ""
#| "let x = ~5; // immutable let mut y = ~5; // mutable *y += 2; // the * "
#| "operator is needed to access the contained value ~~~~"
msgid ""
"let x = ~5; // immutable let mut y = ~5; // mutable *y += 2; // the `*` "
"operator is needed to access the contained value ~~~~"
msgstr ""
"let x = ~5; // イミュータブル\n"
"let mut y = ~5; // ミュータブル\n"
"*y += 2; // ボックスの中身にアクセスするには、 * 演算子が必要\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:1367
#, fuzzy
#| msgid ""
#| "Rust's borrowed pointers are a general purpose reference type. In "
#| "contrast with owned boxes, where the holder of an owned box is the owner "
#| "of the pointed-to memory, borrowed pointers never imply ownership. A "
#| "pointer can be borrowed to any object, and the compiler verifies that it "
#| "cannot outlive the lifetime of the object."
msgid ""
"In contrast with owned boxes, where the holder of an owned box is the owner "
"of the pointed-to memory, references never imply ownership - they are "
"\"borrowed\".  A reference can be borrowed to any object, and the compiler "
"verifies that it cannot outlive the lifetime of the object."
msgstr ""
"Rust の借用ポインタ (borrowed pointer) は汎用的な参照型です。所有ボックスの場"
"合、ボックスの所有者が参照されているメモリの所有者となるのに対して、借用ポイ"
"ンタを所有することがメモリを所有を意味することはありません。ポインタは任意の"
"オブジェクトから借用することが可能で、参照先のオブジェクトよりもポインタが長"
"生きしないことがコンパイラにより保証されます。"

#. type: Plain text
#: src/doc/tutorial.md:1369
msgid "As an example, consider a simple struct type, `Point`:"
msgstr "例として、シンプルな構造体型の `Point` について考えます。"

#. type: Plain text
#: src/doc/tutorial.md:1376
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"~~~\n"
"struct Point {\n"
"    x: f64,\n"
"    y: f64\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:1380
msgid ""
"We can use this simple definition to allocate points in many different ways. "
"For example, in this code, each of these three local variables contains a "
"point, but allocated in a different location:"
msgstr ""
"シンプルな定義ですが、この定義を使って `Point` 型のオブジェクトを様々な方法で"
"割り当てることができます。例えば、このコードの3つのローカル変数は、それぞれ異"
"なった場所に `Point` 型のオブジェクトを割り当てています。"

#. type: Plain text
#: src/doc/tutorial.md:1387
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };"
msgid ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"let on_the_stack : Point  =  Point { x: 3.0, y: 4.0 };\n"
"let managed_box  : @Point = @Point { x: 5.0, y: 1.0 };\n"
"let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };\n"
"~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"# struct Point { x: f64, y: f64 }\n"
"let mut mypoint = Point { x: 1.0, y: 1.0 };\n"
"let origin = Point { x: 0.0, y: 0.0 };"

#. type: Plain text
#: src/doc/tutorial.md:1397
#, fuzzy
#| msgid ""
#| "Suppose we want to write a procedure that computes the distance between "
#| "any two points, no matter where they are stored. For example, we might "
#| "like to compute the distance between `on_the_stack` and `managed_box`, or "
#| "between `managed_box` and `owned_box`. One option is to define a function "
#| "that takes two arguments of type point—that is, it takes the points by "
#| "value. But this will cause the points to be copied when we call the "
#| "function. For points, this is probably not so bad, but often copies are "
#| "expensive. So we’d like to define a function that takes the points by "
#| "pointer. We can use borrowed pointers to do this:"
msgid ""
"Suppose we want to write a procedure that computes the distance between any "
"two points, no matter where they are stored. For example, we might like to "
"compute the distance between `on_the_stack` and `managed_box`, or between "
"`managed_box` and `owned_box`. One option is to define a function that takes "
"two arguments of type point—that is, it takes the points by value. But this "
"will cause the points to be copied when we call the function. For points, "
"this is probably not so bad, but often copies are expensive. So we’d like to "
"define a function that takes the points by pointer. We can use references to "
"do this:"
msgstr ""
"`Point` 型のオブジェクトの割り当て先がどこであったとしても利用可能な、任意の "
"2 点間の距離を計算する処理を書きたいとします。例えば、 `on_the_stack`, "
"`managed_box` 間や `managed_box`, `owned_box` 間の距離を計算する処理です。 1"
"つ目の実装方法として、2つの `Point` 型オブジェクトを引数にとる関数を定義する"
"方法、すなわち、オブジェクトを値で受け渡す方法があります。しかし、この方法で"
"は関数呼び出し時に `Point` オブジェクトのコピーが行われます。`Point` オブジェ"
"クトの場合、このような実装はそれほど悪いものではないでしょうが、コピー処理の"
"コストは高い場合もあります。したがって、`Point` オブジェクトをポインタ渡しす"
"る関数を定義する必要があります。そのために、借用ポインタを利用することが可能"
"です。"

#. type: Plain text
#: src/doc/tutorial.md:1419
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };"
msgid ""
"~~~\n"
"# struct Point{ x: f64, y: f64 };\n"
"# let on_the_stack : Point  =  Point { x: 3.0, y: 4.0 };\n"
"# let managed_box  : @Point = @Point { x: 5.0, y: 1.0 };\n"
"# let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };\n"
"# fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n"
"compute_distance(&on_the_stack, managed_box);\n"
"compute_distance(managed_box, owned_box);\n"
"~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"# struct Point { x: f64, y: f64 }\n"
"let mut mypoint = Point { x: 1.0, y: 1.0 };\n"
"let origin = Point { x: 0.0, y: 0.0 };"

#. type: Plain text
#: src/doc/tutorial.md:1426
#, fuzzy
#| msgid ""
#| "Here the `&` operator is used to take the address of the variable "
#| "`on_the_stack`; this is because `on_the_stack` has the type `Point` (that "
#| "is, a struct value) and we have to take its address to get a value. We "
#| "also call this _borrowing_ the local variable `on_the_stack`, because we "
#| "are creating an alias: that is, another route to the same data."
msgid ""
"Here the `&` operator is used to take the address of the variable "
"`on_the_stack`; this is because `on_the_stack` has the type `Point` (that "
"is, a struct value) and we have to take its address to get a reference. We "
"also call this _borrowing_ the local variable `on_the_stack`, because we are "
"creating an alias: that is, another route to the same data."
msgstr ""
"ここで `&` 演算子は `on_the_stack` 変数のアドレスを取得するために使われていま"
"す。これは、 `on_the_stack` の型は `Point` (つまり、構造体の値) であり、呼び"
"出した関数から値を取得させるため、構造体のアドレスを渡す必要があるからです。"
"値の別名 (エイリアス)、すなわち、同じデータへアクセスするための別の方法を提供"
"するので、このような操作のことをローカル変数 `on_the_stack` の __借用__ "
"(_borrowing_) と呼びます。"

#. type: Plain text
#: src/doc/tutorial.md:1432
#, fuzzy
#| msgid ""
#| "In the case of the boxes `managed_box` and `owned_box`, however, no "
#| "explicit action is necessary. The compiler will automatically convert a "
#| "box like `@point` or `~point` to a borrowed pointer like `&point`. This "
#| "is another form of borrowing; in this case, the contents of the managed/"
#| "owned box are being lent out."
msgid ""
"In the case of the boxes `managed_box` and `owned_box`, however, no explicit "
"action is necessary. The compiler will automatically convert a box like "
"`@point` or `~point` to a reference like `&point`. This is another form of "
"borrowing; in this case, the contents of the managed/owned box are being "
"lent out."
msgstr ""
"ボックスである `managed_box` と `owned_box` の場合は、特に明示的な操作を行う"
"必要はありません。コンパイラは `@point` や `~point` のようなボックスを自動的"
"に `&point` のような借用ポインタへと変換します。これは、別の形態の借用 "
"(borrowing) です。この場合、マネージド/所有ボックスの内容が貸し出されていま"
"す。"

#. type: Plain text
#: src/doc/tutorial.md:1441
#, fuzzy
#| msgid ""
#| "Whenever a value is borrowed, there are some limitations on what you can "
#| "do with the original. For example, if the contents of a variable have "
#| "been lent out, you cannot send that variable to another task, nor will "
#| "you be permitted to take actions that might cause the borrowed value to "
#| "be freed or to change its type. This rule should make intuitive sense: "
#| "you must wait for a borrowed value to be returned (that is, for the "
#| "borrowed pointer to go out of scope) before you can make full use of it "
#| "again."
msgid ""
"Whenever a value is borrowed, there are some limitations on what you can do "
"with the original. For example, if the contents of a variable have been lent "
"out, you cannot send that variable to another task, nor will you be "
"permitted to take actions that might cause the borrowed value to be freed or "
"to change its type. This rule should make intuitive sense: you must wait for "
"a borrowed value to be returned (that is, for the reference to go out of "
"scope) before you can make full use of it again."
msgstr ""
"値が借用されている間、借用元の値に対して行える操作がいくらか制限されます。例"
"えば、変数の内容が貸し出された場合、その変数を他のタスクに送信することはでき"
"ませんし、借用された値を解放したり、型が変化させるような操作も行うことができ"
"ません。このルールは理にかなったものでしょう。貸し出した値を最大限に活用する "
"(make full use of it) ためには、貸し出した値の返却 (借用ポインタが存在するス"
"コープを抜ける) を待たなければなりません。"

#. type: Plain text
#: src/doc/tutorial.md:1444
#, fuzzy
#| msgid ""
#| "For a more in-depth explanation of borrowed pointers, read the [borrowed "
#| "pointer tutorial][borrowtut]."
msgid ""
"For a more in-depth explanation of references and lifetimes, read the "
"[references and lifetimes guide][lifetimes]."
msgstr ""
"借用ポインタの詳細については、[借用ポインタのチュートリアル][borrowtut]を参照"
"してください。"

#. type: Plain text
#: src/doc/tutorial.md:1446
msgid "## Freezing"
msgstr "## 凍結"

#. type: Plain text
#: src/doc/tutorial.md:1450
#, fuzzy
#| msgid ""
#| "Borrowing an immutable pointer to an object freezes it and prevents "
#| "mutation.  `Owned` objects have freezing enforced statically at compile-"
#| "time."
msgid ""
"Lending an immutable pointer to an object freezes it and prevents mutation.  "
"`Freeze` objects have freezing enforced statically at compile-time. An "
"example of a non-`Freeze` type is [`RefCell<T>`][refcell]."
msgstr ""
"オブジェクトへのイミュータブルな (借用) ポインタを借用した場合、借用されたオ"
"ブジェクトは凍結 (freezing) され、変更することができなくなります。`Owned` ト"
"レイトが付与されたオブジェクトは、コンパイル時の静的解析により、強制的に凍結"
"されます (凍結された値を変更しようとすると、コンパイルエラーとなります)。"

#. type: Plain text
#: src/doc/tutorial.md:1459
#, fuzzy, no-wrap
#| msgid ""
#| "~~~~\n"
#| "let mut x = 5;\n"
#| "{\n"
#| "    let y = &x; // x is now frozen, it cannot be modified\n"
#| "}\n"
#| "// x is now unfrozen again\n"
#| "# x = 3;\n"
#| "~~~~\n"
msgid ""
"~~~~\n"
"let mut x = 5;\n"
"{\n"
"    let y = &x; // `x` is now frozen, it cannot be modified\n"
"}\n"
"// `x` is now unfrozen again\n"
"# x = 3;\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"let mut x = 5;\n"
"{\n"
"    let y = &x; // x は凍結されたので、変更することができない\n"
"}\n"
"// x の凍結状態は解除される\n"
"# x = 3;\n"
"~~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:1461
#, fuzzy
#| msgid ""
#| "[tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz [win-exe]: "
#| "http://static.rust-lang.org/dist/rust-nightly-install.exe"
msgid ""
"[refcell]: http://static.rust-lang.org/doc/master/std/cell/struct.RefCell."
"html"
msgstr ""
"[tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz\n"
"[win-exe]: http://static.rust-lang.org/dist/rust-nightly-install.exe"

#. type: Plain text
#: src/doc/tutorial.md:1463
msgid "# Dereferencing pointers"
msgstr "# ポインタのデリファレンス"

#. type: Plain text
#: src/doc/tutorial.md:1466
msgid ""
"Rust uses the unary star operator (`*`) to access the contents of a box or "
"pointer, similarly to C."
msgstr ""
"Rust では、C と同様、ボックスの内容やポインタの参照先にアクセスするためには単"
"項スター演算子 (`*`) を使います。"

#. type: Plain text
#: src/doc/tutorial.md:1471
msgid "~~~ let managed = @10; let owned = ~20; let borrowed = &30;"
msgstr ""
"~~~\n"
"let managed = @10;\n"
"let owned = ~20;\n"
"let borrowed = &30;"

#. type: Plain text
#: src/doc/tutorial.md:1474
msgid "let sum = *managed + *owned + *borrowed; ~~~"
msgstr ""
"let sum = *managed + *owned + *borrowed;\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:1478
msgid ""
"Dereferenced mutable pointers may appear on the left hand side of "
"assignments. Such an assignment modifies the value that the pointer points "
"to."
msgstr ""
"ミュータブルなポインタをデリファレンスしたものは、代入文の左辺に置くことがで"
"きます。このような代入文は、ポインタが指す値を変更します。"

#. type: Plain text
#: src/doc/tutorial.md:1482
#, fuzzy
#| msgid "~~~ let managed = @mut 10; let mut owned = ~20;"
msgid "~~~ let managed = @10; let mut owned = ~20;"
msgstr ""
"~~~\n"
"let managed = @mut 10;\n"
"let mut owned = ~20;"

#. type: Plain text
#: src/doc/tutorial.md:1485
msgid "let mut value = 30; let borrowed = &mut value;"
msgstr ""
"let mut value = 30;\n"
"let borrowed = &mut value;"

#. type: Plain text
#: src/doc/tutorial.md:1493
msgid ""
"Pointers have high operator precedence, but lower precedence than the dot "
"operator used for field and method access. This precedence order can "
"sometimes make code awkward and parenthesis-filled."
msgstr ""
"ポインタ演算子の優先順位は高いですが、フィールドやメソッドのアクセスに用いる"
"ドット演算子よりは優先順位は低いです。この優先順位により、コードが不格好で括"
"弧だらけなものになることがあります。"

#. type: Plain text
#: src/doc/tutorial.md:1503
#, fuzzy
#| msgid ""
#| "~~~ # struct Point { x: f64, y: f64 } # enum Shape { Rectangle(Point, "
#| "Point) } # impl Shape { fn area(&self) -> int { 0 } } let start = @Point "
#| "{ x: 10f, y: 20f }; let end = ~Point { x: (*start).x + 100f, y: (*start)."
#| "y + 100f }; let rect = &Rectangle(*start, *end); let area = (*rect)."
#| "area(); ~~~"
msgid ""
"~~~ # struct Point { x: f64, y: f64 } # enum Shape { Rectangle(Point, "
"Point) } # impl Shape { fn area(&self) -> int { 0 } } let start = @Point "
"{ x: 10.0, y: 20.0 }; let end = ~Point { x: (*start).x + 100.0, y: (*start)."
"y + 100.0 }; let rect = &Rectangle(*start, *end); let area = (*rect).area(); "
"~~~"
msgstr ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"# enum Shape { Rectangle(Point, Point) }\n"
"# impl Shape { fn area(&self) -> int { 0 } }\n"
"let start = @Point { x: 10f, y: 20f };\n"
"let end = ~Point { x: (*start).x + 100f, y: (*start).y + 100f };\n"
"let rect = &Rectangle(*start, *end);\n"
"let area = (*rect).area();\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:1507
msgid ""
"To combat this ugliness the dot operator applies _automatic pointer "
"dereferencing_ to the receiver (the value on the left-hand side of the dot), "
"so in most cases, explicitly dereferencing the receiver is not necessary."
msgstr ""
"コードが醜くなるのを防ぐため、ドット演算子はレシーバ (ドットの左にある値) の "
"__ポインタを自動的にデリファレンス__ します。これにより、ほとんどのケースでは"
"レシーバを明示的にデリファレンスする必要がなくなります。"

#. type: Plain text
#: src/doc/tutorial.md:1517
#, fuzzy
#| msgid ""
#| "~~~ # struct Point { x: f64, y: f64 } # enum Shape { Rectangle(Point, "
#| "Point) } # impl Shape { fn area(&self) -> int { 0 } } let start = @Point "
#| "{ x: 10f, y: 20f }; let end = ~Point { x: start.x + 100f, y: start.y + "
#| "100f }; let rect = &Rectangle(*start, *end); let area = rect.area(); ~~~"
msgid ""
"~~~ # struct Point { x: f64, y: f64 } # enum Shape { Rectangle(Point, "
"Point) } # impl Shape { fn area(&self) -> int { 0 } } let start = @Point "
"{ x: 10.0, y: 20.0 }; let end = ~Point { x: start.x + 100.0, y: start.y + "
"100.0 }; let rect = &Rectangle(*start, *end); let area = rect.area(); ~~~"
msgstr ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"# enum Shape { Rectangle(Point, Point) }\n"
"# impl Shape { fn area(&self) -> int { 0 } }\n"
"let start = @Point { x: 10f, y: 20f };\n"
"let end = ~Point { x: start.x + 100f, y: start.y + 100f };\n"
"let rect = &Rectangle(*start, *end);\n"
"let area = rect.area();\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:1521
msgid ""
"You can write an expression that dereferences any number of pointers "
"automatically. For example, if you feel inclined, you could write something "
"silly like"
msgstr ""
"1つのドット演算子で何度も自動デリファレンスが行うことができます。例えば、やろ"
"うと思えば以下のような馬鹿げたものを書くこともできます。"

#. type: Plain text
#: src/doc/tutorial.md:1527
#, fuzzy
#| msgid ""
#| "~~~ # struct Point { x: f64, y: f64 } let point = &@~Point { x: 10f, y: "
#| "20f }; println(fmt!(\"%f\", point.x)); ~~~"
msgid ""
"~~~ # struct Point { x: f64, y: f64 } let point = &@~Point { x: 10.0, y: "
"20.0 }; println!(\"{:f}\", point.x); ~~~"
msgstr ""
"~~~\n"
"# struct Point { x: f64, y: f64 }\n"
"let point = &@~Point { x: 10f, y: 20f };\n"
"println(fmt!(\"%f\", point.x));\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:1529
msgid "The indexing operator (`[]`) also auto-dereferences."
msgstr "添字演算子 (`[]`) も自動でリファレンスを行います。"

#. type: Plain text
#: src/doc/tutorial.md:1531
msgid "# Vectors and strings"
msgstr "# ベクタと文字列"

#. type: Plain text
#: src/doc/tutorial.md:1535
#, fuzzy
#| msgid ""
#| "A vector is a contiguous section of memory containing zero or more values "
#| "of the same type. Like other types in Rust, vectors can be stored on the "
#| "stack, the local heap, or the exchange heap. Borrowed pointers to vectors "
#| "are also called 'slices'."
msgid ""
"A vector is a contiguous block of memory containing zero or more values of "
"the same type. Rust also supports vector reference types, called slices, "
"which are a view into a block of memory represented as a pointer and a "
"length."
msgstr ""
"ベクタは同じ型の値が0個以上含まれる、メモリ上の連続した部分のことです。Rust "
"の他の型と同様、ベクタもスタック、ローカルヒープ、交換ヒープ (exchange heap) "
"上に格納することができます。ベクトルの借用ポインタは、「スライス」と呼ばれる"
"場合もあります。"

#. type: Plain text
#: src/doc/tutorial.md:1608
msgid "Square brackets denote indexing into a vector:"
msgstr "角括弧はベクタの添字を表します。"

#. type: Plain text
#: src/doc/tutorial.md:1622
msgid "A vector can be destructured using pattern matching:"
msgstr "ベクタはパターンマッチにより destructuring することができます。"

#. type: Plain text
#: src/doc/tutorial.md:1635
#, fuzzy
#| msgid ""
#| "Both vectors and strings support a number of useful [methods](#methods), "
#| "defined in [`std::vec`] and [`std::str`]. Here are some examples."
msgid ""
"Both vectors and strings support a number of useful [methods](#methods), "
"defined in [`std::vec`] and [`std::str`]."
msgstr ""
"ベクタと文字列は、[`std::vec`] と [`std::str`] で定義された、多くの有用な [メ"
"ソッド](#methods) を持ちます。以下にいくつか例を挙げます。"

#. type: Plain text
#: src/doc/tutorial.md:1638
#, fuzzy
#| msgid "[`std::vec`]: std/vec.html [`std::str`]: std/str.html"
msgid "[`std::vec`]: std/vec/index.html [`std::str`]: std/str/index.html"
msgstr ""
"[`std::vec`]: std/vec.html\n"
"[`std::str`]: std/str.html"

#. type: Plain text
#: src/doc/tutorial.md:1650
#, fuzzy
#| msgid "~~~~ use std::task::spawn;"
msgid "~~~ use std::rc::Rc;"
msgstr ""
"~~~~\n"
"use std::task::spawn;"

#. type: Plain text
#: src/doc/tutorial.md:1669
#, fuzzy
#| msgid "~~~~ use std::task::spawn;"
msgid "~~~ use std::gc::Gc;"
msgstr ""
"~~~~\n"
"use std::task::spawn;"

#. type: Plain text
#: src/doc/tutorial.md:1686
msgid "# Closures"
msgstr "# クロージャ"

#. type: Plain text
#: src/doc/tutorial.md:1691
msgid ""
"Named functions, like those we've seen so far, may not refer to local "
"variables declared outside the function: they do not close over their "
"environment (sometimes referred to as \"capturing\" variables in their "
"environment). For example, you couldn't write the following:"
msgstr ""
"これまで登場したような名前のある関数は、関数の外で定義されるローカル変数を参"
"照することはできません。ローカル変数は環境を閉じ込める (環境中の変数を「キャ"
"プチャする」と呼ばれることもあります) ことはありません。例えば、以下のような"
"コードを書くことはできません。"

#. type: Plain text
#: src/doc/tutorial.md:1694
msgid "~~~~ {.ignore} let foo = 10;"
msgstr ""
"~~~~ {.ignore}\n"
"let foo = 10;"

#. type: Plain text
#: src/doc/tutorial.md:1699
#, no-wrap
msgid ""
"fn bar() -> int {\n"
"   return foo; // `bar` cannot refer to `foo`\n"
"}\n"
"~~~~\n"
msgstr ""
"fn bar() -> int {\n"
"   return foo; // `bar` ば `foo` を参照できない\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:1702
msgid ""
"Rust also supports _closures_, functions that can access variables in the "
"enclosing scope."
msgstr ""
"Rust は __クロージャ__ という、周囲のスコープの変数にアクセスできる関数をサ"
"ポートしています。"

#. type: Plain text
#: src/doc/tutorial.md:1705
msgid "~~~~ fn call_closure_with_ten(b: |int|) { b(10); }"
msgstr ""
"~~~~\n"
"fn call_closure_with_ten(b: |int|) { b(10); }"

#. type: Plain text
#: src/doc/tutorial.md:1708
#, fuzzy
#| msgid ""
#| "let captured_var = 20; let closure = |arg| println(fmt!(\"captured_var="
#| "%d, arg=%d\", captured_var, arg));"
msgid ""
"let captured_var = 20; let closure = |arg| println!(\"captured_var={}, "
"arg={}\", captured_var, arg);"
msgstr ""
"let captured_var = 20;\n"
"let closure = |arg| println(fmt!(\"captured_var=%d, arg=%d\", captured_var, "
"arg));"

#. type: Plain text
#: src/doc/tutorial.md:1711
msgid "call_closure_with_ten(closure); ~~~~"
msgstr ""
"call_closure_with_ten(closure);\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:1717
msgid ""
"Closures begin with the argument list between vertical bars and are followed "
"by a single expression. Remember that a block, `{ <expr1>; <expr2>; ... }`, "
"is considered a single expression: it evaluates to the result of the last "
"expression it contains if that expression is not followed by a semicolon, "
"otherwise the block evaluates to `()`."
msgstr ""
"クロージャはバーティカルバー (`|`) で囲まれた引数リストと、それに続く単一の式"
"から構成されます。ブロック `{ <expr1>; <expr2>; ...}` は単一の式とみなされる"
"ことを思い出してください。ブロックに含まれる最後の式に続けてセミコロンがない"
"場合、ブロックの値は最後の式の値となり、そうでなければ `()` となります。"

#. type: Plain text
#: src/doc/tutorial.md:1722
msgid ""
"The types of the arguments are generally omitted, as is the return type, "
"because the compiler can almost always infer them. In the rare case where "
"the compiler needs assistance, though, the arguments and return types may be "
"annotated."
msgstr ""
"引数の型や戻り値の型は、ほとんどすべての場合においてコンパイラにより推論され"
"るため、通常省略できます。発生するのはまれですが、コンパイラが推論に失敗する"
"場合は、引数と戻り値の型注釈を付けることがあります。"

#. type: Plain text
#: src/doc/tutorial.md:1726
msgid "~~~~ let square = |x: int| -> uint { (x * x) as uint }; ~~~~"
msgstr ""
"~~~~\n"
"let square = |x: int| -> uint { (x * x) as uint };\n"
"~~~~~~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:1730
msgid ""
"There are several forms of closure, each with its own role. The most common, "
"called a _stack closure_, has type `||` and can directly access local "
"variables in the enclosing scope."
msgstr ""
"クロージャにはいくつかの形態があり、それぞれに独自の役割があります。最も一般"
"的なのはスタッククロージャと呼ばれるもので、 `||` という型を持ち、外側のロー"
"カル変数に直接アクセスすることができます。"

#. type: Plain text
#: src/doc/tutorial.md:1735
msgid "~~~~ let mut max = 0; [1, 2, 3].map(|x| if *x > max { max = *x }); ~~~~"
msgstr ""
"~~~~\n"
"let mut max = 0;\n"
"[1, 2, 3].map(|x| if *x > max { max = *x });\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:1744
msgid ""
"Stack closures are very efficient because their environment is allocated on "
"the call stack and refers by pointer to captured locals. To ensure that "
"stack closures never outlive the local variables to which they refer, stack "
"closures are not first-class. That is, they can only be used in argument "
"position; they cannot be stored in data structures or returned from "
"functions. Despite these limitations, stack closures are used pervasively in "
"Rust code."
msgstr ""
"スタッククロージャは、閉じ込める環境はコールスタック上に獲得され、ローカル変"
"数をポインタで参照するため、非常に効率的です。スタッククロージャが参照してい"
"るローカル変数よりも長生きしないことを保証するため、スタッククロージャは第一"
"級の値ではありません。すなわち、スタッククロージャは引数としてしか使うことが"
"できず、データ構造や関数の戻り値となることはありません。この制限にも関わら"
"ず、スタッククロージャは Rust のコードのあちこちに登場します。"

#. type: Plain text
#: src/doc/tutorial.md:1746
msgid "## Owned closures"
msgstr "## 所有クロージャ"

#. type: Plain text
#: src/doc/tutorial.md:1753
msgid ""
"Owned closures, written `proc`, hold on to things that can safely be sent "
"between processes. They copy the values they close over, much like managed "
"closures, but they also own them: that is, no other code can access them. "
"Owned closures are used in concurrent code, particularly for spawning [tasks]"
"[tasks]."
msgstr ""
"`~` `proc` で書き表される所有クロージャは安全にプロセス間で送信することができ"
"ます。所有クローじゃはマネージドクロージャと全く同じように閉じ込める値をコ"
"ピーしますが、値を所有します。つまり、他のコードは閉じ込められた値にアクセス"
"できなくなります。所有クロージャは並列プログラム、特に [タスク][tasks] 生成で"
"利用されます。"

#. type: Plain text
#: src/doc/tutorial.md:1755
msgid "## Closure compatibility"
msgstr "## クロージャの互換性"

#. type: Plain text
#: src/doc/tutorial.md:1762
msgid ""
"Rust closures have a convenient subtyping property: you can pass any kind of "
"closure (as long as the arguments and return types match) to functions that "
"expect a `||`. Thus, when writing a higher-order function that only calls "
"its function argument, and does nothing else with it, you should almost "
"always declare the type of that argument as `||`. That way, callers may pass "
"any kind of closure."
msgstr ""
"Rust のクロージャは型の派生 (subtyping) という便利な性質を持っています。この"
"性質により、`||` 型を期待する関数には (引数と戻り値の型が一致する限り) 任意の"
"種類のクロージャを渡すことができます。したがって、引数で渡された関数について"
"は呼び出すだけで他に何もしない高階関数を書くときには、ほぼすべてのケースで引"
"数の型を `||` と宣言するべきです。そうすることで、呼び出し元は任意の種類のク"
"ロージャを渡すことができるよになります。"

#. type: Plain text
#: src/doc/tutorial.md:1770
msgid ""
"~~~~ fn call_twice(f: ||) { f(); f(); } let closure = || { \"I'm a closure, "
"and it doesn't matter what type I am\"; }; fn function() { \"I'm a normal "
"function\"; } call_twice(closure); call_twice(function); ~~~~"
msgstr ""
"~~~~\n"
"fn call_twice(f: ||) { f(); f(); }\n"
"let closure = || { \"I'm a closure, and it doesn't matter what type I am"
"\"; };\n"
"fn function() { \"I'm a normal function\"; }\n"
"call_twice(closure);\n"
"call_twice(function);\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:1774
msgid ""
"> ***Note:*** Both the syntax and the semantics will be changing > in small "
"ways. At the moment they can be unsound in some > scenarios, particularly "
"with non-copyable types."
msgstr ""
"> ***注意*** コードの文法と意味は将来的に変更されるかもしれません。現時点では"
"いくつかの状況、特にコピーできない型が関連するケースにおいて望ましくない振る"
"舞いが起こされる場合があります。"

#. type: Plain text
#: src/doc/tutorial.md:1776
msgid "## Do syntax"
msgstr "## do 構文"

#. type: Plain text
#: src/doc/tutorial.md:1779
#, fuzzy
#| msgid ""
#| "The `do` expression provides a way to treat higher-order functions "
#| "(functions that take closures as arguments) as control structures."
msgid ""
"The `do` expression makes it easier to call functions that take procedures "
"as arguments."
msgstr ""
"`do` 式は高階関数 (クロージャを引数にとる関数) を制御構造のように取り扱う方法"
"を提供します。"

#. type: Plain text
#: src/doc/tutorial.md:1791
msgid ""
"As a caller, if we use a closure to provide the final operator argument, we "
"can write it in a way that has a pleasant, block-like structure."
msgstr ""
"最後の引数にクロージャをとる関数を呼び出す場合、ブロック構造を持つかのように"
"コードを書くことが可能です。"

#. type: Plain text
#: src/doc/tutorial.md:1813
msgid ""
"If you want to see the output of `debug!` statements, you will need to turn "
"on `debug!` logging.  To enable `debug!` logging, set the RUST_LOG "
"environment variable to the name of your crate, which, for a file named `foo."
"rs`, will be `foo` (e.g., with bash, `export RUST_LOG=foo`)."
msgstr ""
"`debug!` ステートメントの出力を見たい場合、`debug!` によるロギングを有効にす"
"る必要があるでしょう。`debug!` によるロギングを有効にするためには、 RUST_LOG "
"環境変数をクレートの名前に設定する必要があります (例えば、bash の場合、 "
"`export RUST_LOG=foo` を実行する)。 `foo.rs` というファイルの場合、クレート名"
"は `foo` になります。"

#. type: Plain text
#: src/doc/tutorial.md:1815
msgid "# Methods"
msgstr "# メソッド"

#. type: Plain text
#: src/doc/tutorial.md:1821
msgid ""
"Methods are like functions except that they always begin with a special "
"argument, called `self`, which has the type of the method's receiver. The "
"`self` argument is like `this` in C++ and many other languages.  Methods are "
"called with dot notation, as in `my_vec.len()`."
msgstr ""
"メソッドは、`self` という、メソッドのレシーバと同じ型の特別な引数を第一引数と"
"してとる関数のようなものです。`self` は、 C++ や他の言語の `this` のようなも"
"のです。メソッドはドット記法を浸かって `my_vec.len()` のように呼び出します。"

#. type: Plain text
#: src/doc/tutorial.md:1825
msgid ""
"_Implementations_, written with the `impl` keyword, can define methods on "
"most Rust types, including structs and enums.  As an example, let's define a "
"`draw` method on our `Shape` enum."
msgstr ""
"`impl` キーワードを使って記述される __実装__ (_implementation_) により、構造"
"体や列挙型を含むほとんどの Rust の型に対してメソッドを定義することができま"
"す。例のように、 `draw` メソッドを `Shape` 列挙型に定義してみましょう。"

#. type: Plain text
#: src/doc/tutorial.md:1833
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };"
msgid ""
"~~~\n"
"# fn draw_circle(p: Point, f: f64) { }\n"
"# fn draw_rectangle(p: Point, p: Point) { }\n"
"struct Point {\n"
"    x: f64,\n"
"    y: f64\n"
"}\n"
msgstr ""
"~~~~ {.ignore}\n"
"# struct Point { x: f64, y: f64 }\n"
"let mut mypoint = Point { x: 1.0, y: 1.0 };\n"
"let origin = Point { x: 0.0, y: 0.0 };"

#. type: Plain text
#: src/doc/tutorial.md:1851
#, fuzzy
#| msgid "let s = Circle(Point { x: 1f, y: 2f }, 3f); s.draw(); ~~~"
msgid "let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0); s.draw(); ~~~"
msgstr ""
"let s = Circle(Point { x: 1f, y: 2f }, 3f);\n"
"s.draw();\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:1855
msgid ""
"This defines an _implementation_ for `Shape` containing a single method, "
"`draw`. In most respects the `draw` method is defined like any other "
"function, except for the name `self`."
msgstr ""
"この例では、 `Shape` に1つのメソッド `draw` をもつ __実装__ を定義していま"
"す。`draw` メソッドは、`self` という名前を除くほとんどの面で他の関数と同じよ"
"うに定義されます。"

#. type: Plain text
#: src/doc/tutorial.md:1860
msgid ""
"The type of `self` is the type on which the method is implemented, or a "
"pointer thereof. As an argument it is written either `self`, `&self`, "
"`@self`, or `~self`.  A caller must in turn have a compatible pointer type "
"to call the method."
msgstr ""
"`self` の型は、メソッドが実装されている型か、それらのポインタである。引数とし"
"ては、 `self`, `&self`, `@self` または `~self` と記述されます。呼び出し側も同"
"様、メソッドを呼び出すための互換性のあるポインタ型をもつ必要があります。"

#. type: Plain text
#: src/doc/tutorial.md:1875
#, fuzzy, no-wrap
#| msgid ""
#| "~~~\n"
#| "# fn draw_circle(p: Point, f: f64) { }\n"
#| "# fn draw_rectangle(p: Point, p: Point) { }\n"
#| "# struct Point { x: f64, y: f64 }\n"
#| "# enum Shape {\n"
#| "#     Circle(Point, f64),\n"
#| "#     Rectangle(Point, Point)\n"
#| "# }\n"
#| "# impl Shape {\n"
#| "#    fn draw_borrowed(&self) { ... }\n"
#| "#    fn draw_managed(@self) { ... }\n"
#| "#    fn draw_owned(~self) { ... }\n"
#| "#    fn draw_value(self) { ... }\n"
#| "# }\n"
#| "# let s = Circle(Point { x: 1f, y: 2f }, 3f);\n"
#| "// As with typical function arguments, managed and owned pointers\n"
#| "// are automatically converted to borrowed pointers\n"
msgid ""
"~~~\n"
"# fn draw_circle(p: Point, f: f64) { }\n"
"# fn draw_rectangle(p: Point, p: Point) { }\n"
"# struct Point { x: f64, y: f64 }\n"
"# enum Shape {\n"
"#     Circle(Point, f64),\n"
"#     Rectangle(Point, Point)\n"
"# }\n"
"impl Shape {\n"
"    fn draw_reference(&self) { ... }\n"
"    fn draw_managed(@self) { ... }\n"
"    fn draw_owned(~self) { ... }\n"
"    fn draw_value(self) { ... }\n"
"}\n"
msgstr ""
"~~~\n"
"# fn draw_circle(p: Point, f: f64) { }\n"
"# fn draw_rectangle(p: Point, p: Point) { }\n"
"# struct Point { x: f64, y: f64 }\n"
"# enum Shape {\n"
"#     Circle(Point, f64),\n"
"#     Rectangle(Point, Point)\n"
"# }\n"
"# impl Shape {\n"
"#    fn draw_borrowed(&self) { ... }\n"
"#    fn draw_managed(@self) { ... }\n"
"#    fn draw_owned(~self) { ... }\n"
"#    fn draw_value(self) { ... }\n"
"# }\n"
"# let s = Circle(Point { x: 1f, y: 2f }, 3f);\n"
"// 関数の引数と同様、マネージドポインタと所有ポインタは、\n"
"// 自動的に借用ポインタに変換される\n"

#. type: Plain text
#: src/doc/tutorial.md:1877
#, fuzzy
#| msgid "let s = Circle(Point { x: 1f, y: 2f }, 3f); s.draw(); ~~~"
msgid "let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);"
msgstr ""
"let s = Circle(Point { x: 1f, y: 2f }, 3f);\n"
"s.draw();\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:1883
#, fuzzy
#| msgid ""
#| "(@s).draw_managed(); (~s).draw_owned(); (&s).draw_borrowed(); s."
#| "draw_value(); ~~~"
msgid ""
"(@s).draw_managed(); (~s).draw_owned(); (&s).draw_reference(); s."
"draw_value(); ~~~"
msgstr ""
"(@s).draw_managed();\n"
"(~s).draw_owned();\n"
"(&s).draw_borrowed();\n"
"s.draw_value();\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:1887
#, fuzzy
#| msgid ""
#| "Methods typically take a borrowed pointer self type, so the compiler will "
#| "go to great lengths to convert a callee to a borrowed pointer."
msgid ""
"Methods typically take a reference self type, so the compiler will go to "
"great lengths to convert a callee to a reference."
msgstr ""
"多くのメソッドは、借用ポインタの self 型を持つので、コンパイラは呼び出し先を"
"借用ポインタに変換するためあらゆる手段を講じます。"

#. type: Plain text
#: src/doc/tutorial.md:1905
#, fuzzy, no-wrap
#| msgid ""
#| "~~~\n"
#| "# fn draw_circle(p: Point, f: f64) { }\n"
#| "# fn draw_rectangle(p: Point, p: Point) { }\n"
#| "# struct Point { x: f64, y: f64 }\n"
#| "# enum Shape {\n"
#| "#     Circle(Point, f64),\n"
#| "#     Rectangle(Point, Point)\n"
#| "# }\n"
#| "# impl Shape {\n"
#| "#    fn draw_borrowed(&self) { ... }\n"
#| "#    fn draw_managed(@self) { ... }\n"
#| "#    fn draw_owned(~self) { ... }\n"
#| "#    fn draw_value(self) { ... }\n"
#| "# }\n"
#| "# let s = Circle(Point { x: 1f, y: 2f }, 3f);\n"
#| "// As with typical function arguments, managed and owned pointers\n"
#| "// are automatically converted to borrowed pointers\n"
msgid ""
"~~~\n"
"# fn draw_circle(p: Point, f: f64) { }\n"
"# fn draw_rectangle(p: Point, p: Point) { }\n"
"# struct Point { x: f64, y: f64 }\n"
"# enum Shape {\n"
"#     Circle(Point, f64),\n"
"#     Rectangle(Point, Point)\n"
"# }\n"
"# impl Shape {\n"
"#    fn draw_reference(&self) { ... }\n"
"#    fn draw_managed(@self) { ... }\n"
"#    fn draw_owned(~self) { ... }\n"
"#    fn draw_value(self) { ... }\n"
"# }\n"
"# let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);\n"
"// As with typical function arguments, managed and owned pointers\n"
"// are automatically converted to references\n"
msgstr ""
"~~~\n"
"# fn draw_circle(p: Point, f: f64) { }\n"
"# fn draw_rectangle(p: Point, p: Point) { }\n"
"# struct Point { x: f64, y: f64 }\n"
"# enum Shape {\n"
"#     Circle(Point, f64),\n"
"#     Rectangle(Point, Point)\n"
"# }\n"
"# impl Shape {\n"
"#    fn draw_borrowed(&self) { ... }\n"
"#    fn draw_managed(@self) { ... }\n"
"#    fn draw_owned(~self) { ... }\n"
"#    fn draw_value(self) { ... }\n"
"# }\n"
"# let s = Circle(Point { x: 1f, y: 2f }, 3f);\n"
"// 関数の引数と同様、マネージドポインタと所有ポインタは、\n"
"// 自動的に借用ポインタに変換される\n"

#. type: Plain text
#: src/doc/tutorial.md:1908
#, fuzzy
#| msgid "(@s).draw_borrowed(); (~s).draw_borrowed();"
msgid "(@s).draw_reference(); (~s).draw_reference();"
msgstr ""
"(@s).draw_borrowed();\n"
"(~s).draw_borrowed();"

#. type: Plain text
#: src/doc/tutorial.md:1912
#, fuzzy
#| msgid ""
#| "// Unlike typical function arguments, the self value will // "
#| "automatically be referenced ...  s.draw_borrowed();"
msgid ""
"// Unlike typical function arguments, the self value will // automatically "
"be referenced ...  s.draw_reference();"
msgstr ""
"// 関数の引数とは異なり、 self の値は自動的にリファレンスされたり、 ...\n"
"s.draw_borrowed();"

#. type: Plain text
#: src/doc/tutorial.md:1915
#, fuzzy
#| msgid "// ... and dereferenced (& &s).draw_borrowed();"
msgid "// ... and dereferenced (& &s).draw_reference();"
msgstr ""
"// ... デリファレンスされたり、\n"
"(& &s).draw_borrowed();"

#. type: Plain text
#: src/doc/tutorial.md:1919
#, fuzzy
#| msgid "// ... and dereferenced and borrowed (&@~s).draw_borrowed(); ~~~"
msgid "// ... and dereferenced and borrowed (&@~s).draw_reference(); ~~~"
msgstr ""
"// ... デリファレンス後借用されたりします\n"
"(&@~s).draw_borrowed();\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:1923
msgid ""
"Implementations may also define standalone (sometimes called \"static\")  "
"methods. The absence of a `self` parameter distinguishes such methods.  "
"These methods are the preferred way to define constructor functions."
msgstr ""
"実装では、スタンドアロンなメソッド (「静的 (static)」メソッドと呼ばれる場合も"
"あります)を定義することも可能です。引数に `self` をつけない場合、スタンドアロ"
"ンなメソッドとなります。コンストラクタ関数は、スタンドアロンなメソッドとして"
"定義することが推奨されています。"

#. type: Plain text
#: src/doc/tutorial.md:1932
msgid ""
"To call such a method, just prefix it with the type name and a double colon:"
msgstr ""
"メソッド名の前に型名と2つのコロンを付けることで、スタンドアロンメソッドは呼び"
"出せます。"

#. type: Plain text
#: src/doc/tutorial.md:1943
msgid "# Generics"
msgstr "# ジェネリクス"

#. type: Plain text
#: src/doc/tutorial.md:1951
msgid ""
"Throughout this tutorial, we've been defining functions that act only on "
"specific data types. With type parameters we can also define functions whose "
"arguments have generic types, and which can be invoked with a variety of "
"types. Consider a generic `map` function, which takes a function `function` "
"and a vector `vector` and returns a new vector consisting of the result of "
"applying `function` to each element of `vector`:"
msgstr ""
"このチュートリアルでは、特定のデータ型のみに対して動作する関数を定義してきま"
"した。型パラメータを用いるとジェネリックな型を引数にとり、様々な型で呼び出す"
"ことの可能な関数を定義できます。関数 `function` とベクタ `vector` を引数にと"
"り、`function` を`vector` の各要素に適用した結果からなる新たなベクタを返す、"
"`map` というジェネリック関数について考えます。"

#. type: Plain text
#: src/doc/tutorial.md:1966
msgid ""
"When defined with type parameters, as denoted by `<T, U>`, this function can "
"be applied to any type of vector, as long as the type of `function`'s "
"argument and the type of the vector's contents agree with each other."
msgstr ""
"上記例で `<T, U>` と示されているように、型パラメータとともに関数を定義するこ"
"とで、`function` の引数の型と`vectror` の要素の型が一致する場合に限りますが、"
"任意の型のベクタを引数として渡すことが可能になります。"

#. type: Plain text
#: src/doc/tutorial.md:1976
msgid ""
"Inside a generic function, the names of the type parameters (capitalized by "
"convention) stand for opaque types. All you can do with instances of these "
"types is pass them around: you can't apply any operations to them or pattern-"
"match on them. Note that instances of generic types are often passed by "
"pointer. For example, the parameter `function()` is supplied with a pointer "
"to a value of type `T` and not a value of type `T` itself. This ensures that "
"the function works with the broadest set of types possible, since some types "
"are expensive or illegal to copy and pass by value."
msgstr ""
"ジェネリック関数の内部では、型パラメータの名前 (慣例的に大文字で表されます) "
"は不透明型 (opaque type) を意味します。これらの型のインスタンスに対しては、他"
"の関数に渡すことだけが可能で、演算子を適用したり、パターンマッチすることはで"
"きません。ジェネリック型のインスタンスは、ポインタにより渡されることもあるこ"
"とに注意してください。例えば、 `function()` パラメータが `T` 型自身の値ではな"
"く `T` 型の値へのポインタとして渡されるということです。いくつかの型は、値をコ"
"ピーするコストが高かったり、コピーが禁じられていたりするので、ポインタ渡しに"
"することで、関数の引数としてとることのできる型の範囲が広がります。"

#. type: Plain text
#: src/doc/tutorial.md:1978
msgid ""
"Generic `type`, `struct`, and `enum` declarations follow the same pattern:"
msgstr ""
"ジェネリックな型、構造体、および列挙型の宣言は、同じパターンに従います。"

#. type: Plain text
#: src/doc/tutorial.md:1982
msgid "~~~~ use std::hashmap::HashMap; type Set<T> = HashMap<T, ()>;"
msgstr ""
"~~~~\n"
"use std::hashmap::HashMap;\n"
"type Set<T> = HashMap<T, ()>;"

#. type: Plain text
#: src/doc/tutorial.md:1995
msgid ""
"These declarations can be instantiated to valid types like `Set<int>`, "
"`Stack<int>`, and `Option<int>`."
msgstr ""
"これらの宣言により、 `Set<int>` や `Stack<int>`、 `Option<int>` のような正当"
"な型を生成することができます。"

#. type: Plain text
#: src/doc/tutorial.md:2001
msgid ""
"The last type in that example, `Option`, appears frequently in Rust code.  "
"Because Rust does not have null pointers (except in unsafe code), we need "
"another way to write a function whose result isn't defined on every possible "
"combination of arguments of the appropriate types. The usual way is to write "
"a function that returns `Option<T>` instead of `T`."
msgstr ""
"最後の例の `Option` 型は、Rust のコード中に頻繁に現れます。Rust には null ポ"
"インタが存在しない (unsafe なコードを除く) ため、引数の組み合わせがとりうるす"
"べての値に対し結果が定義されないような関数を記述するための別の方法が必要で"
"す。このような場合には、 `T` 型ではなく `Option<T>` 型を返すよう関数を定義す"
"ることが一般的です。"

#. type: Plain text
#: src/doc/tutorial.md:2020
msgid ""
"The Rust compiler compiles generic functions very efficiently by "
"*monomorphizing* them. *Monomorphization* is a fancy name for a simple idea: "
"generate a separate copy of each generic function at each call site, a copy "
"that is specialized to the argument types and can thus be optimized "
"specifically for them. In this respect, Rust's generics have similar "
"performance characteristics to C++ templates."
msgstr ""
"Rust のコンパイラは、ジェネリック関数を *monomorphizing* することで効率的にコ"
"ンパイルします。*monomorphization* という名前は大げさに聞こえますが、考え方は"
"単純です。ジェネリック関数のコピーを関数の呼び出し箇所に別々に生成し、引数の"
"型により特殊化された各コピーは、それぞれの特性に応じて最適化が施されます。こ"
"の点において、Rust のジェネリクスは C++ のテンプレートと似たパフォーマンス上"
"の特性を持ちます。"

#. type: Plain text
#: src/doc/tutorial.md:2022
msgid "## Traits"
msgstr "## トレイト"

#. type: Plain text
#: src/doc/tutorial.md:2034
#, fuzzy
#| msgid ""
#| "Within a generic function the operations available on generic types are "
#| "very limited. After all, since the function doesn't know what types it is "
#| "operating on, it can't safely modify or query their values. This is where "
#| "_traits_ come into play. Traits are Rust's most powerful tool for writing "
#| "polymorphic code. Java developers will see them as similar to Java "
#| "interfaces, and Haskellers will notice their similarities to type "
#| "classes. Rust's traits are a form of *bounded polymorphism*: a trait is a "
#| "way of limiting the set of possible types that a type parameter could "
#| "refer to."
msgid ""
"Within a generic function -- that is, a function parameterized by a type "
"parameter, say, `T` -- the operations we can do on arguments of type `T` are "
"quite limited.  After all, since we don't know what type `T` will be "
"instantiated with, we can't safely modify or query values of type `T`.  This "
"is where _traits_ come into play. Traits are Rust's most powerful tool for "
"writing polymorphic code. Java developers will see them as similar to Java "
"interfaces, and Haskellers will notice their similarities to type classes. "
"Rust's traits give us a way to express *bounded polymorphism*: by limiting "
"the set of possible types that a type parameter could refer to, they expand "
"the number of operations we can safely perform on arguments of that type."
msgstr ""
"ジェネリック関数の内部では、ジェネリック型に対して非常に限られた操作しか行え"
"ません。つまるところ、ジェネリック関数は操作の対象とする型が何なのか知らない"
"ため、対象の値を安全に変更・参照することができません。__トレイト__ (_trait_) "
"の出番です。トレイトは Rust でポリモーフィックなコードを書くための最も強力な"
"ツールです。Java 開発者にとってトレイトは Java のインターフェースのように見え"
"ますし、Haskeller は型クラスとの類似点に気づくでしょう。Rust のトレイトは **"
"有界ポリモーフィズム** (*bounded polymorphism*) の形式をとります。トレイトに"
"より、型パラメータが示す得る型の集合を限定することができます。"

#. type: Plain text
#: src/doc/tutorial.md:2041
#, fuzzy
#| msgid ""
#| "As motivation, let us consider copying in Rust.  The `clone` method is "
#| "not defined for all Rust types.  One reason is user-defined destructors: "
#| "copying a type that has a destructor could result in the destructor "
#| "running multiple times.  Therefore, types with destructors cannot be "
#| "copied unless you explicitly implement `Clone` for them."
msgid ""
"As motivation, let us consider copying of values in Rust.  The `clone` "
"method is not defined for values of every type.  One reason is user-defined "
"destructors: copying a value of a type that has a destructor could result in "
"the destructor running multiple times.  Therefore, values of types that have "
"destructors cannot be copied unless we explicitly implement `clone` for them."
msgstr ""
"トレイト導入の動機となる例として、Rust でのコピーについて考えます。`clone` メ"
"ソッドはすべての Rust の型に対して定義されていません。定義されていない理由の"
"一つとして、ユーザ定義のデストラクタの存在が挙げられます。デストラクタを持つ"
"型をコピーすることで、デストラクタが複数回実行されるという事態を招いてしまう"
"かもしれません。そのため、明示的に `Clone` を実装していない型を除き、デストラ"
"クタをもつ型をコピーすることはできません。"

#. type: Plain text
#: src/doc/tutorial.md:2047
#, fuzzy
#| msgid ""
#| "This complicates handling of generic functions.  If you have a type "
#| "parameter `T`, can you copy values of that type? In Rust, you can't, and "
#| "if you try to run the following code the compiler will complain."
msgid ""
"This complicates handling of generic functions.  If we have a function with "
"a type parameter `T`, can we copy values of type `T` inside that function? "
"In Rust, we can't, and if we try to run the following code the compiler will "
"complain."
msgstr ""
"このことはジェネリック関数の扱い方を複雑にします。型パラメータ `T` が存在した"
"として、この型の値をコピーすることができるでしょうか？Rust では、コピーするこ"
"とはできません。以下のコードを実行しようとしてもコンパイラが文句を言うでしょ"
"う。"

#. type: Plain text
#: src/doc/tutorial.md:2054
#, no-wrap
msgid ""
"~~~~ {.ignore}\n"
"// This does not compile\n"
"fn head_bad<T>(v: &[T]) -> T {\n"
"    v[0] // error: copying a non-copyable value\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// このコードはコンパイルできない\n"
"fn head_bad<T>(v: &[T]) -> T {\n"
"    v[0] // error: copying a non-copyable value\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:2060
#, fuzzy
#| msgid ""
#| "However, we can tell the compiler that the `head` function is only for "
#| "copyable types: that is, those that implement the `Clone` trait.  In that "
#| "case, we can explicitly create a second copy of the value we are "
#| "returning using the `clone` keyword:"
msgid ""
"However, we can tell the compiler that the `head` function is only for "
"copyable types.  In Rust, copyable types are those that _implement the "
"`Clone` trait_.  We can then explicitly create a second copy of the value we "
"are returning by calling the `clone` method:"
msgstr ""
"`head` 関数はコピー可能な型、つまり `Clone` トレイトを実装している型だけを対"
"象にしていることをコンパイラに教えることはできます。この場合、`clone` メソッ"
"ドを使うことで、値のコピーを明示的に作成し、戻り値として返すことができます。"

#. type: Plain text
#: src/doc/tutorial.md:2067
#, no-wrap
msgid ""
"~~~~\n"
"// This does\n"
"fn head<T: Clone>(v: &[T]) -> T {\n"
"    v[0].clone()\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~\n"
"// このコードはコンパイルできる\n"
"fn head<T: Clone>(v: &[T]) -> T {\n"
"    v[0].clone()\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:2077
#, fuzzy
#| msgid ""
#| "This says that we can call `head` on any type `T` as long as that type "
#| "implements the `Clone` trait.  When instantiating a generic function, you "
#| "can only instantiate it with types that implement the correct trait, so "
#| "you could not apply `head` to a type that does not implement `Clone`."
msgid ""
"The bounded type parameter `T: Clone` says that `head` can be called on an "
"argument of type `&[T]` for any `T`, so long as there is an implementation "
"of the `Clone` trait for `T`.  When instantiating a generic function, we can "
"only instantiate it with types that implement the correct trait, so we could "
"not apply `head` to a vector whose elements are of some type that does not "
"implement `Clone`."
msgstr ""
"このことは、`Clone` トレイトを実装している任意の型 `T` について、 `head` 関数"
"を呼び出すことができることを示しています。ジェネリック関数を実体化する場合、"
"正しいトレイトを実装した型を用いた場合のみ実体化できます。つまり、`Clone` ト"
"レイトを実装していない型に対して `head` を呼び出すことはできません。"

#. type: Plain text
#: src/doc/tutorial.md:2082
#, fuzzy
#| msgid ""
#| "While most traits can be defined and implemented by user code, two traits "
#| "are automatically derived and implemented for all applicable types by the "
#| "compiler, and may not be overridden:"
msgid ""
"While most traits can be defined and implemented by user code, three traits "
"are automatically derived and implemented for all applicable types by the "
"compiler, and may not be overridden:"
msgstr ""
"ほとんどのトレイトはユーザコードにより定義・実装できますが、2つのトレイトはコ"
"ンパイラにより自動的に導出され、適用可能なすべての型に対し自動的に実装され、"
"上書きすることはできません。"

#. type: Plain text
#: src/doc/tutorial.md:2086
#, fuzzy, no-wrap
#| msgid ""
#| "* `Send` - Sendable types.\n"
#| "Types are sendable\n"
#| "unless they contain managed boxes, managed closures, or borrowed pointers.\n"
msgid ""
"* `Send` - Sendable types.\n"
"Types are sendable\n"
"unless they contain managed boxes, managed closures, or references.\n"
msgstr ""
"* `Send` - 送信可能な型。\n"
"マネージドボックスやマネージドクロージャ、借用ポインタを含まない場合、型は送信可能である。"

#. type: Plain text
#: src/doc/tutorial.md:2090
#, fuzzy, no-wrap
#| msgid ""
#| "* `Freeze` - Constant (immutable) types.\n"
#| "These are types that do not contain anything intrinsically mutable.\n"
#| "Intrinsically mutable values include `@mut`\n"
#| "and `Cell` in the standard library.\n"
msgid ""
"* `Freeze` - Constant (immutable) types.\n"
"These are types that do not contain anything intrinsically mutable.\n"
"Intrinsically mutable values include `Cell` in the standard library.\n"
msgstr ""
"* `Freeze` - 定数 (イミュータブル) 型。\n"
"本質的に変更可能な値を含まない型のことです。本質的に変更可能な値には、`@mut` や標準ライブラリで定義されている `Cell` が含まれます。\n"

#. type: Plain text
#: src/doc/tutorial.md:2099
msgid ""
"> ***Note:*** These two traits were referred to as 'kinds' in earlier > "
"iterations of the language, and often still are."
msgstr ""
"> ***注意*** これら2つのトレイトは、以前は 「種」 (kind) と呼ばれており、現在"
"でもそう呼ばれる場合があります。"

#. type: Plain text
#: src/doc/tutorial.md:2105
#, fuzzy
#| msgid ""
#| "Additionally, the `Drop` trait is used to define destructors. This trait "
#| "defines one method called `drop`, which is automatically called when a "
#| "value of the type that implements this trait is destroyed, either because "
#| "the value went out of scope or because the garbage collector reclaimed it."
msgid ""
"Additionally, the `Drop` trait is used to define destructors. This trait "
"provides one method called `drop`, which is automatically called when a "
"value of the type that implements this trait is destroyed, either because "
"the value went out of scope or because the garbage collector reclaimed it."
msgstr ""
"上記に加え、 `Drop` トレイトはデストラクタを定義するために使われます。このト"
"レイトは `drop` というこのトレイトを実装した型が破壊されるタイミング(値がス"
"コープの外に出たタイミングか、ガベージコレクタが回収するタイミング) で呼び出"
"されるメソッドを1つ定義しています。"

#. type: Plain text
#: src/doc/tutorial.md:2110
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"~~~\n"
"struct TimeBomb {\n"
"    explosivity: uint\n"
"}\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2122
msgid ""
"It is illegal to call `drop` directly. Only code inserted by the compiler "
"may call it."
msgstr ""
"`drop` を直接呼び出すことはできません。コンパイラにより挿入されたコードのみ"
"が `drop` を呼び出すことができます。"

#. type: Plain text
#: src/doc/tutorial.md:2124
msgid "## Declaring and implementing traits"
msgstr "## トレイトの宣言と実装"

#. type: Plain text
#: src/doc/tutorial.md:2129
#, fuzzy
#| msgid ""
#| "A trait consists of a set of methods without bodies, or may be empty, as "
#| "is the case with `Send` and `Freeze`.  For example, we could declare the "
#| "trait `Printable` for things that can be printed to the console, with a "
#| "single method:"
msgid ""
"At its simplest, a trait is a set of zero or more _method signatures_.  For "
"example, we could declare the trait `Printable` for things that can be "
"printed to the console, with a single method signature:"
msgstr ""
"トレイトはボディを持たないメソッドの集合から構成されるか、 `Send` や "
"`Freeze` トレイトのように空の場合があります。例えば、コンソールに出力可能なも"
"のを表しメソッドを1つもつ `Printable` トレイトは以下のように宣言できます。"

#. type: Plain text
#: src/doc/tutorial.md:2135
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"~~~~\n"
"trait Printable {\n"
"    fn print(&self);\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2148
#, fuzzy
#| msgid ""
#| "Traits may be implemented for specific types with [impls]. An impl that "
#| "implements a trait includes the name of the trait at the start of the "
#| "definition, as in the following impls of `Printable` for `int` and `~str`."
msgid ""
"Traits may be implemented for specific types with [impls]. An impl for a "
"particular trait gives an implementation of the methods that trait "
"provides.  For instance, the following impls of `Printable` for `int` and "
"`~str` give implementations of the `print` method."
msgstr ""
"[impl][impls] により特定の型にトレイトを実装することができます。トレイトを実"
"装する impl は、以下の `Printable` の `int` と `~str` に対する実装のように、"
"定義の先頭にトレイトの名前を含みます。"

#. type: Plain text
#: src/doc/tutorial.md:2150
msgid "[impls]: #methods"
msgstr "[impls]: #メソッド"

#. type: Plain text
#: src/doc/tutorial.md:2160 src/doc/tutorial.md:2206
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"impl Printable for ~str {\n"
"    fn print(&self) { println!(\"{}\", *self) }\n"
"}\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2164
msgid "# 1.print(); # (~\"foo\").print(); ~~~~"
msgstr ""
"# 1.print();\n"
"# (~\"foo\").print();\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2167
#, fuzzy
#| msgid ""
#| "Methods defined in an implementation of a trait may be called just like "
#| "any other method, using dot notation, as in `1.print()`. Traits may "
#| "themselves contain type parameters. A trait for generalized sequence "
#| "types might look like the following:"
msgid ""
"Methods defined in an impl for a trait may be called just like any other "
"method, using dot notation, as in `1.print()`."
msgstr ""
"トレイトの実装により定義されたメソッドは他のメソッドと全く同じように、ドット"
"記法を用いて `1.print()` のように呼び出せます。トレイト自体に型パラメータを持"
"たせることもできます。一般化されたシーケンスを表すトレイトは以下のように定義"
"されるでしょう。"

#. type: Plain text
#: src/doc/tutorial.md:2169
#, fuzzy
#| msgid "## Deriving implementations for traits"
msgid "## Default method implementations in trait definitions"
msgstr "## トレイトの実装の導出"

#. type: Plain text
#: src/doc/tutorial.md:2185
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"impl Printable for bool {\n"
"    fn print(&self) { println!(\"{:?}\", *self) }\n"
"}\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2189
#, fuzzy
#| msgid "# 1.print(); # (~\"foo\").print(); ~~~~"
msgid "# true.print(); # 3.14159.print(); ~~~~"
msgstr ""
"# 1.print();\n"
"# (~\"foo\").print();\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2216
#, fuzzy
#| msgid "# 1.print(); # (~\"foo\").print(); ~~~~"
msgid ""
"# 1.print(); # (~\"foo\").print(); # true.print(); # 3.14159.print(); ~~~~"
msgstr ""
"# 1.print();\n"
"# (~\"foo\").print();\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2227
#, fuzzy
#| msgid "## Tuples"
msgid "## Type-parameterized traits"
msgstr "## タプル"

#. type: Plain text
#: src/doc/tutorial.md:2235
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"~~~~\n"
"trait Seq<T> {\n"
"    fn length(&self) -> uint;\n"
"}\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2240
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"impl<T> Seq<T> for ~[T] {\n"
"    fn length(&self) -> uint { self.len() }\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2247
msgid ""
"The implementation has to explicitly declare the type parameter that it "
"binds, `T`, before using it to specify its trait type. Rust requires this "
"declaration because the `impl` could also, for example, specify an "
"implementation of `Seq<int>`. The trait type (appearing between `impl` and "
"`for`) *refers* to a type, rather than defining one."
msgstr ""
"実装が束縛する型パラメータ `T` は、トレイトの型を指定する前に明示的に宣言しな"
"ければなりません。Rust でこの宣言が必要なのは、 `impl` では例えば `Seq<int>` "
"の実装を指定することも可能だからです。トレイトの型 (`impl` と `for` の間に現"
"れるもの) は、型を定義するのではなく、型を **参照** します。"

#. type: Plain text
#: src/doc/tutorial.md:2252
msgid ""
"The type parameters bound by a trait are in scope in each of the method "
"declarations. So, re-declaring the type parameter `T` as an explicit type "
"parameter for `len`, in either the trait or the impl, would be a compile-"
"time error."
msgstr ""
"トレイトにより束縛される型パラメータは、各メソッドの宣言のスコープに属しま"
"す。したがって、trait と impl のいずれかで、型パラメータ `T` を `len` で用い"
"る明示的な型パラメータとして再宣言すると、コンパイル時エラーとなります。"

#. type: Plain text
#: src/doc/tutorial.md:2257
msgid ""
"Within a trait definition, `Self` is a special type that you can think of as "
"a type parameter. An implementation of the trait for any given type `T` "
"replaces the `Self` type parameter with `T`. The following trait describes "
"types that support an equality operation:"
msgstr ""
"トレイトの定義内部では、`Self` は型パラメータとみなすことのできる特別な型とな"
"ります。型 `T` に対するトレイトの実装では `Self` は型パラメータ `T` で置き換"
"えられます。以下のトレイトは等価性演算をサポートする型を意味します。"

#. type: Plain text
#: src/doc/tutorial.md:2264
#, no-wrap
msgid ""
"~~~~\n"
"// In a trait, `self` refers to the self argument.\n"
"// `Self` refers to the type implementing the trait.\n"
"trait Eq {\n"
"    fn equals(&self, other: &Self) -> bool;\n"
"}\n"
msgstr ""
"~~~~\n"
"// trait の内側では, `self` は self 引数を指します。\n"
"// `Self` はトレイトを実装する型を指します。\n"
"trait Eq {\n"
"    fn equals(&self, other: &Self) -> bool;\n"
"}\n"

#. type: Plain text
#: src/doc/tutorial.md:2270
#, no-wrap
msgid ""
"// In an impl, `self` refers just to the value of the receiver\n"
"impl Eq for int {\n"
"    fn equals(&self, other: &int) -> bool { *other == *self }\n"
"}\n"
"~~~~\n"
msgstr ""
"// impl の内側では `self` はレシーバの値を指します\n"
"impl Eq for int {\n"
"    fn equals(&self, other: &int) -> bool { *other == *self }\n"
"}\n"
"~~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:2275
msgid ""
"Notice that in the trait definition, `equals` takes a second parameter of "
"type `Self`.  In contrast, in the `impl`, `equals` takes a second parameter "
"of type `int`, only using `self` as the name of the receiver."
msgstr ""
"トレイトの定義では、`equals` の第二引数の型は `Self` であることに注意してくだ"
"さい。対照的に `impl` では、 `equals` の第二引数の型は `int` で、 `self` はレ"
"シーバの名前としてのみ使用されます。"

#. type: Plain text
#: src/doc/tutorial.md:2280
msgid ""
"Just as in type implementations, traits can define standalone (static)  "
"methods.  These methods are called by prefixing the method name with the "
"trait name and a double colon.  The compiler uses type inference to decide "
"which implementation to use."
msgstr ""
"型への実装の場合と同様、トレイトもスタンドアロン (静的) メソッドを定義するこ"
"とができます。メソッド名の前にトレイト名とコロン2つをつけることで、これらのメ"
"ソッドを呼び出すことができます。コンパイラはどの実装を利用するか決定するた"
"め、型推論を行います。"

#. type: Plain text
#: src/doc/tutorial.md:2286
#, fuzzy
#| msgid ""
#| "~~~~ use std::f64::consts::pi; trait Shape { fn new(area: f64) -> Self; } "
#| "struct Circle { radius: f64 } struct Square { length: f64 }"
msgid ""
"~~~~ use std::f64::consts::PI; trait Shape { fn new(area: f64) -> Self; } "
"struct Circle { radius: f64 } struct Square { length: f64 }"
msgstr ""
"~~~~\n"
"use std::f64::consts::pi;\n"
"trait Shape { fn new(area: f64) -> Self; }\n"
"struct Circle { radius: f64 }\n"
"struct Square { length: f64 }"

#. type: Plain text
#: src/doc/tutorial.md:2298
msgid ""
"let area = 42.5; let c: Circle = Shape::new(area); let s: Square = Shape::"
"new(area); ~~~~"
msgstr ""
"let area = 42.5;\n"
"let c: Circle = Shape::new(area);\n"
"let s: Square = Shape::new(area);\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2300
msgid "## Bounded type parameters and static method dispatch"
msgstr "## 境界型パラメータと静的メソッドディスパッチ"

#. type: Plain text
#: src/doc/tutorial.md:2305
msgid ""
"Traits give us a language for defining predicates on types, or abstract "
"properties that types can have. We can use this language to define _bounds_ "
"on type parameters, so that we can then operate on generic types."
msgstr ""
"トレイトは型の述語 (predicate) や型がもつことのできる抽象的な属性を定義するた"
"めの言語として利用することができます。この言語を使うこととで型パラメータの __"
"境界__ (_bound_) を定義することができ、ジェネリックな型を操作することが可能に"
"なります。"

#. type: Plain text
#: src/doc/tutorial.md:2320
msgid ""
"Declaring `T` as conforming to the `Printable` trait (as we earlier did with "
"`Clone`) makes it possible to call methods from that trait on values of type "
"`T` inside the function. It will also cause a compile-time error when anyone "
"tries to call `print_all` on an array whose element type does not have a "
"`Printable` implementation."
msgstr ""
"(先に登場した `Clone` の例のように) `T` が `Printable` トレイトに従うことを宣"
"言することで、関数内部で `T` 型の値に対して `Printable` トレイトのメソッドを"
"呼び出すことが可能になります。また、この宣言により、`Printable` を実装してい"
"ない型を要素とする配列に対して `print_all` 関数を呼びだそうとすると、コンパイ"
"ル時エラーとなります。"

#. type: Plain text
#: src/doc/tutorial.md:2323
msgid ""
"Type parameters can have multiple bounds by separating them with `+`, as in "
"this version of `print_all` that copies elements."
msgstr ""
"型パラメータは `+` で区切ることで複数の境界を持つことができます。以下の "
"`print_all` は、ベクタの要素をコピーするバージョンです。"

#. type: Plain text
#: src/doc/tutorial.md:2339
msgid ""
"Method calls to bounded type parameters are _statically dispatched_, "
"imposing no more overhead than normal function invocation, so are the "
"preferred way to use traits polymorphically."
msgstr ""
"境界型パラメータに対するメソッドの呼び出しは __静的にディスパッチ__ "
"(_statically dispatched_) されるため、通常の関数呼び出し以上のオーバーヘッド"
"は発生しません。そのため、ポリモーフィックにトレイトを使う方法としては、境界"
"型パラメータが推奨されます。 "

#. type: Plain text
#: src/doc/tutorial.md:2341
msgid "This usage of traits is similar to Haskell type classes."
msgstr "トレイトのこのような使い方は、Haskell の型クラスと似ています。"

#. type: Plain text
#: src/doc/tutorial.md:2343
msgid "## Trait objects and dynamic method dispatch"
msgstr "## トレイトオブジェクトと動的メソッドディスパッチ"

#. type: Plain text
#: src/doc/tutorial.md:2347
msgid ""
"The above allows us to define functions that polymorphically act on values "
"of a single unknown type that conforms to a given trait.  However, consider "
"this function:"
msgstr ""
"上述の例では、指定されたトレイトに従う、単一の未知の型の値についてポリモー"
"フィックにふるまう関数を定義しました。ここでは、以下の関数について考えます。"

#. type: Plain text
#: src/doc/tutorial.md:2353
msgid ""
"~~~~ # type Circle = int; type Rectangle = int; # impl Drawable for int { fn "
"draw(&self) {} } # fn new_circle() -> int { 1 } trait Drawable { fn "
"draw(&self); }"
msgstr ""
"~~~~\n"
"# type Circle = int; type Rectangle = int;\n"
"# impl Drawable for int { fn draw(&self) {} }\n"
"# fn new_circle() -> int { 1 }\n"
"trait Drawable { fn draw(&self); }"

#. type: Plain text
#: src/doc/tutorial.md:2366
msgid ""
"You can call that on an array of circles, or an array of rectangles "
"(assuming those have suitable `Drawable` traits defined), but not on an "
"array containing both circles and rectangles. When such behavior is needed, "
"a trait name can alternately be used as a type, called an _object_."
msgstr ""
"円の配列や長方形の配列に対してこの関数を呼び出すことは (円や長方形に対し適切"
"に `Drawable` トレイトが定義されていると仮定すれば) 可能ですが、円や長方形を"
"両方共含む配列に対しては呼び出すことができません。そのような動作が必要な場"
"合、__オブジェクト__  型として、トレイトの名前を代わりに利用することができま"
"す。"

#. type: Plain text
#: src/doc/tutorial.md:2378
msgid ""
"In this example, there is no type parameter. Instead, the `@Drawable` type "
"denotes any managed box value that implements the `Drawable` trait. To "
"construct such a value, you use the `as` operator to cast a value to an "
"object:"
msgstr ""
"この例中には、型パラメータはありません。代わりに、「`Drawable` トレイトを実装"
"した、任意のマネージドボックス値」を表す型  `@Drawable` 型があります。このよ"
"うな値を作成するには、 `as` 演算子を使って値をオブジェクトへキャストします。"

#. type: Plain text
#: src/doc/tutorial.md:2385
msgid ""
"~~~~ # type Circle = int; type Rectangle = bool; # trait Drawable { fn "
"draw(&self); } # fn new_circle() -> Circle { 1 } # fn new_rectangle() -> "
"Rectangle { true } # fn draw_all(shapes: &[@Drawable]) {}"
msgstr ""
"~~~~\n"
"# type Circle = int; type Rectangle = bool;\n"
"# trait Drawable { fn draw(&self); }\n"
"# fn new_circle() -> Circle { 1 }\n"
"# fn new_rectangle() -> Rectangle { true }\n"
"# fn draw_all(shapes: &[@Drawable]) {}"

#. type: Plain text
#: src/doc/tutorial.md:2388
msgid ""
"impl Drawable for Circle { fn draw(&self) { ... } } impl Drawable for "
"Rectangle { fn draw(&self) { ... } }"
msgstr ""
"impl Drawable for Circle { fn draw(&self) { ... } }\n"
"impl Drawable for Rectangle { fn draw(&self) { ... } }"

#. type: Plain text
#: src/doc/tutorial.md:2393
msgid ""
"let c: @Circle = @new_circle(); let r: @Rectangle = @new_rectangle(); "
"draw_all([c as @Drawable, r as @Drawable]); ~~~~"
msgstr ""
"let c: @Circle = @new_circle();\n"
"let r: @Rectangle = @new_rectangle();\n"
"draw_all([c as @Drawable, r as @Drawable]);\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2401
msgid ""
"We omit the code for `new_circle` and `new_rectangle`; imagine that these "
"just return `Circle`s and `Rectangle`s with a default size. Note that, like "
"strings and vectors, objects have dynamic size and may only be referred to "
"via one of the pointer types.  Other pointer types work as well.  Casts to "
"traits may only be done with compatible pointers so, for example, an "
"`@Circle` may not be cast to an `~Drawable`."
msgstr ""
"`new_circle` と `new_rectangle` のコードは省略されていますが、デフォルトのサ"
"イズをもつ `Circle` と `Rectangle` をただ返すものだと考えてください。文字列や"
"ベクタのように、オブジェクトも動的なサイズを持ち、いずれかのポインタ型を経由"
"してしか参照できないことに注意してください。他のポインタ型でもうまく動作しま"
"す。トレイトへのキャストは互換性のあるポインタの場合しか行えません。例えば、"
"`@Cicle` を `~Drawable` にキャストすることはできません。"

#. type: Plain text
#: src/doc/tutorial.md:2415
msgid ""
"~~~ # type Circle = int; type Rectangle = int; # trait Drawable { fn "
"draw(&self); } # impl Drawable for int { fn draw(&self) {} } # fn "
"new_circle() -> int { 1 } # fn new_rectangle() -> int { 2 } // A managed "
"object let boxy: @Drawable = @new_circle() as @Drawable; // An owned object "
"let owny: ~Drawable = ~new_circle() as ~Drawable; // A borrowed object let "
"stacky: &Drawable = &new_circle() as &Drawable; ~~~"
msgstr ""
"~~~\n"
"# type Circle = int; type Rectangle = int;\n"
"# trait Drawable { fn draw(&self); }\n"
"# impl Drawable for int { fn draw(&self) {} }\n"
"# fn new_circle() -> int { 1 }\n"
"# fn new_rectangle() -> int { 2 }\n"
"// A managed object\n"
"let boxy: @Drawable = @new_circle() as @Drawable;\n"
"// An owned object\n"
"let owny: ~Drawable = ~new_circle() as ~Drawable;\n"
"// A borrowed object\n"
"let stacky: &Drawable = &new_circle() as &Drawable;\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:2420
msgid ""
"Method calls to trait types are _dynamically dispatched_. Since the compiler "
"doesn't know specifically which functions to call at compile time, it uses a "
"lookup table (also known as a vtable or dictionary) to select the method to "
"call at runtime."
msgstr ""
"トレイト型のメソッド呼び出しは __動的にディスパッチ__ (_dynamically "
"dispatched_) されます。どの関数を呼び出すべきかコンパイル時にはわからないた"
"め、ルックアップテーブル (vtable や dictionary としても知られている) を用い"
"て、呼び出すメソッドの選択を実行時に行います。"

#. type: Plain text
#: src/doc/tutorial.md:2422
msgid "This usage of traits is similar to Java interfaces."
msgstr "トレイトのこのような使い方は、Java のインターフェースと似ています。"

#. type: Plain text
#: src/doc/tutorial.md:2448
msgid "## Trait inheritance"
msgstr "## トレイトの継承"

#. type: Plain text
#: src/doc/tutorial.md:2453
msgid ""
"We can write a trait declaration that _inherits_ from other traits, called "
"_supertraits_.  Types that implement a trait must also implement its "
"supertraits.  For example, we can define a `Circle` trait that inherits from "
"`Shape`."
msgstr ""
"__スーパートレイト__ と呼ばれる他のトレイトから __継承した__ トレイトを宣言す"
"ることができます。継承されたトレイトを実装する型は、スーパートレイトも実装し"
"なければなりません。例えば、 `Circle` トレイトを `Shape` トレイトを継承したも"
"のとして定義できます。"

#. type: Plain text
#: src/doc/tutorial.md:2458
msgid ""
"~~~~ trait Shape { fn area(&self) -> f64; } trait Circle : Shape { fn "
"radius(&self) -> f64; } ~~~~"
msgstr ""
"~~~~\n"
"trait Shape { fn area(&self) -> f64; }\n"
"trait Circle : Shape { fn radius(&self) -> f64; }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2460
msgid ""
"Now, we can implement `Circle` on a type only if we also implement `Shape`."
msgstr "`Circle` トレイトの実装は、 `Shape` を実装した型についてのみ行えます。"

#. type: Plain text
#: src/doc/tutorial.md:2475
#, fuzzy, no-wrap
#| msgid "~~~ {.ignore} use std::f64::consts::pi; # trait Shape { fn area(&self) -> f64; } # trait Circle : Shape { fn radius(&self) -> f64; } # struct Point { x: f64, y: f64 } # struct CircleStruct { center: Point, radius: f64 } # impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / pi).sqrt() } } # impl Shape for CircleStruct { fn area(&self) -> f64 { pi * square(self.radius) } }"
msgid ""
"~~~~\n"
"use std::f64::consts::PI;\n"
"# trait Shape { fn area(&self) -> f64; }\n"
"# trait Circle : Shape { fn radius(&self) -> f64; }\n"
"# struct Point { x: f64, y: f64 }\n"
"# fn square(x: f64) -> f64 { x * x }\n"
"struct CircleStruct { center: Point, radius: f64 }\n"
"impl Circle for CircleStruct {\n"
"    fn radius(&self) -> f64 { (self.area() / PI).sqrt() }\n"
"}\n"
"impl Shape for CircleStruct {\n"
"    fn area(&self) -> f64 { PI * square(self.radius) }\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~ {.ignore}\n"
"use std::f64::consts::pi;\n"
"# trait Shape { fn area(&self) -> f64; }\n"
"# trait Circle : Shape { fn radius(&self) -> f64; }\n"
"# struct Point { x: f64, y: f64 }\n"
"# struct CircleStruct { center: Point, radius: f64 }\n"
"# impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / pi).sqrt() } }\n"
"# impl Shape for CircleStruct { fn area(&self) -> f64 { pi * square(self.radius) } }"

#. type: Plain text
#: src/doc/tutorial.md:2480
msgid ""
"Notice that methods of `Circle` can call methods on `Shape`, as our `radius` "
"implementation calls the `area` method.  This is a silly way to compute the "
"radius of a circle (since we could just return the `radius` field), but you "
"get the idea."
msgstr ""
"`radius` の実装から `area` メソッドを呼び出せるように、`Circle` のメソッドは "
"`Shape` のメソッドを呼び出せることに注意してください。(単純に `radius` フィー"
"ルドの値を返すことができるにも関わらず) 円の半径を面積から計算するのは馬鹿げ"
"ていますが、メソッド呼び出しの考え方は分かったでしょう。"

#. type: Plain text
#: src/doc/tutorial.md:2484
msgid ""
"In type-parameterized functions, methods of the supertrait may be called on "
"values of subtrait-bound type parameters.  Refering to the previous example "
"of `trait Circle : Shape`:"
msgstr ""
"型パラメータを持つ関数では、サブトレイトの境界型パラメータの値によりスーパー"
"トレイトのメソッドを呼び出すことになります。前の例の `trait Circle : Shape` "
"を参照してください。"

#. type: Plain text
#: src/doc/tutorial.md:2493
#, no-wrap
msgid ""
"~~~\n"
"# trait Shape { fn area(&self) -> f64; }\n"
"# trait Circle : Shape { fn radius(&self) -> f64; }\n"
"fn radius_times_area<T: Circle>(c: T) -> f64 {\n"
"    // `c` is both a Circle and a Shape\n"
"    c.radius() * c.area()\n"
"}\n"
"~~~\n"
msgstr ""
"~~~\n"
"# trait Shape { fn area(&self) -> f64; }\n"
"# trait Circle : Shape { fn radius(&self) -> f64; }\n"
"fn radius_times_area<T: Circle>(c: T) -> f64 {\n"
"    // `c` は Circle でもあり、Shape でもある\n"
"    c.radius() * c.area()\n"
"}\n"
"~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:2504
#, fuzzy
#| msgid ""
#| "~~~ {.ignore} use std::f64::consts::pi; # trait Shape { fn area(&self) -> "
#| "f64; } # trait Circle : Shape { fn radius(&self) -> f64; } # struct Point "
#| "{ x: f64, y: f64 } # struct CircleStruct { center: Point, radius: f64 } # "
#| "impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / "
#| "pi).sqrt() } } # impl Shape for CircleStruct { fn area(&self) -> f64 { pi "
#| "* square(self.radius) } }"
msgid ""
"~~~ {.ignore} use std::f64::consts::PI; # trait Shape { fn area(&self) -> "
"f64; } # trait Circle : Shape { fn radius(&self) -> f64; } # struct Point "
"{ x: f64, y: f64 } # struct CircleStruct { center: Point, radius: f64 } # "
"impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / PI)."
"sqrt() } } # impl Shape for CircleStruct { fn area(&self) -> f64 { PI * "
"square(self.radius) } }"
msgstr ""
"~~~ {.ignore}\n"
"use std::f64::consts::pi;\n"
"# trait Shape { fn area(&self) -> f64; }\n"
"# trait Circle : Shape { fn radius(&self) -> f64; }\n"
"# struct Point { x: f64, y: f64 }\n"
"# struct CircleStruct { center: Point, radius: f64 }\n"
"# impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / "
"pi).sqrt() } }\n"
"# impl Shape for CircleStruct { fn area(&self) -> f64 { pi * square(self."
"radius) } }"

#. type: Plain text
#: src/doc/tutorial.md:2509
msgid ""
"let concrete = @CircleStruct{center:Point{x:3f,y:4f},radius:5f}; let "
"mycircle: @Circle = concrete as @Circle; let nonsense = mycircle.radius() * "
"mycircle.area(); ~~~"
msgstr ""
"let concrete = @CircleStruct{center:Point{x:3f,y:4f},radius:5f};\n"
"let mycircle: @Circle = concrete as @Circle;\n"
"let nonsense = mycircle.radius() * mycircle.area();\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:2511
msgid "> ***Note:*** Trait inheritance does not actually work with objects yet"
msgstr ""
"> ***注意*** トレイトの継承は、実際にはまだオブジェクトに対しては動作しませ"
"ん。"

#. type: Plain text
#: src/doc/tutorial.md:2513
msgid "## Deriving implementations for traits"
msgstr "## トレイトの実装の導出"

#. type: Plain text
#: src/doc/tutorial.md:2520
msgid ""
"A small number of traits in `std` and `extra` can have implementations that "
"can be automatically derived. These instances are specified by placing the "
"`deriving` attribute on a data type declaration. For example, the following "
"will mean that `Circle` has an implementation for `Eq` and can be used with "
"the equality operators, and that a value of type `ABC` can be randomly "
"generated and converted to a string:"
msgstr ""
"`std` と `extra` で定義されているいくつかのトレイトは、自動的に実装を導出可能"
"です。データ型の宣言時に `deriving` 属性を書くことで、これらのトレイトを実装"
"することを指定します。例えば、以下の例では `Circle` は `Eq` を実装し等価演算"
"子で比較することが可能であり、`ABC` 型の値はランダムに生成することや、文字列"
"に変換することが可能です。"

#. type: Plain text
#: src/doc/tutorial.md:2524
msgid "~~~ #[deriving(Eq)] struct Circle { radius: f64 }"
msgstr ""
"~~~\n"
"#[deriving(Eq)]\n"
"struct Circle { radius: f64 }"

#. type: Plain text
#: src/doc/tutorial.md:2528
msgid "#[deriving(Rand, ToStr)] enum ABC { A, B, C } ~~~"
msgstr ""
"#[deriving(Rand, ToStr)]\n"
"enum ABC { A, B, C }\n"
"~~~"

#. type: Plain text
#: src/doc/tutorial.md:2532
#, fuzzy
#| msgid ""
#| "The full list of derivable traits is `Eq`, `TotalEq`, `Ord`, `TotalOrd`, "
#| "`Encodable` `Decodable`, `Clone`, `DeepClone`, `Hash`, `Rand`, "
#| "`Zero`, and `ToStr`."
msgid ""
"The full list of derivable traits is `Eq`, `TotalEq`, `Ord`, `TotalOrd`, "
"`Encodable` `Decodable`, `Clone`, `DeepClone`, `Hash`, `Rand`, "
"`Default`, `Zero`, and `ToStr`."
msgstr ""
"実装を自動的に導出可能なトレイトは、 `Eq`, `TotalEq`, `Ord`, `TotalOrd`, "
"`Encodable` `Decodable`, `Clone`, `DeepClone`, `Hash`, `Rand`, `Zero`, "
"および `ToStr` です。."

#. type: Plain text
#: src/doc/tutorial.md:2534
#, fuzzy
#| msgid "# Modules and crates"
msgid "# Crates and the module system"
msgstr "# モジュールとクレート"

#. type: Plain text
#: src/doc/tutorial.md:2539
msgid "## Crates"
msgstr "## クレート"

#. type: Plain text
#: src/doc/tutorial.md:2554
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"~~~~\n"
"// `main.rs`\n"
"fn main() {\n"
"    println!(\"Hello world!\");\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2557
#, fuzzy
#| msgid ""
#| "The unit of independent compilation in Rust is the crate: rustc compiles "
#| "a single crate at a time, from which it produces either a library or an "
#| "executable."
msgid ""
"A crate is also the unit of independent compilation in Rust: `rustc` always "
"compiles a single crate at a time, from which it produces either a library "
"or an executable."
msgstr ""
"Rust の独立コンパイルの単位はクレートです。rustc は1度に1つのクレートをコンパ"
"イルし、ライブラリか実行可能ファイルを生成します。"

#. type: Plain text
#: src/doc/tutorial.md:2561
#, fuzzy
#| msgid "## The standard library"
msgid "## The module hierarchy"
msgstr "## 標準ライブラリ"

#. type: Plain text
#: src/doc/tutorial.md:2587
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"fn main() {\n"
"    println!(\"Hello farm!\");\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2595
#, fuzzy
#| msgid "## Managed closures"
msgid "## Paths and visibility"
msgstr "## マネージドクロージャ"

#. type: Plain text
#: src/doc/tutorial.md:2607
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"fn main() {\n"
"    println!(\"Hello chicken!\");\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2639
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"fn main() {\n"
"    println!(\"Hello chicken!\");\n"
"    ::farm::chicken(); // This compiles now\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2646
#, fuzzy
#| msgid ""
#| "Visibility restrictions in Rust exist only at module boundaries. This is "
#| "quite different from most object-oriented languages that also enforce "
#| "restrictions on objects themselves. That's not to say that Rust doesn't "
#| "support encapsulation: both struct fields and methods can be private. But "
#| "this encapsulation is at the module level, not the struct level. Note "
#| "that fields and methods are _public_ by default."
msgid ""
"Visibility restrictions in Rust exist only at module boundaries. This is "
"quite different from most object-oriented languages that also enforce "
"restrictions on objects themselves. That's not to say that Rust doesn't "
"support encapsulation: both struct fields and methods can be private. But "
"this encapsulation is at the module level, not the struct level."
msgstr ""
"Rust での可視性の制約はモジュールの境界にのみ存在します。これは、オブジェクト"
"自体にも可視性の制約を課すほとんどのオブジェクト指向言語とは全く異なっていま"
"す。しかし、Rust がカプセル化をサポートしていないというわけではありません。構"
"造体のフィールドとメソッドはプライベートにすることができます。しかし、このカ"
"プセル化はモジュールレベルで働くもので、構造体のレベルで働くものではありませ"
"ん。フィールドとメソッドでは、デフォルトでは __パブリック__ であることに注意"
"してください。"

#. type: Plain text
#: src/doc/tutorial.md:2689
#, fuzzy
#| msgid "# Modules and crates"
msgid "## Files and modules"
msgstr "# モジュールとクレート"

#. type: Plain text
#: src/doc/tutorial.md:2719
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"fn main() {\n"
"    println!(\"Hello farm!\");\n"
"    ::farm::cow();\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2755
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} let foo = 10;"
msgid ""
"~~~ {.ignore}\n"
"// `src/main.rs`\n"
"mod plants;\n"
"mod animals {\n"
"    mod fish;\n"
"    mod mammals {\n"
"        mod humans;\n"
"    }\n"
"}\n"
"~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"let foo = 10;"

#. type: Plain text
#: src/doc/tutorial.md:2761 src/doc/tutorial.md:2793
#, fuzzy
#| msgid "~~~~ {.ignore} let foo = 10;"
msgid "~~~ {.notrust} src/plants.rs src/plants/mod.rs"
msgstr ""
"~~~~ {.ignore}\n"
"let foo = 10;"

#. type: Plain text
#: src/doc/tutorial.md:2778
#, fuzzy
#| msgid "~~~~ {.ignore} let foo = 10;"
msgid "~~~ {.ignore} // `src/main.rs` mod plants; mod animals; ~~~"
msgstr ""
"~~~~ {.ignore}\n"
"let foo = 10;"

#. type: Plain text
#: src/doc/tutorial.md:2786
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} let foo = 10;"
msgid ""
"~~~ {.ignore}\n"
"// `src/animals.rs` or `src/animals/mod.rs`\n"
"mod fish;\n"
"mod mammals {\n"
"    mod humans;\n"
"}\n"
"~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"let foo = 10;"

#. type: Plain text
#: src/doc/tutorial.md:2820
#, fuzzy
#| msgid "~~~~ {.ignore} let foo = 10;"
msgid "~~~ {.ignore} #[path=\"../../area51/alien.rs\"] mod classified; ~~~"
msgstr ""
"~~~~ {.ignore}\n"
"let foo = 10;"

#. type: Plain text
#: src/doc/tutorial.md:2897
#, fuzzy
#| msgid ""
#| "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello "
#| "\" + world::explore()); } ~~~~"
msgid "fn main() { cow() } ~~~"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2916
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"fn main() {\n"
"    println!(\"Hello farm!\");\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2923
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"    // Can now refer to those names directly:\n"
"    chicken();\n"
"    cow();\n"
"    barn::hay();\n"
"}\n"
"~~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2932
#, fuzzy
#| msgid ""
#| "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello "
#| "\" + world::explore()); } ~~~~"
msgid ""
"~~~{.ignore} // `a.rs` - crate root use b::foo; mod b; fn main() { foo(); } "
"~~~"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2939
#, fuzzy
#| msgid ""
#| "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello "
#| "\" + world::explore()); } ~~~~"
msgid ""
"~~~{.ignore} // `b.rs` use b::c::bar; pub mod c; pub fn foo() { bar(); } ~~~"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2985
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"fn main() {\n"
"    egg_layer();\n"
"}\n"
"~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:2991
#, fuzzy
#| msgid "# Dereferencing pointers"
msgid "## Reexporting names"
msgstr "# ポインタのデリファレンス"

#. type: Plain text
#: src/doc/tutorial.md:3014
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"fn main() {\n"
"    farm::chicken();\n"
"    farm::cow();\n"
"    farm::hay();\n"
"}\n"
"~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:3026
#, fuzzy
#| msgid "## Using other crates"
msgid "## Using libraries"
msgstr "## 他のクレートの利用"

#. type: Plain text
#: src/doc/tutorial.md:3035
#, fuzzy
#| msgid "## Using other crates"
msgid "For that, Rust offers you the `extern crate` declaration:"
msgstr "## 他のクレートの利用"

#. type: Plain text
#: src/doc/tutorial.md:3045
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"fn main() {\n"
"    // The rational number '1/2':\n"
"    let one_half = ::extra::rational::Ratio::new(1, 2);\n"
"}\n"
"~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:3068
#, fuzzy
#| msgid "~~~~ {.ignore} let foo = 10;"
msgid "~~~ extern crate extra;"
msgstr ""
"~~~~ {.ignore}\n"
"let foo = 10;"

#. type: Plain text
#: src/doc/tutorial.md:3081
#, fuzzy, no-wrap
#| msgid "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello \" + world::explore()); } ~~~~"
msgid ""
"fn main() {\n"
"    farm::dog();\n"
"    let a_third = Ratio::new(1, 3);\n"
"}\n"
"~~~\n"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:3086
#, fuzzy
#| msgid "## Structs"
msgid "## Package ids"
msgstr "## 構造体"

#. type: Plain text
#: src/doc/tutorial.md:3123
#, fuzzy
#| msgid ""
#| "~~~~ {.ignore} extern crate farm; extern crate my_farm (name = \"farm\", vers "
#| "= \"2.5\"); extern crate my_auxiliary_farm (name = \"farm\", author = \"mjh"
#| "\"); ~~~~"
msgid ""
"~~~~ {.ignore} extern crate farm; extern crate farm = \"farm#2.5\"; extern crate "
"my_farm = \"farm\"; ~~~~"
msgstr ""
"~~~~ {.ignore}\n"
"extern crate farm;\n"
"extern crate my_farm (name = \"farm\", vers = \"2.5\");\n"
"extern crate my_auxiliary_farm (name = \"farm\", author = \"mjh\");\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:3134
#, fuzzy
#| msgid "// Make a library (\"bin\" is the default)  #[crate_type = \"lib\"];"
msgid ""
"// This crate is a library (\"bin\" is the default)  #[crate_id = "
"\"farm#2.5\"]; #[crate_type = \"lib\"];"
msgstr ""
"// ライブラリを作成する (\"bin\" がデフォルト値)\n"
"#[crate_type = \"lib\"];"

#. type: Plain text
#: src/doc/tutorial.md:3139
#, fuzzy
#| msgid "// Turn on a warning #[warn(non_camel_case_types)]"
msgid "// Turn on a warning #[warn(non_camel_case_types)] # fn farm() {} ~~~~"
msgstr ""
"// 警告を有効にする\n"
"#[warn(non_camel_case_types)]"

#. type: Plain text
#: src/doc/tutorial.md:3141
msgid "## A minimal example"
msgstr "## 最小限の例"

#. type: Plain text
#: src/doc/tutorial.md:3143
#, fuzzy
#| msgid ""
#| "Now for something that you can actually compile yourself, we have these "
#| "two files:"
msgid "Now for something that you can actually compile yourself."
msgstr ""
"あなた自身で実際にコンパイルが行える例として、以下の2つのファイルを例示しま"
"す。"

#. type: Plain text
#: src/doc/tutorial.md:3153
#, fuzzy
#| msgid ""
#| "~~~~ // world.rs #[link(name = \"world\", vers = \"1.0\")]; pub fn "
#| "explore() -> &str { \"world\" } ~~~~"
msgid ""
"~~~~ // `world.rs` #[crate_id = \"world#0.42\"]; # extern crate extra; pub fn "
"explore() -> &'static str { \"world\" } # fn main() {} ~~~~"
msgstr ""
"~~~~\n"
"// world.rs\n"
"#[link(name = \"world\", vers = \"1.0\")];\n"
"pub fn explore() -> &str { \"world\" }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:3159
#, fuzzy
#| msgid ""
#| "~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\"hello "
#| "\" + world::explore()); } ~~~~"
msgid ""
"~~~~ {.ignore} // `main.rs` extern crate world; fn main() { println!(\"hello "
"{}\", world::explore()); } ~~~~"
msgstr ""
"~~~~ {.ignore}\n"
"// main.rs\n"
"extern crate world;\n"
"fn main() { println(~\"hello \" + world::explore()); }\n"
"~~~~"

#. type: Plain text
#: src/doc/tutorial.md:3161
msgid "Now compile and run like this (adjust to your platform if necessary):"
msgstr ""
"以下のようにコンパイルし、実行します (必要であれば、お使いのプラットフォーム"
"に合わせて修正してください。)"

#. type: Plain text
#: src/doc/tutorial.md:3168
#, fuzzy, no-wrap
#| msgid ""
#| "~~~~ {.notrust}\n"
#| "> rustc --lib world.rs  # compiles libworld-94839cbfe144198-1.0.so\n"
#| "> rustc main.rs -L .    # compiles main\n"
#| "> ./main\n"
#| "\"hello world\"\n"
#| "~~~~\n"
msgid ""
"~~~~ {.notrust}\n"
"> rustc --lib world.rs  # compiles libworld-<HASH>-0.42.so\n"
"> rustc main.rs -L .    # compiles main\n"
"> ./main\n"
"\"hello world\"\n"
"~~~~\n"
msgstr ""
"~~~~ {.notrust}\n"
"> rustc --lib world.rs  # libworld-94839cbfe144198-1.0.so が生成される\n"
"> rustc main.rs -L .    # main が生成される\n"
"> ./main\n"
"\"hello world\"\n"
"~~~~\n"

#. type: Plain text
#: src/doc/tutorial.md:3173
#, fuzzy
#| msgid ""
#| "Notice that the library produced contains the version in the filename as "
#| "well as an inscrutable string of alphanumerics. These are both part of "
#| "Rust's library versioning scheme. The alphanumerics are a hash "
#| "representing the crate metadata."
msgid ""
"Notice that the library produced contains the version in the file name as "
"well as an inscrutable string of alphanumerics. As explained in the previous "
"paragraph, these are both part of Rust's library versioning scheme. The "
"alphanumerics are a hash representing the crates package ID."
msgstr ""
"生成されたライブラリのファイル名には、バージョン番号だけでなく謎めいた英数字"
"が含まれていることに注意してください。これらは両方共 Rust のバージョン管理ス"
"キームの一員です。英数字は、クレートのメタデータを表すハッシュ値です。"

#. type: Plain text
#: src/doc/tutorial.md:3175
#, fuzzy
#| msgid "## The standard library"
msgid "## The standard library and the prelude"
msgstr "## 標準ライブラリ"

#. type: Plain text
#: src/doc/tutorial.md:3187
#, fuzzy
#| msgid "~~~~ {.ignore} let foo = 10;"
msgid "~~~ {.ignore} extern crate std; ~~~"
msgstr ""
"~~~~ {.ignore}\n"
"let foo = 10;"

#. type: Plain text
#: src/doc/tutorial.md:3193
#, fuzzy
#| msgid "~~~~ {.ignore} let foo = 10;"
msgid "~~~ {.ignore} use std::prelude::*; ~~~"
msgstr ""
"~~~~ {.ignore}\n"
"let foo = 10;"

#. type: Plain text
#: src/doc/tutorial.md:3234
#, fuzzy
#| msgid "## The standard library"
msgid "## The extra library"
msgstr "## 標準ライブラリ"

#. type: Plain text
#: src/doc/tutorial.md:3246
msgid "# What next?"
msgstr "# 次のステップは？"

#. type: Plain text
#: src/doc/tutorial.md:3249
#, fuzzy
#| msgid ""
#| "Now that you know the essentials, check out any of the additional "
#| "tutorials on individual topics."
msgid ""
"Now that you know the essentials, check out any of the additional guides on "
"individual topics."
msgstr ""
"Rust の本質的な部分に関する説明は以上です。個々のトピックにおける追加のチュー"
"トリアルもチェックしてみてください。"

#. type: Bullet: '* '
#: src/doc/tutorial.md:3260
#, fuzzy
#| msgid "[Containers and iterators](tutorial-container.html)"
msgid "[Pointers][pointers]"
msgstr "[コンテナとイテレータ](tutorial-container.html)"

#. type: Bullet: '* '
#: src/doc/tutorial.md:3260
#, fuzzy
#| msgid "% The Rust Language Tutorial"
msgid "[Lifetimes][lifetimes]"
msgstr "% Rust 言語チュートリアル"

#. type: Bullet: '* '
#: src/doc/tutorial.md:3260
msgid "[Tasks and communication][tasks]"
msgstr "[タスクと通信][tasks]"

#. type: Bullet: '* '
#: src/doc/tutorial.md:3260
msgid "[Macros][macros]"
msgstr "[マクロ][macros]"

#. type: Bullet: '* '
#: src/doc/tutorial.md:3260
msgid "[The foreign function interface][ffi]"
msgstr "[他言語間インターフェース (foreign function inferface)][ffi]"

#. type: Bullet: '* '
#: src/doc/tutorial.md:3260
#, fuzzy
#| msgid "[Containers and iterators](tutorial-container.html)"
msgid "[Containers and iterators][container]"
msgstr "[コンテナとイテレータ](tutorial-container.html)"

#. type: Bullet: '* '
#: src/doc/tutorial.md:3260
#, fuzzy
#| msgid "% The Rust Language Tutorial"
msgid "[Testing Rust code][testing]"
msgstr "% Rust 言語チュートリアル"

#. type: Bullet: '* '
#: src/doc/tutorial.md:3260
#, fuzzy
#| msgid "% The Rust Language Tutorial"
msgid "[The Rust Runtime][runtime]"
msgstr "% Rust 言語チュートリアル"
