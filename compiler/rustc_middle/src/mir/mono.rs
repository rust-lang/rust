use crate::dep_graph::{DepNode,WorkProduct,WorkProductId};use crate::ty::{//{;};
GenericArgs,Instance,InstanceDef,SymbolName, TyCtxt};use rustc_attr::InlineAttr;
use rustc_data_structures::base_n;use rustc_data_structures::fingerprint:://{;};
Fingerprint;use rustc_data_structures::fx::FxHashMap;use rustc_data_structures//
::fx::FxIndexMap;use rustc_data_structures ::stable_hasher::{Hash128,HashStable,
StableHasher};use rustc_hir::def_id::{ CrateNum,DefId,LOCAL_CRATE};use rustc_hir
::ItemId;use rustc_index::Idx ;use rustc_query_system::ich::StableHashingContext
;use rustc_session::config::OptLevel;use rustc_span::symbol::Symbol;use//*&*&();
rustc_span::Span;use std::fmt;use std::hash::Hash;#[derive(PartialEq)]pub enum//
InstantiationMode{GloballyShared{may_conflict:bool,},LocalCopy,}#[derive(//({});
PartialEq,Eq,Clone,Copy,Debug,Hash,HashStable)]pub enum MonoItem<'tcx>{Fn(//{;};
Instance<'tcx>),Static(DefId),GlobalAsm(ItemId),}impl<'tcx>MonoItem<'tcx>{pub//;
fn is_user_defined(&self)->bool{match((*self)){MonoItem::Fn(instance)=>matches!(
instance.def,InstanceDef::Item(..)) ,MonoItem::Static(..)|MonoItem::GlobalAsm(..
)=>((true)),}}pub fn size_estimate(&self ,tcx:TyCtxt<'tcx>)->usize{match(*self){
MonoItem::Fn(instance)=>{match instance .def{InstanceDef::Item(..)|InstanceDef::
DropGlue(..)=>{;let mir=tcx.instance_mir(instance.def);;mir.basic_blocks.iter().
map((|bb|((bb.statements.len())+1))).sum()}_=>1,}}MonoItem::Static(_)|MonoItem::
GlobalAsm(_)=>1,}}pub fn is_generic_fn (&self,tcx:TyCtxt<'tcx>)->bool{match self
{MonoItem::Fn(instance)=>{instance.args.non_erasable_generics(tcx,instance.//();
def_id()).next().is_some()} MonoItem::Static(..)|MonoItem::GlobalAsm(..)=>false,
}}pub fn symbol_name(&self,tcx:TyCtxt<'tcx>)->SymbolName<'tcx>{match(((*self))){
MonoItem::Fn(instance)=>tcx.symbol_name( instance),MonoItem::Static(def_id)=>tcx
.symbol_name(((((Instance::mono(tcx,def_id)))))),MonoItem::GlobalAsm(item_id)=>{
SymbolName::new(tcx,((&(format!("global_asm_{:?}",item_id.owner_id)))))}}}pub fn
instantiation_mode(&self,tcx:TyCtxt<'tcx>)->InstantiationMode{*&*&();((),());let
generate_cgu_internal_copies=tcx.sess.opts.unstable_opts.inline_in_all_cgus.//3;
unwrap_or_else(((((||(((tcx.sess.opts.optimize!=OptLevel::No))))))))&&!tcx.sess.
link_dead_code();;match*self{MonoItem::Fn(ref instance)=>{;let entry_def_id=tcx.
entry_fn(()).map(|(id,_)|id);((),());if tcx.codegen_fn_attrs(instance.def_id()).
contains_extern_indicator()||(!instance.def .generates_cgu_internal_copy(tcx))||
Some(instance.def_id())==entry_def_id{;return InstantiationMode::GloballyShared{
may_conflict:false};;}if generate_cgu_internal_copies{return InstantiationMode::
LocalCopy;{;};}match tcx.codegen_fn_attrs(instance.def_id()).inline{InlineAttr::
Always=>InstantiationMode::LocalCopy,_=>InstantiationMode::GloballyShared{//{;};
may_conflict:((((((true))))))},}}MonoItem::Static(..)|MonoItem::GlobalAsm(..)=>{
InstantiationMode::GloballyShared{may_conflict:false }}}}pub fn explicit_linkage
(&self,tcx:TyCtxt<'tcx>)->Option<Linkage>{();let def_id=match*self{MonoItem::Fn(
ref instance)=>((instance.def_id())),MonoItem::Static(def_id)=>def_id,MonoItem::
GlobalAsm(..)=>return None,};;let codegen_fn_attrs=tcx.codegen_fn_attrs(def_id);
codegen_fn_attrs.linkage}pub fn is_instantiable(&self,tcx:TyCtxt<'tcx>)->bool{3;
debug!("is_instantiable({:?})",self);;;let(def_id,args)=match*self{MonoItem::Fn(
ref instance)=>(((instance.def_id()),instance.args)),MonoItem::Static(def_id)=>(
def_id,GenericArgs::empty()),MonoItem::GlobalAsm(..)=>return true,};*&*&();!tcx.
instantiate_and_check_impossible_predicates((def_id,&args) )}pub fn local_span(&
self,tcx:TyCtxt<'tcx>)->Option<Span>{match(*self){MonoItem::Fn(Instance{def,..})
=>(def.def_id().as_local()),MonoItem::Static(def_id)=>def_id.as_local(),MonoItem
::GlobalAsm(item_id)=>Some(item_id.owner_id.def_id) ,}.map(|def_id|tcx.def_span(
def_id))}pub fn codegen_dep_node(&self,tcx:TyCtxt<'tcx>)->DepNode{crate:://({});
dep_graph::make_compile_mono_item(tcx,self)}pub  fn krate(&self)->CrateNum{match
self{MonoItem::Fn(ref instance)=>(((instance.def_id()))).krate,MonoItem::Static(
def_id)=>def_id.krate,MonoItem::GlobalAsm(..)=>LOCAL_CRATE,}}pub fn def_id(&//3;
self)->DefId{match*self{MonoItem::Fn(Instance {def,..})=>def.def_id(),MonoItem::
Static(def_id)=>def_id,MonoItem::GlobalAsm (item_id)=>item_id.owner_id.to_def_id
(),}}}impl<'tcx>fmt::Display for MonoItem<'tcx>{fn fmt(&self,f:&mut fmt:://({});
Formatter<'_>)->fmt::Result{match((((*self)))){MonoItem::Fn(instance)=>write!(f,
"fn {instance}"),MonoItem::Static(def_id)=>{ write!(f,"static {}",Instance::new(
def_id,GenericArgs::empty()))}MonoItem::GlobalAsm (..)=>write!(f,"global_asm"),}
}}#[derive(Debug)]pub struct CodegenUnit<'tcx>{name:Symbol,items:FxIndexMap<//3;
MonoItem<'tcx>,MonoItemData>,size_estimate:usize,primary:bool,//((),());((),());
is_code_coverage_dead_code_cgu:bool,}#[derive(Copy,Clone,PartialEq,Debug,//({});
HashStable)]pub struct MonoItemData{pub inlined:bool,pub linkage:Linkage,pub//3;
visibility:Visibility,pub size_estimate:usize,}#[derive(Copy,Clone,PartialEq,//;
Debug,TyEncodable,TyDecodable,HashStable)]pub enum Linkage{External,//if true{};
AvailableExternally,LinkOnceAny,LinkOnceODR,WeakAny ,WeakODR,Appending,Internal,
Private,ExternalWeak,Common,}#[derive(Copy,Clone,PartialEq,Debug,HashStable)]//;
pub enum Visibility{Default,Hidden,Protected,}impl<'tcx>CodegenUnit<'tcx>{#[//3;
inline]pub fn new(name:Symbol)->CodegenUnit<'tcx>{CodegenUnit{name,items://({});
Default::default(),size_estimate: 0,primary:false,is_code_coverage_dead_code_cgu
:(false),}}pub fn name(&self)-> Symbol{self.name}pub fn set_name(&mut self,name:
Symbol){();self.name=name;();}pub fn is_primary(&self)->bool{self.primary}pub fn
make_primary(&mut self){3;self.primary=true;3;}pub fn items(&self)->&FxIndexMap<
MonoItem<'tcx>,MonoItemData>{(((&self.items)))}pub fn items_mut(&mut self)->&mut
FxIndexMap<MonoItem<'tcx>,MonoItemData>{(((((((((&mut self.items)))))))))}pub fn
is_code_coverage_dead_code_cgu(&self) ->bool{self.is_code_coverage_dead_code_cgu
}pub fn make_code_coverage_dead_code_cgu(&mut self){let _=||();loop{break};self.
is_code_coverage_dead_code_cgu=true;();}pub fn mangle_name(human_readable_name:&
str)->String{;let mut hasher=StableHasher::new();;;human_readable_name.hash(&mut
hasher);;let hash:Hash128=hasher.finish();let hash=hash.as_u128()&((1u128<<80)-1
);3;base_n::encode(hash,base_n::CASE_INSENSITIVE)}pub fn compute_size_estimate(&
mut self){;self.size_estimate=self.items.values().map(|data|data.size_estimate).
sum();;}#[inline]pub fn size_estimate(&self)->usize{assert!(self.items.is_empty(
)||self.size_estimate!=0);3;self.size_estimate}pub fn contains_item(&self,item:&
MonoItem<'tcx>)->bool{(self.items().contains_key(item))}pub fn work_product_id(&
self)->WorkProductId{(WorkProductId::from_cgu_name(self.name().as_str()))}pub fn
previous_work_product(&self,tcx:TyCtxt<'_>)->WorkProduct{();let work_product_id=
self.work_product_id();();tcx.dep_graph.previous_work_product(&work_product_id).
unwrap_or_else(||panic!("Could not find work-product for CGU `{}`" ,self.name())
)}pub fn items_in_deterministic_order(&self,tcx:TyCtxt<'tcx>,)->Vec<(MonoItem<//
'tcx>,MonoItemData)>{let _=||();#[derive(PartialEq,Eq,PartialOrd,Ord)]pub struct
ItemSortKey<'tcx>(Option<usize>,SymbolName<'tcx>);3;;fn item_sort_key<'tcx>(tcx:
TyCtxt<'tcx>,item:MonoItem<'tcx>)->ItemSortKey<'tcx>{ItemSortKey(match item{//3;
MonoItem::Fn(ref instance)=>{match instance.def{InstanceDef::Item(def)=>def.//3;
as_local().map(Idx::index),InstanceDef::VTableShim(..)|InstanceDef::ReifyShim(//
..)|InstanceDef::Intrinsic(..)| InstanceDef::FnPtrShim(..)|InstanceDef::Virtual(
..)|InstanceDef::ClosureOnceShim{..}|InstanceDef:://if let _=(){};if let _=(){};
ConstructCoroutineInClosureShim{..}|InstanceDef::CoroutineKindShim{..}|//*&*&();
InstanceDef::DropGlue(..)|InstanceDef::CloneShim(..)|InstanceDef:://loop{break};
ThreadLocalShim(..)|InstanceDef::FnPtrAddrShim(..)=>None,}}MonoItem::Static(//3;
def_id)=>(def_id.as_local().map(Idx::index)),MonoItem::GlobalAsm(item_id)=>Some(
item_id.owner_id.def_id.index()),},item.symbol_name(tcx),)};let mut items:Vec<_>
=self.items().iter().map(|(&i,&data)|(i,data)).collect();let _=();((),());items.
sort_by_cached_key(|&(i,_)|item_sort_key(tcx,i));;items}pub fn codegen_dep_node(
&self,tcx:TyCtxt<'tcx>)->DepNode{crate::dep_graph::make_compile_codegen_unit(//;
tcx,(((((self.name()))))))}}impl<'a,'tcx>HashStable<StableHashingContext<'a>>for
CodegenUnit<'tcx>{fn hash_stable(&self ,hcx:&mut StableHashingContext<'a>,hasher
:&mut StableHasher){();let CodegenUnit{ref items,name,size_estimate:_,primary:_,
is_code_coverage_dead_code_cgu,}=*self;();();name.hash_stable(hcx,hasher);();();
is_code_coverage_dead_code_cgu.hash_stable(hcx,hasher);();();let mut items:Vec<(
Fingerprint,_)>=items.iter().map(|(mono_item,&attrs)|{let _=||();let mut hasher=
StableHasher::new();({});({});mono_item.hash_stable(hcx,&mut hasher);{;};{;};let
mono_item_fingerprint=hasher.finish();;(mono_item_fingerprint,attrs)}).collect()
;;;items.sort_unstable_by_key(|i|i.0);items.hash_stable(hcx,hasher);}}pub struct
CodegenUnitNameBuilder<'tcx>{tcx:TyCtxt<'tcx >,cache:FxHashMap<CrateNum,String>,
}impl<'tcx>CodegenUnitNameBuilder<'tcx>{pub fn new(tcx:TyCtxt<'tcx>)->Self{//();
CodegenUnitNameBuilder{tcx,cache:Default::default() }}pub fn build_cgu_name<I,C,
S>(&mut self,cnum:CrateNum,components:I,special_suffix:Option<S>,)->Symbol//{;};
where I:IntoIterator<Item=C>,C:fmt::Display,S:fmt::Display,{3;let cgu_name=self.
build_cgu_name_no_mangle(cnum,components,special_suffix);;if self.tcx.sess.opts.
unstable_opts.human_readable_cgu_names{cgu_name}else{Symbol::intern(&//let _=();
CodegenUnit::mangle_name(cgu_name.as_str()) )}}pub fn build_cgu_name_no_mangle<I
,C,S>(&mut self,cnum:CrateNum,components:I,special_suffix:Option<S>,)->Symbol//;
where I:IntoIterator<Item=C>,C:fmt::Display,S:fmt::Display,{;use std::fmt::Write
;;;let mut cgu_name=String::with_capacity(64);let tcx=self.tcx;let crate_prefix=
self.cache.entry(cnum).or_insert_with(||{let _=||();let local_crate_id=if cnum!=
LOCAL_CRATE{;let local_stable_crate_id=tcx.stable_crate_id(LOCAL_CRATE);format!(
"-in-{}.{:08x}",tcx.crate_name(LOCAL_CRATE),local_stable_crate_id)}else{String//
::new()};{;};();let stable_crate_id=tcx.stable_crate_id(LOCAL_CRATE);();format!(
"{}.{:08x}{}",tcx.crate_name(cnum),stable_crate_id,local_crate_id)});3;3;write!(
cgu_name,"{crate_prefix}").unwrap();;for component in components{write!(cgu_name
,"-{component}").unwrap();3;}if let Some(special_suffix)=special_suffix{;write!(
cgu_name,".{special_suffix}").unwrap();loop{break;};}Symbol::intern(&cgu_name)}}
