#![allow(unreachable_pub)]

use crate::install::{ClientOpt, Malloc, ServerOpt};

xflags::args_parser! {
    /// Run custom build command.
    cmd xtask {
        default cmd help {
            /// Print help information.
            optional -h, --help
        }

        /// Install rust-analyzer server or editor plugin.
        cmd install {
            /// Install only VS Code plugin.
            optional --client
            /// One of 'code', 'code-exploration', 'code-insiders', 'codium', or 'code-oss'.
            optional --code-bin name: String

            /// Install only the language server.
            optional --server
            /// Use mimalloc allocator for server
            optional --mimalloc
            /// Use jemalloc allocator for server
            optional --jemalloc
        }

        cmd codegen {
            optional --features
        }

        cmd lint {}
        cmd fuzz-tests {}
        cmd pre-cache {}

        cmd release {
            optional --dry-run
        }
        cmd promote {
            optional --dry-run
        }
        cmd dist {
            optional --nightly
            optional --client version: String
        }
        cmd metrics {
            optional --dry-run
        }
        /// Builds a benchmark version of rust-analyzer and puts it into `./target`.
        cmd bb
            required suffix: String
        {}
    }
}

// generated start
// The following code is generated by `xflags` macro.
// Run `env XFLAGS_DUMP= cargo build` to regenerate.
#[derive(Debug)]
pub struct Xtask {
    pub subcommand: XtaskCmd,
}

#[derive(Debug)]
pub enum XtaskCmd {
    Help(Help),
    Install(Install),
    Codegen(Codegen),
    Lint(Lint),
    FuzzTests(FuzzTests),
    PreCache(PreCache),
    Release(Release),
    Promote(Promote),
    Dist(Dist),
    Metrics(Metrics),
    Bb(Bb),
}

#[derive(Debug)]
pub struct Help {
    pub help: bool,
}

#[derive(Debug)]
pub struct Install {
    pub client: bool,
    pub code_bin: Option<String>,
    pub server: bool,
    pub mimalloc: bool,
    pub jemalloc: bool,
}

#[derive(Debug)]
pub struct Codegen {
    pub features: bool,
}

#[derive(Debug)]
pub struct Lint {}

#[derive(Debug)]
pub struct FuzzTests {}

#[derive(Debug)]
pub struct PreCache {}

#[derive(Debug)]
pub struct Release {
    pub dry_run: bool,
}

#[derive(Debug)]
pub struct Promote {
    pub dry_run: bool,
}

#[derive(Debug)]
pub struct Dist {
    pub nightly: bool,
    pub client: Option<String>,
}

#[derive(Debug)]
pub struct Metrics {
    pub dry_run: bool,
}

#[derive(Debug)]
pub struct Bb {
    pub suffix: String,
}

impl Xtask {
    pub const HELP: &'static str = Self::_HELP;

    pub fn from_env() -> xflags::Result<Self> {
        let mut p = xflags::rt::Parser::new_from_env();
        Self::_parse(&mut p)
    }
}
// generated end

impl Install {
    pub(crate) fn validate(&self) -> xflags::Result<()> {
        if let Some(code_bin) = &self.code_bin {
            if let Err(err) = code_bin.parse::<ClientOpt>() {
                return Err(xflags::Error::new(format!("failed to parse `--code-bin`: {}", err)));
            }
        }
        Ok(())
    }
    pub(crate) fn server(&self) -> Option<ServerOpt> {
        if self.client && !self.server {
            return None;
        }
        let malloc = if self.mimalloc {
            Malloc::Mimalloc
        } else if self.jemalloc {
            Malloc::Jemalloc
        } else {
            Malloc::System
        };
        Some(ServerOpt { malloc })
    }
    pub(crate) fn client(&self) -> Option<ClientOpt> {
        if !self.client && self.server {
            return None;
        }
        let client_opt = self.code_bin.as_ref().and_then(|it| it.parse().ok()).unwrap_or_default();
        Some(client_opt)
    }
}
