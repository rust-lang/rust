#![cfg(not(target_arch = "wasm32"))]

use core::num::flt2dec::decoder::{Decoded64, decode_f16, decode_f32, decode_f64};
use core::num::flt2dec::strategy::{dragon, grisu};
use std::mem::MaybeUninit;
use std::str;

use rand::distr::{Distribution, Uniform};

/// Compare the short representation of grisu and dragon against each other.
/// A total `n` test cases are generated by invoking `sample` with range `0..n`.
fn test_short_representation<F>(test_name: &str, n: usize, mut sample: F) -> (usize, usize)
where
    F: FnMut(usize) -> Decoded64,
{
    let mut npassed = 0;
    let mut nignored = 0;

    for i in 0..n {
        if (i & 0xfffff) == 0 {
            println!(
                "in progress, {:x}/{:x} (ignored={} passed={} failed={})",
                i,
                n,
                nignored,
                npassed,
                i - nignored - npassed
            );
        }

        let decoded = sample(i);
        let mut buf1 = [MaybeUninit::new(0); 17];
        if let Some((s1, e1)) = grisu::format_short(&decoded, &mut buf1) {
            let mut buf2 = [MaybeUninit::new(0); 17];
            let (s2, e2) = dragon::format_short(&decoded, &mut buf2);
            if e1 == e2 && s1 == s2 {
                npassed += 1;
            } else {
                println!(
                    "equivalence test failed, {i:x}/{n:x}: {decoded:?} f(i)={s1}e{e1} g(i)={s2}e{e2}"
                );
            }
        } else {
            nignored += 1;
        }
    }
    println!(
        "{}(): done, ignored={} passed={} failed={}",
        test_name,
        nignored,
        npassed,
        n - nignored - npassed
    );
    assert!(
        nignored + npassed == n,
        "{}(): {} out of {} values returns an incorrect value!",
        test_name,
        n - nignored - npassed,
        n
    );
    (npassed, nignored)
}

// Bits 0u16..0x7C00 cover the positive finite-range,
// with 1u16..0x7C00 for non-zero.
const F16_POS_FIN_RANGE: std::ops::Range<u16> = 1..0x7C00;

// Bits 0u32..0x7F80_0000 cover the positive finite-range,
// with 1u32..0x7F80_0000 for non-zero.
const F32_POS_FIN_RANGE: std::ops::Range<u32> = 1..0x7F80_000;

// Bits 0u64..0x7FF0_0000_0000_0000 cover the positive finite-range,
// With 1u64..0x7FF0_0000_0000_0000 for non-zero.
const F64_POS_FIN_RANGE: std::ops::Range<u64> = 1..0x7FF0_0000_0000_0000;

#[cfg(target_has_reliable_f16)]
pub fn f16_random_equivalence_test(n: usize) {
    let mut rng = crate::test_rng();
    let f16_range = Uniform::new(F16_POS_FIN_RANGE.start, F16_POS_FIN_RANGE.end).unwrap();
    test_short_representation("short_f16_random_equivalence", n, |_| {
        let x = f16::from_bits(f16_range.sample(&mut rng));
        assert!(x.is_finite());
        decode_f16(x)
    });
}

pub fn f32_random_equivalence_test(n: usize) {
    let mut rng = crate::test_rng();
    let f32_range = Uniform::new(F32_POS_FIN_RANGE.start, F32_POS_FIN_RANGE.end).unwrap();
    test_short_representation("short_f32_random_equivalence", n, |_| {
        let x = f32::from_bits(f32_range.sample(&mut rng));
        assert!(x.is_finite());
        decode_f32(x)
    });
}

pub fn f64_random_equivalence_test(n: usize) {
    let mut rng = crate::test_rng();
    let f64_range = Uniform::new(F64_POS_FIN_RANGE.start, F64_POS_FIN_RANGE.end).unwrap();
    test_short_representation("short_f64_random_equivalence", n, |_| {
        let x = f64::from_bits(f64_range.sample(&mut rng));
        assert!(x.is_finite());
        decode_f64(x)
    });
}

/// Half precision is narrow enough to cover all of its finite numbers.
#[test]
#[cfg_attr(miri, ignore)] // Miri is too slow
#[cfg(target_has_reliable_f16)]
fn short_f16_exhaustive_equivalence_test() {
    let (npassed, nignored) = test_short_representation(
        "short_f16_exhaustive_equivalence",
        (F16_POS_FIN_RANGE.end - F16_POS_FIN_RANGE.start) as usize,
        |i: usize| {
            let x = f16::from_bits(i as u16 + F16_POS_FIN_RANGE.start);
            assert!(x.is_finite());
            decode_f16(x)
        },
    );
    assert_eq!((npassed, nignored), (29735, 2008));
}

/// Single precision is too wide to cover all of its finite numbers.
/// There are 2^23 * (2^8 - 1) - 1 = 2,139,095,039 positive finite f32 values.
/// With `-C opt-level=3 -C lto` this takes about an hour, give or take. Use
/// `--nocapture` for progress reporting.
#[test]
#[ignore] // it is too expensive
fn short_f32_exhaustive_equivalence_test() {
    let (npassed, nignored) = test_short_representation(
        "short_f32_exhaustive_equivalence",
        (F32_POS_FIN_RANGE.end - F32_POS_FIN_RANGE.start) as usize,
        |i: usize| {
            let x = f32::from_bits(i as u32 + F32_POS_FIN_RANGE.start);
            assert!(x.is_finite());
            decode_f32(x)
        },
    );
    assert_eq!((npassed, nignored), (2121451881, 17643158));
}

#[test]
fn short_random_equivalence_test() {
    // Miri is too slow
    let n = if cfg!(miri) { 10 } else { 10_000 };

    f64_random_equivalence_test(n);
    f32_random_equivalence_test(n);
    #[cfg(target_has_reliable_f16)]
    f16_random_equivalence_test(n);
}

#[test]
#[ignore] // it is too expensive
fn short_f64_hard_random_equivalence_test() {
    // this again probably has to use appropriate rustc flags.
    f64_random_equivalence_test(100_000_000);
}

/// Compare the fixed representation of grisu and dragon against each other.
/// A total `n` test cases are generated by invoking `sample` with range `0..n`.
fn test_fixed_representation<F>(test_name: &str, bufn: usize, n: usize, mut sample: F)
where
    F: FnMut(usize) -> Decoded64,
{
    const BUF_CAP: usize = 128;
    assert!(bufn <= BUF_CAP);
    let mut npassed = 0;
    let mut nignored = 0;

    for i in 0..n {
        if (i & 0xfffff) == 0 {
            println!(
                "in progress, {:x}/{:x} (ignored={} passed={} failed={})",
                i,
                n,
                nignored,
                npassed,
                i - nignored - npassed
            );
        }

        let decoded = sample(i);
        let mut buf1 = [MaybeUninit::new(0); BUF_CAP];
        if let Some((s1, e1)) = grisu::format_fixed(&decoded, &mut buf1[..bufn], isize::MIN) {
            let mut buf2 = [MaybeUninit::new(0); BUF_CAP];
            let (s2, e2) = dragon::format_fixed(&decoded, &mut buf2[..bufn], isize::MIN);
            if e1 == e2 && s1 == s2 {
                npassed += 1;
            } else {
                println!(
                    "equivalence test failed, {i:x}/{n:x}: {decoded:?} f(i)={s1}e{e1} g(i)={s2}e{e2}"
                );
            }
        } else {
            nignored += 1;
        }
    }
    println!(
        "fixed_{}(): done, ignored={} passed={} failed={}",
        test_name,
        nignored,
        npassed,
        n - nignored - npassed
    );
    assert!(
        nignored + npassed == n,
        "{}(): {} out of {} values returns an incorrect value!",
        test_name,
        n - nignored - npassed,
        n
    );
}

#[test]
#[cfg(target_has_reliable_f16)]
fn fixed_f16_random_equivalence_test() {
    // Miri is too slow
    let n = if cfg!(miri) { 3 } else { 1_000 };
    // Run bufn times n test cases.
    for bufn in 1..21 {
        let mut rng = crate::test_rng();
        let f16_range = Uniform::new(F16_POS_FIN_RANGE.start, F16_POS_FIN_RANGE.end).unwrap();
        test_fixed_representation("fixed_f16_random_equivalence", bufn, n, |_| {
            let x = f16::from_bits(f16_range.sample(&mut rng));
            assert!(x.is_finite());
            decode_f16(x)
        });
    }
}

#[test]
fn fixed_f32_random_equivalence_test() {
    // Miri is too slow
    let n = if cfg!(miri) { 3 } else { 1_000 };
    // Run bufn times n test cases.
    for bufn in 1..21 {
        let mut rng = crate::test_rng();
        let f32_range = Uniform::new(F32_POS_FIN_RANGE.start, F32_POS_FIN_RANGE.end).unwrap();
        test_fixed_representation("fixed_f32_random_equivalence", bufn, n, |_| {
            let x = f32::from_bits(f32_range.sample(&mut rng));
            assert!(x.is_finite());
            decode_f32(x)
        });
    }
}

#[test]
fn fixed_f64_random_equivalence_test() {
    // Miri is too slow
    let n = if cfg!(miri) { 2 } else { 1_000 };
    // Run bufn times n test cases.
    for bufn in 1..21 {
        let mut rng = crate::test_rng();
        let f64_range = Uniform::new(F64_POS_FIN_RANGE.start, F64_POS_FIN_RANGE.end).unwrap();
        test_fixed_representation("fixed_f64_random_equivalence", bufn, n, |_| {
            let x = f64::from_bits(f64_range.sample(&mut rng));
            assert!(x.is_finite());
            decode_f64(x)
        });
    }
}
