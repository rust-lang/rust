arch_cfgs:
  - arch_name: aarch64
    target_feature: [neon]
    llvm_prefix: llvm.aarch64.neon
# Generate big endian shuffles
auto_big_endian: true

# We do not want to automatically generate signed/unsigned casts
auto_llvm_sign_conversion: false

# Repeatedly used anchors
# #[stable(feature = "neon_intrinsics", since = "1.59.0")]
neon-stable: &neon-stable
  FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]

# #[unstable(feature = "stdarch_arm_neon_intrinsics", issue = "111800")]
neon-unstable: &neon-unstable
  FnCall: [unstable, ['feature = "stdarch_arm_neon_intrinsics"', 'issue = "111800"']]

# #[cfg_attr(target_arch = "arm", target_feature(enable = "v7"))]
neon-v7: &neon-v7
  FnCall: [cfg_attr, ['target_arch = "arm"', { FnCall: [target_feature, [ 'enable = "v7"']]} ]]

# #[target_feature(enable = "neon,v7")]
enable-v7: &enable-v7
  FnCall: [target_feature, ['enable = "neon,v7"']]

# #[cfg_attr(target_arch = "arm", target_feature(enable = "v8"))]
neon-v8: &neon-v8
  FnCall: [cfg_attr, ['target_arch = "arm"', { FnCall: [target_feature, [ 'enable = "v8"']]} ]]

target-is-arm: &target-is-arm
  FnCall: [cfg, ['target_arch = "arm"']]

# #[cfg(not(target_arch = "arm"))]
target-not-arm: &target-not-arm
  FnCall: [cfg, [{ FnCall: [not, ['target_arch = "arm"']]}]]

neon-target-aarch64-arm64ec: &neon-target-aarch64-arm64ec
  FnCall: [all, [test, {FnCall: [any, ['target_arch = "aarch64"', 'target_arch = "arm64ec"']]}]]

# #[cfg_attr(not(target_arch = "arm"), stable(feature = "neon_intrinsics", since = "1.59.0"))]
neon-stable-not-arm: &neon-stable-not-arm
  FnCall: [cfg_attr, [{ FnCall: [not, ['target_arch = "arm"']]}, *neon-stable]]

#[cfg_attr(target_arch = "arm", unstable(feature = "stdarch_arm_neon_intrinsics", issue = "111800"))]
neon-unstable-is-arm: &neon-unstable-is-arm
  FnCall: [ cfg_attr, ['target_arch = "arm"', *neon-unstable]] 

# #[cfg_attr(all(test, not(target_env = "msvc"))]
msvc-disabled: &msvc-disabled
  FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]

# all(test, target_arch = "arm")
test-is-arm: &test-is-arm
  FnCall: [all, [test, 'target_arch = "arm"']]

# #[target_feature(enable = "neon,aes")]
neon-aes: &neon-aes
  FnCall: [target_feature, ['enable = "neon,aes"']]

# #[target_feature(enable = "neon,i8mm")]
neon-i8mm: &neon-i8mm
  FnCall: [target_feature, ['enable = "neon,i8mm"']]

# #[target_feature(enable = "neon,fp16")]
neon-fp16: &neon-fp16
  FnCall: [target_feature, ['enable = "neon,fp16"']]

# #[cfg_attr(not(target_arch = "arm"), target_feature(enable = "fhm"))]
enable-fhm: &enable-fhm
  FnCall: [cfg_attr, [{ FnCall: [not, ['target_arch = "arm"']]}, { FnCall: [target_feature, ['enable = "fhm"']] }]]

enable-fcma: &enable-fcma
  FnCall: [cfg_attr, [{ FnCall: [not, ['target_arch = "arm"']]}, { FnCall: [target_feature, ['enable = "fcma"']] }]]

#[cfg_attr(not(target_arch = "arm"), unstable(feature = "stdarch_neon_i8mm", issue = "117223"))]
neon-unstable-i8mm: &neon-unstable-i8mm
  FnCall: [cfg_attr, [{ FnCall: [not, ['target_arch = "arm"']] }, { FnCall: [unstable, ['feature = "stdarch_neon_i8mm"', 'issue = "117223"']] } ]]

# #[unstable(feature = "stdarch_neon_fcma", issue = "117222")]
neon-unstable-fcma: &neon-unstable-fcma
  FnCall: [unstable, ['feature = "stdarch_neon_fcma"', 'issue = "117222"']]

aarch64-crc-stable: &aarch64-crc-stable
  FnCall: [stable, ['feature = "stdarch_aarch64_crc32"', 'since = "1.80.0"']]

# #[unstable(feature = "stdarch_neon_f16", issue = "136306")]
neon-unstable-f16: &neon-unstable-f16
  FnCall: [unstable, ['feature = "stdarch_neon_f16"', 'issue = "136306"']]

# #[unstable(feature = "stdarch_neon_feat_lut", issue = "138050")]
neon-unstable-feat-lut: &neon-unstable-feat-lut
  FnCall: [unstable, ['feature = "stdarch_neon_feat_lut"', 'issue = "138050"']]

intrinsics:
  - name: "vaddd_{type}"
    doc: Add
    arguments: ["a: {type}", "b: {type}"]
    return_type: "{type}"
    attr: [*neon-stable]
    assert_instr: [nop]
    safety: safe
    types:
      - i64
      - u64
    compose:
      - MethodCall:
          - a
          - wrapping_add
          - - b

  - name: "veor3{neon_type.no}"
    doc: Three-way exclusive OR
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sha3"']]
      - FnCall: [stable, ['feature = "stdarch_neon_sha3"', 'since = "1.79.0"']]
    assert_instr: [eor3]
    safety: safe
    types:
      - int8x16_t
      - int16x8_t
      - int32x4_t
      - int64x2_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.crypto.eor3s.{neon_type}"
          links:
            - link: "llvm.aarch64.crypto.eor3s.{neon_type}"
              arch: aarch64,arm64ec

  - name: "veor3{neon_type.no}"
    doc: Three-way exclusive OR
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sha3"']]
      - FnCall: [stable, ['feature = "stdarch_neon_sha3"', 'since = "1.79.0"']]
    assert_instr: [eor3]
    safety: safe
    types:
      - uint8x16_t
      - uint16x8_t
      - uint32x4_t
      - uint64x2_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.crypto.eor3u.{neon_type}"
          links:
            - link: "llvm.aarch64.crypto.eor3u.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vabd{neon_type.no}"
    doc: Absolute difference between the arguments of Floating
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [fabd]
    safety: safe
    types:
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "fabd.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fabd.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vabd{type[0]}"
    doc: "Floating-point absolute difference"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[1]}"
    attr: [*neon-stable]
    assert_instr: [fabd]
    safety: safe
    types:
      - ['s_f32', 'f32']
      - ['d_f64', 'f64']
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vabd_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
                  - FnCall: ["vdup_n_{type[1]}", [b]]
            - 0

  - name: "vabd{type[0]}"
    doc: "Floating-point absolute difference"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fabd]
    safety: safe
    types:
      - ['h_f16', 'f16']
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vabd_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
                  - FnCall: ["vdup_n_{type[1]}", [b]]
            - 0

  - name: "vabdl_high{neon_type[0].noq}"
    doc: Signed Absolute difference Long
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    assert_instr: [sabdl]
    safety: safe
    types:
      - [int8x16_t, int16x8_t, int8x8_t, uint8x8_t]
    compose:
      - Let:
          - c
          - "{neon_type[2]}"
          - FnCall:
              - simd_shuffle!
              - - a
                - a
                - [8, 9, 10, 11, 12, 13, 14, 15]
      - Let:
          - d
          - "{neon_type[2]}"
          - FnCall:
              - simd_shuffle!
              - - b
                - b
                - [8, 9, 10, 11, 12, 13, 14, 15]
      - Let:
          - e
          - "{neon_type[3]}"
          - FnCall:
              - simd_cast
              - - FnCall:
                    - "vabd_{neon_type[0]}"
                    - - c
                      - d
      - FnCall:
          - simd_cast
          - - e

  - name: "vabdl_high{neon_type[0].noq}"
    doc: Signed Absolute difference Long
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall:
          - stable
          - - 'feature = "neon_intrinsics"'
            - 'since = "1.59.0"'
    assert_instr: [sabdl]
    safety: safe
    types:
      - [int16x8_t, int32x4_t, int16x4_t, uint16x4_t]
    compose:
      - Let:
          - c
          - "{neon_type[2]}"
          - FnCall:
              - simd_shuffle!
              - - a
                - a
                - [4, 5, 6, 7]
      - Let:
          - d
          - "{neon_type[2]}"
          - FnCall:
              - simd_shuffle!
              - - b
                - b
                - [4, 5, 6, 7]
      - Let:
          - e
          - "{neon_type[3]}"
          - FnCall:
              - simd_cast
              - - FnCall:
                    - "vabd_{neon_type[0]}"
                    - - c
                      - d
      - FnCall:
          - simd_cast
          - - e

  - name: "vabdl_high{neon_type[0].noq}"
    doc: Signed Absolute difference Long
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall:
          - stable
          - - 'feature = "neon_intrinsics"'
            - 'since = "1.59.0"'
    assert_instr: [sabdl]
    safety: safe
    types:
      - [int32x4_t, int64x2_t, int32x2_t, uint32x2_t]
    compose:
      - Let:
          - c
          - "{neon_type[2]}"
          - FnCall:
              - simd_shuffle!
              - - a
                - a
                - [2, 3]
      - Let:
          - d
          - "{neon_type[2]}"
          - FnCall:
              - simd_shuffle!
              - - b
                - b
                - [2, 3]
      - Let:
          - e
          - "{neon_type[3]}"
          - FnCall:
              - simd_cast
              - - FnCall:
                    - "vabd_{neon_type[0]}"
                    - - c
                      - d
      - FnCall:
          - simd_cast
          - - e

  - name: "vceq{neon_type[0].no}"
    doc: "Compare bitwise Equal (vector)"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmeq]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint64x1_t, uint64x1_t]
      - [uint64x2_t, uint64x2_t]
      - [int64x1_t, uint64x1_t]
      - [int64x2_t, uint64x2_t]
      - [poly64x1_t, uint64x1_t]
      - [poly64x2_t, uint64x2_t]
    compose:
      - FnCall: [simd_eq, [a, b]]

  - name: "vceq{neon_type[0].no}"
    doc: "Floating-point compare equal"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmeq]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - FnCall: [simd_eq, [a, b]]

  - name: "vceq{type[0]}"
    doc: "Floating-point compare equal"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "f32", "u32"]
      - ["d_f64", "f64", "u64"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vceq_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
                  - FnCall: ["vdup_n_{type[1]}", [b]]
            - '0'


  - name: "vceq{type[0]}"
    doc: "Floating-point compare equal"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["h_f16", "f16", "u16"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vceq_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
                  - FnCall: ["vdup_n_{type[1]}", [b]]
            - '0'

  - name: "vceqd_{type[0]}"
    doc: "Compare bitwise equal"
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i64", "u64", "s64"]
      - ["u64", "u64", "u64"]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vceq_{type[2]}"
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vtst{neon_type[0].no}"
    doc: "Signed compare bitwise Test bits nonzero"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmtst]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int64x1_t, uint64x1_t, 'i64x1', 'i64x1::new(0)']
      - [int64x2_t, uint64x2_t, 'i64x2', 'i64x2::new(0, 0)']
      - [poly64x1_t, uint64x1_t, 'i64x1', 'i64x1::new(0)']
      - [poly64x2_t, uint64x2_t, 'i64x2', 'i64x2::new(0, 0)']
    compose:
      - Let: [c, "{neon_type[0]}", {FnCall: [simd_and, [a, b]]}]
      - Let: [d, "{type[2]}", "{type[3]}"]
      - FnCall: [simd_ne, [c, {FnCall: [transmute, [d]]}]]

  - name: "vtstd_{type[0]}"
    doc: "Compare bitwise test bits nonzero"
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tst]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i64", "u64", "s64"]
      - ["u64", "u64", "u64"]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vtst_{type[2]}"
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vuqadd{type[0]}"
    doc: "Signed saturating accumulate of unsigned value"
    arguments: ["a: {type[1]}", "b: {type[2]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [suqadd]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_s32", "i32", "u32"]
      - ["d_s64", "i64", "u64"]
    compose:
      - LLVMLink:
          name: "vuqadd{type[0]}"
          links:
            - link: "llvm.aarch64.neon.suqadd.{type[1]}"
              arch: aarch64,arm64ec

  - name: "vuqadd{type[0]}"
    doc: "Signed saturating accumulate of unsigned value"
    arguments: ["a: {type[1]}", "b: {type[2]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [suqadd]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["b_s8", "i8", "u8", "s8"]
      - ["h_s16", "i16", "u16", "s16"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vuqadd_{type[3]}"
                - - FnCall: ["vdup_n_{type[3]}", [a]]
                  - FnCall: ["vdup_n_{type[2]}", [b]]
            - '0'

  - name: "vabs{neon_type.no}"
    doc: "Floating-point absolute value"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fabs]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - float64x1_t
      - float64x2_t
    compose:
      - FnCall: [simd_fabs, [a]]

  - name: "vcgt{neon_type[0].no}"
    doc: "Compare signed greater than"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmgt]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int64x1_t, uint64x1_t]
      - [int64x2_t, uint64x2_t]
    compose:
      - FnCall: [simd_gt, [a, b]]

  - name: "vcgt{neon_type.no}"
    doc: "Compare unsigned greater than"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmhi]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - uint64x1_t
      - uint64x2_t
    compose:
      - FnCall: [simd_gt, [a, b]]

  - name: "vcgt{neon_type[0].no}"
    doc: "Floating-point compare greater than"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmgt]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - FnCall: [simd_gt, [a, b]]

  - name: "vcgt{type[0]}"
    doc: "Floating-point compare greater than"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "f32", "u32"]
      - ["d_f64", "f64", "u64"]
    compose:
      - FnCall:
          - 'simd_extract!'
          - - FnCall:
                - "vcgt_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
                  - FnCall: ["vdup_n_{type[1]}", [b]]
            - '0'


  - name: "vcgt{type[0]}"
    doc: "Floating-point compare greater than"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["h_f16", "f16", "u16"]
    compose:
      - FnCall:
          - 'simd_extract!'
          - - FnCall:
                - "vcgt_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
                  - FnCall: ["vdup_n_{type[1]}", [b]]
            - '0'

  - name: "vclt{neon_type[0].no}"
    doc: "Compare signed less than"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmgt]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int64x1_t, uint64x1_t]
      - [int64x2_t, uint64x2_t]
    compose:
      - FnCall: [simd_lt, [a, b]]

  - name: "vcle{neon_type[0].no}"
    doc: "Compare signed less than or equal"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmge]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int64x1_t, uint64x1_t]
      - [int64x2_t, uint64x2_t]
    compose:
      - FnCall: [simd_le, [a, b]]

  - name: "vcle{neon_type[0].no}"
    doc: "Floating-point compare less than or equal"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmge]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - FnCall: [simd_le, [a, b]]

  - name: "vcle{type[0]}"
    doc: "Floating-point compare less than or equal"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "f32", "u32"]
      - ["d_f64", "f64", "u64"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vcle_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
                  - FnCall: ["vdup_n_{type[1]}", [b]]
            - '0'


  - name: "vcle{type[0]}"
    doc: "Floating-point compare less than or equal"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["h_f16", "f16", "u16"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vcle_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
                  - FnCall: ["vdup_n_{type[1]}", [b]]
            - '0'

  - name: "vcge{neon_type[0].no}"
    doc: "Compare signed greater than or equal"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmge]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int64x1_t, uint64x1_t]
      - [int64x2_t, uint64x2_t]
    compose:
      - FnCall: [simd_ge, [a, b]]

  - name: "vcgez{neon_type[0].no}"
    doc: "Compare signed greater than or equal to zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmge]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, uint8x8_t, i8x8, 'i8x8::new(0, 0, 0, 0, 0, 0, 0, 0)']
      - [int8x16_t, uint8x16_t, i8x16, 'i8x16::new(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)']
      - [int16x4_t, uint16x4_t, i16x4, 'i16x4::new(0, 0, 0, 0)']
      - [int16x8_t, uint16x8_t, i16x8, 'i16x8::new(0, 0, 0, 0, 0, 0, 0, 0)']
      - [int32x2_t, uint32x2_t, i32x2, 'i32x2::new(0, 0)']
      - [int32x4_t, uint32x4_t, i32x4, 'i32x4::new(0, 0, 0, 0)']
      - [int64x1_t, uint64x1_t, i64x1, 'i64x1::new(0)']
      - [int64x2_t, uint64x2_t, i64x2, 'i64x2::new(0, 0)']
    compose:
      - Let: [b, "{type[2]}", "{type[3]}"]
      - FnCall: [simd_ge, [a, {FnCall: [transmute, [b]]}]]

  - name: "vcgezd_s64"
    doc: "Compare signed greater than or equal to zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i64", "u64"]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - vcgez_s64
                - - FnCall: [transmute, [a]]

  - name: "vclez{neon_type[0].no}"
    doc: "Compare signed less than or equal to zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmle]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, uint8x8_t, i8x8, 'i8x8::new(0, 0, 0, 0, 0, 0, 0, 0)']
      - [int8x16_t, uint8x16_t, i8x16, 'i8x16::new(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)']
      - [int16x4_t, uint16x4_t, i16x4, 'i16x4::new(0, 0, 0, 0)']
      - [int16x8_t, uint16x8_t, i16x8, 'i16x8::new(0, 0, 0, 0, 0, 0, 0, 0)']
      - [int32x2_t, uint32x2_t, i32x2, 'i32x2::new(0, 0)']
      - [int32x4_t, uint32x4_t, i32x4, 'i32x4::new(0, 0, 0, 0)']
      - [int64x1_t, uint64x1_t, i64x1, 'i64x1::new(0)']
      - [int64x2_t, uint64x2_t, i64x2, 'i64x2::new(0, 0)']
    compose:
      - Let: [b, "{type[2]}", "{type[3]}"]
      - FnCall:
          - simd_le
          - - a
            - FnCall: [transmute, [b]]

  - name: "vclez{neon_type[0].no}"
    doc: "Floating-point compare less than or equal to zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmle]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, uint32x2_t, f32x2, 'f32x2::new(0.0, 0.0)']
      - [float32x4_t, uint32x4_t, f32x4, 'f32x4::new(0.0, 0.0, 0.0, 0.0)']
      - [float64x1_t, uint64x1_t, f64, '0.0']
      - [float64x2_t, uint64x2_t, f64x2, 'f64x2::new(0.0, 0.0)']
    compose:
      - Let: [b, "{type[2]}", "{type[3]}"]
      - FnCall:
          - simd_le
          - - a
            - FnCall: [transmute, [b]]

  - name: "vclez{type[0]}"
    doc: "Floating-point compare less than or equal to zero"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "f32", "u32"]
      - ["d_f64", "f64", "u64"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vclez_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
            - '0'

  - name: "vclez{type[0]}"
    doc: "Floating-point compare less than or equal to zero"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["h_f16", "f16", "u16"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vclez_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
            - '0'

  - name: "vcltz{neon_type[0].no}"
    doc: "Compare signed less than zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmlt]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, uint8x8_t, i8x8, 'i8x8::new(0, 0, 0, 0, 0, 0, 0, 0)']
      - [int8x16_t, uint8x16_t, i8x16, 'i8x16::new(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)']
      - [int16x4_t, uint16x4_t, i16x4, 'i16x4::new(0, 0, 0, 0)']
      - [int16x8_t, uint16x8_t, i16x8, 'i16x8::new(0, 0, 0, 0, 0, 0, 0, 0)']
      - [int32x2_t, uint32x2_t, i32x2, 'i32x2::new(0, 0)']
      - [int32x4_t, uint32x4_t, i32x4, 'i32x4::new(0, 0, 0, 0)']
      - [int64x1_t, uint64x1_t, i64x1, 'i64x1::new(0)']
      - [int64x2_t, uint64x2_t, i64x2, 'i64x2::new(0, 0)']
    compose:
      - Let: [b, "{type[2]}", "{type[3]}"]
      - FnCall:
          - simd_lt
          - - a
            - FnCall: [transmute, [b]]

  - name: "vcltz{neon_type[0].no}"
    doc: "Floating-point compare less than zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmlt]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, uint32x2_t, f32x2, 'f32x2::new(0.0, 0.0)']
      - [float32x4_t, uint32x4_t, f32x4, 'f32x4::new(0.0, 0.0, 0.0, 0.0)']
      - [float64x1_t, uint64x1_t, f64, '0.0']
      - [float64x2_t, uint64x2_t, f64x2, 'f64x2::new(0.0, 0.0)']
    compose:
      - Let: [b, "{type[2]}", "{type[3]}"]
      - FnCall:
          - simd_lt
          - - a
            - FnCall: [transmute, [b]]

  - name: "vcltz{type[0]}"
    doc: "Floating-point compare less than zero"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "f32", "u32"]
      - ["d_f64", "f64", "u64"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vcltz_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
            - '0'

  - name: "vcltz{type[0]}"
    doc: "Floating-point compare less than zero"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["h_f16", "f16", "u16"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vcltz_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
            - '0'

  - name: "vcltzd_s64"
    doc: "Compare less than zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [asr]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i64", "u64"]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - vcltz_s64
                - - FnCall: [transmute, [a]]

  - name: "vcagt{neon_type[0].no}"
    doc: "Floating-point absolute compare greater than"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [facgt]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - LLVMLink:
          name: "vcagt{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.facgt.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vcagt{type[0]}"
    doc: "Floating-point absolute compare greater than"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [facgt]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "f32", "u32", i32]
      - ["d_f64", "f64", "u64", i64]
    compose:
      - LLVMLink:
          name: "vcagt{type[0]}"
          links:
            - link: "llvm.aarch64.neon.facgt.{type[3]}.{type[1]}"
              arch: aarch64,arm64ec

  - name: "vcagt{type[0]}"
    doc: "Floating-point absolute compare greater than"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [facgt]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["h_f16", "f16", "u16", i32]
    compose:
      - LLVMLink:
          name: "vcagt{type[0]}"
          return_type: "{type[3]}"
          links:
            - link: "llvm.aarch64.neon.facgt.{type[3]}.{type[1]}"
              arch: aarch64,arm64ec
      - 'unsafe {{ _vcagth_f16(a, b) as u16 }}'

  - name: "vcage{neon_type[0].no}"
    doc: "Floating-point absolute compare greater than or equal"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [facge]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - LLVMLink:
          name: "vcage{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.facge.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vcage{type[0]}"
    doc: "Floating-point absolute compare greater than or equal"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [facge]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "f32", "u32", i32]
      - ["d_f64", "f64", "u64", i64]
    compose:
      - LLVMLink:
          name: "vcage{type[0]}"
          links:
            - link: "llvm.aarch64.neon.facge.{type[3]}.{type[1]}"
              arch: aarch64,arm64ec


  - name: "vcage{type[0]}"
    doc: "Floating-point absolute compare greater than or equal"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [facge]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["h_f16", "f16", "u16", i32]
    compose:
      - LLVMLink:
          name: "vcage{type[0]}"
          return_type: "{type[3]}"
          links:
            - link: "llvm.aarch64.neon.facge.{type[3]}.{type[1]}"
              arch: aarch64,arm64ec
      - "unsafe {{ _vcageh_f16(a, b) as u16 }}"

  - name: "vcalt{neon_type[0].no}"
    doc: "Floating-point absolute compare less than"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [facgt]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - FnCall: ["vcagt{neon_type[0].no}", [b, a]]

  - name: "vcalt{type[0]}"
    doc: "Floating-point absolute compare less than"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [facgt]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "f32", "u32"]
      - ["d_f64", "f64", "u64"]
    compose:
      - FnCall: ["vcagt{type[0]}", [b, a]]

  - name: "vcalt{type[0]}"
    doc: "Floating-point absolute compare less than"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [facgt]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["h_f16", "f16", "u16"]
    compose:
      - FnCall: ["vcagt{type[0]}", [b, a]]

  - name: "vcale{neon_type[0].no}"
    doc: "Floating-point absolute compare less than or equal"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [facge]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - FnCall: ["vcage{neon_type[0].no}", [b, a]]

  - name: "vcale{type[0]}"
    doc: "Floating-point absolute compare less than or equal"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [facge]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "f32", "u32"]
      - ["d_f64", "f64", "u64"]
    compose:
      - FnCall: ["vcage{type[0]}", [b, a]]

  - name: "vcale{type[0]}"
    doc: "Floating-point absolute compare less than or equal"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [facge]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["h_f16", "f16", "u16"]
    compose:
      - FnCall: ["vcage{type[0]}", [b, a]]

  - name: "vcvt{neon_type[1].no}_{neon_type[0]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [scvtf]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int64x1_t, float64x1_t]
      - [int64x2_t, float64x2_t]
    compose:
      - FnCall: [simd_cast, [a]]

  - name: "vcvt{type[0]}_{type[3]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [scvtf]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "i32", "f32", s32]
      - ["d_f64", "i64", "f64", s64]
    compose:
      - Identifier: ["a as {type[2]}", Symbol]

  - name: "vcvt{neon_type[1].no}_{neon_type[0]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ucvtf]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint64x1_t, float64x1_t]
      - [uint64x2_t, float64x2_t]
    compose:
      - FnCall: [simd_cast, [a]]

  - name: "vcvt{type[2]}_{type[0]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ucvtf]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["u32", "f32", "s_f32"]
      - ["u64", "f64", "d_f64"]
    compose:
      - Identifier: ["a as {type[1]}", Symbol]

  - name: "vcvt{neon_type[1].N}_{neon_type[0]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [scvtf, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int64x1_t, float64x1_t]
      - [int64x2_t, float64x2_t]
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 64']]
      - LLVMLink:
          name: "vcvt{neon_type[1].N}_{neon_type[0]}"
          arguments:
            - "a: {neon_type[0]}"
            - "n: i32"
          links:
            - link: "llvm.aarch64.neon.vcvtfxs2fp.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vcvt{neon_type[1].N}_{neon_type[0]}", [a, N], [], true]


  - name: "vcvt{type[2]}_n_{type[1]}_{type[0]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [scvtf, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [i32, f16, 'h']
      - [i64, f16, 'h']
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 16']]
      - LLVMLink:
          name: "vcvt{type[2]}_n_{type[1]}_{type[0]}"
          arguments:
            - "a: {type[0]}"
            - "n: i32"
          links:
            - link: "llvm.aarch64.neon.vcvtfxs2fp.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vcvt{type[2]}_n_{type[1]}_{type[0]}", [a, N], [], true]


  - name: "vcvt{type[2]}_n_{type[1]}_{type[0]}"
    doc: "Floating-point convert to fixed-point, rounding toward zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[4]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzs, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [f16, s16, 'h', i32, i16]
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 16']]
      - "vcvt{type[2]}_n_{type[3]}_{type[0]}::<N>(a) as i16"

  - name: "vcvt{type[2]}_n_{type[1]}_{type[0]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ucvtf, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [u32, f16, 'h']
      - [u64, f16, 'h']
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 16']]
      - LLVMLink:
          name: "vcvt{type[2]}_n_{type[1]}_{type[0]}"
          arguments:
            - "a: {type[0]}"
            - "n: i32"
          links:
            - link: "llvm.aarch64.neon.vcvtfxu2fp.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vcvt{type[2]}_n_{type[1]}_{type[0]}", [a, N], [], true]


  - name: "vcvt{type[2]}_n_{type[1]}_{type[0]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [scvtf, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [i16, f16, 'h', 'i32', 'as i32']
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 16']]
      - "vcvt{type[2]}_n_{type[1]}_{type[3]}::<N>(a {type[4]}) as {type[1]}"


  - name: "vcvt{type[2]}_n_{type[1]}_{type[0]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ucvtf, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [u16, f16, 'h', u32]
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 16']]
      - "vcvt{type[2]}_n_{type[1]}_{type[3]}::<N>(a as {type[3]}) as {type[1]}"


  - name: "vcvt{type[2]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [scvtf, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["i32", "f32", 's_n_f32_s32', 'N >= 1 && N <= 32']
      - ["i64", "f64", 'd_n_f64_s64', 'N >= 1 && N <= 64']
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 64']]
      - LLVMLink:
          name: "vcvt{type[2]}"
          arguments:
            - "a: {type[0]}"
            - "n: i32"
          links:
            - link: "llvm.aarch64.neon.vcvtfxs2fp.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vcvt{type[2]}", [a, N], [], true]


  - name: "vcvt{neon_type[1].N}_{neon_type[0]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ucvtf, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [uint64x1_t, float64x1_t]
      - [uint64x2_t, float64x2_t]
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 64']]
      - LLVMLink:
          name: "vcvt{neon_type[1].N}_{neon_type[0]}"
          arguments:
            - "a: {neon_type[0]}"
            - "n: i32"
          links:
            - link: "llvm.aarch64.neon.vcvtfxu2fp.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vcvt{neon_type[1].N}_{neon_type[0]}", ["a", N], [], true]

  - name: "vcvt{type[2]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ucvtf, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["u32", "f32", 's_n_f32_u32', 'N >= 1 && N <= 32']
      - ["u64", "f64", 'd_n_f64_u64', 'N >= 1 && N <= 64']
    compose:
      - FnCall: [static_assert!, ["{type[3]}"]]
      - LLVMLink:
          name: "vcvt{type[2]}"
          arguments:
            - "a: {type[0]}"
            - "n: i32"
          links:
            - link: "llvm.aarch64.neon.vcvtfxu2fp.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vcvt{type[2]}", ["a", N], [], true]

  - name: "vcvt{type[2]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzs]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["f32", "i32", "s_s32_f32", "32"]
      - ["f64", "i64", "d_s64_f64", "64"]
    compose:
      - Identifier: ["a as i{type[3]}", Symbol]

  - name: "vcvt{type[2]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzu]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["f32", "u32", "s_u32_f32"]
      - ["f64", "u64", "d_u64_f64"]
    compose:
      - Identifier: ["a as {type[1]}", Symbol]


  - name: "vcvt{type[2]}"
    doc: "Fixed-point convert to floating-point"
    arguments: ["a: {type[3]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [scvtf]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["s16", "f16", "h_f16_s16", i16]
      - ["s32", "f16", "h_f16_s32", i32]
      - ["s64", "f16", "h_f16_s64", i64]
    compose:
      - Identifier: ["a as {type[1]}", Symbol]

  - name: "vcvt{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to signed fixed-point"
    arguments: ["a: {type[0]}"]
    return_type: "{type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzs]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "s16", "h", i16, 'a as i16']
      - ["f16", "s32", "h", i32, 'a as i32']
      - ["f16", "s64", "h", i64, 'a as i64']
    compose:
      - Identifier: ["{type[4]}", Symbol]

  - name: "vcvt{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to unsigned fixed-point"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzu]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "u16", "h", 'a as u16']
      - ["f16", "u32", "h", 'a as u32']
      - ["f16", "u64", "h", 'a as u64']
    compose:
      - Identifier: ["{type[3]}", Symbol]


  - name: "vcvt{type[2]}"
    doc: "Unsigned fixed-point convert to floating-point"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ucvtf]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["u16", "f16", "h_f16_u16"]
      - ["u32", "f16", "h_f16_u32"]
      - ["u64", "f16", "h_f16_u64"]
    compose:
      - Identifier: ["a as {type[1]}", Symbol]


  - name: "vcvt_f64_f32"
    doc: "Floating-point convert to higher precision long"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, float64x2_t]
    compose:
      - FnCall: [simd_cast, [a]]

  - name: "vcvt_high_f64_f32"
    doc: "Floating-point convert to higher precision long"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x4_t, float64x2_t]
    compose:
      - Let:
          - b
          - float32x2_t
          - FnCall:
              - simd_shuffle!
              - - a
                - a
                - '[2, 3]'
      - FnCall: [simd_cast, [b]]

  - name: "vcvt_high_f16_f32"
    doc: "Floating-point convert to lower precision"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtn2]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [float16x8_t, float16x4_t, float32x4_t]
    compose:
      - FnCall:
          - vcombine_f16
          - - a
            - FnCall: [vcvt_f16_f32, [b]]

  - name: "vcvt_high_f32_f16"
    doc: "Floating-point convert to higher precision"
    arguments: ["a: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtl2]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [float32x4_t, float16x8_t]
    compose:
      - FnCall:
          - vcvt_f32_f16
          - - FnCall: [vget_high_f16, [a]]


  - name: "vcvt_f32_f64"
    doc: "Floating-point convert"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtn]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x2_t, float32x2_t]
    compose:
      - FnCall: [simd_cast, [a]]

  - name: "vcvt_high_f32_f64"
    doc: "Floating-point convert to lower precision narrow"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtn]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, float64x2_t, float32x4_t]
    compose:
      - FnCall:
          - simd_shuffle!
          - - a
            - FnCall: [simd_cast, [b]]
            - '[0, 1, 2, 3]'

  - name: "vcvtx_f32_f64"
    doc: "Floating-point convert to lower precision narrow, rounding to odd"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtxn]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x2_t, float32x2_t]
    compose:
      - LLVMLink:
          name: "vcvtx_f32_f64"
          links:
            - link: "llvm.aarch64.neon.fcvtxn.v2f32.v2f64"
              arch: aarch64,arm64ec

  - name: "vcvtxd_f32_f64"
    doc: "Floating-point convert to lower precision narrow, rounding to odd"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtxn]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["f64", "f32"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - vcvtx_f32_f64
                - - FnCall: [vdupq_n_f64, [a]]
            - '0'

  - name: "vcvtx_high_f32_f64"
    doc: "Floating-point convert to lower precision narrow, rounding to odd"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtxn]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, float64x2_t, float32x4_t]
    compose:
      - FnCall:
          - simd_shuffle!
          - - a
            - FnCall: [vcvtx_f32_f64, [b]]
            - '[0, 1, 2, 3]'

  - name: "vcvt{type[2]}"
    doc: "Floating-point convert to fixed-point, rounding toward zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzs, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [float64x1_t, int64x1_t, _n_s64_f64, '64']
      - [float64x2_t, int64x2_t, q_n_s64_f64, '64']
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= {type[3]}']]
      - LLVMLink:
          name: "vcvt{type[2]}"
          arguments: ["a: {type[0]}", "n: i32"]
          links:
            - link: "llvm.aarch64.neon.vcvtfp2fxs.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vcvt{type[2]}", [a, N], [], true]

  - name: "vcvt{type[2]}"
    doc: "Floating-point convert to fixed-point, rounding toward zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzs, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["f32", "i32", s_n_s32_f32, '32']
      - ["f64", "i64", d_n_s64_f64, '64']
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= {type[3]}']]
      - LLVMLink:
          name: "vcvt{type[2]}"
          arguments: ["a: {type[0]}", "n: i32"]
          links:
            - link: "llvm.aarch64.neon.vcvtfp2fxs.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vcvt{type[2]}", [a, N], [], true]


  - name: "vcvt{type[2]}_n_{type[1]}_{type[0]}"
    doc: "Floating-point convert to fixed-point, rounding toward zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzs, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["f16", "i32", 'h', '16']
      - ["f16", "i64", 'h', '16']
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= {type[3]}']]
      - LLVMLink:
          name: "vcvt{type[2]}_n_{type[1]}_{type[0]}"
          arguments: ["a: {type[0]}", "n: i32"]
          links:
            - link: "llvm.aarch64.neon.vcvtfp2fxs.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vcvt{type[2]}_n_{type[1]}_{type[0]}", [a, N], [], true]


  - name: "vcvt{type[2]}_n_{type[1]}_{type[0]}"
    doc: "Floating-point convert to fixed-point, rounding toward zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzu, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [f16, u16, 'h', u32]
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 16']]
      - "vcvt{type[2]}_n_{type[3]}_{type[0]}::<N>(a) as {type[1]}"


  - name: "vcvt{type[2]}_n_{type[1]}_{type[0]}"
    doc: "Floating-point convert to fixed-point, rounding toward zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzu, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["f16", "u32", 'h', '16']
      - ["f16", "u64", 'h', '16']
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= {type[3]}']]
      - LLVMLink:
          name: "vcvt{type[2]}_n_{type[1]}_{type[0]}"
          arguments: ["a: {type[0]}", "n: i32"]
          links:
            - link: "llvm.aarch64.neon.vcvtfp2fxu.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vcvt{type[2]}_n_{type[1]}_{type[0]}", [a, N], [], true]

  - name: "vcvt{type[2]}"
    doc: "Floating-point convert to fixed-point, rounding toward zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzu, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [float64x1_t, uint64x1_t, _n_u64_f64, '64']
      - [float64x2_t, uint64x2_t, q_n_u64_f64, '64']
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= {type[3]}']]
      - LLVMLink:
          name: "vcvt{type[2]}"
          arguments: ["a: {type[0]}", "n: i32"]
          links:
            - link: "llvm.aarch64.neon.vcvtfp2fxu.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vcvt{type[2]}", [a, N], [], true]

  - name: "vcvt{type[2]}"
    doc: "Floating-point convert to fixed-point, rounding toward zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzu, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["f32", "u32", s_n_u32_f32, '32']
      - ["f64", "u64", d_n_u64_f64, '64']
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= {type[3]}']]
      - LLVMLink:
          name: "vcvt{type[2]}"
          arguments: ["a: {type[0]}", "n: i32"]
          links:
            - link: "llvm.aarch64.neon.vcvtfp2fxu.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vcvt{type[2]}", [a, N], [], true]

  - name: "vcvta{type[2]}"
    doc: "Floating-point convert to signed integer, rounding to nearest with ties to away"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtas]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, int32x2_t, _s32_f32]
      - [float32x4_t, int32x4_t, q_s32_f32]
      - [float64x1_t, int64x1_t, _s64_f64]
      - [float64x2_t, int64x2_t, q_s64_f64]
    compose:
      - LLVMLink:
          name: "vcvta{type[2]}"
          links:
            - link: "llvm.aarch64.neon.fcvtas.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvta{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to signed integer, rounding to nearest with ties to away"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtas]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [float16x4_t, int16x4_t]
      - [float16x8_t, int16x8_t]
    compose:
      - LLVMLink:
          name: "vcvta_{neon_type[1]}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtas.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvta{type[2]}"
    doc: "Floating-point convert to integer, rounding to nearest with ties to away"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtas]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["f32", "i32", 's_s32_f32']
      - ["f64", "i64", 'd_s64_f64']
    compose:
      - LLVMLink:
          name: "vcvta{type[2]}"
          links:
            - link: "llvm.aarch64.neon.fcvtas.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvta{type[2]}"
    doc: "Floating-point convert to integer, rounding to nearest with ties to away"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtau]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "u32", 'h_u32_f16']
      - ["f16", "u64", 'h_u64_f16']

    compose:
      - LLVMLink:
          name: "vcvta{type[2]}"
          links:
            - link: "llvm.aarch64.neon.fcvtau.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvta{type[2]}"
    doc: "Floating-point convert to integer, rounding to nearest with ties to away"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtas]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "i32", 'h_s32_f16']
      - ["f16", "i64", 'h_s64_f16']
    compose:
      - LLVMLink:
          name: "vcvta{type[2]}"
          return_type: "{type[1]}"
          links:
            - link: "llvm.aarch64.neon.fcvtas.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvta{type[2]}"
    doc: "Floating-point convert to integer, rounding to nearest with ties to away"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtas]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "i16", 'h_s16_f16', 's32']
    compose:
      - 'vcvtah_{type[3]}_f16(a) as i16'

  - name: "vcvta{type[2]}"
    doc: "Floating-point convert to integer, rounding to nearest with ties to away"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtau]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "u16", 'h_u16_f16', 'u32']
    compose:
      - 'vcvtah_{type[3]}_f16(a) as u16'

  - name: "vcvta{type[2]}"
    doc: "Floating-point convert to integer, rounding to nearest with ties to away"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtau]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["f32", "u32", 's_u32_f32']
      - ["f64", "u64", 'd_u64_f64']
    compose:
      - LLVMLink:
          name: "vcvta{type[2]}"
          links:
            - link: "llvm.aarch64.neon.fcvtau.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtn{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to signed integer, rounding to nearest with ties to even"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtns]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, int32x2_t]
      - [float32x4_t, int32x4_t]
      - [float64x1_t, int64x1_t]
      - [float64x2_t, int64x2_t]
    compose:
      - LLVMLink:
          name: "vcvtn{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtns.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtn{type[2]}"
    doc: "Floating-point convert to signed integer, rounding to nearest with ties to even"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtns]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["f32", "i32", 's_s32_f32']
      - ["f64", "i64", 'd_s64_f64']
    compose:
      - LLVMLink:
          name: "vcvtn{type[2]}"
          links:
            - link: "llvm.aarch64.neon.fcvtns.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvtn{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to signed integer, rounding to nearest with ties to even"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtns]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [float16x4_t, int16x4_t]
      - [float16x8_t, int16x8_t]
    compose:
      - LLVMLink:
          name: "vcvtn{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtns.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvtn{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to unsigned integer, rounding to nearest with ties to even"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtnu]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [float16x4_t, uint16x4_t]
      - [float16x8_t, uint16x8_t]
    compose:
      - LLVMLink:
          name: "vcvtn{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtnu.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtn{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to integer, rounding to nearest with ties to even"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtns]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "i32", 'h']
      - ["f16", "i64", 'h']
    compose:
      - LLVMLink:
          name: "vcvtm{type[2]}_{type[1]}_{type[0]}"
          return_type: "{type[1]}"
          links:
            - link: "llvm.aarch64.neon.fcvtns.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtn{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to integer, rounding to nearest with ties to even"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtns]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "i16", 'h', 'i32']
    compose:
      - 'vcvtnh_{type[3]}_f16(a) as i16'


  - name: "vcvtn{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to unsigned integer, rounding to nearest with ties to even"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtnu]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "u32", 'h']
      - ["f16", "u64", 'h']
    compose:
      - LLVMLink:
          name: "vcvtm{type[2]}_{type[1]}_{type[0]}"
          return_type: "{type[1]}"
          links:
            - link: "llvm.aarch64.neon.fcvtnu.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtn{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to unsigned integer, rounding to nearest with ties to even"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtnu]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "u16", 'h', 'u32']
    compose:
      - 'vcvtnh_{type[3]}_f16(a) as u16'

  - name: "vcvtm{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to signed integer, rounding toward minus infinity"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtms]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, int32x2_t]
      - [float32x4_t, int32x4_t]
      - [float64x1_t, int64x1_t]
      - [float64x2_t, int64x2_t]
    compose:
      - LLVMLink:
          name: "vcvtm{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtms.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvtm{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to signed integer, rounding toward minus infinity"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtms]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [float16x4_t, int16x4_t]
      - [float16x8_t, int16x8_t]
    compose:
      - LLVMLink:
          name: "vcvtm{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtms.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvtm{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to unsigned integer, rounding toward minus infinity"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtmu]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [float16x4_t, uint16x4_t]
      - [float16x8_t, uint16x8_t]
    compose:
      - LLVMLink:
          name: "vcvtm{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtmu.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvtm{type[2]}"
    doc: "Floating-point convert to signed integer, rounding toward minus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtms]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["f32", "i32", 's_s32_f32']
      - ["f64", "i64", 'd_s64_f64']
    compose:
      - LLVMLink:
          name: "vcvtm{type[2]}"
          links:
            - link: "llvm.aarch64.neon.fcvtms.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtp{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to signed integer, rounding toward plus infinity"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtps]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, int32x2_t]
      - [float32x4_t, int32x4_t]
      - [float64x1_t, int64x1_t]
      - [float64x2_t, int64x2_t]
    compose:
      - LLVMLink:
          name: "vcvtp{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtps.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtp{type[2]}"
    doc: "Floating-point convert to signed integer, rounding toward plus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtps]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["f32", "i32", 's_s32_f32']
      - ["f64", "i64", 'd_s64_f64']
    compose:
      - LLVMLink:
          name: "vcvtp{type[2]}"
          links:
            - link: "llvm.aarch64.neon.fcvtps.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtn{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to unsigned integer, rounding to nearest with ties to even"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtnu]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, uint32x2_t]
      - [float32x4_t, uint32x4_t]
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - LLVMLink:
          name: "vcvtn{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtnu.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtn{type[2]}"
    doc: "Floating-point convert to unsigned integer, rounding to nearest with ties to even"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtnu]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["f32", "u32", 's_u32_f32']
      - ["f64", "u64", 'd_u64_f64']
    compose:
      - LLVMLink:
          name: "vcvtn{type[2]}"
          links:
            - link: "llvm.aarch64.neon.fcvtnu.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtm{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to unsigned integer, rounding toward minus infinity"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtmu]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, uint32x2_t]
      - [float32x4_t, uint32x4_t]
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - LLVMLink:
          name: "vcvtm{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtmu.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtm{type[2]}"
    doc: "Floating-point convert to unsigned integer, rounding toward minus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtmu]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["f32", "u32", s_u32_f32]
      - ["f64", "u64", d_u64_f64]
    compose:
      - LLVMLink:
          name: "vcvtm{type[2]}"
          links:
            - link: "llvm.aarch64.neon.fcvtmu.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtp{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to unsigned integer, rounding toward plus infinity"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtpu]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, uint32x2_t]
      - [float32x4_t, uint32x4_t]
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - LLVMLink:
          name: "vcvtp{neon_type[1].no}_{neon_type[1]}"
          links:
            - link: "llvm.aarch64.neon.fcvtpu.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtp{type[2]}"
    doc: "Floating-point convert to unsigned integer, rounding toward plus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtpu]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["f32", "u32", s_u32_f32, 'i32']
      - ["f64", "u64", d_u64_f64, 'u64']
    compose:
      - LLVMLink:
          name: "vcvtp{type[2]}"
          arguments:
            - "a: {type[0]}"
          return_type: "{type[1]}"
          links:
            - link: "llvm.aarch64.neon.fcvtpu.{type[3]}.{type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvtp{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to signed integer, rounding to plus infinity"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtps]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [float16x4_t, int16x4_t]
      - [float16x8_t, int16x8_t]
    compose:
      - LLVMLink:
          name: "vcvtp{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtps.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvtp{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to unsigned integer, rounding to plus infinity"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtpu]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [float16x4_t, uint16x4_t]
      - [float16x8_t, uint16x8_t]
    compose:
      - LLVMLink:
          name: "vcvtp{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtpu.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvtp{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to integer, rounding to plus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtps]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "i32", 'h']
      - ["f16", "i64", 'h']
    compose:
      - LLVMLink:
          name: "vcvtp{type[2]}_{type[1]}_{type[0]}"
          return_type: "{type[1]}"
          links:
            - link: "llvm.aarch64.neon.fcvtps.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtp{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to integer, rounding to plus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtps]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "i16", 'h', 'i32']
    compose:
      - 'vcvtph_{type[3]}_f16(a) as i16'

  - name: "vcvtp{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to unsigned integer, rounding to plus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtpu]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "u32", 'h']
      - ["f16", "u64", 'h']
    compose:
      - LLVMLink:
          name: "vcvtp{type[2]}_{type[1]}_{type[0]}"
          return_type: "{type[1]}"
          links:
            - link: "llvm.aarch64.neon.fcvtpu.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtp{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to unsigned integer, rounding to plus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtpu]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "u16", 'h', 'u32']
    compose:
      - 'vcvtph_{type[3]}_f16(a) as u16'

  - name: "vdup{neon_type.laneq_nox}"
    doc: "Set all vector lanes to the same value"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [dup, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - poly64x2_t
      - float64x2_t
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, 1]]
      - FnCall: [simd_shuffle!, [a, a, '[N as u32, N as u32]']]

  - name: "vdup{neon_type[1].lane_nox}"
    doc: "Set all vector lanes to the same value"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [dup, 'N = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [poly64x1_t, poly64x2_t]
      - [float64x1_t, float64x2_t]
    compose:
      - FnCall: [static_assert!, ['N == 0']]
      - FnCall: [simd_shuffle!, [a, a, '[N as u32, N as u32]']]

  - name: "vdup{neon_type.lane_nox}"
    doc: "Set all vector lanes to the same value"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'N = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - poly64x1_t
      - float64x1_t
    compose:
      - FnCall: [static_assert!, ['N == 0']]
      - Identifier: [a, Symbol]

  - name: "vdupd{neon_type[0].lane_nox}"
    doc: "Set all vector lanes to the same value"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'N = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int64x1_t, "i64"]
      - [uint64x1_t, "u64"]
      - [float64x1_t, "f64"]
    compose:
      - FnCall: [static_assert!, ['N == 0']]
      - FnCall: [simd_extract!, [a, 'N as u32']]

  - name: "vdup_laneq_{neon_type[0]}"
    doc: "Set all vector lanes to the same value"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [poly64x2_t, poly64x1_t, 'u64']
      - [float64x2_t, float64x1_t, 'f64']
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, 1]]
      - FnCall:
          - "transmute::<{type[2]}, _>"
          - - FnCall: [simd_extract!, [a, 'N as u32']]

  - name: "vdup{type[2]}"
    doc: "Set all vector lanes to the same value"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int32x2_t, "i32", s_lane_s32]
      - [int64x2_t, "i64", d_laneq_s64]
      - [uint32x2_t, "u32", s_lane_u32]
      - [uint64x2_t, "u64", d_laneq_u64]
      - [float32x2_t, "f32", s_lane_f32]
      - [float64x2_t, "f64", d_laneq_f64]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, 1]]
      - FnCall: [simd_extract!, [a, 'N as u32']]

  - name: "vdup{type[2]}"
    doc: "Set all vector lanes to the same value"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'N = 4']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int8x8_t, "i8", b_lane_s8]
      - [int16x8_t, "i16", h_laneq_s16]
      - [uint8x8_t, "u8", b_lane_u8]
      - [uint16x8_t, "u16", h_laneq_u16]
      - [poly8x8_t, "p8", b_lane_p8]
      - [poly16x8_t, "p16", h_laneq_p16]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, 3]]
      - FnCall: [simd_extract!, [a, 'N as u32']]


  - name: "vdup{type[2]}"
    doc: "Set all vector lanes to the same value"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [float16x4_t, "f16", h_lane_f16]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, 2]]
      - FnCall: [simd_extract!, [a, 'N as u32']]


  - name: "vdup{type[2]}"
    doc: "Extract an element from a vector"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'N = 4']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [float16x8_t, "f16", h_laneq_f16]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, 4]]
      - FnCall: [simd_extract!, [a, 'N as u32']]


  - name: "vdup{type[2]}"
    doc: "Extract an element from a vector"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'N = 8']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int8x16_t, "i8", b_laneq_s8]
      - [uint8x16_t, "u8", b_laneq_u8]
      - [poly8x16_t, "p8", b_laneq_p8]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, 4]]
      - FnCall: [simd_extract!, [a, 'N as u32']]

  - name: "vdup{type[2]}"
    doc: "Set all vector lanes to the same value"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int16x4_t, "i16", h_lane_s16]
      - [int32x4_t, "i32", s_laneq_s32]
      - [uint16x4_t, "u16", h_lane_u16]
      - [uint32x4_t, "u32", s_laneq_u32]
      - [poly16x4_t, "p16", h_lane_p16]
      - [float32x4_t, "f32", s_laneq_f32]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, 2]]
      - FnCall: [simd_extract!, [a, 'N as u32']]

  - name: "vext{neon_type[0].no}"
    doc: "Extract vector from pair of vectors"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ext, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [poly64x2_t, ' static_assert_uimm_bits!(N, 1);', 'unsafe { match N & 0b1 { 0 => simd_shuffle!(a, b, [0, 1]), 1 => simd_shuffle!(a, b, [1, 2]), _ => unreachable_unchecked(), } }']
      - [float64x2_t, ' static_assert_uimm_bits!(N, 1);', 'unsafe { match N & 0b1 { 0 => simd_shuffle!(a, b, [0, 1]), 1 => simd_shuffle!(a, b, [1, 2]), _ => unreachable_unchecked(), } }']
    compose:
      - Identifier: ["{type[1]}", Symbol]
      - Identifier: ["{type[2]}", Symbol]

  - name: "vmla{neon_type.no}"
    doc: "Floating-point multiply-add to accumulator"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmul]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - float64x1_t
      - float64x2_t
    compose:
      - FnCall: [simd_add, [a, {FnCall: [simd_mul, [b, c]]}]]

  - name: "vmlal_high_{neon_type[1]}"
    doc: "Signed multiply-add long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [smlal2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int16x8_t, int8x16_t, int8x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]', '[8, 9, 10, 11, 12, 13, 14, 15]']
      - [int32x4_t, int16x8_t, int16x4_t, '[4, 5, 6, 7]', '[4, 5, 6, 7]']
      - [int64x2_t, int32x4_t, int32x2_t, '[2, 3]', '[2, 3]']
    compose:
      - Let: [b, "{neon_type[2]}", {FnCall: [simd_shuffle!, [b, b, "{type[3]}"]]}]
      - Let: [c, "{neon_type[2]}", {FnCall: [simd_shuffle!, [c, c, "{type[4]}"]]}]
      - FnCall: ["vmlal_{neon_type[2]}", [a, b, c]]

  - name: "vmlal_high_{neon_type[1]}"
    doc: "Unsigned multiply-add long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [umlal2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint16x8_t, uint8x16_t, uint8x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint32x4_t, uint16x8_t, uint16x4_t, '[4, 5, 6, 7]']
      - [uint64x2_t, uint32x4_t, uint32x2_t, '[2, 3]']
    compose:
      - Let:
          - b
          - "{neon_type[2]}"
          - FnCall: [simd_shuffle!, [b, b, "{type[3]}"]]
      - Let:
          - c
          - "{neon_type[2]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[3]}"]]
      - FnCall: ["vmlal_{neon_type[1]}", [a, b, c]]

  - name: "vmlsl_high_{neon_type[1]}"
    doc: "Signed multiply-subtract long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [smlsl2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int16x8_t, int8x16_t, int8x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]']
      - [int32x4_t, int16x8_t, int16x4_t, '[4, 5, 6, 7]']
      - [int64x2_t, int32x4_t, int32x2_t, '[2, 3]']
    compose:
      - Let:
          - b
          - "{neon_type[2]}"
          - FnCall: [simd_shuffle!, [b, b, "{type[3]}"]]
      - Let:
          - c
          - "{neon_type[2]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[3]}"]]
      - FnCall: ["vmlsl_{neon_type[1]}", [a, b, c]]

  - name: "vmlsl_high_{neon_type[1]}"
    doc: "Unsigned multiply-subtract long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [umlsl2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint16x8_t, uint8x16_t, uint8x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint32x4_t, uint16x8_t, uint16x4_t, '[4, 5, 6, 7]']
      - [uint64x2_t, uint32x4_t, uint32x2_t, '[2, 3]']
    compose:
      - Let: [b, "{neon_type[2]}", {FnCall: [simd_shuffle!, [b, b, "{type[3]}"]]}]
      - Let: [c, "{neon_type[2]}", {FnCall: [simd_shuffle!, [c, c, "{type[3]}"]]}]
      - FnCall: ["vmlsl_{neon_type[1]}", [a, b, c]]

  - name: "vmovn_high{neon_type[1].noq}"
    doc: Extract narrow
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr: [*neon-stable]
    assert_instr: [xtn2]
    safety: safe
    types:
      - [int8x8_t, int16x8_t, int8x16_t, '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [int16x4_t, int32x4_t, int16x8_t, '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [int32x2_t, int64x2_t, int32x4_t, '[0, 1, 2, 3]']
      - [uint8x8_t, uint16x8_t, uint8x16_t, '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint16x4_t, uint32x4_t, uint16x8_t, '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [uint32x2_t, uint64x2_t, uint32x4_t, '[0, 1, 2, 3]']
    compose:
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall:
              - simd_cast
              - - b
      - FnCall:
          - simd_shuffle!
          - - a
            - c
            - "{type[3]}"

  - name: "vneg{neon_type.no}"
    doc: Negate
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [neg]
    safety: safe
    types:
      - int64x1_t
      - int64x2_t
    compose:
      - FnCall:
          - simd_neg
          - - a

  - name: "vnegd_s64"
    doc: Negate
    arguments: ["a: {type}"]
    return_type: "{type}"
    attr: [*neon-stable]
    assert_instr: [neg]
    safety: safe
    types:
      - i64
    compose:
      - MethodCall: [a, wrapping_neg, []]


  - name: "vnegh_{type}"
    doc: Negate
    arguments: ["a: {type}"]
    return_type: "{type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fneg]
    safety: safe
    types:
      - f16
    compose:
      - '-a'

  - name: "vneg{neon_type.no}"
    doc: Negate
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall:
          - stable
          - - 'feature = "neon_intrinsics"'
            - 'since = "1.59.0"'
    assert_instr: [fneg]
    safety: safe
    types:
      - float64x1_t
      - float64x2_t
    compose:
      - FnCall:
          - simd_neg
          - - a

  - name: "vqneg{type[1]}"
    doc: Signed saturating negate
    arguments: ["a: {type[0]}"]
    return_type: "{type[0]}"
    attr: [*neon-stable]
    assert_instr: [sqneg]
    safety: safe
    types:
      - [i8, 'b_s8', 's8']
      - [i16, 'h_s16', 's16']
      - [i32, 's_s32', 's32']
      - [i64, 'd_s64', 's64']
    compose:
      - FnCall:
          - 'simd_extract!'
          - - FnCall:
                - 'vqneg_{type[2]}'
                - - FnCall: ['vdup_n_{type[2]}', [a]]
            - 0

  - name: "vqneg{neon_type[0].no}"
    doc: Signed saturating negate
    arguments: ["a: {type[0]}"]
    return_type: "{type[0]}"
    attr: [*neon-stable]
    assert_instr: [sqneg]
    safety: safe
    types:
      - [int64x1_t, 'i64']
      - [int64x2_t, 'i64']
    compose:
      - LLVMLink:
          name: "sqneg.{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.sqneg.v{neon_type[0].lane}{type[1]}"
              arch: aarch64,arm64ec

  - name: "vqsub{type[1]}"
    doc: Saturating subtract
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[0]}"
    attr: [*neon-stable]
    assert_instr: [sqsub]
    safety: safe
    types:
      - [i32, 's_s32', 'i32']
      - [i64, 'd_s64', 'i64']
    compose:
      - LLVMLink:
          name: "sqsub.{type[0]}"
          links:
            - link: "llvm.aarch64.neon.sqsub.{type[2]}"
              arch: aarch64,arm64ec

  - name: "vqsub{type[1]}"
    doc: Saturating subtract
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[0]}"
    attr: [*neon-stable]
    assert_instr: [uqsub]
    safety: safe
    types:
      - [u32, 's_u32', 'i32']
      - [u64, 'd_u64', 'i64']
    compose:
      - LLVMLink:
          name: "uqsub.{type[0]}"
          links:
            - link: "llvm.aarch64.neon.uqsub.{type[2]}"
              arch: aarch64,arm64ec

  - name: "vqsub{type[3]}"
    doc: Saturating subtract
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[0]}"
    attr: [*neon-stable]
    assert_instr: [sqsub]
    safety: safe
    types:
      - [i8, int8x8_t, s8, 'b_s8']
      - [i16, int16x4_t, s16, 'h_s16']
    compose:
      - Let:
          - a
          - "{neon_type[1]}"
          - FnCall:
              - "vdup_n_{type[2]}"
              - - a
      - Let:
          - b
          - "{neon_type[1]}"
          - FnCall:
              - "vdup_n_{type[2]}"
              - - b
      - FnCall:
          - 'simd_extract!'
          - - FnCall:
                - "vqsub_{type[2]}"
                - - a
                  - b
            - "0"

  - name: "vqsub{type[3]}"
    doc: Saturating subtract
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[0]}"
    attr: [*neon-stable]
    assert_instr: [uqsub]
    safety: safe
    types:
      - [u8, uint8x8_t, u8, 'b_u8']
      - [u16, uint16x4_t, u16, 'h_u16']
    compose:
      - Let:
          - a
          - "{neon_type[1]}"
          - FnCall:
              - "vdup_n_{type[2]}"
              - - a
      - Let:
          - b
          - "{neon_type[1]}"
          - FnCall:
              - "vdup_n_{type[2]}"
              - - b
      - FnCall:
          - 'simd_extract!'
          - - FnCall:
                - "vqsub_{type[2]}"
                - - a
                  - b
            - "0"

  - name: "vrbit{neon_type.no}"
    doc: Reverse bit order
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [rbit]
    safety: safe
    types:
      - int8x8_t
      - int8x16_t
    compose:
      - LLVMLink:
          name: "rbit.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.rbit.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vrbit{neon_type[0].no}"
    doc: Reverse bit order
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr: [*neon-stable]
    assert_instr: [rbit]
    safety: safe
    types:
      - [uint8x8_t, int8x8_t]
      - [uint8x16_t, int8x16_t]
      - [poly8x8_t, int8x8_t]
      - [poly8x16_t, int8x16_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vrbit{neon_type[1].no}"
                - - FnCall: [transmute, [a]]

  - name: "vrndx{neon_type.no}"
    doc: "Floating-point round to integral exact, using current rounding mode"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [frintx]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "llvm.rint.{neon_type}"
          links:
            - link: "llvm.rint.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vrndx{neon_type.no}"
    doc: "Floating-point round to integral exact, using current rounding mode"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [frintx]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "llvm.rint.{neon_type}"
          links:
            - link: "llvm.rint.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vrndx{type[1]}{type[0]}"
    doc: "Floating-point round to integral, using current rounding mode"
    arguments: ["a: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [frintx]
    safety: safe
    types:
      - [f16, 'h_']
    compose:
      - LLVMLink:
          name: "llvm.rint.{type[0]}"
          links:
            - link: "llvm.rint.{type[0]}"
              arch: aarch64,arm64ec


  - name: "vrnda{neon_type.no}"
    doc: "Floating-point round to integral, to nearest with ties to away"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [frinta]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "llvm.round.{neon_type}"
          links:
            - link: "llvm.round.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vrnda{neon_type.no}"
    doc: "Floating-point round to integral, to nearest with ties to away"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [frinta]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "llvm.round.{neon_type}"
          links:
            - link: "llvm.round.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vrnda{type[1]}{type[0]}"
    doc: "Floating-point round to integral, to nearest with ties to away"
    arguments: ["a: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [frinta]
    safety: safe
    types:
      - [f16, 'h_']
    compose:
      - LLVMLink:
          name: "llvm.round.{type[0]}"
          links:
            - link: "llvm.round.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vrndn{neon_type.no}"
    doc: "Floating-point round to integral, to nearest with ties to even"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [frintn]
    safety: safe
    types:
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "frintn.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.frintn.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vrndns_{type}"
    doc: "Floating-point round to integral, to nearest with ties to even"
    arguments: ["a: {type}"]
    return_type: "{type}"
    attr: [*neon-stable]
    assert_instr: [frintn]
    safety: safe
    types:
      - f32
    compose:
      - LLVMLink:
          name: "roundeven.{type}"
          links:
            - link: "llvm.roundeven.{type}"
              arch: aarch64,arm64ec

  - name: "vrndn{type[1]}{type[0]}"
    doc: "Floating-point round to integral, toward minus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [frintn]
    safety: safe
    types:
      - [f16, 'h_']
    compose:
      - LLVMLink:
          name: "llvm.roundeven.{type[0]}"
          links:
            - link: "llvm.roundeven.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vrndm{neon_type.no}"
    doc: "Floating-point round to integral, toward minus infinity"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [frintm]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "llvm.floor.{neon_type}"
          links:
            - link: "llvm.floor.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vrndm{neon_type.no}"
    doc: "Floating-point round to integral, toward minus infinity"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [frintm]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "llvm.floor.{neon_type}"
          links:
            - link: "llvm.floor.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vrndm{type[1]}{type[0]}"
    doc: "Floating-point round to integral, toward minus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [frintm]
    safety: safe
    types:
      - [f16, 'h_']
    compose:
      - LLVMLink:
          name: "llvm.floor.{type[0]}"
          links:
            - link: "llvm.floor.{type[0]}"
              arch: aarch64,arm64ec



  - name: "vrndp{neon_type.no}"
    doc: "Floating-point round to integral, toward plus infinity"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [frintp]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "llvm.ceil.{neon_type}"
          links:
            - link: "llvm.ceil.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vrndp{neon_type.no}"
    doc: "Floating-point round to integral, toward plus infinity"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [frintp]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "llvm.ceil.{neon_type}"
          links:
            - link: "llvm.ceil.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vrndp{type[1]}{type[0]}"
    doc: "Floating-point round to integral, toward plus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [frintp]
    safety: safe
    types:
      - [f16, 'h_']
    compose:
      - LLVMLink:
          name: "llvm.ceil.{type[0]}"
          links:
            - link: "llvm.ceil.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vrnd{neon_type.no}"
    doc: "Floating-point round to integral, toward zero"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [frintz]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "llvm.trunc.{neon_type}"
          links:
            - link: "llvm.trunc.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vrnd{neon_type.no}"
    doc: "Floating-point round to integral, toward zero"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [frintz]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "llvm.trunc.{neon_type}"
          links:
            - link: "llvm.trunc.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vrnd{type[1]}{type[0]}"
    doc: "Floating-point round to integral, to nearest with ties to away"
    arguments: ["a: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [frintz]
    safety: safe
    types:
      - [f16, 'h_']
    compose:
      - LLVMLink:
          name: "llvm.trunc.{type[0]}"
          links:
            - link: "llvm.trunc.{type[0]}"
              arch: aarch64,arm64ec


  - name: "vrndi{neon_type.no}"
    doc: "Floating-point round to integral, using current rounding mode"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [frinti]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "llvm.nearbyint.{neon_type}"
          links:
            - link: "llvm.nearbyint.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vrndi{neon_type.no}"
    doc: "Floating-point round to integral, using current rounding mode"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [frinti]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "llvm.nearbyint.{neon_type}"
          links:
            - link: "llvm.nearbyint.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vrndi{type[1]}{type[0]}"
    doc: "Floating-point round to integral, using current rounding mode"
    arguments: ["a: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    # TODO: double check me
    assert_instr: [frinti]
    safety: safe
    types:
      - [f16, 'h_']
    compose:
      - LLVMLink:
          name: "llvm.nearbyint.{type[0]}"
          links:
            - link: "llvm.nearbyint.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vqadd{type[1]}"
    doc: Saturating add
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[0]}"
    attr: [*neon-stable]
    assert_instr: [uqadd]
    safety: safe
    types:
      - [u32, 's_u32', i32]
      - [u64, 'd_u64', i64]
    compose:
      - LLVMLink:
          name: "uqadd.{type[2]}"
          links:
            - link: "llvm.aarch64.neon.uqadd.{type[2]}"
              arch: aarch64,arm64ec

  - name: "vqadd{type[1]}"
    doc: Saturating add
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[0]}"
    attr: [*neon-stable]
    assert_instr: [sqadd]
    safety: safe
    types:
      - [i32, 's_s32', i32]
      - [i64, 'd_s64', i64]
    compose:
      - LLVMLink:
          name: "uqadd.{type[2]}"
          links:
            - link: "llvm.aarch64.neon.sqadd.{type[2]}"
              arch: aarch64,arm64ec

  - name: "vqadd{type[2]}"
    doc: Saturating add
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[0]}"
    attr: [*neon-stable]
    assert_instr: [sqadd]
    safety: safe
    types:
      - [i8, int8x8_t, 'b_s8']
      - [i16, int16x4_t, 'h_s16']
    compose:
      - Let:
          - a
          - "{neon_type[1]}"
          - FnCall:
              - "vdup_n_{type[0]}"
              - - a
      - Let:
          - b
          - "{neon_type[1]}"
          - FnCall:
              - "vdup_n_{type[0]}"
              - - b
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vqadd_{type[0]}"
                - - a
                  - b
            - "0"

  - name: "vqadd{type[2]}"
    doc: Saturating add
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[0]}"
    attr: [*neon-stable]
    assert_instr: [uqadd]
    safety: safe
    types:
      - [u8, uint8x8_t, 'b_u8']
      - [u16, uint16x4_t, 'h_u16']
    compose:
      - Let:
          - a
          - "{neon_type[1]}"
          - FnCall:
              - "vdup_n_{type[0]}"
              - - a
      - Let:
          - b
          - "{neon_type[1]}"
          - FnCall:
              - "vdup_n_{type[0]}"
              - - b
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vqadd_{type[0]}"
                - - a
                  - b
            - "0"

  - name: "vld1{neon_type[1].no}"
    doc: "Load multiple single-element structures to one, two, three, or four registers"
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    assert_instr: [ld1]
    safety:
      unsafe: [neon]
    types:
      - ["*const f64", float64x1x2_t]
      - ["*const f64", float64x2x2_t]
      - ["*const f64", float64x1x3_t]
      - ["*const f64", float64x2x3_t]
      - ["*const f64", float64x1x4_t]
      - ["*const f64", float64x2x4_t]
    compose:
      - LLVMLink:
          name: "vld1{neon_type[1].no}"
          links:
            - link: "llvm.aarch64.neon.ld1x{neon_type[1].tuple}.v{neon_type[1].lane}f{neon_type[1].base}.p0f64"
              arch: aarch64,arm64ec

  - name: "vld2{neon_type[1].lane_nox}"
    doc: Load multiple 2-element structures to two registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld2, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ["*const i8", int8x16x2_t, i8, int8x16_t, "4"]
      - ["*const i64", int64x2x2_t, i64, int64x2_t, "1"]
      - ["*const f64", float64x2x2_t, f64, float64x2_t, "1"]
    compose:
      - FnCall:
          - "static_assert_uimm_bits!"
          - - LANE
            - "{type[4]}"
      - LLVMLink:
          name: "vld2.{neon_type[1]}"
          arguments:
            - "a: {neon_type[3]}"
            - "b: {neon_type[3]}"
            - "n: i64"
            - "ptr: *const i8"
          links:
            - link: "llvm.aarch64.neon.ld2lane.v{neon_type[1].lane}{type[2]}.p0i8"
              arch: aarch64,arm64ec
      - FnCall: ["_vld2{neon_type[1].lane_nox}", ["b.0", "b.1", "LANE as i64", "a as _"]]

  - name: "vld2{neon_type[1].lane_nox}"
    doc: Load multiple 2-element structures to two registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld2, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ["*const i64", int64x1x2_t, i64, int64x1_t]
      - ["*const f64", float64x1x2_t, f64, float64x1_t]
    compose:
      - FnCall: ["static_assert!", ['LANE == 0']]
      - LLVMLink:
          name: "vld2.{neon_type[1]}"
          arguments:
            - "a: {neon_type[3]}"
            - "b: {neon_type[3]}"
            - "n: i64"
            - "ptr: *const i8"
          links:
            - link: "llvm.aarch64.neon.ld2lane.v{neon_type[1].lane}{type[2]}.p0i8"
              arch: aarch64,arm64ec
      - FnCall: ["_vld2{neon_type[1].lane_nox}", ["b.0", "b.1", "LANE as i64", "a as _"]]

  - name: "vld2{neon_type[1].lane_nox}"
    doc: Load multiple 2-element structures to two registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld2, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ["*const u64", uint64x1x2_t, int64x1x2_t]
    compose:
      - FnCall:
          - "static_assert!"
          - - 'LANE == 0'
      - FnCall:
          - transmute
          - - FnCall:
                - "vld2{neon_type[2].lane_nox}::<LANE>"
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vld2{neon_type[1].lane_nox}"
    doc: Load multiple 2-element structures to two registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - *neon-aes
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld2, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ["*const p64", poly64x1x2_t, int64x1x2_t]
    compose:
      - FnCall:
          - "static_assert!"
          - - 'LANE == 0'
      - FnCall:
          - transmute
          - - FnCall:
                - "vld2{neon_type[2].lane_nox}::<LANE>"
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vld2{neon_type[1].lane_nox}"
    doc: Load multiple 2-element structures to two registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld2, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ["*const u8", uint8x16x2_t, int8x16x2_t, "4"]
      - ["*const p8", poly8x16x2_t, int8x16x2_t, "4"]
      - ["*const u64", uint64x2x2_t, int64x2x2_t, "1"]
    compose:
      - FnCall:
          - "static_assert_uimm_bits!"
          - - LANE
            - "{type[3]}"
      - FnCall:
          - transmute
          - - FnCall:
                - "vld2{neon_type[2].lane_nox}::<LANE>"
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vld2{neon_type[1].lane_nox}"
    doc: Load multiple 2-element structures to two registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - *neon-aes
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld2, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ["*const p64", poly64x2x2_t, int64x2x2_t, "1"]
    compose:
      - FnCall: ["static_assert_uimm_bits!", [LANE, '{type[3]}']]
      - FnCall:
          - transmute
          - - FnCall:
                - "vld2{neon_type[2].lane_nox}::<LANE>"
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vld2{neon_type[1].nox}"
    doc: Load multiple 2-element structures to two registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    assert_instr: [ld2]
    safety:
      unsafe: [neon]
    types:
      - ["*const f64", float64x2x2_t, f64, float64x2_t]
      - ["*const i64", int64x2x2_t, i64, int64x2_t]
    compose:
      - LLVMLink:
          name: "vld2.{neon_type[1]}"
          arguments:
            - "ptr: *const {neon_type[3]}"
          links:
            - link: "llvm.aarch64.neon.ld2.v{neon_type[1].lane}{type[2]}.p0v{neon_type[1].lane}{type[2]}"
              arch: aarch64,arm64ec
      - FnCall:
          - "_vld2{neon_type[1].nox}"
          - - "a as _"

  - name: "vld2{neon_type[1].nox}"
    doc: Load multiple 2-element structures to two registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    assert_instr: [nop]
    safety:
      unsafe: [neon]
    types:
      - ["*const f64", float64x1x2_t, f64, float64x1_t]
    compose:
      - LLVMLink:
          name: "vld2.{neon_type[1]}"
          arguments:
            - "ptr: *const {neon_type[3]}"
          links:
            - link: "llvm.aarch64.neon.ld2.v{neon_type[1].lane}{type[2]}.p0v{neon_type[1].lane}{type[2]}"
              arch: aarch64,arm64ec
      - FnCall:
          - "_vld2{neon_type[1].nox}"
          - - "a as _"

  - name: "vld2{neon_type[1].nox}"
    doc: Load multiple 2-element structures to two registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    assert_instr: [ld2]
    safety:
      unsafe: [neon]
    types:
      - ["*const u64", uint64x2x2_t, int64x2x2_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vld2{neon_type[2].nox}"
                - - FnCall: [transmute, [a]]

  - name: "vld2{neon_type[1].nox}"
    doc: Load multiple 2-element structures to two registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - *neon-aes
      - *neon-stable
    assert_instr: [ld2]
    safety:
      unsafe: [neon]
    types:
      - ["*const p64", poly64x2x2_t, int64x2x2_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vld2{neon_type[2].nox}"
                - - FnCall: [transmute, [a]]

  - name: "vld2{neon_type[1].dup_nox}"
    doc: Load single 2-element structure and replicate to all lanes of two registers
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: [ld2r]
    safety:
      unsafe: [neon]
    types:
      - ["*const i64", int64x2x2_t, i64]
      - ["*const f64", float64x1x2_t, f64]
      - ["*const f64", float64x2x2_t, f64]
    compose:
      - LLVMLink:
          name: "vld2dup.{neon_type[1]}"
          arguments:
            - "ptr: {type[0]}"
          links:
            - link: "llvm.aarch64.neon.ld2r.v{neon_type[1].lane}{type[2]}.p0{type[2]}"
              arch: aarch64,arm64ec
      - FnCall:
          - "_vld2{neon_type[1].dup_nox}"
          - - "a as _"

  - name: "vld2{neon_type[1].dup_nox}"
    doc: Load single 2-element structure and replicate to all lanes of two registers
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: [ld2r]
    safety:
      unsafe: [neon]
    types:
      - ["*const u64", uint64x2x2_t, int64x2x2_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vld2{neon_type[2].dup_nox}"
                - - FnCall:
                      - transmute
                      - - a

  - name: "vld2{neon_type[1].dup_nox}"
    doc: Load single 2-element structure and replicate to all lanes of two registers
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-aes
      - *neon-stable
    assert_instr: [ld2r]
    safety:
      unsafe: [neon]
    types:
      - ["*const p64", poly64x2x2_t, int64x2x2_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vld2{neon_type[2].dup_nox}"
                - - FnCall:
                      - transmute
                      - - a

  - name: "vld3{neon_type[1].lane_nox}"
    doc: "Load multiple 3-element structures to two registers"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ['*const i8', int8x16x3_t, int8x16_t, i8, '3']
      - ['*const i64', int64x2x3_t, int64x2_t, i64, '1']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[4]}']]
      - LLVMLink:
          name: 'ld3lane.{neon_type[2]}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'n: i64'
            - 'ptr: *const i8'
          links:
            - link: 'llvm.aarch64.neon.ld3lane.v{neon_type[1].lane}{type[3]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vld3{neon_type[1].lane_nox}', ['b.0', 'b.1', 'b.2', 'LANE as i64', 'a as _']]

  - name: "vld3{neon_type[1].lane_nox}"
    doc: "Load multiple 3-element structures to three registers"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ['*const f64', float64x2x3_t, float64x2_t, f64, '1']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[4]}']]
      - LLVMLink:
          name: 'ld3lane.{neon_type[2]}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'n: i64'
            - 'ptr: *const i8'
          links:
            - link: 'llvm.aarch64.neon.ld3lane.v{neon_type[1].lane}{type[3]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vld3{neon_type[1].lane_nox}', ['b.0', 'b.1', 'b.2', 'LANE as i64', 'a as _']]

  - name: "vld3{neon_type[1].lane_nox}"
    doc: Load multiple 3-element structures to three registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ['*const f64', float64x1x3_t, float64x1_t, f64]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - LLVMLink:
          name: 'vld3.{neon_type[2]}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'n: i64'
            - 'ptr: *const i8'
          links:
            - link: 'llvm.aarch64.neon.ld3lane.v{neon_type[1].lane}{type[3]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vld3{neon_type[1].lane_nox}', ['b.0', 'b.1', 'b.2', 'LANE as i64', 'a as _']]

  - name: "vld3{neon_type[1].lane_nox}"
    doc: "Load multiple 3-element structures to two registers"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ['*const i64', int64x1x3_t, int64x1_t, i64]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - LLVMLink:
          name: 'vld3.{neon_type[2]}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'n: i64'
            - 'ptr: *const i8'
          links:
            - link: 'llvm.aarch64.neon.ld3lane.v{neon_type[1].lane}{type[3]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vld3{neon_type[1].lane_nox}', ['b.0', 'b.1', 'b.2', 'LANE as i64', 'a as _']]

  - name: "vld3{neon_type[1].lane_nox}"
    doc: Load multiple 3-element structures to three registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ['*const p8', poly8x16x3_t, int8x16x3_t, '4']
      - ['*const u8', uint8x16x3_t, int8x16x3_t, '4']
      - ['*const u64', uint64x2x3_t, int64x2x3_t, '1']
    compose:
      - FnCall: [static_assert_uimm_bits!, ['LANE', '{type[3]}']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vld3{neon_type[2].lane_nox}::<LANE>'
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vld3{neon_type[1].lane_nox}"
    doc: Load multiple 3-element structures to three registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ['*const u64', uint64x1x3_t, int64x1x3_t, '1']
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vld3{neon_type[2].lane_nox}::<LANE>'
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vld3{neon_type[1].lane_nox}"
    doc: Load multiple 3-element structures to three registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - *neon-aes
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ['*const p64', poly64x2x3_t, int64x2x3_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, ['LANE', 1]]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vld3{neon_type[2].lane_nox}::<LANE>'
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vld3{neon_type[1].lane_nox}"
    doc: Load multiple 3-element structures to three registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - *neon-aes
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ['*const p64', poly64x1x3_t, int64x1x3_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vld3{neon_type[2].lane_nox}::<LANE>'
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vld3{neon_type[1].nox}"
    doc: Load multiple 3-element structures to three registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    safety:
      unsafe: [neon]
    assert_instr: [ld3]
    types:
      - ['*const i64', int64x2x3_t, '*const int64x2_t', i64]
      - ['*const f64', float64x2x3_t, '*const float64x2_t', f64]
    compose:
      - LLVMLink:
          name: 'vld3{neon_type[1].nox}'
          arguments:
            - 'ptr: {type[2]}'
          links:
            - link: 'llvm.aarch64.neon.ld3.v{neon_type[1].lane}{type[3]}.p0v{neon_type[1].lane}{type[3]}'
              arch: aarch64,arm64ec
      - FnCall: ['_vld3{neon_type[1].nox}', ['a as _']]

  - name: "vld3{neon_type[1].nox}"
    doc: Load multiple 3-element structures to three registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    safety:
      unsafe: [neon]
    assert_instr: [nop]
    types:
      - ['*const f64', float64x1x3_t, '*const float64x1_t', f64]
    compose:
      - LLVMLink:
          name: 'vld3{neon_type[1].nox}'
          arguments:
            - 'ptr: {type[2]}'
          links:
            - link: 'llvm.aarch64.neon.ld3.v{neon_type[1].lane}{type[3]}.p0v{neon_type[1].lane}{type[3]}'
              arch: aarch64,arm64ec
      - FnCall: ['_vld3{neon_type[1].nox}', ['a as _']]

  - name: "vld3{neon_type[1].nox}"
    doc: Load multiple 3-element structures to three registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    safety:
      unsafe: [neon]
    assert_instr: [ld3]
    types:
      - ['*const u64', uint64x2x3_t, int64x2x3_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - 'vld3{neon_type[2].nox}'
                - - FnCall:
                      - transmute
                      - - a

  - name: "vld3{neon_type[1].nox}"
    doc: Load multiple 3-element structures to three registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - *neon-aes
      - *neon-stable
    safety:
      unsafe: [neon]
    assert_instr: [ld3]
    types:
      - ['*const p64', poly64x2x3_t, int64x2x3_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - 'vld3{neon_type[2].nox}'
                - - FnCall:
                      - transmute
                      - - a

  - name: "vld3{neon_type[1].dup_nox}"
    doc: Load single 3-element structure and replicate to all lanes of three registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    assert_instr: [ld3r]
    safety:
      unsafe: [neon]
    types:
      - ["*const i64", int64x2x3_t, i64]
      - ["*const f64", float64x1x3_t, f64]
      - ["*const f64", float64x2x3_t, f64]
    compose:
      - LLVMLink:
          name: 'ld3r{neon_type[1].dup_nox}'
          arguments:
            - 'ptr: {type[0]}'
          links:
            - link: 'llvm.aarch64.neon.ld3r.v{neon_type[1].lane}{type[2]}.p0{type[2]}'
              arch: aarch64,arm64ec
      - FnCall: ['_vld3{neon_type[1].dup_nox}', ['a as _']]

  - name: "vld3{neon_type[1].dup_nox}"
    doc: Load single 3-element structure and replicate to all lanes of three registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    assert_instr: [ld3r]
    safety:
      unsafe: [neon]
    types:
      - ["*const u64", uint64x2x3_t, int64x2x3_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vld3{neon_type[2].dup_nox}"
                - - FnCall:
                      - transmute
                      - - a

  - name: "vld3{neon_type[1].dup_nox}"
    doc: Load single 3-element structure and replicate to all lanes of three registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - *neon-aes
      - *neon-stable
    assert_instr: [ld3r]
    safety:
      unsafe: [neon]
    types:
      - ["*const p64", poly64x2x3_t, int64x2x3_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vld3{neon_type[2].dup_nox}"
                - - FnCall:
                      - transmute
                      - - a

  - name: "vld4{neon_type[1].nox}"
    doc: Load multiple 4-element structures to four registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - *neon-stable
    assert_instr: [ld4]
    safety:
      unsafe: [neon]
    types:
      - ['*const f64', float64x2x4_t, f64, '*const float64x2_t']
      - ['*const i64', int64x2x4_t, i64, '*const int64x2_t']
    compose:
      - LLVMLink:
          name: 'vld4{neon_type[1].nox}'
          arguments:
            - 'ptr: {type[3]}'
          links:
            - link: 'llvm.aarch64.neon.ld4.v{neon_type[1].lane}{type[2]}.p0v{neon_type[1].lane}{type[2]}'
              arch: aarch64,arm64ec
      - FnCall: ['_vld4{neon_type[1].nox}', ['a as _']]

  - name: "vld4{neon_type[1].nox}"
    doc: Load multiple 4-element structures to four registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - *neon-stable
    assert_instr: [nop]
    safety:
      unsafe: [neon]
    types:
      - ['*const f64', float64x1x4_t, f64, '*const float64x1_t']
    compose:
      - LLVMLink:
          name: 'vld4{neon_type[1].nox}'
          arguments:
            - 'ptr: {type[3]}'
          links:
            - link: 'llvm.aarch64.neon.ld4.v{neon_type[1].lane}{type[2]}.p0v{neon_type[1].lane}{type[2]}'
              arch: aarch64,arm64ec
      - FnCall: ['_vld4{neon_type[1].nox}', ['a as _']]

  - name: "vld4{neon_type[1].nox}"
    doc: Load multiple 4-element structures to four registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    assert_instr: [ld4]
    safety:
      unsafe: [neon]
    types:
      - ["*const u64", uint64x2x4_t, int64x2x4_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - 'vld4{neon_type[2].nox}'
                - - FnCall:
                      - transmute
                      - - a

  - name: "vld4{neon_type[1].nox}"
    doc: Load multiple 4-element structures to four registers
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - *neon-stable
      - *neon-aes
    assert_instr: [ld4]
    safety:
      unsafe: [neon]
    types:
      - ["*const p64", poly64x2x4_t, int64x2x4_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - 'vld4{neon_type[2].nox}'
                - - FnCall:
                      - transmute
                      - - a

  - name: "vld4{neon_type[1].lane_nox}"
    doc: Load multiple 4-element structures to four registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld4, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ['*const i8', int8x16x4_t, int8x16_t, i8, '3']
      - ['*const i64', int64x2x4_t, int64x2_t, i64, '1']
      - ['*const f64', float64x2x4_t, float64x2_t, f64, '1']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[4]}']]
      - LLVMLink:
          name: 'ld4lane.{neon_type[2]}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'd: {type[2]}'
            - 'n: i64'
            - 'ptr: *const i8'
          links:
            - link: 'llvm.aarch64.neon.ld4lane.v{neon_type[1].lane}{type[3]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vld4{neon_type[1].lane_nox}', ['b.0', 'b.1', 'b.2', 'b.3', 'LANE as i64', 'a as _']]

  - name: "vld4{neon_type[1].lane_nox}"
    doc: Load multiple 4-element structures to four registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld4, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ['*const i64', int64x1x4_t, int64x1_t, i64]
      - ['*const f64', float64x1x4_t, float64x1_t, f64]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - LLVMLink:
          name: 'ld4lane.{neon_type[2]}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'd: {type[2]}'
            - 'n: i64'
            - 'ptr: *const i8'
          links:
            - link: 'llvm.aarch64.neon.ld4lane.v{neon_type[1].lane}{type[3]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vld4{neon_type[1].lane_nox}', ['b.0', 'b.1', 'b.2', 'b.3', 'LANE as i64', 'a as _']]

  - name: "vld4{neon_type[1].lane_nox}"
    doc: Load multiple 4-element structures to four registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld4, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ['*const p8', poly8x16x4_t, int8x16x4_t, '4']
      - ['*const u8', uint8x16x4_t, int8x16x4_t, '4']
      - ['*const u64', uint64x2x4_t, int64x2x4_t, '1']
    compose:
      - FnCall: [static_assert_uimm_bits!, ['LANE', '{type[3]}']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vld4{neon_type[2].lane_nox}::<LANE>'
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vld4{neon_type[1].lane_nox}"
    doc: Load multiple 4-element structures to four registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - *neon-aes
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld4, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ['*const p64', poly64x2x4_t, int64x2x4_t, '1']
    compose:
      - FnCall: [static_assert_uimm_bits!, ['LANE', '{type[3]}']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vld4{neon_type[2].lane_nox}::<LANE>'
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vld4{neon_type[1].lane_nox}"
    doc: Load multiple 4-element structures to four registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld4, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs:
      - "const LANE: i32"
    safety:
      unsafe: [neon]
    types:
      - ['*const u64', uint64x1x4_t, int64x1x4_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vld4{neon_type[2].lane_nox}::<LANE>'
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vld4{neon_type[1].lane_nox}"
    doc: Load multiple 4-element structures to four registers
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall:
          - target_feature
          - - 'enable = "neon,aes"'
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld4, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - ['*const p64', poly64x1x4_t, int64x1x4_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vld4{neon_type[2].lane_nox}::<LANE>'
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vst1{neon_type[1].lane_nox}"
    doc: "Store multiple single-element structures from one, two, three, or four registers"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    types:
      - ['*mut f64', float64x1_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - Assign:
          - "*a"
          - FnCall: [simd_extract!, [b, 'LANE as u32']]
      - Identifier: [';', Symbol]

  - name: "vst1{neon_type[1].lane_nox}"
    doc: "Store multiple single-element structures from one, two, three, or four registers"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    types:
      - ['*mut f64', float64x2_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '1']]
      - Assign:
          - "*a"
          - FnCall: [simd_extract!, [b, 'LANE as u32']]
      - Identifier: [';', Symbol]

  - name: "vst2{neon_type[1].nox}"
    doc: "Store multiple 2-element structures from two registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    safety:
      unsafe: [neon]
    attr:
      - *neon-stable
    assert_instr: [st1]
    types:
      - ['f64', float64x1x2_t, float64x1_t]
    compose:
      - LLVMLink:
          name: 'st2.{neon_type[1]}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'ptr: *mut i8'
          links:
            - link: 'llvm.aarch64.neon.st2.v{neon_type[1].lane}{type[0]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vst2{neon_type[1].nox}', ['b.0', 'b.1', 'a as _']]

  - name: "vst2{neon_type[1].nox}"
    doc: "Store multiple 2-element structures from two registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    safety:
      unsafe: [neon]
    attr:
      - *neon-stable
    assert_instr: [st2]
    types:
      - [i64, int64x2x2_t, int64x2_t]
      - [f64, float64x2x2_t, float64x2_t]
    compose:
      - LLVMLink:
          name: 'st2.{neon_type[1]}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'ptr: *mut i8'
          links:
            - link: 'llvm.aarch64.neon.st2.v{neon_type[1].lane}{type[0]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vst2{neon_type[1].nox}', ['b.0', 'b.1', 'a as _']]

  - name: "vst2{neon_type[1].lane_nox}"
    doc: "Store multiple 2-element structures from two registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st2, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [i64, int64x1x2_t, int64x1_t]
      - [f64, float64x1x2_t, float64x1_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - LLVMLink:
          name: 'st2.{neon_type[1]}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'n: i64'
            - 'ptr: *mut i8'
          links:
            - link: 'llvm.aarch64.neon.st2lane.v{neon_type[1].lane}{type[0]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vst2{neon_type[1].lane_nox}', ['b.0', 'b.1', 'LANE as i64', 'a as _']]

  - name: "vst2{neon_type[1].lane_nox}"
    doc: "Store multiple 2-element structures from two registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st2, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [i8, int8x16x2_t, int8x16_t, '4']
      - [i64, int64x2x2_t, int64x2_t, '1']
      - [f64, float64x2x2_t, float64x2_t, '1']
    compose:
      - FnCall: [static_assert_uimm_bits!, ['LANE', "{type[3]}"]]
      - LLVMLink:
          name: 'st2.{neon_type[1]}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'n: i64'
            - 'ptr: *mut i8'
          links:
            - link: 'llvm.aarch64.neon.st2lane.v{neon_type[1].lane}{type[0]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vst2{neon_type[1].lane_nox}', ['b.0', 'b.1', 'LANE as i64', 'a as _']]

  - name: "vst2{neon_type[1].lane_nox}"
    doc: "Store multiple 2-element structures from two registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st2, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [u8, uint8x16x2_t, int8x16x2_t, '4']
      - [u64, uint64x2x2_t, int64x2x2_t, '1']
      - [p8, poly8x16x2_t, int8x16x2_t, '4']
    compose:
      - FnCall: [static_assert_uimm_bits!, ['LANE', "{type[3]}"]]
      - FnCall:
          - "vst2{neon_type[2].lane_nox}::<LANE>"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst2{neon_type[1].lane_nox}"
    doc: "Store multiple 2-element structures from two registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st2, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [u64, uint64x1x2_t, int64x1x2_t, '1']
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - "vst2{neon_type[2].lane_nox}::<LANE>"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst2{neon_type[1].nox}"
    doc: "Store multiple 2-element structures from two registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-stable
    assert_instr: [st2]
    safety:
      unsafe: [neon]
    types:
      - [u64, uint64x2x2_t, int64x2x2_t]
    compose:
      - FnCall:
          - "vst2{neon_type[2].nox}"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst2{neon_type[1].lane_nox}"
    doc: "Store multiple 2-element structures from two registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-aes
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st2, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [p64, poly64x1x2_t, int64x1x2_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - "vst2{neon_type[2].lane_nox}::<LANE>"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst2{neon_type[1].lane_nox}"
    doc: "Store multiple 2-element structures from two registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-aes
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st2, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ["2"]]
      - *neon-stable
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [p64, poly64x2x2_t, int64x2x2_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, ['LANE', '1']]
      - FnCall:
          - "vst2{neon_type[2].lane_nox}::<LANE>"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst2{neon_type[1].nox}"
    doc: "Store multiple 2-element structures from two registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-aes
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st2]]}]]
      - *neon-stable
    safety:
      unsafe: [neon]
    types:
      - [p64, poly64x2x2_t, int64x2x2_t]
    compose:
      - FnCall:
          - "vst2{neon_type[2].nox}"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst3{neon_type[1].nox}"
    doc: "Store multiple 3-element structures from three registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr: [*neon-stable]
    assert_instr: [nop]
    safety:
      unsafe: [neon]
    types:
      - [f64, float64x1x3_t, float64x1_t]
    compose:
      - LLVMLink:
          name: 'st3.{neon_type[1].nox}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'ptr: *mut i8'
          links:
            - link: 'llvm.aarch64.neon.st3.v{neon_type[1].lane}{type[0]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vst3{neon_type[1].nox}', ['b.0', 'b.1', 'b.2', 'a as _']]

  - name: "vst3{neon_type[1].lane_nox}"
    doc: "Store multiple 3-element structures from three registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-stable
      - *neon-aes
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ['const LANE: i32']
    safety:
      unsafe: [neon]
    types:
      - [p64, poly64x1x3_t, int64x1x3_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - "vst3{neon_type[2].lane_nox}::<LANE>"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst3{neon_type[1].lane_nox}"
    doc: "Store multiple 3-element structures from three registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-stable
      - *neon-aes
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ['const LANE: i32']
    safety:
      unsafe: [neon]
    types:
      - [p64, poly64x2x3_t, int64x2x3_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '1']]
      - FnCall:
          - "vst3{neon_type[2].lane_nox}::<LANE>"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst3{neon_type[1].nox}"
    doc: "Store multiple 3-element structures from three registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-stable
      - *neon-aes
    assert_instr: [st3]
    safety:
      unsafe: [neon]
    types:
      - [p64, poly64x2x3_t, int64x2x3_t]
    compose:
      - FnCall:
          - "vst3{neon_type[2].nox}"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst3{neon_type[1].nox}"
    doc: "Store multiple 3-element structures from three registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr: [*neon-stable]
    assert_instr: [st3]
    safety:
      unsafe: [neon]
    types:
      - [i64, int64x2x3_t, int64x2_t]
      - [f64, float64x2x3_t, float64x2_t]
    compose:
      - LLVMLink:
          name: 'st3.{neon_type[1].nox}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'ptr: *mut i8'
          links:
            - link: 'llvm.aarch64.neon.st3.v{neon_type[1].lane}{type[0]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vst3{neon_type[1].nox}', ['b.0', 'b.1', 'b.2', 'a as _']]

  - name: "vst3{neon_type[1].nox}"
    doc: "Store multiple 3-element structures from three registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr: [*neon-stable]
    assert_instr: [st3]
    safety:
      unsafe: [neon]
    types:
      - [u64, uint64x2x3_t, int64x2x3_t]
    compose:
      - FnCall:
          - "vst3{neon_type[2].nox}"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst3{neon_type[1].lane_nox}"
    doc: "Store multiple 3-element structures from three registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ['const LANE: i32']
    safety:
      unsafe: [neon]
    types:
      - [u64, uint64x1x3_t, int64x1x3_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - "vst3{neon_type[2].lane_nox}::<LANE>"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst3{neon_type[1].lane_nox}"
    doc: "Store multiple 3-element structures from three registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ['const LANE: i32']
    safety:
      unsafe: [neon]
    types:
      - [u8, uint8x16x3_t, int8x16x3_t, '4']
      - [u64, uint64x2x3_t, int64x2x3_t, '1']
      - [p8, poly8x16x3_t, int8x16x3_t, '4']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[3]}"]]
      - FnCall:
          - "vst3{neon_type[2].lane_nox}::<LANE>"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst3{neon_type[1].lane_nox}"
    doc: "Store multiple 3-element structures from three registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ['const LANE: i32']
    safety:
      unsafe: [neon]
    types:
      - [f64, float64x2x3_t, float64x2_t, '1']
      - [i8, int8x16x3_t, int8x16_t, '4']
      - [i64, int64x2x3_t, int64x2_t, '1']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[3]}"]]
      - LLVMLink:
          name: 'st3lane.{neon_type[1].nox}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'n: i64'
            - 'ptr: *mut i8'
          links:
            - link: 'llvm.aarch64.neon.st3lane.v{neon_type[1].lane}{type[0]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vst3{neon_type[1].lane_nox}', ['b.0', 'b.1', 'b.2', 'LANE as i64', 'a as _']]

  - name: "vst3{neon_type[1].lane_nox}"
    doc: "Store multiple 3-element structures from three registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st3, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ['const LANE: i32']
    safety:
      unsafe: [neon]
    types:
      - [i64, int64x1x3_t, int64x1_t, '1']
      - [f64, float64x1x3_t, float64x1_t, '1']
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - LLVMLink:
          name: 'st3lane.{neon_type[1].nox}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'n: i64'
            - 'ptr: *mut i8'
          links:
            - link: 'llvm.aarch64.neon.st3lane.v{neon_type[1].lane}{type[0]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vst3{neon_type[1].lane_nox}', ['b.0', 'b.1', 'b.2', 'LANE as i64', 'a as _']]

  - name: "vst4{neon_type[1].nox}"
    doc: "Store multiple 4-element structures from four registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr: [*neon-stable]
    assert_instr: [nop]
    safety:
      unsafe: [neon]
    types:
      - [f64, float64x1x4_t, float64x1_t]
    compose:
      - LLVMLink:
          name: 'st4.{neon_type[1].nox}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'd: {type[2]}'
            - 'ptr: *mut i8'
          links:
            - link: 'llvm.aarch64.neon.st4.v{neon_type[1].lane}{type[0]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vst4{neon_type[1].nox}', ['b.0', 'b.1', 'b.2', 'b.3', 'a as _']]

  - name: "vst4{neon_type[1].lane_nox}"
    doc: "Store multiple 4-element structures from four registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-stable
      - *neon-aes
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st4, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ['const LANE: i32']
    safety:
      unsafe: [neon]
    types:
      - [p64, poly64x1x4_t, int64x1x4_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - "vst4{neon_type[2].lane_nox}::<LANE>"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst4{neon_type[1].lane_nox}"
    doc: "Store multiple 4-element structures from four registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-stable
      - *neon-aes
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st4, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ['const LANE: i32']
    safety:
      unsafe: [neon]
    types:
      - [p64, poly64x2x4_t, int64x2x4_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '1']]
      - FnCall:
          - "vst4{neon_type[2].lane_nox}::<LANE>"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst4{neon_type[1].nox}"
    doc: "Store multiple 4-element structures from four registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-stable
      - *neon-aes
    assert_instr: [st4]
    safety:
      unsafe: [neon]
    types:
      - [p64, poly64x2x4_t, int64x2x4_t]
    compose:
      - FnCall:
          - "vst4{neon_type[2].nox}"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst4{neon_type[1].nox}"
    doc: "Store multiple 4-element structures from four registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr: [*neon-stable]
    assert_instr: [st4]
    safety:
      unsafe: [neon]
    types:
      - [i64, int64x2x4_t, int64x2_t]
      - [f64, float64x2x4_t, float64x2_t]
    compose:
      - LLVMLink:
          name: 'st4.{neon_type[1].nox}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'd: {type[2]}'
            - 'ptr: *mut i8'
          links:
            - link: 'llvm.aarch64.neon.st4.v{neon_type[1].lane}{type[0]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vst4{neon_type[1].nox}', ['b.0', 'b.1', 'b.2', 'b.3', 'a as _']]

  - name: "vst4{neon_type[1].nox}"
    doc: "Store multiple 4-element structures from four registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr: [*neon-stable]
    assert_instr: [st4]
    safety:
      unsafe: [neon]
    types:
      - [u64, uint64x2x4_t, int64x2x4_t]
    compose:
      - FnCall:
          - "vst4{neon_type[2].nox}"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst4{neon_type[1].lane_nox}"
    doc: "Store multiple 4-element structures from four registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st4, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ['const LANE: i32']
    safety:
      unsafe: [neon]
    types:
      - [u64, uint64x1x4_t, int64x1x4_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - "vst4{neon_type[2].lane_nox}::<LANE>"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst4{neon_type[1].lane_nox}"
    doc: "Store multiple 4-element structures from four registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st4, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ['const LANE: i32']
    safety:
      unsafe: [neon]
    types:
      - [u8, uint8x16x4_t, int8x16x4_t, '4']
      - [u64, uint64x2x4_t, int64x2x4_t, '1']
      - [p8, poly8x16x4_t, int8x16x4_t, '4']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[3]}"]]
      - FnCall:
          - "vst4{neon_type[2].lane_nox}::<LANE>"
          - - FnCall: [transmute, [a]]
            - FnCall: [transmute, [b]]

  - name: "vst4{neon_type[1].lane_nox}"
    doc: "Store multiple 4-element structures from four registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st4, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ['const LANE: i32']
    safety:
      unsafe: [neon]
    types:
      - [f64, float64x2x4_t, float64x2_t, '1']
      - [i8, int8x16x4_t, int8x16_t, '4']
      - [i64, int64x2x4_t, int64x2_t, '1']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[3]}"]]
      - LLVMLink:
          name: 'st4lane.{neon_type[1].nox}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'd: {type[2]}'
            - 'n: i64'
            - 'ptr: *mut i8'
          links:
            - link: 'llvm.aarch64.neon.st4lane.v{neon_type[1].lane}{type[0]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vst4{neon_type[1].lane_nox}', ['b.0', 'b.1', 'b.2', 'b.3', 'LANE as i64', 'a as _']]

  - name: "vst4{neon_type[1].lane_nox}"
    doc: "Store multiple 4-element structures from four registers"
    arguments: ["a: *mut {type[0]}", "b: {neon_type[1]}"]
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st4, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ['const LANE: i32']
    safety:
      unsafe: [neon]
    types:
      - [i64, int64x1x4_t, int64x1_t, '1']
      - [f64, float64x1x4_t, float64x1_t, '1']
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - LLVMLink:
          name: 'st4lane.{neon_type[1].nox}'
          arguments:
            - 'a: {type[2]}'
            - 'b: {type[2]}'
            - 'c: {type[2]}'
            - 'd: {type[2]}'
            - 'n: i64'
            - 'ptr: *mut i8'
          links:
            - link: 'llvm.aarch64.neon.st4lane.v{neon_type[1].lane}{type[0]}.p0i8'
              arch: aarch64,arm64ec
      - FnCall: ['_vst4{neon_type[1].lane_nox}', ['b.0', 'b.1', 'b.2', 'b.3', 'LANE as i64', 'a as _']]

  - name: "vusdot{neon_type[0].laneq_nox}"
    doc: "Dot product index form with unsigned and signed integers"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-i8mm
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [usdot, 'LANE = 3']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [unstable, ['feature = "stdarch_neon_i8mm"', 'issue = "117223"']]
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [int32x2_t, uint8x8_t, int8x16_t, '[LANE as u32, LANE as u32]']
      - [int32x4_t, uint8x16_t, int8x16_t, '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '2']]
      - Let: [c, int32x4_t, {FnCall: [transmute, [c]]}]
      - Let: [c, "{neon_type[0]}", {FnCall: [simd_shuffle!, [c, c, "{type[3]}"]]}]
      - FnCall: ["vusdot{neon_type[0].no}", [a, b, {FnCall: [transmute, [c]]}]]

  - name: "vsudot{neon_type[0].laneq_nox}"
    doc: "Dot product index form with signed and unsigned integers"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-i8mm
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sudot, 'LANE = 3']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [unstable, ['feature = "stdarch_neon_i8mm"', 'issue = "117223"']]
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [int32x2_t, int8x8_t, uint8x16_t, '[LANE as u32, LANE as u32]', uint32x2_t]
      - [int32x4_t, int8x16_t, uint8x16_t, '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]', uint32x4_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, 2]]
      - Let:
          - c
          - uint32x4_t
          - FnCall: [transmute, [c]]
      - Let:
          - c
          - "{type[4]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[3]}"]]
      - FnCall: ["vusdot{neon_type[0].no}", [a, {FnCall: [transmute, [c]]}, b]]

  - name: "vmul{neon_type.no}"
    doc: Multiply
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [fmul]
    safety: safe
    types:
      - float64x1_t
      - float64x2_t
    compose:
      - FnCall: [simd_mul, [a, b]]

  - name: "vmull_high{neon_type[0].noq}"
    doc: Signed multiply long
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[3]}"
    attr: [*neon-stable]
    assert_instr: [smull2]
    safety: safe
    types:
      - [int8x16_t, int8x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]', int16x8_t]
      - [int16x8_t, int16x4_t, '[4, 5, 6, 7]', int32x4_t]
      - [int32x4_t, int32x2_t, '[2, 3]', int64x2_t]
    compose:
      - Let:
          - a
          - "{neon_type[1]}"
          - FnCall: [simd_shuffle!, [a, a, "{type[2]}"]]
      - Let:
          - b
          - "{neon_type[1]}"
          - FnCall: [simd_shuffle!, [b, b, "{type[2]}"]]
      - FnCall: ["vmull_{neon_type[0]}", [a, b]]

  - name: "vmull_high{neon_type[0].noq}"
    doc: "Unsigned multiply long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[3]}"
    attr: [*neon-stable]
    assert_instr: [umull2]
    safety: safe
    types:
      - [uint8x16_t, uint8x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]', uint16x8_t]
      - [uint16x8_t, uint16x4_t, '[4, 5, 6, 7]', uint32x4_t]
      - [uint32x4_t, uint32x2_t, '[2, 3]', uint64x2_t]
    compose:
      - Let:
          - a
          - "{neon_type[1]}"
          - FnCall: [simd_shuffle!, [a, a, "{type[2]}"]]
      - Let:
          - b
          - "{neon_type[1]}"
          - FnCall: [simd_shuffle!, [b, b, "{type[2]}"]]
      - FnCall: ["vmull_{neon_type[0]}", [a, b]]

  - name: "vmull_p64"
    doc: "Polynomial multiply long"
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-aes
      - *neon-stable
    safety: safe
    assert_instr: [pmull]
    types:
      - ["p64", "p128"]
    compose:
      - LLVMLink:
          name: "pmull.{type[0]}"
          return_type: "int8x16_t"
          links:
            - link: "llvm.aarch64.neon.pmull64"
              arch: aarch64,arm64ec
      - FnCall: [transmute, [{FnCall: ["_vmull_p64", [a, b]]}]]

  - name: "vmull_high{neon_type[0].noq}"
    doc: "Polynomial multiply long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[3]}"
    attr:
      - *neon-stable
    safety: safe
    assert_instr: [pmull]
    types:
      - [poly8x16_t, poly8x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]', poly16x8_t]
    compose:
      - Let:
          - a
          - "{neon_type[1]}"
          - FnCall: [simd_shuffle!, [a, a, "{type[2]}"]]
      - Let:
          - b
          - "{neon_type[1]}"
          - FnCall: [simd_shuffle!, [b, b, "{type[2]}"]]
      - FnCall: ["vmull_{neon_type[0]}", [a, b]]

  - name: "vmull_high{neon_type[0].noq}"
    doc: "Polynomial multiply long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-aes
      - *neon-stable
    safety: safe
    assert_instr: [pmull]
    types:
      - [poly64x2_t, "p128"]
    compose:
      - FnCall:
          - "vmull_{neon_type[0]}"
          - - FnCall: [simd_extract!, [a, '1']]
            - FnCall: [simd_extract!, [b, '1']]

  - name: "vmulx{neon_type.no}"
    doc: Floating-point multiply extended
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [fmulx]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "fmulx.{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.fmulx.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vmulx{neon_type.no}"
    doc: Floating-point multiply extended
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fmulx]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "fmulx.{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.fmulx.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vmulx{type[0]}"
    doc: Floating-point multiply extended
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[1]}"
    attr: [*neon-stable]
    assert_instr: [fmulx]
    safety: safe
    types:
      - ["s_f32", "f32"]
      - ["d_f64", "f64"]
    compose:
      - LLVMLink:
          name: "fmulx.{type[1]}"
          links:
            - link: "llvm.aarch64.neon.fmulx.{type[1]}"
              arch: aarch64,arm64ec


  - name: "vmulx{type[0]}"
    doc: Floating-point multiply extended
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fmulx]
    safety: safe
    types:
      - ["h_f16", "f16"]
    compose:
      - LLVMLink:
          name: "fmulx.{type[1]}"
          links:
            - link: "llvm.aarch64.neon.fmulx.{type[1]}"
              arch: aarch64,arm64ec


  - name: "vmulx_lane_f64"
    doc: Floating-point multiply extended
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmulx, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - float64x1_t
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - vmulx_f64
          - - a
            - FnCall:
                - 'transmute::<f64, _>'
                - - FnCall:
                      - "simd_extract!"
                      - - b
                        - 'LANE as u32'

  - name: "vmulx{type[0]}"
    doc: Floating-point multiply extended
    arguments: ["a: {type[1]}", "b: {neon_type[2]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmulx, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - ["q_lane_f64", float64x2_t, float64x1_t, "q_f64", '[LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - "vmulx{type[3]}"
          - - a
            - FnCall:
                - "simd_shuffle!"
                - - b
                  - b
                  - "{type[4]}"

  - name: "vmulx{type[0]}"
    doc: Floating-point multiply extended
    arguments: ["a: {type[1]}", "b: {neon_type[2]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmulx, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - ["d_lane_f64", "f64", float64x1_t, "d_f64", 'LANE as u32']
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - "vmulx{type[3]}"
          - - a
            - FnCall:
                - "simd_extract!"
                - - b
                  - "{type[4]}"

  - name: "vmulx_laneq_f64"
    doc: Floating-point multiply extended
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmulx, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float64x1_t, float64x2_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, ['LANE', '1']]
      - FnCall:
          - vmulx_f64
          - - a
            - FnCall:
                - 'transmute::<f64, _>'
                - - FnCall:
                      - "simd_extract!"
                      - - b
                        - 'LANE as u32'

  - name: "vmulx{type[0]}"
    doc: Floating-point multiply extended
    arguments: ["a: {type[1]}", "b: {neon_type[2]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmulx, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - ['_lane_f32', float32x2_t, float32x2_t, '1', '_f32', '[LANE as u32, LANE as u32]']
      - ['_laneq_f32', float32x2_t, float32x4_t, '2', '_f32', '[LANE as u32, LANE as u32]']
      - ['q_lane_f32', float32x4_t, float32x2_t, '1', 'q_f32', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - ['q_laneq_f32', float32x4_t, float32x4_t, '2', 'q_f32', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - ['q_laneq_f64', float64x2_t, float64x2_t, '1', 'q_f64', '[LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, ['LANE', "{type[3]}"]]
      - FnCall:
          - "vmulx{type[4]}"
          - - a
            - FnCall:
                - "simd_shuffle!"
                - - b
                  - b
                  - "{type[5]}"


  - name: "vmulx{type[0]}"
    doc: Floating-point multiply extended
    arguments: ["a: {type[1]}", "b: {neon_type[2]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmulx, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-fp16 
      - *neon-unstable-f16
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - ['_lane_f16', float16x4_t, float16x4_t, '2', '_f16', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - ['_laneq_f16', float16x4_t, float16x8_t, '3', '_f16', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - ['q_lane_f16', float16x8_t, float16x4_t, '2', 'q_f16', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - ['q_laneq_f16', float16x8_t, float16x8_t, '3', 'q_f16', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, ['LANE', "{type[3]}"]]
      - FnCall:
          - "vmulx{type[4]}"
          - - a
            - FnCall:
                - "simd_shuffle!"
                - - b
                  - b
                  - "{type[5]}"


  - name: "vmulx{type[0]}"
    doc: Floating-point multiply extended
    arguments: ["a: {type[1]}", "b: {neon_type[2]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmulx, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - ['s_lane_f32', f32, float32x2_t, '1', 's_f32', 'LANE as u32']
      - ['s_laneq_f32', f32, float32x4_t, '2', 's_f32', 'LANE as u32']
      - ['d_laneq_f64', f64, float64x2_t, '1', 'd_f64', 'LANE as u32']
    compose:
      - FnCall: [static_assert_uimm_bits!, ['LANE', "{type[3]}"]]
      - FnCall:
          - "vmulx{type[4]}"
          - - a
            - FnCall:
                - "simd_extract!"
                - - b
                  - "{type[5]}"


  - name: "vmulx{type[0]}"
    doc: Floating-point multiply extended
    arguments: ["a: {type[1]}", "b: {neon_type[2]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmulx, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-fp16 
      - *neon-unstable-f16
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - ['h_lane_f16', f16, float16x4_t, '2', 'h_f16', "LANE as u32"]
      - ['h_laneq_f16', f16, float16x8_t, '3', 'h_f16', "LANE as u32"]
    compose:
      - FnCall: [static_assert_uimm_bits!, ['LANE', "{type[3]}"]]
      - FnCall:
          - "vmulx{type[4]}"
          - - a
            - FnCall:
                - "simd_extract!"
                - - b
                  - "{type[5]}"


  - name: "vmulx{neon_type[0].N}"
    doc: "Vector multiply by scalar"
    arguments: ["a: {neon_type[0]}", "b: {type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmulx]]}]]
      - *neon-fp16 
      - *neon-unstable-f16
    safety: safe
    types:
      - [float16x4_t, "f16"]
      - [float16x8_t, "f16"]
    compose:
      - FnCall:
          - vmulx{neon_type[0].no}
          - - a
            - FnCall: ["vdup{neon_type[0].N}", [b]]

  - name: "vfma{neon_type.no}"
    doc: Floating-point fused Multiply-Add to accumulator(vector)
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-stable
    assert_instr: [fmadd]
    safety: safe
    types:
      - float64x1_t
    compose:
      - LLVMLink:
          name: "_vfma{neon_type.no}"
          arguments: ["a: {type}", "b: {type}", "c: {type}"]
          links:
            - link: "llvm.fma.{neon_type}"
              arch: aarch64,arm64ec
      - FnCall: ["_vfma{neon_type.no}", [b, c, a], [], true]

  - name: "vfma{neon_type.no}"
    doc: Floating-point fused Multiply-Add to accumulator(vector)
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-stable
    assert_instr: [fmla]
    safety: safe
    types:
      - float64x2_t
    compose:
      - LLVMLink:
          name: "_vfma{neon_type.no}"
          arguments: ["a: {type}", "b: {type}", "c: {type}"]
          links:
            - link: "llvm.fma.{neon_type}"
              arch: aarch64,arm64ec
      - FnCall: ["_vfma{neon_type.no}", [b, c, a], [], true]

  - name: "vfma_n_f64"
    doc: Floating-point fused Multiply-Add to accumulator(vector)
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
    assert_instr: [fmadd]
    safety: safe
    types:
      - [float64x1_t, f64]
    compose:
      - FnCall:
          - "vfma_f64"
          - - a
            - b
            - FnCall:
                - "vdup_n_f64"
                - - c

  - name: "vfmaq_n_f64"
    doc: Floating-point fused Multiply-Add to accumulator(vector)
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall:
          - stable
          - - 'feature = "neon_intrinsics"'
            - 'since = "1.59.0"'
    assert_instr: [fmla]
    safety: safe
    types:
      - [float64x2_t, f64]
    compose:
      - FnCall:
          - "vfmaq_f64"
          - - a
            - b
            - FnCall:
                - "vdupq_n_f64"
                - - c

  - name: "vfma{neon_type[0].N}"
    doc: Floating-point fused Multiply-Subtract from accumulator.
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-fp16 
      - *neon-unstable-f16
    assert_instr: [fmla]
    safety: safe
    types:
      - [float16x4_t, f16]
      - [float16x8_t, f16]
    compose:
      - FnCall:
          - "vfma{neon_type[0].no}"
          - - a
            - b
            - FnCall:
                - "vdup{neon_type[0].N}"
                - - c

  - name: "vdiv{neon_type.no}"
    doc: "Divide"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [fdiv]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x1_t
      - float64x2_t
    compose:
      - FnCall: [simd_div, [a, b]]

  - name: "vdiv{neon_type.no}"
    doc: "Divide"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fdiv]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - FnCall: [simd_div, [a, b]]

  - name: "vdiv{type[1]}_{type[0]}"
    doc: Divide
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [nop]
    safety: safe
    types:
      - [f16, 'h']
    compose:
      - 'a / b'

  - name: "vsub{neon_type.no}"
    doc: "Subtract"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [fsub]
    safety: safe
    types:
      - float64x1_t
      - float64x2_t
    compose:
      - FnCall: [simd_sub, [a, b]]

  - name: "vsub{type[0]}"
    doc: "Subtract"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[1]}"
    attr: [*neon-stable]
    assert_instr: [nop]
    safety: safe
    types:
      - ['d_s64', 'i64']
      - ['d_u64', 'u64']
    compose:
      - MethodCall: [a, wrapping_sub, [b]]

  - name: "vsub{type[0]}"
    doc: "Subtract"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [nop]
    safety: safe
    types:
      - ['h_f16', 'f16']
    compose:
      - 'a - b'

  - name: "vaddv{neon_type[0].no}"
    doc: Floating-point add across vector
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall:
          - stable
          - - 'feature = "neon_intrinsics"'
            - 'since = "1.59.0"'
    assert_instr: [faddp]
    safety: safe
    types:
      - [float32x2_t, f32]
      - [float32x4_t, f32]
      - [float64x2_t, f64]
    compose:
      - LLVMLink:
          name: "faddv.{type[1]}.{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.faddv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vaddlv{neon_type[0].no}"
    doc: Signed Add Long across Vector
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr: [*neon-stable]
    assert_instr: [saddlv]
    safety: safe
    types:
      - [int16x4_t, i32]
      - [int16x8_t, i32]
      - [int32x4_t, i64]
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.saddlv.{type[1]}.{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.saddlv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vaddlv{neon_type.no}"
    doc: Signed Add Long across Vector
    arguments: ["a: {neon_type}"]
    return_type: "i64"
    attr: [*neon-stable]
    assert_instr: [saddlp]
    safety: safe
    types:
      - int32x2_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.saddlv.i64.v2i32"
          links:
            - link: "llvm.aarch64.neon.saddlv.i64.v2i32"
              arch: aarch64,arm64ec

  - name: "vaddlv{neon_type[0].no}"
    doc: Unsigned Add Long across Vector
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr: [*neon-stable]
    assert_instr: [uaddlv]
    safety: safe
    types:
      - [uint16x4_t, u32, i32]
      - [uint16x8_t, u32, i32]
      - [uint32x4_t, u64, i64]
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.uaddlv.{type[2]}.{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.uaddlv.{type[2]}.{neon_type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ['_vaddlv{neon_type[0].no}', ['a'], [], true]

  - name: "vaddlv{neon_type[0].no}"
    doc: Unsigned Add Long across Vector
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr: [*neon-stable]
    assert_instr: [uaddlp]
    safety: safe
    types:
      - [uint32x2_t, u64, i64]
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.uaddlv.{type[2]}.{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.uaddlv.{type[2]}.{neon_type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ['_vaddlv{neon_type[0].no}', ['a'], [], true]

  - name: "vsubw_high{neon_type[1].noq}"
    doc: Signed Subtract Wide
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr: [*neon-stable]
    assert_instr: [ssubw]
    safety: safe
    types:
      - [int16x8_t, int8x16_t, int8x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]']
      - [int32x4_t, int16x8_t, int16x4_t, '[4, 5, 6, 7]']
      - [int64x2_t, int32x4_t, int32x2_t, '[2, 3]']
    compose:
      - Let:
          - c
          - "{neon_type[2]}"
          - FnCall: [simd_shuffle!, [b, b, "{type[3]}"]]
      - FnCall:
          - simd_sub
          - - a
            - FnCall: [simd_cast, [c]]

  - name: "vsubw_high{neon_type[1].noq}"
    doc: Unsigned Subtract Wide
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr: [*neon-stable]
    assert_instr: [usubw]
    safety: safe
    types:
      - [uint16x8_t, uint8x16_t, uint8x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint32x4_t, uint16x8_t, uint16x4_t, '[4, 5, 6, 7]']
      - [uint64x2_t, uint32x4_t, uint32x2_t, '[2, 3]']
    compose:
      - Let:
          - c
          - "{neon_type[2]}"
          - FnCall: [simd_shuffle!, [b, b, "{type[3]}"]]
      - FnCall:
          - simd_sub
          - - a
            - FnCall: [simd_cast, [c]]

  - name: "vsubl_high{neon_type[0].noq}"
    doc: "Signed Subtract Long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    assert_instr: [ssubl]
    safety: safe
    types:
      - [int8x16_t, int16x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]', int8x8_t]
      - [int16x8_t, int32x4_t, '[4, 5, 6, 7]', int16x4_t]
      - [int32x4_t, int64x2_t, '[2, 3]', int32x2_t]
    compose:
      - Let:
          - c
          - "{neon_type[3]}"
          - FnCall: [simd_shuffle!, [a, a, "{type[2]}"]]
      - Let:
          - d
          - "{neon_type[1]}"
          - FnCall: [simd_cast, [c]]
      - Let:
          - e
          - "{neon_type[3]}"
          - FnCall: [simd_shuffle!, [b, b, "{type[2]}"]]
      - Let:
          - f
          - "{neon_type[1]}"
          - FnCall: [simd_cast, [e]]
      - FnCall: [simd_sub, [d, f]]

  - name: "vsubl_high{neon_type[0].noq}"
    doc: "Unsigned Subtract Long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    assert_instr: [usubl]
    safety: safe
    types:
      - [uint8x16_t, uint16x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]', uint8x8_t]
      - [uint16x8_t, uint32x4_t, '[4, 5, 6, 7]', uint16x4_t]
      - [uint32x4_t, uint64x2_t, '[2, 3]', uint32x2_t]
    compose:
      - Let:
          - c
          - "{neon_type[3]}"
          - FnCall: [simd_shuffle!, [a, a, "{type[2]}"]]
      - Let:
          - d
          - "{neon_type[1]}"
          - FnCall: [simd_cast, [c]]
      - Let:
          - e
          - "{neon_type[3]}"
          - FnCall: [simd_shuffle!, [b, b, "{type[2]}"]]
      - Let:
          - f
          - "{neon_type[1]}"
          - FnCall: [simd_cast, [e]]
      - FnCall: [simd_sub, [d, f]]

  - name: "vbcax{neon_type.no}"
    doc: Bit clear and exclusive OR
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sha3"']]
      - FnCall: [stable, ['feature = "stdarch_neon_sha3"', 'since = "1.79.0"']]
    assert_instr: [bcax]
    safety: safe
    types:
      - int8x16_t
      - int16x8_t
      - int32x4_t
      - int64x2_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.crypto.bcaxs.{neon_type}"
          links:
            - link: "llvm.aarch64.crypto.bcaxs.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vbcax{neon_type.no}"
    doc: Bit clear and exclusive OR
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sha3"']]
      - FnCall: [stable, ['feature = "stdarch_neon_sha3"', 'since = "1.79.0"']]
    assert_instr: [bcax]
    safety: safe
    types:
      - uint8x16_t
      - uint16x8_t
      - uint32x4_t
      - uint64x2_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.crypto.bcaxu.{neon_type}"
          links:
            - link: "llvm.aarch64.crypto.bcaxu.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vcadd{neon_type.rot270}"
    doc: "Floating-point complex add"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - *neon-unstable-fcma
    assert_instr: [fcadd]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.vcadd.rot270.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.vcadd.rot270.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vcadd{neon_type.rot90}"
    doc: "Floating-point complex add"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - *neon-unstable-fcma
    assert_instr: [fcadd]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.vcadd.rot90.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.vcadd.rot90.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vcadd{neon_type.rot270}"
    doc: "Floating-point complex add"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-fp16
      - *enable-fcma
      - *neon-unstable-f16
    assert_instr: [fcadd]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "vcadd.rot270.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.vcadd.rot270.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vcadd{neon_type.rot90}"
    doc: "Floating-point complex add"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-fp16
      - *enable-fcma
      - *neon-unstable-f16
    assert_instr: [fcadd]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "vcadd.rot90.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.vcadd.rot90.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vcmla{neon_type.no}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - *neon-unstable-fcma
    assert_instr: [fcmla]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.vcmla.rot0.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.vcmla.rot0.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vcmla{neon_type.no}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fcmla]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.vcmla.rot0.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.vcmla.rot0.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vcmla{neon_type.rot90}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - *neon-unstable-fcma
    assert_instr: [fcmla]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.vcmla.rot90.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.vcmla.rot90.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vcmla{neon_type.rot90}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fcmla]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.vcmla.rot90.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.vcmla.rot90.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vcmla{neon_type.rot270}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - *neon-unstable-fcma
    assert_instr: [fcmla]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.vcmla.rot270.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.vcmla.rot270.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vcmla{neon_type.rot270}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fcmla]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.vcmla.rot270.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.vcmla.rot270.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vcmla{neon_type[0].laneq_nox}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-unstable-fcma
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float32x2_t, float32x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float32x4_t, float32x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, 1]]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].no}", [a, b, c]]

  - name: "vcmla{neon_type[0].laneq_nox}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float16x4_t, float16x8_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float16x8_t, float16x8_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, 2]]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].no}", [a, b, c]]

  - name: "vcmla{neon_type[0].rot90_laneq}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-unstable-fcma
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float32x2_t, float32x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float32x4_t, float32x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, 1]]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].rot90}", [a, b, c]]

  - name: "vcmla{neon_type[0].rot90_laneq}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float16x4_t, float16x8_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float16x8_t, float16x8_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, 2]]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].rot90}", [a, b, c]]

  - name: "vcmla{neon_type[0].rot90_lane}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-unstable-fcma
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float32x2_t, float32x2_t, '[2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float32x4_t, float32x2_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].rot90}", [a, b, c]]

  - name: "vcmla{neon_type[0].rot90_lane}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float16x4_t, float16x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float16x8_t, float16x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, 1]]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].rot90}", [a, b, c]]

  - name: "vcmla{neon_type.rot180}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - *neon-unstable-fcma
    assert_instr: [fcmla]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.vcmla.rot180.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.vcmla.rot180.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vcmla{neon_type.rot180}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fcmla]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "llvm.aarch64.neon.vcmla.rot180.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.vcmla.rot180.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vcmla{neon_type[0].rot180_laneq}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-unstable-fcma
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float32x2_t, float32x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float32x4_t, float32x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, 1]]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].rot180}", [a, b, c]]

  - name: "vcmla{neon_type[0].rot180_laneq}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float16x4_t, float16x8_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float16x8_t, float16x8_t,
        '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]'
        ]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, 2]]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].rot180}", [a, b, c]]

  - name: "vcmla{type[3]}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-unstable-fcma
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float32x2_t, float32x2_t, '[2 * LANE as u32, 2 * LANE as u32 + 1]', '_rot180_lane_f32']
      - [float32x4_t, float32x2_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]', 'q_rot180_lane_f32']
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].rot180}", [a, b, c]]

  - name: "vcmla{type[3]}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float16x4_t, float16x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]', '_rot180_lane_f16']
      - [float16x8_t, float16x4_t,
          '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]', 'q_rot180_lane_f16'
        ]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, 1]]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].rot180}", [a, b, c]]

  - name: "vcmla{neon_type[0].rot270_laneq}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-unstable-fcma
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float32x2_t, float32x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float32x4_t, float32x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, 1]]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].rot270}", [a, b, c]]

  - name: "vcmla{neon_type[0].rot270_laneq}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float16x4_t, float16x8_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float16x8_t, float16x8_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, 2]]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].rot270}", [a, b, c]]

  - name: "vcmla{neon_type[0].lane_nox}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-unstable-fcma
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float32x2_t, float32x2_t, '[2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float32x4_t, float32x2_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].no}", [a, b, c]]


  - name: "vcmla{neon_type[0].lane_nox}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float16x4_t, float16x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float16x8_t, float16x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, 1]]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]
      - FnCall: ["vcmla{neon_type[0].no}", [a, b, c]]

  - name: "vcmla{neon_type[0].rot270_lane}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-unstable-fcma
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float32x2_t, float32x2_t, '[2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float32x4_t, float32x2_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - Let: [c, "{neon_type[0]}", {FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]}]
      - FnCall: ["vcmla{neon_type[0].rot270}", [a, b, c]]


  - name: "vcmla{neon_type[0].rot270_lane}"
    doc: Floating-point complex multiply accumulate
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,fcma"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ["const LANE: i32"]
    safety: safe
    types:
      - [float16x4_t, float16x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
      - [float16x8_t, float16x4_t, '[2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1, 2 * LANE as u32, 2 * LANE as u32 + 1]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, 1]]
      - Let: [c, "{neon_type[0]}", {FnCall: [simd_shuffle!, [c, c, "{type[2]}"]]}]
      - FnCall: ["vcmla{neon_type[0].rot270}", [a, b, c]]

  - name: "vdot{neon_type[0].laneq_nox}"
    doc: Dot product arithmetic (indexed)
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    static_defs: ["const LANE: i32"]
    attr:
      - FnCall: [target_feature, ['enable = "neon,dotprod"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sdot, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [unstable, ['feature = "stdarch_neon_dotprod"', 'issue = "117224"']]
    safety: safe
    types:
      - [int32x2_t, int8x8_t, int8x16_t, int32x4_t, '[LANE as u32, LANE as u32]']
      - [int32x4_t, int8x16_t, int8x16_t, int32x4_t, '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '2']]
      - Let:
          - c
          - "{neon_type[3]}"
          - FnCall: [transmute, [c]]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, '{type[4]}']]
      - FnCall:
          - "vdot{neon_type[0].no}"
          - - a
            - b
            - FnCall: [transmute, [c]]

  - name: "vdot{neon_type[0].laneq_nox}"
    doc: Dot product arithmetic (indexed)
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    static_defs: ["const LANE: i32"]
    attr:
      - FnCall: [target_feature, ['enable = "neon,dotprod"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [udot, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [unstable, ['feature = "stdarch_neon_dotprod"', 'issue = "117224"']]
    safety: safe
    types:
      - [uint32x2_t, uint8x8_t, uint8x16_t, uint32x4_t, '[LANE as u32, LANE as u32]']
      - [uint32x4_t, uint8x16_t, uint8x16_t, uint32x4_t, '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '2']]
      - Let:
          - c
          - "{neon_type[3]}"
          - FnCall: [transmute, [c]]
      - Let:
          - c
          - "{neon_type[0]}"
          - FnCall: [simd_shuffle!, [c, c, '{type[4]}']]
      - FnCall:
          - "vdot{neon_type[0].no}"
          - - a
            - b
            - FnCall: [transmute, [c]]

  - name: "vmax{neon_type.no}"
    doc: Maximum (vector)
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [fmax]
    safety: safe
    types:
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "fmax.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fmax.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vmaxh_{type}"
    doc: Maximum (vector)
    arguments: ["a: {type}", "b: {type}"]
    return_type: "{type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fmax]
    safety: safe
    types:
      - f16
    compose:
      - LLVMLink:
          name: "vmaxh.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fmax.{type}"
              arch: aarch64,arm64ec



  - name: "vmaxnm{neon_type.no}"
    doc: Floating-point Maximum Number (vector)
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [fmaxnm]
    safety: safe
    types:
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "fmaxnm.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fmaxnm.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vmaxnmh_{type}"
    doc: Floating-point Maximum Number
    arguments: ["a: {type}", "b: {type}"]
    return_type: "{type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fmaxnm]
    safety: safe
    types:
      - f16
    compose:
      - LLVMLink:
          name: "vmaxh.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fmaxnm.{type}"
              arch: aarch64,arm64ec


  - name: "vminnmh_{type}"
    doc: Floating-point Minimum Number
    arguments: ["a: {type}", "b: {type}"]
    return_type: "{type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fminnm]
    safety: safe
    types:
      - f16
    compose:
      - LLVMLink:
          name: "vminh.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fminnm.{type}"
              arch: aarch64,arm64ec


  - name: "vmaxnmv{neon_type[0].no}"
    doc: Floating-point maximum number across vector
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr: [*neon-stable]
    assert_instr: [fmaxnmp]
    safety: safe
    types:
      - [float32x2_t, f32]
      - [float64x2_t, f64]
    compose:
      - LLVMLink:
          name: "fmaxnmv.{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fmaxnmv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vmaxnmv{neon_type[0].no}"
    doc: Floating-point maximum number across vector
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr: [*neon-stable]
    assert_instr: [fmaxnmv]
    safety: safe
    types:
      - [float32x4_t, f32]
    compose:
      - LLVMLink:
          name: "fmaxnmv.{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fmaxnmv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec


  - name: "vmaxnmv{neon_type[0].no}"
    doc: Floating-point maximum number across vector
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fmaxnmv]
    safety: safe
    types:
      - [float16x4_t, f16]
      - [float16x8_t, f16]
    compose:
      - LLVMLink:
          name: "fmaxnmv.{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fmaxnmv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec


  - name: "vminnmv{neon_type[0].no}"
    doc: Floating-point minimum number across vector
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fminnmv]
    safety: safe
    types:
      - [float16x4_t, f16]
      - [float16x8_t, f16]
    compose:
      - LLVMLink:
          name: "fminnmv.{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fminnmv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec


  - name: "vmaxv{neon_type[0].no}"
    doc: Floating-point maximum number across vector
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fmaxv]
    safety: safe
    types:
      - [float16x4_t, f16]
      - [float16x8_t, f16]
    compose:
      - LLVMLink:
          name: "fmaxv.{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fmaxv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vminv{neon_type[0].no}"
    doc: Floating-point minimum number across vector
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fminv]
    safety: safe
    types:
      - [float16x4_t, f16]
      - [float16x8_t, f16]
    compose:
      - LLVMLink:
          name: "fminv.{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fminv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vpmax{type[0]}"
    doc: "Floating-point maximum pairwise"
    arguments: ["a: {neon_type[1]}"]
    return_type: "{type[2]}"
    attr: [*neon-stable]
    assert_instr: [fmaxp]
    safety: safe
    types:
      - ["s_f32", float32x2_t, f32]
      - ["qd_f64", float64x2_t, f64]
    compose:
      - LLVMLink:
          name: "fmaxv.{type[0]}"
          links:
            - link: "llvm.aarch64.neon.fmaxv.{type[2]}.{neon_type[1]}"
              arch: aarch64,arm64ec

  - name: "vmin{neon_type.no}"
    doc: "Minimum (vector)"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [fmin]
    safety: safe
    types:
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "fmin.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fmin.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vminh_{type}"
    doc: Minimum (vector)
    arguments: ["a: {type}", "b: {type}"]
    return_type: "{type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fmin]
    safety: safe
    types:
      - f16
    compose:
      - LLVMLink:
          name: "vminh.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fmin.{type}"
              arch: aarch64,arm64ec


  - name: "vminnm{neon_type.no}"
    doc: "Floating-point Minimum Number (vector)"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr: [*neon-stable]
    assert_instr: [fminnm]
    safety: safe
    types:
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "fminnm.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fminnm.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vminnmv{neon_type[0].no}"
    doc: "Floating-point minimum number across vector"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fminnmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, "f32"]
      - [float64x2_t, "f64"]
    compose:
      - LLVMLink:
          name: "vminnmv.{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fminnmv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vminnmv{neon_type[0].no}"
    doc: "Floating-point minimum number across vector"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fminnmv]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x4_t, "f32"]
    compose:
      - LLVMLink:
          name: "vminnmv.{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fminnmv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vmovl_high{neon_type[0].noq}"
    doc: Vector move
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    assert_instr: [sxtl2]
    safety: safe
    types:
      - [int8x16_t, int16x8_t, int8x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]']
      - [int16x8_t, int32x4_t, int16x4_t, '[4, 5, 6, 7]']
      - [int32x4_t, int64x2_t, int32x2_t, '[2, 3]']
    compose:
      - Let:
          - a
          - "{neon_type[2]}"
          - FnCall: [simd_shuffle!, [a, a, "{type[3]}"]]
      - FnCall: ["vmovl{neon_type[0].noq}", [a]]

  - name: "vmovl_high{neon_type[0].noq}"
    doc: Vector move
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr: [*neon-stable]
    assert_instr: [uxtl2]
    safety: safe
    types:
      - [uint8x16_t, uint16x8_t, uint8x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint16x8_t, uint32x4_t, uint16x4_t, '[4, 5, 6, 7]']
      - [uint32x4_t, uint64x2_t, uint32x2_t, '[2, 3]']
    compose:
      - Let:
          - a
          - "{neon_type[2]}"
          - FnCall: [simd_shuffle!, [a, a, "{type[3]}"]]
      - FnCall: ["vmovl{neon_type[0].noq}", [a]]

  - name: "vpadd{neon_type.no}"
    doc: Floating-point add pairwise
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{type}"
    attr: [*neon-stable]
    assert_instr: [faddp]
    safety: safe
    types:
      - float32x4_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "faddp.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.faddp.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vpadd{neon_type.no}"
    doc: Floating-point add pairwise
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [faddp]
    safety: safe
    types:
      - float16x8_t
    compose:
      - LLVMLink:
          name: "faddp.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.faddp.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vpmax{neon_type.no}"
    doc: Floating-point add pairwise
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fmaxp]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "fmaxp.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fmaxp.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vpmaxnm{neon_type.no}"
    doc: Floating-point add pairwise
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fmaxnmp]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "fmaxnmp.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fmaxnmp.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vpmin{neon_type.no}"
    doc: Floating-point add pairwise
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fminp]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "fminp.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fminp.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vpminnm{neon_type.no}"
    doc: Floating-point add pairwise
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{type}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fminnmp]
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - LLVMLink:
          name: "fminnmp.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fminnmp.{neon_type}"
              arch: aarch64,arm64ec


  - name: "vpadd{type[0]}"
    doc: "Floating-point add pairwise"
    arguments: ["a: {neon_type[1]}"]
    return_type: "{type[2]}"
    attr: [*neon-stable]
    assert_instr: [nop]
    safety: safe
    types:
      - ["s_f32", float32x2_t, f32]
      - ["d_f64", float64x2_t, f64]
    compose:
      - Let:
          - a1
          - "{type[2]}"
          - FnCall: [simd_extract!, [a, '0']]
      - Let:
          - a2
          - "{type[2]}"
          - FnCall: [simd_extract!, [a, '1']]
      - Identifier: ['a1 + a2', Symbol]

  - name: "vpmin{type[0]}"
    doc: Floating-point minimum pairwise
    arguments: ["a: {neon_type[1]}"]
    return_type: "{type[2]}"
    attr: [*neon-stable]
    assert_instr: [fminp]
    safety: safe
    types:
      - ["s_f32", float32x2_t, f32]
      - ["qd_f64", float64x2_t, f64]
    compose:
      - LLVMLink:
          name: "fminv.{type[2]}.{neon_type[1]}"
          links:
            - link: "llvm.aarch64.neon.fminv.{type[2]}.{neon_type[1]}"
              arch: aarch64,arm64ec

  - name: "vqdmullh_s16"
    doc: "Signed saturating doubling multiply long"
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmull]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i16", "i32"]
    compose:
      - Let: [a, int16x4_t, {FnCall: [vdup_n_s16, [a]]}]
      - Let: [b, int16x4_t, {FnCall: [vdup_n_s16, [b]]}]
      - FnCall: [simd_extract!, [{FnCall: [vqdmull_s16, [a, b]]}, '0']]

  - name: "vqdmulls_s32"
    doc: "Signed saturating doubling multiply long"
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmull]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i32", "i64"]
    compose:
      - LLVMLink:
          name: "vqdmulls_s32"
          links:
            - link: "llvm.aarch64.neon.sqdmulls.scalar"
              arch: aarch64,arm64ec

  - name: "vqdmull_high{neon_type[0].noq}"
    doc: "Signed saturating doubling multiply long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmull2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int16x8_t, int32x4_t, int16x4_t, '[4, 5, 6, 7]']
      - [int32x4_t, int64x2_t, int32x2_t, '[2, 3]']
    compose:
      - Let: [a, "{neon_type[2]}", {FnCall: [simd_shuffle!, [a, a, '{type[3]}']]}]
      - Let: [b, "{neon_type[2]}", {FnCall: [simd_shuffle!, [b, b, '{type[3]}']]}]
      - FnCall: ["vqdmull{neon_type[0].noq}", [a, b]]

  - name: "vqdmull_high_n_{type[1]}"
    doc: "Signed saturating doubling multiply long"
    arguments: ["a: {neon_type[0]}", "b: {type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmull2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int16x8_t, "i16", int32x4_t, int16x4_t, '[4, 5, 6, 7]']
      - [int32x4_t, "i32", int64x2_t, int32x2_t, '[2, 3]']
    compose:
      - Let: [a, "{neon_type[3]}", {FnCall: [simd_shuffle!, [a, a, "{type[4]}"]]}]
      - Let: [b, "{neon_type[3]}", {FnCall: ["vdup_n{neon_type[0].noq}", [b]]}]
      - FnCall: ["vqdmull{neon_type[0].noq}", [a, b]]

  - name: "vqdmull{type[3]}"
    doc: "Signed saturating doubling multiply long"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmull, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["i16", int16x4_t, "i32", 'h_lane_s16', 'h_s16']
      - ["i32", int32x4_t, "i64", 's_laneq_s32', 's_s32']
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, 2]]
      - Let: [b, "{type[0]}", {FnCall: [simd_extract!, [b, 'N as u32']]}]
      - FnCall: ["vqdmull{type[4]}", [a, b]]

  - name: "vqdmullh_laneq_s16"
    doc: "Signed saturating doubling multiply long"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmull, N = 4]]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["i16", int16x8_t, "i32"]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, 3]]
      - Let: [b, "{type[0]}", {FnCall: [simd_extract!, [b, 'N as u32']]}]
      - FnCall: ["vqdmullh_s16", [a, b]]

  - name: "vqdmulls_lane_s32"
    doc: "Signed saturating doubling multiply long"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmull, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["i32", int32x2_t, "i64"]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, 1]]
      - Let: [b, "{type[0]}", {FnCall: [simd_extract!, [b, 'N as u32']]}]
      - FnCall: ["vqdmulls_s32", [a, b]]

  - name: "vqdmull{type[6]}"
    doc: "Signed saturating doubling multiply long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmull2, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int16x8_t, int16x4_t, int32x4_t, int16x4_t, '[4, 5, 6, 7]', '[N as u32, N as u32, N as u32, N as u32]', '_high_lane_s16']
      - [int32x4_t, int32x4_t, int64x2_t, int32x2_t, '[2, 3]', '[N as u32, N as u32]', '_high_laneq_s32']
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, '2']]
      - Let: [a, "{neon_type[3]}", {FnCall: [simd_shuffle!, [a, a, "{type[4]}"]]}]
      - Let: [b, "{neon_type[3]}", {FnCall: [simd_shuffle!, [b, b, "{type[5]}"]]}]
      - FnCall: ["vqdmull{neon_type[0].noq}", [a, b]]

  - name: "vqdmull_high_lane_s32"
    doc: "Signed saturating doubling multiply long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmull2, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int32x4_t, int32x2_t, int64x2_t, int32x2_t, '[2, 3]', '[N as u32, N as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, '1']]
      - Let: [a, "{neon_type[3]}", {FnCall: [simd_shuffle!, [a, a, "{type[4]}"]]}]
      - Let: [b, "{neon_type[3]}", {FnCall: [simd_shuffle!, [b, b, "{type[5]}"]]}]
      - FnCall: ["vqdmull{neon_type[0].noq}", [a, b]]

  - name: "vqdmull_high_laneq_s16"
    doc: "Signed saturating doubling multiply long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmull2, N = 4]]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int16x8_t, int16x8_t, int32x4_t, int16x4_t, '[4, 5, 6, 7]', '[N as u32, N as u32, N as u32, N as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, '3']]
      - Let: [a, "{neon_type[3]}", {FnCall: [simd_shuffle!, [a, a, "{type[4]}"]]}]
      - Let: [b, "{neon_type[3]}", {FnCall: [simd_shuffle!, [b, b, "{type[5]}"]]}]
      - FnCall: ["vqdmull{neon_type[0].noq}", [a, b]]

  - name: "vqdmull_laneq_s16"
    doc: "Vector saturating doubling long multiply by scalar"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmull, 'N = 4']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int16x4_t, int16x8_t, int32x4_t, '[N as u32, N as u32, N as u32, N as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, '3']]
      - Let: [b, "{neon_type[0]}", {FnCall: [simd_shuffle!, [b, b, "{type[3]}"]]}]
      - FnCall: [vqdmull_s16, [a, b]]

  - name: "vqdmull_laneq_s32"
    doc: "Vector saturating doubling long multiply by scalar"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmull, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int32x2_t, int32x4_t, int64x2_t, '[N as u32, N as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, '2']]
      - Let: [b, "{neon_type[0]}", {FnCall: [simd_shuffle!, [b, b, "{type[3]}"]]}]
      - FnCall: [vqdmull_s32, [a, b]]

  - name: "vqdmlal{type[4]}"
    doc: "Signed saturating doubling multiply-add long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlal2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int32x4_t, int16x8_t, int16x8_t, int32x4_t, _high_s16]
      - [int64x2_t, int32x4_t, int32x4_t, int64x2_t, _high_s32]
      - [int32x4_t, int16x8_t, "i16", int32x4_t, _high_n_s16]
      - [int64x2_t, int32x4_t, "i32", int64x2_t, _high_n_s32]
    compose:
      - FnCall: ["vqadd{neon_type[0].no}", [a, {FnCall: ["vqdmull{type[4]}", [b, c]]}]]

  - name: "vqdmlal{type[4]}"
    doc: "Signed saturating doubling multiply-add long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlal2, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int32x4_t, int16x8_t, int16x4_t, int32x4_t, _high_lane_s16, '2']
      - [int32x4_t, int16x8_t, int16x8_t, int32x4_t, _high_laneq_s16, '3']
      - [int64x2_t, int32x4_t, int32x2_t, int64x2_t, _high_lane_s32, '1']
      - [int64x2_t, int32x4_t, int32x4_t, int64x2_t, _high_laneq_s32, '2']
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, "{type[5]}"]]
      - FnCall: ["vqadd{neon_type[0].no}", [a, {FnCall: ["vqdmull{type[4]}::<N>", [b, c]]}]]

  - name: "vqdmlalh_{type[2]}"
    doc: "Signed saturating doubling multiply-add long"
    arguments: ["a: {type[0]}", "b: {type[1]}", "c: {type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlal]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i32", "i16", "s16"]
    compose:
      - Let: [x, int32x4_t, {FnCall: [vqdmull_s16, [{FnCall: [vdup_n_s16, [b]]}, {FnCall: [vdup_n_s16, [c]]}]]}]
      - FnCall: [vqadds_s32, [a, {FnCall: [simd_extract!, [x, 0]]}]]

  - name: "vqdmlals_s32"
    doc: "Signed saturating doubling multiply-add long"
    arguments: ["a: {type[0]}", "b: {type[1]}", "c: {type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlal]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i64", "i32", "i32", "i64"]
    compose:
      - Let: [x, i64, {FnCall: [vqaddd_s64, [a, {FnCall: [vqdmulls_s32, [b, c]]}]]}]
      - Identifier: ['x as i64', Symbol]

  - name: "vqdmlal{type[4]}"
    doc: "Signed saturating doubling multiply-add long"
    arguments: ["a: {type[0]}", "b: {type[1]}", "c: {neon_type[2]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlal, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["i32", "i16", int16x4_t, "i32", h_lane_s16, '2', h_s16]
      - ["i32", "i16", int16x8_t, "i32", h_laneq_s16, '3', h_s16]
      - ["i64", "i32", int32x2_t, "i64", s_lane_s32, '1', s_s32]
      - ["i64", "i32", int32x4_t, "i64", s_laneq_s32, '2', s_s32]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[5]}"]]
      - FnCall: ["vqdmlal{type[6]}", [a, b, {FnCall: [simd_extract!, [c, 'LANE as u32']]}]]

  - name: "vqdmlal_laneq_s16"
    doc: "Vector widening saturating doubling multiply accumulate with scalar"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlal, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int32x4_t, int16x4_t, int16x8_t, int32x4_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, '3']]
      - FnCall: [vqaddq_s32, [a, {FnCall: ["vqdmull_laneq_s16::<N>", [b, c]]}]]

  - name: "vqdmlal_laneq_s32"
    doc: "Vector widening saturating doubling multiply accumulate with scalar"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlal, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int64x2_t, int32x2_t, int32x4_t, int64x2_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, '2']]
      - FnCall: [vqaddq_s64, [a, {FnCall: ["vqdmull_laneq_s32::<N>", [b, c]]}]]

  - name: "vqdmlsl{type[4]}"
    doc: "Signed saturating doubling multiply-subtract long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlsl2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int32x4_t, int16x8_t, int16x8_t, int32x4_t, _high_s16]
      - [int64x2_t, int32x4_t, int32x4_t, int64x2_t, _high_s32]
      - [int32x4_t, int16x8_t, "i16", int32x4_t, _high_n_s16]
      - [int64x2_t, int32x4_t, "i32", int64x2_t, _high_n_s32]
    compose:
      - FnCall: ["vqsub{neon_type[0].no}", [a, {FnCall: ["vqdmull{type[4]}", [b, c]]}]]

  - name: "vqdmlsl{type[4]}"
    doc: "Signed saturating doubling multiply-subtract long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlsl2, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int32x4_t, int16x8_t, int16x4_t, int32x4_t, '_high_lane_s16', '2']
      - [int32x4_t, int16x8_t, int16x8_t, int32x4_t, '_high_laneq_s16', '3']
      - [int64x2_t, int32x4_t, int32x2_t, int64x2_t, '_high_lane_s32', '1']
      - [int64x2_t, int32x4_t, int32x4_t, int64x2_t, '_high_laneq_s32', '2']
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, "{type[5]}"]]
      - FnCall: ["vqsub{neon_type[0].no}", [a, {FnCall: ["vqdmull{type[4]}::<N>", [b, c]]}]]

  - name: "vqdmlslh_s16"
    doc: "Signed saturating doubling multiply-subtract long"
    arguments: ["a: {type[0]}", "b: {type[1]}", "c: {type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlsl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i32", "i16"]
    compose:
      - Let: [x, int32x4_t, {FnCall: [vqdmull_s16, [{FnCall: [vdup_n_s16, [b]]}, {FnCall: [vdup_n_s16, [c]]}]]}]
      - FnCall: [vqsubs_s32, [a, {FnCall: [simd_extract!, [x, '0']]}]]

  - name: "vqdmlsls_s32"
    doc: "Signed saturating doubling multiply-subtract long"
    arguments: ["a: {type[0]}", "b: {type[1]}", "c: {type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlsl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i64", "i32", "i32", "i64"]
    compose:
      - Let: [x, i64, {FnCall: [vqsubd_s64, [a, {FnCall: [vqdmulls_s32, [b, c]]}]]}]
      - Identifier: ['x as i64', Symbol]

  - name: "vqdmlsl{type[4]}"
    doc: "Signed saturating doubling multiply-subtract long"
    arguments: ["a: {type[0]}", "b: {type[1]}", "c: {neon_type[2]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlsl, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["i32", "i16", int16x4_t, "i32", 'h_lane_s16', '2', 'h_s16']
      - ["i32", "i16", int16x8_t, "i32", 'h_laneq_s16', '3', 'h_s16']
      - ["i64", "i32", int32x2_t, "i64", 's_lane_s32', '1', 's_s32']
      - ["i64", "i32", int32x4_t, "i64", 's_laneq_s32', '2', 's_s32']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[5]}"]]
      - FnCall: ["vqdmlsl{type[6]}", [a, b, {FnCall: [simd_extract!, [c, 'LANE as u32']]}]]

  - name: "vqdmlsl_laneq_s16"
    doc: "Vector widening saturating doubling multiply subtract with scalar"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlsl, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int32x4_t, int16x4_t, int16x8_t, int32x4_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, '3']]
      - FnCall: ["vqsubq_s32", [a, {FnCall: ["vqdmull_laneq_s16::<N>", [b, c]]}]]

  - name: "vqdmlsl_laneq_s32"
    doc: "Vector widening saturating doubling multiply subtract with scalar"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmlsl, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int64x2_t, int32x2_t, int32x4_t, int64x2_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, '2']]
      - FnCall: [vqsubq_s64, [a, {FnCall: ["vqdmull_laneq_s32::<N>", [b, c]]}]]

  - name: "vqdmulh{type[4]}"
    doc: "Signed saturating doubling multiply returning high half"
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmulh]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i16", "i16", "i16", int16x4_t, 'h_s16']
      - ["i32", "i32", "i32", int32x2_t, 's_s32']
    compose:
      - Let: [a, "{neon_type[3]}", {FnCall: ["vdup_n{neon_type[3].no}", [a]]}]
      - Let: [b, "{neon_type[3]}", {FnCall: ["vdup_n{neon_type[3].no}", [b]]}]
      - FnCall: [simd_extract!, [{FnCall: ["vqdmulh{neon_type[3].no}", [a, b]]}, '0']]

  - name: "vqdmulhh{type[3]}"
    doc: "Signed saturating doubling multiply returning high half"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmulh, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["i16", int16x4_t, "i16", '_lane_s16', '2']
      - ["i16", int16x8_t, "i16", '_laneq_s16', '3']
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, "{type[4]}"]]
      - Let: [b, 'i16', {FnCall: [simd_extract!, [b, 'N as u32']]}]
      - FnCall: ['vqdmulhh_s16', [a, b]]

  - name: "vqdmulhs{type[3]}"
    doc: "Signed saturating doubling multiply returning high half"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmulh, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["i32", int32x2_t, "i32", "_lane_s32", '1']
      - ["i32", int32x4_t, "i32", "_laneq_s32", '2']
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, "{type[4]}"]]
      - Let: [b, 'i32', {FnCall: [simd_extract!, [b, 'N as u32']]}]
      - FnCall: ['vqdmulhs_s32', [a, b]]

  - name: "vqmovn_high{neon_type[1].noq}"
    doc: "Signed saturating extract narrow"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqxtn2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, int16x8_t, int8x16_t, '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [int16x4_t, int32x4_t, int16x8_t, '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [int32x2_t, int64x2_t, int32x4_t, '[0, 1, 2, 3]']
    compose:
      - FnCall: [simd_shuffle!, [a, {FnCall: ["vqmovn{neon_type[1].noq}", [b]]}, "{type[3]}"]]

  - name: "vqmovn_high{neon_type[1].noq}"
    doc: "Signed saturating extract narrow"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uqxtn2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x8_t, uint16x8_t, uint8x16_t, '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint16x4_t, uint32x4_t, uint16x8_t, '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [uint32x2_t, uint64x2_t, uint32x4_t, '[0, 1, 2, 3]']
    compose:
      - FnCall: [simd_shuffle!, [a, {FnCall: ["vqmovn{neon_type[1].noq}", [b]]}, "{type[3]}"]]

  - name: "vqmovn{type[2]}"
    doc: "Saturating extract narrow"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqxtn]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i16", "i8", 'h_s16', s16]
      - ["i32", "i16", 's_s32', s32]
    compose:
      - FnCall: [simd_extract!, [{FnCall: ["vqmovn_{type[3]}", [{FnCall: ["vdupq_n_{type[3]}", [a]]}]]}, '0']]

  - name: "vqmovn{type[2]}"
    doc: "Saturating extract narrow"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uqxtn]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["u16", "u8", 'h_u16', 'u16']
      - ["u32", "u16", 's_u32', 'u32']
    compose:
      - FnCall: [simd_extract!, [{FnCall: ["vqmovn_{type[3]}", [{FnCall: ["vdupq_n_{type[3]}", [a]]}]]}, '0']]

  - name: "vqmovnd_s64"
    doc: "Saturating extract narrow"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqxtn]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i64", "i32"]
    compose:
      - LLVMLink:
          name: "vqmovnd_s64"
          links:
            - link: "llvm.aarch64.neon.scalar.sqxtn.i32.i64"
              arch: aarch64,arm64ec

  - name: "vqmovnd_u64"
    doc: "Saturating extract narrow"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uqxtn]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["u64", "u32"]
    compose:
      - LLVMLink:
          name: "vqmovnd_u64"
          links:
            - link: "llvm.aarch64.neon.scalar.uqxtn.i32.i64"
              arch: aarch64,arm64ec

  - name: "vqmovun{type[2]}"
    doc: "Signed saturating extract unsigned narrow"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqxtun]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i16", "u8", 'h_s16', s16]
      - ["i32", "u16", 's_s32', s32]
      - ["i64", "u32", 'd_s64', s64]
    compose:
      - FnCall: [simd_extract!, [{FnCall: ["vqmovun_{type[3]}", [{FnCall: ["vdupq_n_{type[3]}", [a]]}]]}, '0']]

  - name: "vqmovun_high_{neon_type[1]}"
    doc: "Signed saturating extract unsigned narrow"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqxtun2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x8_t, int16x8_t, uint8x16_t, s16, '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint16x4_t, int32x4_t, uint16x8_t, s32, '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [uint32x2_t, int64x2_t, uint32x4_t, s64, '[0, 1, 2, 3]']
    compose:
      - FnCall: [simd_shuffle!, [a, {FnCall: ["vqmovun_{type[3]}", [b]]}, "{type[4]}"]]

  - name: "vqrdmulh{type[1]}"
    doc: "Signed saturating rounding doubling multiply returning high half"
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrdmulh]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i16", 'h_s16', 's16']
      - ["i32", 's_s32', 's32']
    compose:
      - FnCall: [simd_extract!, [{FnCall: ["vqrdmulh_{type[2]}", [{FnCall: ["vdup_n_{type[2]}", [a]]}, {FnCall: ["vdup_n_{type[2]}", [b]]}]]}, '0']]

  - name: "vqrdmulh{type[2]}"
    doc: "Signed saturating rounding doubling multiply returning high half"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrdmulh, LANE = 1]]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["i16", int16x4_t, 'h_lane_s16', 'h_s16', '2']
      - ["i16", int16x8_t, 'h_laneq_s16', 'h_s16', '3']
      - ["i32", int32x2_t, 's_lane_s32', 's_s32', '1']
      - ["i32", int32x4_t, 's_laneq_s32', 's_s32', '2']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[4]}"]]
      - FnCall: ["vqrdmulh{type[3]}", [a, {FnCall: [simd_extract!, [b, 'LANE as u32']]}]]

  - name: "vqrdmlah{neon_type.no}"
    doc: "Signed saturating rounding doubling multiply accumulate returning high half"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "rdm"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrdmlah]]}]]
      - FnCall: [stable, ['feature = "rdm_intrinsics"', 'since = "1.62.0"']]
    safety: safe
    types:
      - int16x4_t
      - int16x8_t
      - int32x2_t
      - int32x4_t
    compose:
      - LLVMLink:
          name: "vqrdmlah{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.sqrdmlah.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vqrdmlah{type[3]}"
    doc: "Signed saturating rounding doubling multiply accumulate returning high half"
    arguments: ["a: {type[0]}", "b: {type[0]}", "c: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "rdm"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrdmlah]]}]]
      - FnCall: [stable, ['feature = "rdm_intrinsics"', 'since = "1.62.0"']]
    safety: safe
    types:
      - ["i16", int16x4_t, s16, 'h_s16']
      - ["i32", int32x2_t, s32, 's_s32']
    compose:
      - Let: [a, "{neon_type[1]}", {FnCall: ["vdup_n_{type[2]}", [a]]}]
      - Let: [b, "{neon_type[1]}", {FnCall: ["vdup_n_{type[2]}", [b]]}]
      - Let: [c, "{neon_type[1]}", {FnCall: ["vdup_n_{type[2]}", [c]]}]
      - FnCall: [simd_extract!, [{FnCall: ["vqrdmlah_{type[2]}", [a, b, c]]}, '0']]

  - name: "vqrdmlah{type[0]}"
    doc: "Signed saturating rounding doubling multiply accumulate returning high half"
    arguments: ["a: {type[1]}", "b: {type[2]}", "c: {neon_type[3]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [target_feature, ['enable = "rdm"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrdmlah, 'LANE = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "rdm_intrinsics"', 'since = "1.62.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [_lane_s16, int16x4_t, int16x4_t, int16x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [_laneq_s16, int16x4_t, int16x4_t, int16x8_t, '3', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [q_lane_s16, int16x8_t, int16x8_t, int16x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [q_laneq_s16, int16x8_t, int16x8_t, int16x8_t, '3', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [_lane_s32, int32x2_t, int32x2_t, int32x2_t, '1', '[LANE as u32, LANE as u32]']
      - [_laneq_s32, int32x2_t, int32x2_t, int32x4_t, '2', '[LANE as u32, LANE as u32]']
      - [q_lane_s32, int32x4_t, int32x4_t, int32x2_t, '1', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [q_laneq_s32, int32x4_t, int32x4_t, int32x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[4]}']]
      - Let: [c, "{type[1]}", {FnCall: [simd_shuffle!, [c, c, "{type[5]}"]]}]
      - FnCall: ["vqrdmlah{neon_type[2].no}", [a, b, c]]

  - name: "vqrdmlah{type[4]}"
    doc: "Signed saturating rounding doubling multiply accumulate returning high half"
    arguments: ["a: {type[0]}", "b: {type[0]}", "c: {neon_type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "rdm"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrdmlah, 'LANE = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "rdm_intrinsics"', 'since = "1.62.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["i16", int16x4_t, '2', "h_s16", h_lane_s16, h_s16]
      - ["i16", int16x8_t, '3', "h_s16", h_laneq_s16, h_s16]
      - ["i32", int32x2_t, '1', "s_s32", s_lane_s32, s_s32]
      - ["i32", int32x4_t, '2', "s_s32", s_laneq_s32, s_s32]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[2]}"]]
      - FnCall: ["vqrdmlah{type[5]}", [a, b, {FnCall: [simd_extract!, [c, 'LANE as u32']]}]]

  - name: "vqrdmlsh{neon_type.no}"
    doc: "Signed saturating rounding doubling multiply subtract returning high half"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "rdm"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrdmlsh]]}]]
      - FnCall: [stable, ['feature = "rdm_intrinsics"', 'since = "1.62.0"']]
    safety: safe
    types:
      - int16x4_t
      - int16x8_t
      - int32x2_t
      - int32x4_t
    compose:
      - LLVMLink:
          name: "vqrdmlsh{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.sqrdmlsh.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vqrdmlsh{type[1]}"
    doc: "Signed saturating rounding doubling multiply subtract returning high half"
    arguments: ["a: {type[0]}", "b: {type[0]}", "c: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "rdm"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrdmlsh]]}]]
      - FnCall: [stable, ['feature = "rdm_intrinsics"', 'since = "1.62.0"']]
    safety: safe
    types:
      - ["i16", "h_s16", int16x4_t, s16]
      - ["i32", "s_s32", int32x2_t, s32]
    compose:
      - Let: [a, "{neon_type[2]}", {FnCall: ["vdup_n_{type[3]}", [a]]}]
      - Let: [b, "{neon_type[2]}", {FnCall: ["vdup_n_{type[3]}", [b]]}]
      - Let: [c, "{neon_type[2]}", {FnCall: ["vdup_n_{type[3]}", [c]]}]
      - FnCall: [simd_extract!, [{FnCall: ["vqrdmlsh_{type[3]}", [a, b, c]]}, '0']]

  - name: "vqrdmlsh{type[0]}"
    doc: "Signed saturating rounding doubling multiply subtract returning high half"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[2]}", "c: {neon_type[3]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [target_feature, ['enable = "rdm"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrdmlsh, LANE = 1]]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "rdm_intrinsics"', 'since = "1.62.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [_lane_s16, int16x4_t, int16x4_t, int16x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [_laneq_s16, int16x4_t, int16x4_t, int16x8_t, '3', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [q_lane_s16, int16x8_t, int16x8_t, int16x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [q_laneq_s16, int16x8_t, int16x8_t, int16x8_t, '3', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [_lane_s32, int32x2_t, int32x2_t, int32x2_t, '1', '[LANE as u32, LANE as u32]']
      - [_laneq_s32, int32x2_t, int32x2_t, int32x4_t, '2', '[LANE as u32, LANE as u32]']
      - [q_lane_s32, int32x4_t, int32x4_t, int32x2_t, '1', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [q_laneq_s32, int32x4_t, int32x4_t, int32x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[4]}']]
      - Let: [c, "{type[1]}", {FnCall: [simd_shuffle!, [c, c, "{type[5]}"]]}]
      - FnCall: ["vqrdmlsh{neon_type[2].no}", [a, b, c]]

  - name: "vqrdmlsh{type[3]}"
    doc: "Signed saturating rounding doubling multiply subtract returning high half"
    arguments: ["a: {type[0]}", "b: {type[0]}", "c: {type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "rdm"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrdmlsh, LANE = 1]]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "rdm_intrinsics"', 'since = "1.62.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["i16", int16x4_t, '2', h_lane_s16, h_s16]
      - ["i16", int16x8_t, '3', h_laneq_s16, h_s16]
      - ["i32", int32x2_t, '1', s_lane_s32, s_s32]
      - ["i32", int32x4_t, '2', s_laneq_s32, s_s32]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[2]}"]]
      - FnCall: ["vqrdmlsh{type[4]}", [a, b, {FnCall: [simd_extract!, [c, 'LANE as u32']]}]]

  - name: "vqrshl{type[0]}"
    doc: "Signed saturating rounding shift left"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrshl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ['s_s32', "i32"]
      - ['d_s64', "i64"]
    compose:
      - LLVMLink:
          name: "vqrshl{type[0]}"
          links:
            - link: "llvm.aarch64.neon.sqrshl.{type[1]}"
              arch: aarch64,arm64ec

  - name: "vqrshl{type[1]}"
    doc: "Signed saturating rounding shift left"
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrshl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i8", 'b_s8', int8x8_t, s8]
      - ["i16", 'h_s16', int16x4_t, s16]
    compose:
      - Let: [a, "{neon_type[2]}", {FnCall: ["vdup_n_{type[3]}", [a]]}]
      - Let: [b, "{neon_type[2]}", {FnCall: ["vdup_n_{type[3]}", [b]]}]
      - FnCall: [simd_extract!, [{FnCall: ["vqrshl_{type[3]}", [a, b]]}, '0']]

  - name: "vqrshl{type[2]}"
    doc: "Unsigned signed saturating rounding shift left"
    arguments: ["a: {type[0]}", "b: {type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uqrshl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["u32", "i32", 's_u32']
      - ["u64", "i64", 'd_u64']
    compose:
      - LLVMLink:
          name: "vqrshl{type[2]}"
          links:
            - link: "llvm.aarch64.neon.uqrshl.{type[1]}"
              arch: aarch64,arm64ec

  - name: "vqrshl{type[2]}"
    doc: "Unsigned signed saturating rounding shift left"
    arguments: ["a: {type[0]}", "b: {type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uqrshl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["u8", "i8", "b_u8", uint8x8_t, int8x8_t, s8]
      - ["u16", "i16", "h_u16", uint16x4_t, int16x4_t, s16]
    compose:
      - Let: [a, "{neon_type[3]}", {FnCall: ["vdup_n_{type[0]}", [a]]}]
      - Let: [b, "{neon_type[4]}", {FnCall: ["vdup_n_{type[5]}", [b]]}]
      - FnCall: [simd_extract!, [{FnCall: ["vqrshl_{type[0]}", [a, b]]}, '0']]

  - name: "vqrshrn{type[2]}"
    doc: "Signed saturating rounded shift right narrow"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrshrn, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["i16", "i8", 'h_n_s16', 'N >= 1 && N <= 8', int16x8_t, q_n_s16]
      - ["i32", "i16", 's_n_s32', 'N >= 1 && N <= 16', int32x4_t, q_n_s32]
      - ["i64", "i32", 'd_n_s64', 'N >= 1 && N <= 32', int64x2_t, q_n_s64]
    compose:
      - FnCall: [static_assert!, ["{type[3]}"]]
      - Let: [a, "{neon_type[4]}", {FnCall: ["vdup{type[5]}", [a]]}]
      - FnCall: [simd_extract!, [{FnCall: ["vqrshrn_n{neon_type[4].noq}::<N>", [a]]}, '0']]

  - name: "vqrshrn{type[3]}"
    doc: "Signed saturating rounded shift right narrow"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrshrn2, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int8x8_t, int16x8_t, int8x16_t, '_high_n_s16', '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]', 'N >= 1 && N <= 8']
      - [int16x4_t, int32x4_t, int16x8_t, '_high_n_s32', '[0, 1, 2, 3, 4, 5, 6, 7]', 'N >= 1 && N <= 16']
      - [int32x2_t, int64x2_t, int32x4_t, '_high_n_s64', '[0, 1, 2, 3]', 'N >= 1 && N <= 32']
    compose:
      - FnCall: [static_assert!, ["{type[5]}"]]
      - FnCall: [simd_shuffle!, [a, {FnCall: ["vqrshrn_n{neon_type[1].noq}::<N>", [b]]}, "{type[4]}"]]

  - name: "vqrshrn{type[0]}"
    doc: "Unsigned saturating rounded shift right narrow"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uqrshrn, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [h_n_u16, u16, u8, 'N >= 1 && N <= 8', uint16x8_t, q_n_u16, _n_u16]
      - [s_n_u32, u32, u16, 'N >= 1 && N <= 16', uint32x4_t, q_n_u32, _n_u32]
      - [d_n_u64, u64, u32, 'N >= 1 && N <= 32', uint64x2_t, q_n_u64, _n_u64]
    compose:
      - FnCall: [static_assert!, ['{type[3]}']]
      - Let: [a, "{neon_type[4]}", {FnCall: ["vdup{type[5]}", [a]]}]
      - FnCall: [simd_extract!, [{FnCall: ["vqrshrn{type[6]}::<N>", [a]]}, '0']]

  - name: "vqrshrn_high_n{neon_type[1].noq}"
    doc: "Unsigned saturating rounded shift right narrow"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uqrshrn2, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [uint8x8_t, uint16x8_t, uint8x16_t, 'N >= 1 && N <= 8', '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint16x4_t, uint32x4_t, uint16x8_t, 'N >= 1 && N <= 16', '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [uint32x2_t, uint64x2_t, uint32x4_t, 'N >= 1 && N <= 32', '[0, 1, 2, 3]']
    compose:
      - FnCall: [static_assert!, ['{type[3]}']]
      - FnCall:
          - simd_shuffle!
          - - a
            - FnCall:
                - "vqrshrn_n{neon_type[1].noq}::<N>"
                - - b
            - "{type[4]}"

  - name: "vqrshrun{type[0]}"
    doc: "Signed saturating rounded shift right unsigned narrow"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrshrun, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [h_n_s16, "i16", "u8", 'N >= 1 && N <= 8', int16x8_t, s16]
      - [s_n_s32, "i32", "u16", 'N >= 1 && N <= 16', int32x4_t, s32]
      - [d_n_s64, "i64", "u32", 'N >= 1 && N <= 32', int64x2_t, s64]
    compose:
      - FnCall: [static_assert!, ["{type[3]}"]]
      - Let:
          - a
          - "{neon_type[4]}"
          - FnCall: ["vdupq_n_{type[5]}", [a]]
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vqrshrun_n_{type[5]}::<N>"
                - - a
            - '0'

  - name: "vqrshrun_high_n{neon_type[1].noq}"
    doc: "Signed saturating rounded shift right unsigned narrow"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqrshrun2, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [uint8x8_t, int16x8_t, uint8x16_t, 'N >= 1 && N <= 8', s16, '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint16x4_t, int32x4_t, uint16x8_t, 'N >= 1 && N <= 16', s32, '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [uint32x2_t, int64x2_t, uint32x4_t, 'N >= 1 && N <= 32', s64, '[0, 1, 2, 3]']
    compose:
      - FnCall: [static_assert!, ["{type[3]}"]]
      - FnCall:
          - simd_shuffle!
          - - a
            - FnCall:
                - "vqrshrun_n_{type[4]}::<N>"
                - - b
            - "{type[5]}"

  - name: "vqshld_{type}"
    doc: "Signed saturating shift left"
    arguments: ["a: {type}", "b: {type}"]
    return_type: "{type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqshl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - i64
    compose:
      - LLVMLink:
          name: "vqshld{type}"
          links:
            - link: "llvm.aarch64.neon.sqshl.{type}"
              arch: aarch64,arm64ec

  - name: "vqshl{type[0]}"
    doc: "Signed saturating shift left"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqshl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [b_s8, "i8", int8x8_t]
      - [h_s16, "i16", int16x4_t]
      - [s_s32, "i32", int32x2_t]
    compose:
      - Let:
          - c
          - "{neon_type[2]}"
          - FnCall:
              - "vqshl{neon_type[2].noq}"
              - - FnCall: ["vdup_n{neon_type[2].no}", [a]]
                - FnCall: ["vdup_n{neon_type[2].no}", [b]]
      - FnCall: [simd_extract!, [c, '0']]

  - name: "vqshl{type[0]}"
    doc: "Signed saturating shift left"
    arguments: ["a: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqshl, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [b_n_s8, "i8", "3", s8]
      - [h_n_s16, "i16", "4", s16]
      - [s_n_s32, "i32", "5", s32]
      - [d_n_s64, "i64", "6", s64]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, "{type[2]}"]]
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vqshl_n_{type[3]}::<N>"
                - - FnCall: ["vdup_n_{type[3]}", [a]]
            - '0'

  - name: "vqshld_{type[0]}"
    doc: "Unsigned saturating shift left"
    arguments: ["a: {type[0]}", "b: {type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uqshl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["u64", "i64"]
    compose:
      - LLVMLink:
          name: "vqshld{type[0]}"
          links:
            - link: "llvm.aarch64.neon.uqshl.{type[1]}"
              arch: aarch64,arm64ec

  - name: "vqshl{type[0]}"
    doc: "Unsigned saturating shift left"
    arguments: ["a: {type[1]}", "b: {type[2]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uqshl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [b_u8, "u8", "i8", uint8x8_t, int8x8_t]
      - [h_u16, "u16", "i16", uint16x4_t, int16x4_t]
      - [s_u32, "u32", "i32", uint32x2_t, int32x2_t]
    compose:
      - Let:
          - c
          - "{neon_type[3]}"
          - FnCall:
              - "vqshl{neon_type[3].noq}"
              - - FnCall: ["vdup{neon_type[3].N}", [a]]
                - FnCall: ["vdup{neon_type[4].N}", [b]]
      - FnCall: [simd_extract!, [c, '0']]

  - name: "vqshl{type[0]}"
    doc: "Unsigned saturating shift left"
    arguments: ["a: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uqshl, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [b_n_u8, "u8", '3']
      - [h_n_u16, "u16", '4']
      - [s_n_u32, "u32", '5']
      - [d_n_u64, "u64", '6']
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, "{type[2]}"]]
      - FnCall:
          - simd_extract!
          - - FnCall: ["vqshl_n_{type[1]}::<N>", [{FnCall: ["vdup_n_{type[1]}", [a]]}]]
            - '0'

  - name: "vqshrnd_n_s64"
    doc: "Signed saturating shift right narrow"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqshrn, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["i64", "i32"]
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 32']]
      - LLVMLink:
          name: "vqshrnd{type[1]}"
          arguments:
            - "a: {type[0]}"
            - "n: i32"
          links:
            - link: "llvm.aarch64.neon.sqshrn.{type[1]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vqshrnd_n_s64", [a, N], [], true]

  - name: "vqshrn{type[0]}"
    doc: "Signed saturating shift right narrow"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqshrn, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [h_n_s16, "i16", "i8", 'N >= 1 && N <= 8', s16]
      - [s_n_s32, "i32", "i16", 'N >= 1 && N <= 16', s32]
    compose:
      - FnCall: [static_assert!, ["{type[3]}"]]
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vqshrn_n_{type[4]}::<N>"
                - - FnCall: ["vdupq_n_{type[4]}", [a]]
            - '0'

  - name: "vqshrn{type[0]}"
    doc: "Signed saturating shift right narrow"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[2]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqshrn2, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [_high_n_s16, int8x8_t, int16x8_t, int8x16_t, 'N >= 1 && N <= 8', '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]', s16]
      - [_high_n_s32, int16x4_t, int32x4_t, int16x8_t, 'N >= 1 && N <= 16', '[0, 1, 2, 3, 4, 5, 6, 7]', s32]
      - [_high_n_s64, int32x2_t, int64x2_t, int32x4_t, 'N >= 1 && N <= 32', '[0, 1, 2, 3]', s64]
    compose:
      - FnCall: [static_assert!, ["{type[4]}"]]
      - FnCall:
          - simd_shuffle!
          - - a
            - FnCall: ["vqshrn_n_{type[6]}::<N>", [b]]
            - "{type[5]}"

  - name: "vqshrnd_n_u64"
    doc: "Unsigned saturating shift right narrow"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uqshrn, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["u64", "u32"]
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 32']]
      - LLVMLink:
          name: "vqshrnd_n_u64"
          arguments:
            - "a: u64"
            - "n: i32"
          links:
            - link: "llvm.aarch64.neon.uqshrn.i32"
              arch: aarch64,arm64ec
      - FnCall: ["_vqshrnd_n_u64", ["a", N], [], true]

  - name: "vqshrn{type[0]}"
    doc: "Unsigned saturating shift right narrow"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uqshrn, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ['h_n_u16', "u16", "u8", 'N >= 1 && N <= 8']
      - ['s_n_u32', "u32", "u16", 'N >= 1 && N <= 16']
    compose:
      - FnCall: [static_assert!, ["{type[3]}"]]
      - FnCall:
          - "simd_extract!"
          - - FnCall:
                - "vqshrn_n_{type[1]}::<N>"
                - - FnCall: ["vdupq_n_{type[1]}", [a]]
            - '0'

  - name: "vqshrn{type[0]}"
    doc: "Unsigned saturating shift right narrow"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[2]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uqshrn2, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [_high_n_u16, uint8x8_t, uint16x8_t, uint8x16_t, 'N >= 1 && N <= 8', '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [_high_n_u32, uint16x4_t, uint32x4_t, uint16x8_t, 'N >= 1 && N <= 16', '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [_high_n_u64, uint32x2_t, uint64x2_t, uint32x4_t, 'N >= 1 && N <= 32', '[0, 1, 2, 3]']
    compose:
      - FnCall: [static_assert!, ["{type[4]}"]]
      - FnCall:
          - simd_shuffle!
          - - a
            - FnCall: ["vqshrn_n_{neon_type[2]}::<N>", [b]]
            - "{type[5]}"

  - name: "vqshrun{type[0]}"
    doc: "Signed saturating shift right unsigned narrow"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqshrun, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [h_n_s16, "i16", "u8", 'N >= 1 && N <= 8', s16]
      - [s_n_s32, "i32", "u16", 'N >= 1 && N <= 16', s32]
      - [d_n_s64, "i64", "u32", 'N >= 1 && N <= 32', s64]
    compose:
      - FnCall: [static_assert!, ["{type[3]}"]]
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vqshrun_n_{type[4]}::<N>"
                - - FnCall: ["vdupq_n_{type[4]}", [a]]
            - '0'

  - name: "vqshrun_high_n_{neon_type[1]}"
    doc: "Signed saturating shift right unsigned narrow"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqshrun2, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [uint8x8_t, int16x8_t, uint8x16_t, 'N >= 1 && N <= 8', '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint16x4_t, int32x4_t, uint16x8_t, 'N >= 1 && N <= 16', '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [uint32x2_t, int64x2_t, uint32x4_t, 'N >= 1 && N <= 32', '[0, 1, 2, 3]']
    compose:
      - FnCall: [static_assert!, ["{type[3]}"]]
      - FnCall:
          - simd_shuffle!
          - - a
            - FnCall: ["vqshrun_n_{neon_type[1]}::<N>", [b]]
            - "{type[4]}"

  - name: "vsqadd{type[0]}"
    doc: "Unsigned saturating accumulate of signed value"
    arguments: ["a: {type[1]}", "b: {type[2]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [usqadd]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [b_u8, "u8", "i8", s8]
      - [h_u16, "u16", "i16", s16]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vsqadd_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
                  - FnCall: ["vdup_n_{type[2]}", [b]]
            - '0'

  - name: "vsqadd{type[0]}"
    doc: "Unsigned saturating accumulate of signed value"
    arguments: ["a: {type[1]}", "b: {type[2]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [usqadd]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [s_u32, "u32", "i32"]
      - [d_u64, "u64", "i64"]
    compose:
      - LLVMLink:
          name: "vsqadd{type[0]}"
          links:
            - link: "llvm.aarch64.neon.usqadd.{type[2]}"
              arch: aarch64,arm64ec

  - name: "vsqrt{neon_type.no}"
    doc: "Calculates the square root of each lane."
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fsqrt]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x1_t
      - float64x2_t
    compose:
      - FnCall: [simd_fsqrt, [a]]

  - name: "vsqrt{neon_type.no}"
    doc: "Calculates the square root of each lane."
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fsqrt]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - float16x4_t
      - float16x8_t
    compose:
      - FnCall: [simd_fsqrt, [a]]

  - name: "vsqrt{type[1]}{type[0]}"
    doc: "Floating-point round to integral, using current rounding mode"
    arguments: ["a: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fsqrt]
    safety: safe
    types:
      - [f16, 'h_']
    compose:
      - LLVMLink:
          name: "llvm.sqrt.{type[0]}"
          links:
            - link: "llvm.sqrt.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vrsqrts{type[0]}"
    doc: "Floating-point reciprocal square root step"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frsqrts]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [_f64, float64x1_t, v1f64]
      - [q_f64, float64x2_t, v2f64]
    compose:
      - LLVMLink:
          name: "vrsqrts{type[0]}"
          links:
            - link: "llvm.aarch64.neon.frsqrts.{type[2]}"
              arch: aarch64,arm64ec

  - name: "vrsqrts{type[0]}"
    doc: "Floating-point reciprocal square root step"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frsqrts]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [s_f32, "f32"]
      - [d_f64, "f64"]
    compose:
      - LLVMLink:
          name: "vrsqrts{type[0]}"
          links:
            - link: "llvm.aarch64.neon.frsqrts.{type[1]}"
              arch: aarch64,arm64ec


  - name: "vrsqrts{type[0]}"
    doc: "Floating-point reciprocal square root step"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-fp16
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frsqrts]]}]]
      - *neon-unstable-f16
    safety: safe
    types:
      - [h_f16, "f16"]
    compose:
      - LLVMLink:
          name: "vrsqrts{type[0]}"
          links:
            - link: "llvm.aarch64.neon.frsqrts.{type[1]}"
              arch: aarch64,arm64ec


  - name: "vrecpe{type[0]}"
    doc: "Reciprocal estimate."
    arguments: ["a: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frecpe]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [_f64, float64x1_t, v1f64]
      - [q_f64, float64x2_t, v2f64]
    compose:
      - LLVMLink:
          name: "vrecpe{type[0]}"
          links:
            - link: "llvm.aarch64.neon.frecpe.{type[2]}"
              arch: aarch64,arm64ec

  - name: "vrecpe{type[0]}"
    doc: "Reciprocal estimate."
    arguments: ["a: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frecpe]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [s_f32, "f32"]
      - [d_f64, "f64"]
    compose:
      - LLVMLink:
          name: "vrecpe{type[0]}"
          links:
            - link: "llvm.aarch64.neon.frecpe.{type[1]}"
              arch: aarch64,arm64ec


  - name: "vrecpe{type[0]}"
    doc: "Reciprocal estimate."
    arguments: ["a: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frecpe]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [h_f16, "f16"]
    compose:
      - LLVMLink:
          name: "vrecpe{type[0]}"
          links:
            - link: "llvm.aarch64.neon.frecpe.{type[1]}"
              arch: aarch64,arm64ec


  - name: "vrecps{type[0]}"
    doc: "Floating-point reciprocal step"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frecps]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [_f64, float64x1_t, v1f64]
      - [q_f64, float64x2_t, v2f64]
    compose:
      - LLVMLink:
          name: "vrecps{type[0]}"
          links:
            - link: "llvm.aarch64.neon.frecps.{type[2]}"
              arch: aarch64,arm64ec

  - name: "vrecps{type[0]}"
    doc: "Floating-point reciprocal step"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frecps]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [s_f32, "f32"]
      - [d_f64, "f64"]
    compose:
      - LLVMLink:
          name: "vrecps{type[0]}"
          links:
            - link: "llvm.aarch64.neon.frecps.{type[1]}"
              arch: aarch64,arm64ec


  - name: "vrecps{type[0]}"
    doc: "Floating-point reciprocal step"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frecps]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [h_f16, "f16"]
    compose:
      - LLVMLink:
          name: "vrecps{type[0]}"
          links:
            - link: "llvm.aarch64.neon.frecps.{type[1]}"
              arch: aarch64,arm64ec


  - name: "vrecpx{type[0]}"
    doc: "Floating-point reciprocal exponent"
    arguments: ["a: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frecpx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [s_f32, "f32"]
      - [d_f64, "f64"]
    compose:
      - LLVMLink:
          name: "vrecpxs{type[0]}"
          links:
            - link: "llvm.aarch64.neon.frecpx.{type[1]}"
              arch: aarch64,arm64ec


  - name: "vrecpx{type[0]}"
    doc: "Floating-point reciprocal exponent"
    arguments: ["a: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frecpx]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [h_f16, "f16"]
    compose:
      - LLVMLink:
          name: "vrecpxs{type[0]}"
          links:
            - link: "llvm.aarch64.neon.frecpx.{type[1]}"
              arch: aarch64,arm64ec


  - name: "vreinterpret{neon_type[1].no}{neon_type[0].noq}"
    doc: Vector reinterpret cast operation
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr: [*neon-stable]
    assert_instr: [nop]
    safety: safe
    types:
      - [poly64x1_t, int64x1_t]
      - [poly64x1_t, uint64x1_t]
      - [int64x1_t, poly64x1_t]
      - [uint64x1_t, poly64x1_t]
      - [poly64x2_t, int64x2_t]
      - [poly64x2_t, uint64x2_t]
      - [int64x2_t, poly64x2_t]
      - [uint64x2_t, poly64x2_t]
      - [float64x1_t, int8x8_t]
      - [float64x1_t, int16x4_t]
      - [float64x1_t, int32x2_t]
      - [float64x1_t, int64x1_t]
      - [float64x2_t, int8x16_t]
      - [float64x2_t, int16x8_t]
      - [float64x2_t, int32x4_t]
      - [float64x2_t, int64x2_t]
      - [float64x1_t, uint8x8_t]
      - [float64x1_t, uint16x4_t]
      - [float64x1_t, uint32x2_t]
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint8x16_t]
      - [float64x2_t, uint16x8_t]
      - [float64x2_t, uint32x4_t]
      - [float64x2_t, uint64x2_t]
      - [float64x1_t, poly8x8_t]
      - [float64x1_t, poly16x4_t]
      - [float32x2_t, poly64x1_t]
      - [float64x1_t, poly64x1_t]
      - [float64x2_t, poly8x16_t]
      - [float64x2_t, poly16x8_t]
      - [float32x4_t, poly64x2_t]
      - [float64x2_t, poly64x2_t]
      - [float64x2_t, p128]
      - [int8x8_t, float64x1_t]
      - [int16x4_t, float64x1_t]
      - [int32x2_t, float64x1_t]
      - [int64x1_t, float64x1_t]
      - [int8x16_t, float64x2_t]
      - [int16x8_t, float64x2_t]
      - [int32x4_t, float64x2_t]
      - [int64x2_t, float64x2_t]
      - [poly8x8_t, float64x1_t]
      - [uint16x4_t, float64x1_t]
      - [uint32x2_t, float64x1_t]
      - [uint64x1_t, float64x1_t]
      - [poly8x16_t, float64x2_t]
      - [uint16x8_t, float64x2_t]
      - [uint32x4_t, float64x2_t]
      - [uint64x2_t, float64x2_t]
      - [uint8x8_t, float64x1_t]
      - [poly16x4_t, float64x1_t]
      - [poly64x1_t, float64x1_t]
      - [poly64x1_t, float32x2_t]
      - [uint8x16_t, float64x2_t]
      - [poly16x8_t, float64x2_t]
      - [poly64x2_t, float64x2_t]
      - [poly64x2_t, float32x4_t]
      - [p128, float64x2_t]
      - [float32x2_t, float64x1_t]
      - [float64x1_t, float32x2_t]
      - [float32x4_t, float64x2_t]
      - [float64x2_t, float32x4_t]
    compose:
      - FnCall: [transmute, [a]]


  - name: "vreinterpret{neon_type[1].no}{neon_type[0].noq}"
    doc: Vector reinterpret cast operation
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [nop]
    safety: safe
    types:
      - [float64x1_t, float16x4_t]
      - [float16x4_t, float64x1_t]
      # q
      - [float64x2_t, float16x8_t]
      - [float16x8_t, float64x2_t]
    compose:
      - FnCall: [transmute, [a]]


  - name: "vrshld_s64"
    doc: "Signed rounding shift left"
    arguments: ["a: {type}", "b: {type}"]
    return_type: "{type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [srshl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - "i64"
    compose:
      - LLVMLink:
          name: "vrshld_{type}"
          links:
            - link: "llvm.aarch64.neon.srshl.{type}"
              arch: aarch64,arm64ec

  - name: "vrshld_{type[0]}"
    doc: "Unsigned rounding shift left"
    arguments: ["a: {type[0]}", "b: {type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [urshl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["u64", "i64"]
    compose:
      - LLVMLink:
          name: "vrshld_{type[0]}"
          links:
            - link: "llvm.aarch64.neon.urshl.{type[1]}"
              arch: aarch64,arm64ec

  - name: "vrshrd_n_s64"
    doc: "Signed rounding shift right"
    arguments: ["a: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [srshr, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - ["i64", 'N >= 1 && N <= 64', '-N as i64']
    compose:
      - FnCall: [static_assert!, ["{type[1]}"]]
      - FnCall: [vrshld_s64, [a, "{type[2]}"]]

  - name: "vrshrd_n_u64"
    doc: "Unsigned rounding shift right"
    arguments: ["a: {type}"]
    return_type: "{type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [urshr, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - "u64"
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 64']]
      - FnCall: ["vrshld_u64", [a, '-N as i64']]

  - name: "vrshrn_high_n_{neon_type[1]}"
    doc: "Rounding shift right narrow"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [rshrn2, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int8x8_t, int16x8_t, int8x16_t, 'N >= 1 && N <= 8', '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [int16x4_t, int32x4_t, int16x8_t, 'N >= 1 && N <= 16', '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [int32x2_t, int64x2_t, int32x4_t, 'N >= 1 && N <= 32', '[0, 1, 2, 3]']
      - [uint8x8_t, uint16x8_t, uint8x16_t, 'N >= 1 && N <= 8', '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint16x4_t, uint32x4_t, uint16x8_t, 'N >= 1 && N <= 16', '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [uint32x2_t, uint64x2_t, uint32x4_t, 'N >= 1 && N <= 32', '[0, 1, 2, 3]']
    compose:
      - FnCall: [static_assert!, ["{type[3]}"]]
      - FnCall:
          - simd_shuffle!
          - - a
            - FnCall: ["vrshrn_n_{neon_type[1]}::<N>", [b]]
            - "{type[4]}"

  - name: "vrsubhn_high_{neon_type[1]}"
    doc: "Rounding subtract returning high narrow"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [rsubhn2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, int16x8_t, int16x8_t, int8x16_t, '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [int16x4_t, int32x4_t, int32x4_t, int16x8_t, '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [int32x2_t, int64x2_t, int64x2_t, int32x4_t, '[0, 1, 2, 3]']
      - [uint8x8_t, uint16x8_t, uint16x8_t, uint8x16_t, '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint16x4_t, uint32x4_t, uint32x4_t, uint16x8_t, '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [uint32x2_t, uint64x2_t, uint64x2_t, uint32x4_t, '[0, 1, 2, 3]']
    compose:
      - Let:
          - x
          - "{neon_type[0]}"
          - FnCall: ["vrsubhn_{neon_type[1]}", [b, c]]
      - FnCall: [simd_shuffle!, [a, x, "{type[4]}"]]

  - name: "vcopy{neon_type[0].lane_nox}"
    doc: "Insert vector element from another vector element"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [mov, 'LANE1 = 0', 'LANE2 = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1', '3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE1: i32, const LANE2: i32']
    safety: safe
    types:
      - [int8x8_t, int8x8_t, int8x8_t, '3', '3', ' unsafe { match LANE1 & 0b111 { 0 => simd_shuffle!(a, b, [8 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7]), 1 => simd_shuffle!(a, b, [0, 8 + LANE2 as u32, 2, 3, 4, 5, 6, 7]), 2 => simd_shuffle!(a, b, [0, 1, 8 + LANE2 as u32, 3, 4, 5, 6, 7]), 3 => simd_shuffle!(a, b, [0, 1, 2, 8 + LANE2 as u32, 4, 5, 6, 7]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 8 + LANE2 as u32, 5, 6, 7]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 8 + LANE2 as u32, 6, 7]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 8 + LANE2 as u32, 7]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 8 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [int16x4_t, int16x4_t, int16x4_t, '2', '2', ' unsafe { match LANE1 & 0b11 { 0 => simd_shuffle!(a, b, [4 + LANE2 as u32, 1, 2, 3]), 1 => simd_shuffle!(a, b, [0, 4 + LANE2 as u32, 2, 3]), 2 => simd_shuffle!(a, b, [0, 1, 4 + LANE2 as u32, 3]), 3 => simd_shuffle!(a, b, [0, 1, 2, 4 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [int32x2_t, int32x2_t, int32x2_t, '1', '1', ' unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [2 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 2 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint8x8_t, uint8x8_t, uint8x8_t, '3', '3', ' unsafe { match LANE1 & 0b111 { 0 => simd_shuffle!(a, b, [8 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7]), 1 => simd_shuffle!(a, b, [0, 8 + LANE2 as u32, 2, 3, 4, 5, 6, 7]), 2 => simd_shuffle!(a, b, [0, 1, 8 + LANE2 as u32, 3, 4, 5, 6, 7]), 3 => simd_shuffle!(a, b, [0, 1, 2, 8 + LANE2 as u32, 4, 5, 6, 7]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 8 + LANE2 as u32, 5, 6, 7]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 8 + LANE2 as u32, 6, 7]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 8 + LANE2 as u32, 7]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 8 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint16x4_t, uint16x4_t, uint16x4_t, '2', '2', ' unsafe { match LANE1 & 0b11 { 0 => simd_shuffle!(a, b, [4 + LANE2 as u32, 1, 2, 3]), 1 => simd_shuffle!(a, b, [0, 4 + LANE2 as u32, 2, 3]), 2 => simd_shuffle!(a, b, [0, 1, 4 + LANE2 as u32, 3]), 3 => simd_shuffle!(a, b, [0, 1, 2, 4 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint32x2_t, uint32x2_t, uint32x2_t, '1', '1', ' unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [2 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 2 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [poly8x8_t, poly8x8_t, poly8x8_t, '3', '3', ' unsafe { match LANE1 & 0b111 { 0 => simd_shuffle!(a, b, [8 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7]), 1 => simd_shuffle!(a, b, [0, 8 + LANE2 as u32, 2, 3, 4, 5, 6, 7]), 2 => simd_shuffle!(a, b, [0, 1, 8 + LANE2 as u32, 3, 4, 5, 6, 7]), 3 => simd_shuffle!(a, b, [0, 1, 2, 8 + LANE2 as u32, 4, 5, 6, 7]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 8 + LANE2 as u32, 5, 6, 7]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 8 + LANE2 as u32, 6, 7]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 8 + LANE2 as u32, 7]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 8 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [poly16x4_t, poly16x4_t, poly16x4_t, '2', '2', ' unsafe { match LANE1 & 0b11 { 0 => simd_shuffle!(a, b, [4 + LANE2 as u32, 1, 2, 3]), 1 => simd_shuffle!(a, b, [0, 4 + LANE2 as u32, 2, 3]), 2 => simd_shuffle!(a, b, [0, 1, 4 + LANE2 as u32, 3]), 3 => simd_shuffle!(a, b, [0, 1, 2, 4 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [float32x2_t, float32x2_t, float32x2_t, '1', '1', ' unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [2 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 2 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE1, '{type[3]}']]
      - FnCall: [static_assert_uimm_bits!, [LANE2, '{type[4]}']]
      - Identifier: ["{type[5]}", Symbol]

  - name: "vcopy{neon_type[0].lane_nox}"
    doc: "Insert vector element from another vector element"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [mov, 'LANE1 = 0', 'LANE2 = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1', '3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE1: i32, const LANE2: i32']
    safety: safe
    types:
      - [int8x16_t, int8x8_t, int8x16_t, '4', '3', ' let b: int8x16_t = unsafe { simd_shuffle!(b, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) };', 'unsafe { match LANE1 & 0b1111 { 0 => simd_shuffle!(a, b, [16 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 1 => simd_shuffle!(a, b, [0, 16 + LANE2 as u32, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 2 => simd_shuffle!(a, b, [0, 1, 16 + LANE2 as u32, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 3 => simd_shuffle!(a, b, [0, 1, 2, 16 + LANE2 as u32, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 16 + LANE2 as u32, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 16 + LANE2 as u32, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 16 + LANE2 as u32, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 16 + LANE2 as u32, 8, 9, 10, 11, 12, 13, 14, 15]), 8 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 16 + LANE2 as u32, 9, 10, 11, 12, 13, 14, 15]), 9 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 16 + LANE2 as u32, 10, 11, 12, 13, 14, 15]), 10 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16 + LANE2 as u32, 11, 12, 13, 14, 15]), 11 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 16 + LANE2 as u32, 12, 13, 14, 15]), 12 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16 + LANE2 as u32, 13, 14, 15]), 13 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 16 + LANE2 as u32, 14, 15]), 14 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16 + LANE2 as u32, 15]), 15 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [int16x8_t, int16x4_t, int16x8_t, '3', '2', ' let b: int16x8_t = unsafe { simd_shuffle!(b, b, [0, 1, 2, 3, 4, 5, 6, 7]) };', 'unsafe { match LANE1 & 0b111 { 0 => simd_shuffle!(a, b, [8 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7]), 1 => simd_shuffle!(a, b, [0, 8 + LANE2 as u32, 2, 3, 4, 5, 6, 7]), 2 => simd_shuffle!(a, b, [0, 1, 8 + LANE2 as u32, 3, 4, 5, 6, 7]), 3 => simd_shuffle!(a, b, [0, 1, 2, 8 + LANE2 as u32, 4, 5, 6, 7]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 8 + LANE2 as u32, 5, 6, 7]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 8 + LANE2 as u32, 6, 7]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 8 + LANE2 as u32, 7]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 8 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [int32x4_t, int32x2_t, int32x4_t, '2', '1', ' let b: int32x4_t = unsafe { simd_shuffle!(b, b, [0, 1, 2, 3]) };', 'unsafe { match LANE1 & 0b11 { 0 => simd_shuffle!(a, b, [4 + LANE2 as u32, 1, 2, 3]), 1 => simd_shuffle!(a, b, [0, 4 + LANE2 as u32, 2, 3]), 2 => simd_shuffle!(a, b, [0, 1, 4 + LANE2 as u32, 3]), 3 => simd_shuffle!(a, b, [0, 1, 2, 4 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint8x16_t, uint8x8_t, uint8x16_t, '4', '3', ' let b: uint8x16_t = unsafe { simd_shuffle!(b, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) };', 'unsafe { match LANE1 & 0b1111 { 0 => simd_shuffle!(a, b, [16 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 1 => simd_shuffle!(a, b, [0, 16 + LANE2 as u32, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 2 => simd_shuffle!(a, b, [0, 1, 16 + LANE2 as u32, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 3 => simd_shuffle!(a, b, [0, 1, 2, 16 + LANE2 as u32, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 16 + LANE2 as u32, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 16 + LANE2 as u32, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 16 + LANE2 as u32, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 16 + LANE2 as u32, 8, 9, 10, 11, 12, 13, 14, 15]), 8 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 16 + LANE2 as u32, 9, 10, 11, 12, 13, 14, 15]), 9 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 16 + LANE2 as u32, 10, 11, 12, 13, 14, 15]), 10 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16 + LANE2 as u32, 11, 12, 13, 14, 15]), 11 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 16 + LANE2 as u32, 12, 13, 14, 15]), 12 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16 + LANE2 as u32, 13, 14, 15]), 13 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 16 + LANE2 as u32, 14, 15]), 14 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16 + LANE2 as u32, 15]), 15 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint16x8_t, uint16x4_t, uint16x8_t, '3', '2', ' let b: uint16x8_t = unsafe { simd_shuffle!(b, b, [0, 1, 2, 3, 4, 5, 6, 7]) };', 'unsafe { match LANE1 & 0b111 { 0 => simd_shuffle!(a, b, [8 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7]), 1 => simd_shuffle!(a, b, [0, 8 + LANE2 as u32, 2, 3, 4, 5, 6, 7]), 2 => simd_shuffle!(a, b, [0, 1, 8 + LANE2 as u32, 3, 4, 5, 6, 7]), 3 => simd_shuffle!(a, b, [0, 1, 2, 8 + LANE2 as u32, 4, 5, 6, 7]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 8 + LANE2 as u32, 5, 6, 7]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 8 + LANE2 as u32, 6, 7]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 8 + LANE2 as u32, 7]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 8 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint32x4_t, uint32x2_t, uint32x4_t, '2', '1', ' let b: uint32x4_t = unsafe { simd_shuffle!(b, b, [0, 1, 2, 3]) };', 'unsafe { match LANE1 & 0b11 { 0 => simd_shuffle!(a, b, [4 + LANE2 as u32, 1, 2, 3]), 1 => simd_shuffle!(a, b, [0, 4 + LANE2 as u32, 2, 3]), 2 => simd_shuffle!(a, b, [0, 1, 4 + LANE2 as u32, 3]), 3 => simd_shuffle!(a, b, [0, 1, 2, 4 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [poly8x16_t, poly8x8_t, poly8x16_t, '4', '3', ' let b: poly8x16_t = unsafe { simd_shuffle!(b, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) };', 'unsafe { match LANE1 & 0b1111 { 0 => simd_shuffle!(a, b, [16 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 1 => simd_shuffle!(a, b, [0, 16 + LANE2 as u32, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 2 => simd_shuffle!(a, b, [0, 1, 16 + LANE2 as u32, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 3 => simd_shuffle!(a, b, [0, 1, 2, 16 + LANE2 as u32, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 16 + LANE2 as u32, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 16 + LANE2 as u32, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 16 + LANE2 as u32, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 16 + LANE2 as u32, 8, 9, 10, 11, 12, 13, 14, 15]), 8 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 16 + LANE2 as u32, 9, 10, 11, 12, 13, 14, 15]), 9 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 16 + LANE2 as u32, 10, 11, 12, 13, 14, 15]), 10 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16 + LANE2 as u32, 11, 12, 13, 14, 15]), 11 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 16 + LANE2 as u32, 12, 13, 14, 15]), 12 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16 + LANE2 as u32, 13, 14, 15]), 13 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 16 + LANE2 as u32, 14, 15]), 14 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16 + LANE2 as u32, 15]), 15 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [poly16x8_t, poly16x4_t, poly16x8_t, '3', '2', ' let b: poly16x8_t = unsafe { simd_shuffle!(b, b, [0, 1, 2, 3, 4, 5, 6, 7]) };', 'unsafe { match LANE1 & 0b111 { 0 => simd_shuffle!(a, b, [8 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7]), 1 => simd_shuffle!(a, b, [0, 8 + LANE2 as u32, 2, 3, 4, 5, 6, 7]), 2 => simd_shuffle!(a, b, [0, 1, 8 + LANE2 as u32, 3, 4, 5, 6, 7]), 3 => simd_shuffle!(a, b, [0, 1, 2, 8 + LANE2 as u32, 4, 5, 6, 7]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 8 + LANE2 as u32, 5, 6, 7]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 8 + LANE2 as u32, 6, 7]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 8 + LANE2 as u32, 7]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 8 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE1, '{type[3]}']]
      - FnCall: [static_assert_uimm_bits!, [LANE2, '{type[4]}']]
      - Identifier: ["{type[5]}", Symbol]
      - Identifier: ["{type[6]}", Symbol]

  - name: "vcopy{neon_type[0].laneq_nox}"
    doc: "Insert vector element from another vector element"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [mov, 'LANE1 = 0', 'LANE2 = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1', '3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE1: i32, const LANE2: i32']
    safety: safe
    types:
      - [int8x16_t, int8x16_t, int8x16_t, '4', '4', ' unsafe { match LANE1 & 0b1111 { 0 => simd_shuffle!(a, b, [16 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 1 => simd_shuffle!(a, b, [0, 16 + LANE2 as u32, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 2 => simd_shuffle!(a, b, [0, 1, 16 + LANE2 as u32, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 3 => simd_shuffle!(a, b, [0, 1, 2, 16 + LANE2 as u32, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 16 + LANE2 as u32, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 16 + LANE2 as u32, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 16 + LANE2 as u32, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 16 + LANE2 as u32, 8, 9, 10, 11, 12, 13, 14, 15]), 8 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 16 + LANE2 as u32, 9, 10, 11, 12, 13, 14, 15]), 9 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 16 + LANE2 as u32, 10, 11, 12, 13, 14, 15]), 10 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16 + LANE2 as u32, 11, 12, 13, 14, 15]), 11 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 16 + LANE2 as u32, 12, 13, 14, 15]), 12 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16 + LANE2 as u32, 13, 14, 15]), 13 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 16 + LANE2 as u32, 14, 15]), 14 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16 + LANE2 as u32, 15]), 15 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [int16x8_t, int16x8_t, int16x8_t, '3', '3', ' unsafe { match LANE1 & 0b111 { 0 => simd_shuffle!(a, b, [8 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7]), 1 => simd_shuffle!(a, b, [0, 8 + LANE2 as u32, 2, 3, 4, 5, 6, 7]), 2 => simd_shuffle!(a, b, [0, 1, 8 + LANE2 as u32, 3, 4, 5, 6, 7]), 3 => simd_shuffle!(a, b, [0, 1, 2, 8 + LANE2 as u32, 4, 5, 6, 7]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 8 + LANE2 as u32, 5, 6, 7]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 8 + LANE2 as u32, 6, 7]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 8 + LANE2 as u32, 7]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 8 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [int32x4_t, int32x4_t, int32x4_t, '2', '2', ' unsafe { match LANE1 & 0b11 { 0 => simd_shuffle!(a, b, [4 + LANE2 as u32, 1, 2, 3]), 1 => simd_shuffle!(a, b, [0, 4 + LANE2 as u32, 2, 3]), 2 => simd_shuffle!(a, b, [0, 1, 4 + LANE2 as u32, 3]), 3 => simd_shuffle!(a, b, [0, 1, 2, 4 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [int64x2_t, int64x2_t, int64x2_t, '1', '1', ' unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [2 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 2 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint8x16_t, uint8x16_t, uint8x16_t, '4', '4', ' unsafe { match LANE1 & 0b1111 { 0 => simd_shuffle!(a, b, [16 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 1 => simd_shuffle!(a, b, [0, 16 + LANE2 as u32, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 2 => simd_shuffle!(a, b, [0, 1, 16 + LANE2 as u32, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 3 => simd_shuffle!(a, b, [0, 1, 2, 16 + LANE2 as u32, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 16 + LANE2 as u32, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 16 + LANE2 as u32, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 16 + LANE2 as u32, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 16 + LANE2 as u32, 8, 9, 10, 11, 12, 13, 14, 15]), 8 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 16 + LANE2 as u32, 9, 10, 11, 12, 13, 14, 15]), 9 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 16 + LANE2 as u32, 10, 11, 12, 13, 14, 15]), 10 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16 + LANE2 as u32, 11, 12, 13, 14, 15]), 11 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 16 + LANE2 as u32, 12, 13, 14, 15]), 12 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16 + LANE2 as u32, 13, 14, 15]), 13 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 16 + LANE2 as u32, 14, 15]), 14 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16 + LANE2 as u32, 15]), 15 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint16x8_t, uint16x8_t, uint16x8_t, '3', '3', ' unsafe { match LANE1 & 0b111 { 0 => simd_shuffle!(a, b, [8 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7]), 1 => simd_shuffle!(a, b, [0, 8 + LANE2 as u32, 2, 3, 4, 5, 6, 7]), 2 => simd_shuffle!(a, b, [0, 1, 8 + LANE2 as u32, 3, 4, 5, 6, 7]), 3 => simd_shuffle!(a, b, [0, 1, 2, 8 + LANE2 as u32, 4, 5, 6, 7]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 8 + LANE2 as u32, 5, 6, 7]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 8 + LANE2 as u32, 6, 7]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 8 + LANE2 as u32, 7]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 8 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint32x4_t, uint32x4_t, uint32x4_t, '2', '2', ' unsafe { match LANE1 & 0b11 { 0 => simd_shuffle!(a, b, [4 + LANE2 as u32, 1, 2, 3]), 1 => simd_shuffle!(a, b, [0, 4 + LANE2 as u32, 2, 3]), 2 => simd_shuffle!(a, b, [0, 1, 4 + LANE2 as u32, 3]), 3 => simd_shuffle!(a, b, [0, 1, 2, 4 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint64x2_t, uint64x2_t, uint64x2_t, '1', '1', ' unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [2 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 2 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [poly8x16_t, poly8x16_t, poly8x16_t, '4', '4', ' unsafe { match LANE1 & 0b1111 { 0 => simd_shuffle!(a, b, [16 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 1 => simd_shuffle!(a, b, [0, 16 + LANE2 as u32, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 2 => simd_shuffle!(a, b, [0, 1, 16 + LANE2 as u32, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 3 => simd_shuffle!(a, b, [0, 1, 2, 16 + LANE2 as u32, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 16 + LANE2 as u32, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 16 + LANE2 as u32, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 16 + LANE2 as u32, 7, 8, 9, 10, 11, 12, 13, 14, 15]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 16 + LANE2 as u32, 8, 9, 10, 11, 12, 13, 14, 15]), 8 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 16 + LANE2 as u32, 9, 10, 11, 12, 13, 14, 15]), 9 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 16 + LANE2 as u32, 10, 11, 12, 13, 14, 15]), 10 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16 + LANE2 as u32, 11, 12, 13, 14, 15]), 11 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 16 + LANE2 as u32, 12, 13, 14, 15]), 12 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16 + LANE2 as u32, 13, 14, 15]), 13 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 16 + LANE2 as u32, 14, 15]), 14 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16 + LANE2 as u32, 15]), 15 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [poly16x8_t, poly16x8_t, poly16x8_t, '3', '3', ' unsafe { match LANE1 & 0b111 { 0 => simd_shuffle!(a, b, [8 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7]), 1 => simd_shuffle!(a, b, [0, 8 + LANE2 as u32, 2, 3, 4, 5, 6, 7]), 2 => simd_shuffle!(a, b, [0, 1, 8 + LANE2 as u32, 3, 4, 5, 6, 7]), 3 => simd_shuffle!(a, b, [0, 1, 2, 8 + LANE2 as u32, 4, 5, 6, 7]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 8 + LANE2 as u32, 5, 6, 7]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 8 + LANE2 as u32, 6, 7]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 8 + LANE2 as u32, 7]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 8 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [poly64x2_t, poly64x2_t, poly64x2_t, '1', '1', ' unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [2 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 2 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [float32x4_t, float32x4_t, float32x4_t, '2', '2', ' unsafe { match LANE1 & 0b11 { 0 => simd_shuffle!(a, b, [4 + LANE2 as u32, 1, 2, 3]), 1 => simd_shuffle!(a, b, [0, 4 + LANE2 as u32, 2, 3]), 2 => simd_shuffle!(a, b, [0, 1, 4 + LANE2 as u32, 3]), 3 => simd_shuffle!(a, b, [0, 1, 2, 4 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [float64x2_t, float64x2_t, float64x2_t, '1', '1', ' unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [2 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 2 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE1, '{type[3]}']]
      - FnCall: [static_assert_uimm_bits!, [LANE2, '{type[4]}']]
      - Identifier: ["{type[5]}", Symbol]

  - name: "vcopy{neon_type[0].laneq_nox}"
    doc: "Insert vector element from another vector element"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [mov, 'LANE1 = 0', 'LANE2 = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1', '3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE1: i32, const LANE2: i32']
    safety: safe
    types:
      - [int8x8_t, int8x16_t, int8x8_t, '3', '4', ' let a: int8x16_t = unsafe { simd_shuffle!(a, a, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) };', 'unsafe { match LANE1 & 0b111 { 0 => simd_shuffle!(a, b, [16 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7]), 1 => simd_shuffle!(a, b, [0, 16 + LANE2 as u32, 2, 3, 4, 5, 6, 7]), 2 => simd_shuffle!(a, b, [0, 1, 16 + LANE2 as u32, 3, 4, 5, 6, 7]), 3 => simd_shuffle!(a, b, [0, 1, 2, 16 + LANE2 as u32, 4, 5, 6, 7]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 16 + LANE2 as u32, 5, 6, 7]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 16 + LANE2 as u32, 6, 7]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 16 + LANE2 as u32, 7]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 16 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [int16x4_t, int16x8_t, int16x4_t, '2', '3', ' let a: int16x8_t = unsafe { simd_shuffle!(a, a, [0, 1, 2, 3, 4, 5, 6, 7]) };', 'unsafe { match LANE1 & 0b11 { 0 => simd_shuffle!(a, b, [8 + LANE2 as u32, 1, 2, 3]), 1 => simd_shuffle!(a, b, [0, 8 + LANE2 as u32, 2, 3]), 2 => simd_shuffle!(a, b, [0, 1, 8 + LANE2 as u32, 3]), 3 => simd_shuffle!(a, b, [0, 1, 2, 8 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [int32x2_t, int32x4_t, int32x2_t, '1', '2', ' let a: int32x4_t = unsafe { simd_shuffle!(a, a, [0, 1, 2, 3]) };', 'unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [4 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 4 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint8x8_t, uint8x16_t, uint8x8_t, '3', '4', ' let a: uint8x16_t = unsafe { simd_shuffle!(a, a, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) };', 'unsafe { match LANE1 & 0b111 { 0 => simd_shuffle!(a, b, [16 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7]), 1 => simd_shuffle!(a, b, [0, 16 + LANE2 as u32, 2, 3, 4, 5, 6, 7]), 2 => simd_shuffle!(a, b, [0, 1, 16 + LANE2 as u32, 3, 4, 5, 6, 7]), 3 => simd_shuffle!(a, b, [0, 1, 2, 16 + LANE2 as u32, 4, 5, 6, 7]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 16 + LANE2 as u32, 5, 6, 7]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 16 + LANE2 as u32, 6, 7]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 16 + LANE2 as u32, 7]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 16 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint16x4_t, uint16x8_t, uint16x4_t, '2', '3', ' let a: uint16x8_t = unsafe { simd_shuffle!(a, a, [0, 1, 2, 3, 4, 5, 6, 7]) };', 'unsafe { match LANE1 & 0b11 { 0 => simd_shuffle!(a, b, [8 + LANE2 as u32, 1, 2, 3]), 1 => simd_shuffle!(a, b, [0, 8 + LANE2 as u32, 2, 3]), 2 => simd_shuffle!(a, b, [0, 1, 8 + LANE2 as u32, 3]), 3 => simd_shuffle!(a, b, [0, 1, 2, 8 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint32x2_t, uint32x4_t, uint32x2_t, '1', '2', 'let a: uint32x4_t = unsafe { simd_shuffle!(a, a, [0, 1, 2, 3]) };', 'unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [4 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 4 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [poly8x8_t, poly8x16_t, poly8x8_t, '3', '4', ' let a: poly8x16_t = unsafe { simd_shuffle!(a, a, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) };', 'unsafe { match LANE1 & 0b111 { 0 => simd_shuffle!(a, b, [16 + LANE2 as u32, 1, 2, 3, 4, 5, 6, 7]), 1 => simd_shuffle!(a, b, [0, 16 + LANE2 as u32, 2, 3, 4, 5, 6, 7]), 2 => simd_shuffle!(a, b, [0, 1, 16 + LANE2 as u32, 3, 4, 5, 6, 7]), 3 => simd_shuffle!(a, b, [0, 1, 2, 16 + LANE2 as u32, 4, 5, 6, 7]), 4 => simd_shuffle!(a, b, [0, 1, 2, 3, 16 + LANE2 as u32, 5, 6, 7]), 5 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 16 + LANE2 as u32, 6, 7]), 6 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 16 + LANE2 as u32, 7]), 7 => simd_shuffle!(a, b, [0, 1, 2, 3, 4, 5, 6, 16 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [poly16x4_t, poly16x8_t, poly16x4_t, '2', '3', ' let a: poly16x8_t = unsafe { simd_shuffle!(a, a, [0, 1, 2, 3, 4, 5, 6, 7]) };', 'unsafe { match LANE1 & 0b11 { 0 => simd_shuffle!(a, b, [8 + LANE2 as u32, 1, 2, 3]), 1 => simd_shuffle!(a, b, [0, 8 + LANE2 as u32, 2, 3]), 2 => simd_shuffle!(a, b, [0, 1, 8 + LANE2 as u32, 3]), 3 => simd_shuffle!(a, b, [0, 1, 2, 8 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [float32x2_t, float32x4_t, float32x2_t, '1', '2', ' let a: float32x4_t = unsafe { simd_shuffle!(a, a, [0, 1, 2, 3]) };', 'unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [4 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 4 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE1, '{type[3]}']]
      - FnCall: [static_assert_uimm_bits!, [LANE2, '{type[4]}']]
      - Identifier: ["{type[5]}", Symbol]
      - Identifier: ["{type[6]}", Symbol]

  - name: "vcopyq_lane_{neon_type[0]}"
    doc: "Insert vector element from another vector element"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [mov, 'LANE1 = 1', 'LANE2 = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1', '3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE1: i32, const LANE2: i32']
    safety: safe
    types:
      - [int64x2_t, int64x1_t, ' let b: int64x2_t = unsafe { simd_shuffle!(b, b, [0, 1]) };', 'unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [2 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 2 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [uint64x2_t, uint64x1_t, ' let b: uint64x2_t = unsafe { simd_shuffle!(b, b, [0, 1]) };', 'unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [2 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 2 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [poly64x2_t, poly64x1_t, ' let b: poly64x2_t = unsafe { simd_shuffle!(b, b, [0, 1]) };', 'unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [2 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 2 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
      - [float64x2_t, float64x1_t, ' let b: float64x2_t = unsafe { simd_shuffle!(b, b, [0, 1]) };', 'unsafe { match LANE1 & 0b1 { 0 => simd_shuffle!(a, b, [2 + LANE2 as u32, 1]), 1 => simd_shuffle!(a, b, [0, 2 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE1, '1']]
      - FnCall: [static_assert!, ['LANE2 == 0']]
      - Identifier: ['{type[2]}', Symbol]
      - Identifier: ['{type[3]}', Symbol]

  - name: "vcopyq_lane_f32"
    doc: "Insert vector element from another vector element"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [mov, 'LANE1 = 1', 'LANE2 = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1', '3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE1: i32, const LANE2: i32']
    safety: safe
    types:
      - [float32x4_t, float32x2_t, ' let b: float32x4_t = unsafe { simd_shuffle!(b, b, [0, 1, 2, 3]) };', 'unsafe { match LANE1 & 0b11 { 0 => simd_shuffle!(a, b, [4 + LANE2 as u32, 1, 2, 3]), 1 => simd_shuffle!(a, b, [0, 4 + LANE2 as u32, 2, 3]), 2 => simd_shuffle!(a, b, [0, 1, 4 + LANE2 as u32, 3]), 3 => simd_shuffle!(a, b, [0, 1, 2, 4 + LANE2 as u32]), _ => unreachable_unchecked(), } }']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE1, 2]]
      - FnCall: [static_assert_uimm_bits!, [LANE2, 1]]
      - Identifier: ["{type[2]}", Symbol]
      - Identifier: ["{type[3]}", Symbol]

  - name: "vcreate_f64"
    doc: "Insert vector element from another vector element"
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["u64", float64x1_t]
    compose:
      - FnCall: [transmute, [a]]

  - name: "vset_lane_f64"
    doc: "Insert vector element from another vector element"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["f64", float64x1_t, float64x1_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall: [simd_insert!, [b, 'LANE as u32', a]]

  - name: "vsetq_lane_f64"
    doc: "Insert vector element from another vector element"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["f64", float64x2_t, float64x2_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '1']]
      - FnCall: [simd_insert!, [b, 'LANE as u32', a]]

  - name: "vshld_s64"
    doc: "Signed Shift left"
    arguments: ["a: {type}", "b: {type}"]
    return_type: "{type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sshl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - "i64"
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - vshl_s64
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vshld_{type[0]}"
    doc: "Unsigned Shift left"
    arguments: ["a: {type[0]}", "b: {type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ushl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["u64", "i64"]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - vshl_u64
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vshll_high_n_{neon_type[0]}"
    doc: "Signed shift left long"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sshll2, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int8x16_t, int16x8_t, int8x8_t, 'N >= 0 && N <= 8', '[8, 9, 10, 11, 12, 13, 14, 15]']
      - [int16x8_t, int32x4_t, int16x4_t, 'N >= 0 && N <= 16', '[4, 5, 6, 7]']
      - [int32x4_t, int64x2_t, int32x2_t, 'N >= 0 && N <= 32', '[2, 3]']
    compose:
      - FnCall: [static_assert!, ["{type[3]}"]]
      - Let: [b, "{neon_type[2]}", {FnCall: [simd_shuffle!, [a, a, "{type[4]}"]]}]
      - FnCall: ["vshll_n_{neon_type[2]}::<N>", [b]]

  - name: "vshll_high_n_{neon_type[0]}"
    doc: "Signed shift left long"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ushll2, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [uint8x16_t, uint16x8_t, uint8x8_t, 'N >= 0 && N <= 8', '[8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint16x8_t, uint32x4_t, uint16x4_t, 'N >= 0 && N <= 16', '[4, 5, 6, 7]']
      - [uint32x4_t, uint64x2_t, uint32x2_t, 'N >= 0 && N <= 32', '[2, 3]']
    compose:
      - FnCall: [static_assert!, ["{type[3]}"]]
      - Let: [b, "{neon_type[2]}", {FnCall: [simd_shuffle!, [a, a, "{type[4]}"]]}]
      - FnCall: ["vshll_n_{neon_type[2]}::<N>", [b]]

  - name: "vshrn_high_n_{neon_type[1]}"
    doc: "Shift right narrow"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [shrn2, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int8x8_t, int16x8_t, int8x16_t, 'N >= 1 && N <= 8', '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [int16x4_t, int32x4_t, int16x8_t, 'N >= 1 && N <= 16', '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [int32x2_t, int64x2_t, int32x4_t, 'N >= 1 && N <= 32', '[0, 1, 2, 3]']
      - [uint8x8_t, uint16x8_t, uint8x16_t, 'N >= 1 && N <= 8', '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint16x4_t, uint32x4_t, uint16x8_t, 'N >= 1 && N <= 16', '[0, 1, 2, 3, 4, 5, 6, 7]']
      - [uint32x2_t, uint64x2_t, uint32x4_t, 'N >= 1 && N <= 32', '[0, 1, 2, 3]']
    compose:
      - FnCall: [static_assert!, ["{type[3]}"]]
      - FnCall:
          - simd_shuffle!
          - - a
            - FnCall: ["vshrn_n_{neon_type[1]}::<N>", [b]]
            - "{type[4]}"

  - name: "vsm3partw1{neon_type.no}"
    doc: "SM3PARTW1"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sm4"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sm3partw1]]}]]
      - FnCall: [unstable, ['feature = "stdarch_neon_sm4"', 'issue = "117226"']]
    safety: safe
    types:
      - uint32x4_t
    compose:
      - LLVMLink:
          name: llvm.aarch64.crypto.sm3partw1
          links:
            - link: "llvm.aarch64.crypto.sm3partw1"
              arch: aarch64,arm64ec

  - name: "vsm3partw2{neon_type.no}"
    doc: "SM3PARTW2"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sm4"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sm3partw2]]}]]
      - FnCall: [unstable, ['feature = "stdarch_neon_sm4"', 'issue = "117226"']]
    safety: safe
    types:
      - uint32x4_t
    compose:
      - LLVMLink:
          name: llvm.aarch64.crypto.sm3partw2
          links:
            - link: "llvm.aarch64.crypto.sm3partw2"
              arch: aarch64,arm64ec

  - name: "vsm3ss1{neon_type.no}"
    doc: "SM3SS1"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sm4"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sm3ss1]]}]]
      - FnCall: [unstable, ['feature = "stdarch_neon_sm4"', 'issue = "117226"']]
    safety: safe
    types:
      - uint32x4_t
    compose:
      - LLVMLink:
          name: llvm.aarch64.crypto.sm3ss1
          links:
            - link: "llvm.aarch64.crypto.sm3ss1"
              arch: aarch64,arm64ec

  - name: "vsm4ekey{neon_type.no}"
    doc: "SM4 key"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sm4"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sm4ekey]]}]]
      - FnCall: [unstable, ['feature = "stdarch_neon_sm4"', 'issue = "117226"']]
    safety: safe
    types:
      - uint32x4_t
    compose:
      - LLVMLink:
          name: llvm.aarch64.crypto.sm4ekey
          links:
            - link: "llvm.aarch64.crypto.sm4ekey"
              arch: aarch64,arm64ec

  - name: "vsm4e{neon_type.no}"
    doc: "SM4 encode"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sm4"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sm4e]]}]]
      - FnCall: [unstable, ['feature = "stdarch_neon_sm4"', 'issue = "117226"']]
    safety: safe
    types:
      - uint32x4_t
    compose:
      - LLVMLink:
          name: llvm.aarch64.crypto.sm4e
          links:
            - link: "llvm.aarch64.crypto.sm4e"
              arch: aarch64,arm64ec

  - name: "vrax1{neon_type.no}"
    doc: "Rotate and exclusive OR"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sha3"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [rax1]]}]]
      - FnCall: [stable, ['feature = "stdarch_neon_sha3"', 'since = "1.79.0"']]
    safety: safe
    types:
      - uint64x2_t
    compose:
      - LLVMLink:
          name: llvm.aarch64.crypto.rax1
          links:
            - link: "llvm.aarch64.crypto.rax1"
              arch: aarch64,arm64ec

  - name: "vsha512h{neon_type.no}"
    doc: "SHA512 hash update part 1"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sha3"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sha512h]]}]]
      - FnCall: [stable, ['feature = "stdarch_neon_sha3"', 'since = "1.79.0"']]
    safety: safe
    types:
      - uint64x2_t
    compose:
      - LLVMLink:
          name: llvm.aarch64.crypto.sha512h
          links:
            - link: "llvm.aarch64.crypto.sha512h"
              arch: aarch64,arm64ec

  - name: "vsha512h2{neon_type.no}"
    doc: "SHA512 hash update part 2"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sha3"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sha512h2]]}]]
      - FnCall: [stable, ['feature = "stdarch_neon_sha3"', 'since = "1.79.0"']]
    safety: safe
    types:
      - uint64x2_t
    compose:
      - LLVMLink:
          name: llvm.aarch64.crypto.sha512h2
          links:
            - link: "llvm.aarch64.crypto.sha512h2"
              arch: aarch64,arm64ec

  - name: "vsha512su0{neon_type.no}"
    doc: "SHA512 schedule update 0"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sha3"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sha512su0]]}]]
      - FnCall: [stable, ['feature = "stdarch_neon_sha3"', 'since = "1.79.0"']]
    safety: safe
    types:
      - uint64x2_t
    compose:
      - LLVMLink:
          name: llvm.aarch64.crypto.sha512su0
          links:
            - link: "llvm.aarch64.crypto.sha512su0"
              arch: aarch64,arm64ec

  - name: "vsha512su1{neon_type.no}"
    doc: "SHA512 schedule update 1"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sha3"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sha512su1]]}]]
      - FnCall: [stable, ['feature = "stdarch_neon_sha3"', 'since = "1.79.0"']]
    safety: safe
    types:
      - uint64x2_t
    compose:
      - LLVMLink:
          name: llvm.aarch64.crypto.sha512su1
          links:
            - link: "llvm.aarch64.crypto.sha512su1"
              arch: aarch64,arm64ec

  - name: "vsm3tt{type[0]}"
    doc: "{type[3]}"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[1]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sm4"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, ['{type[2]}', 'IMM2 = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [unstable, ['feature = "stdarch_neon_sm4"', 'issue = "117226"']]
    static_defs: ["const IMM2: i32"]
    safety: safe
    types:
      - ['1aq_u32', uint32x4_t, 'sm3tt1a', 'SM3TT1A']
      - ['1bq_u32', uint32x4_t, 'sm3tt1b', 'SM3TT1B']
      - ['2aq_u32', uint32x4_t, 'sm3tt2a', 'SM3TT2A']
      - ['2bq_u32', uint32x4_t, 'sm3tt2b', 'SM3TT2B']
    compose:
      - FnCall: ["static_assert_uimm_bits!", [IMM2, "2"]]
      - LLVMLink:
          name: "_vsm3tt{type[0]}"
          arguments:
            - "a: {neon_type[1]}"
            - "b: {neon_type[1]}"
            - "c: {neon_type[1]}"
            - "n: i64"
          links:
            - link: "llvm.aarch64.crypto.{type[2]}"
              arch: aarch64,arm64ec
      - FnCall:
          - "_vsm3tt{type[0]}"
          - - "a"
            - "b"
            - "c"
            - "IMM2 as i64"
          - []
          - true

  - name: "vxarq_u64"
    doc: "Exclusive OR and rotate"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,sha3"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, ['xar', 'IMM6 = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "stdarch_neon_sha3"', 'since = "1.79.0"']]
    static_defs: ["const IMM6: i32"]
    safety: safe
    types:
      - uint64x2_t
    compose:
      - FnCall: ["static_assert_uimm_bits!", [IMM6, "6"]]
      - LLVMLink:
          name: "_vxarq_u64"
          arguments:
            - "a: {neon_type}"
            - "b: {neon_type}"
            - "n: i64"
          links:
            - link: "llvm.aarch64.crypto.xar"
              arch: aarch64,arm64ec
      - FnCall:
          - "_vxarq_u64"
          - - "a"
            - "b"
            - "IMM6 as i64"
          - []
          - true

  - name: "vrnd32x{neon_type.no}"
    doc: "Floating-point round to 32-bit integer, using current rounding mode"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,frintts"']]
      - FnCall: [unstable, ['feature = "stdarch_neon_ftts"', 'issue = "117227"']]
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [frint32x]]}]]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "vrnd32x{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.frint32x.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vrnd32x{neon_type.no}"
    doc: "Floating-point round to 32-bit integer, using current rounding mode"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,frintts"']]
      - FnCall: [unstable, ['feature = "stdarch_neon_ftts"', 'issue = "117227"']]
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [frint32x]]}]]
    safety: safe
    types:
      - float64x1_t
    compose:
      - LLVMLink:
          name: "vrnd32x{neon_type.no}"
          arguments:
            - "a: f64"
          return_type: "f64"
          links:
            - link: "llvm.aarch64.frint32x.f64"
              arch: aarch64,arm64ec
      - FnCall:
          - transmute
          - - FnCall:
                - _vrnd32x_f64
                - - FnCall: [simd_extract!, [a, 0]]

  - name: "vrnd32z{neon_type.no}"
    doc: "Floating-point round to 32-bit integer toward zero"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,frintts"']]
      - FnCall: [unstable, ['feature = "stdarch_neon_ftts"', 'issue = "117227"']]
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [frint32z]]}]]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "vrnd32z{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.frint32z.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vrnd32z{neon_type.no}"
    doc: "Floating-point round to 32-bit integer toward zero"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,frintts"']]
      - FnCall: [unstable, ['feature = "stdarch_neon_ftts"', 'issue = "117227"']]
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [frint32z]]}]]
    safety: safe
    types:
      - float64x1_t
    compose:
      - LLVMLink:
          name: "vrnd32z{neon_type.no}"
          arguments:
            - "a: f64"
          return_type: "f64"
          links:
            - link: "llvm.aarch64.frint32z.f64"
              arch: aarch64,arm64ec
      - FnCall:
          - transmute
          - - FnCall: [_vrnd32z_f64, [{FnCall: [simd_extract!, [a, 0]]}]]

  - name: "vrnd64x{neon_type.no}"
    doc: "Floating-point round to 64-bit integer, using current rounding mode"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,frintts"']]
      - FnCall: [unstable, ['feature = "stdarch_neon_ftts"', 'issue = "117227"']]
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [frint64x]]}]]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "vrnd64x{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.frint64x.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vrnd64x{neon_type.no}"
    doc: "Floating-point round to 64-bit integer, using current rounding mode"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,frintts"']]
      - FnCall: [unstable, ['feature = "stdarch_neon_ftts"', 'issue = "117227"']]
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [frint64x]]}]]
    safety: safe
    types:
      - float64x1_t
    compose:
      - LLVMLink:
          name: "vrnd64x{neon_type.no}"
          arguments:
            - "a: f64"
          return_type: "f64"
          links:
            - link: "llvm.aarch64.frint64x.f64"
              arch: aarch64,arm64ec
      - FnCall:
          - transmute
          - - FnCall: [_vrnd64x_f64, [{FnCall: [simd_extract!, [a, 0]]}]]

  - name: "vrnd64z{neon_type.no}"
    doc: "Floating-point round to 64-bit integer toward zero"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,frintts"']]
      - FnCall: [unstable, ['feature = "stdarch_neon_ftts"', 'issue = "117227"']]
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [frint64z]]}]]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "vrnd64z{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.frint64z.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vrnd64z{neon_type.no}"
    doc: "Floating-point round to 64-bit integer toward zero"
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,frintts"']]
      - FnCall: [unstable, ['feature = "stdarch_neon_ftts"', 'issue = "117227"']]
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [frint64z]]}]]
    safety: safe
    types:
      - float64x1_t
    compose:
      - LLVMLink:
          name: "vrnd64z{neon_type.no}"
          arguments:
            - "a: f64"
          return_type: "f64"
          links:
            - link: "llvm.aarch64.frint64z.f64"
              arch: aarch64,arm64ec
      - FnCall:
          - transmute
          - - FnCall: [_vrnd64z_f64, [{FnCall: [simd_extract!, [a, 0]]}]]

  - name: "vtrn1{neon_type[0].no}"
    doc: Transpose vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [trn1]]}]]
    safety: safe
    types:
      - [int8x8_t, '[0, 8, 2, 10, 4, 12, 6, 14]']
      - [int8x16_t, '[0, 16, 2, 18, 4, 20, 6, 22, 8, 24, 10, 26, 12, 28, 14, 30]']
      - [int16x4_t, '[0, 4, 2, 6]']
      - [int16x8_t, '[0, 8, 2, 10, 4, 12, 6, 14]']
      - [int32x4_t, '[0, 4, 2, 6]']
      - [uint8x8_t, '[0, 8, 2, 10, 4, 12, 6, 14]']
      - [uint8x16_t, '[0, 16, 2, 18, 4, 20, 6, 22, 8, 24, 10, 26, 12, 28, 14, 30]']
      - [uint16x4_t, '[0, 4, 2, 6]']
      - [uint16x8_t, '[0, 8, 2, 10, 4, 12, 6, 14]']
      - [uint32x4_t, '[0, 4, 2, 6]']
      - [poly8x8_t, '[0, 8, 2, 10, 4, 12, 6, 14]']
      - [poly8x16_t, '[0, 16, 2, 18, 4, 20, 6, 22, 8, 24, 10, 26, 12, 28, 14, 30]']
      - [poly16x4_t, '[0, 4, 2, 6]']
      - [poly16x8_t, '[0, 8, 2, 10, 4, 12, 6, 14]']
      - [float32x4_t, '[0, 4, 2, 6]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]


  - name: "vtrn1{neon_type[0].no}"
    doc: Transpose vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [trn1]]}]]
    safety: safe
    types:
      - [float16x4_t, '[0, 4, 2, 6]']
      - [float16x8_t, '[0, 8, 2, 10, 4, 12, 6, 14]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]

  - name: "vtrn1{neon_type[0].no}"
    doc: Transpose vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [zip1]]}]]
    safety: safe
    types:
      - [int32x2_t, '[0, 2]']
      - [int64x2_t, '[0, 2]']
      - [uint32x2_t, '[0, 2]']
      - [uint64x2_t, '[0, 2]']
      - [poly64x2_t, '[0, 2]']
      - [float32x2_t, '[0, 2]']
      - [float64x2_t, '[0, 2]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]

  - name: "vtrn2{neon_type[0].no}"
    doc: Transpose vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [trn2]]}]]
    safety: safe
    types:
      - [int8x8_t, '[1, 9, 3, 11, 5, 13, 7, 15]']
      - [int8x16_t, '[1, 17, 3, 19, 5, 21, 7, 23, 9, 25, 11, 27, 13, 29, 15, 31]']
      - [int16x4_t, '[1, 5, 3, 7]']
      - [int16x8_t, '[1, 9, 3, 11, 5, 13, 7, 15]']
      - [int32x4_t, '[1, 5, 3, 7]']
      - [uint8x8_t, '[1, 9, 3, 11, 5, 13, 7, 15]']
      - [uint8x16_t, '[1, 17, 3, 19, 5, 21, 7, 23, 9, 25, 11, 27, 13, 29, 15, 31]']
      - [uint16x4_t, '[1, 5, 3, 7]']
      - [uint16x8_t, '[1, 9, 3, 11, 5, 13, 7, 15]']
      - [uint32x4_t, '[1, 5, 3, 7]']
      - [poly8x8_t, '[1, 9, 3, 11, 5, 13, 7, 15]']
      - [poly8x16_t, '[1, 17, 3, 19, 5, 21, 7, 23, 9, 25, 11, 27, 13, 29, 15, 31]']
      - [poly16x4_t, '[1, 5, 3, 7]']
      - [poly16x8_t, '[1, 9, 3, 11, 5, 13, 7, 15]']
      - [float32x4_t, '[1, 5, 3, 7]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]

  - name: "vtrn2{neon_type[0].no}"
    doc: Transpose vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [trn2]]}]]
    safety: safe
    types:
      - [float16x4_t, '[1, 5, 3, 7]']
      - [float16x8_t, '[1, 9, 3, 11, 5, 13, 7, 15]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]

  - name: "vtrn2{neon_type[0].no}"
    doc: Transpose vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [zip2]]}]]
    safety: safe
    types:
      - [int32x2_t, '[1, 3]']
      - [int64x2_t, '[1, 3]']
      - [uint32x2_t, '[1, 3]']
      - [uint64x2_t, '[1, 3]']
      - [poly64x2_t, '[1, 3]']
      - [float32x2_t, '[1, 3]']
      - [float64x2_t, '[1, 3]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]

  - name: "vzip2{neon_type[0].no}"
    doc: Zip vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [zip2]]}]]
    safety: safe
    types:
      - [int8x8_t, '[4, 12, 5, 13, 6, 14, 7, 15]']
      - [int8x16_t, '[8, 24, 9, 25, 10, 26, 11, 27, 12, 28, 13, 29, 14, 30, 15, 31]']
      - [int16x4_t, '[2, 6, 3, 7]']
      - [int16x8_t, '[4, 12, 5, 13, 6, 14, 7, 15]']
      - [int32x2_t, '[1, 3]']
      - [int32x4_t, '[2, 6, 3, 7]']
      - [int64x2_t, '[1, 3]']
      - [uint8x8_t, '[4, 12, 5, 13, 6, 14, 7, 15]']
      - [uint8x16_t, '[8, 24, 9, 25, 10, 26, 11, 27, 12, 28, 13, 29, 14, 30, 15, 31]']
      - [uint16x4_t, '[2, 6, 3, 7]']
      - [uint16x8_t, '[4, 12, 5, 13, 6, 14, 7, 15]']
      - [uint32x2_t, '[1, 3]']
      - [uint32x4_t, '[2, 6, 3, 7]']
      - [uint64x2_t, '[1, 3]']
      - [poly8x8_t, '[4, 12, 5, 13, 6, 14, 7, 15]']
      - [poly8x16_t, '[8, 24, 9, 25, 10, 26, 11, 27, 12, 28, 13, 29, 14, 30, 15, 31]']
      - [poly16x4_t, '[2, 6, 3, 7]']
      - [poly16x8_t, '[4, 12, 5, 13, 6, 14, 7, 15]']
      - [poly64x2_t, '[1, 3]']
      - [float32x2_t, '[1, 3]']
      - [float32x4_t, '[2, 6, 3, 7]']
      - [float64x2_t, '[1, 3]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]

  - name: "vzip2{neon_type[0].no}"
    doc: Zip vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [zip2]]}]]
    safety: safe
    types:
      - [float16x4_t, '[2, 6, 3, 7]']
      - [float16x8_t, '[4, 12, 5, 13, 6, 14, 7, 15]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]

  - name: "vzip1{neon_type[0].no}"
    doc: Zip vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [zip1]]}]]
    safety: safe
    types:
      - [int8x8_t, '[0, 8, 1, 9, 2, 10, 3, 11]']
      - [int8x16_t, '[0, 16, 1, 17, 2, 18, 3, 19, 4, 20, 5, 21, 6, 22, 7, 23]']
      - [int16x4_t, '[0, 4, 1, 5]']
      - [int16x8_t, '[0, 8, 1, 9, 2, 10, 3, 11]']
      - [int32x2_t, '[0, 2]']
      - [int32x4_t, '[0, 4, 1, 5]']
      - [int64x2_t, '[0, 2]']
      - [uint8x8_t, '[0, 8, 1, 9, 2, 10, 3, 11]']
      - [uint8x16_t, '[0, 16, 1, 17, 2, 18, 3, 19, 4, 20, 5, 21, 6, 22, 7, 23]']
      - [uint16x4_t, '[0, 4, 1, 5]']
      - [uint16x8_t, '[0, 8, 1, 9, 2, 10, 3, 11]']
      - [uint32x2_t, '[0, 2]']
      - [uint32x4_t, '[0, 4, 1, 5]']
      - [uint64x2_t, '[0, 2]']
      - [poly8x8_t, '[0, 8, 1, 9, 2, 10, 3, 11]']
      - [poly8x16_t, '[0, 16, 1, 17, 2, 18, 3, 19, 4, 20, 5, 21, 6, 22, 7, 23]']
      - [poly16x4_t, '[0, 4, 1, 5]']
      - [poly16x8_t, '[0, 8, 1, 9, 2, 10, 3, 11]']
      - [poly64x2_t, '[0, 2]']
      - [float32x2_t, '[0, 2]']
      - [float32x4_t, '[0, 4, 1, 5]']
      - [float64x2_t, '[0, 2]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]


  - name: "vzip1{neon_type[0].no}"
    doc: Zip vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [zip1]]}]]
    safety: safe
    types:
      - [float16x4_t, '[0, 4, 1, 5]']
      - [float16x8_t, '[0, 8, 1, 9, 2, 10, 3, 11]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]

  - name: "vuzp1{neon_type[0].no}"
    doc: Unzip vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [zip1]]}]]
    safety: safe
    types:
      - [int32x2_t, '[0, 2]']
      - [int64x2_t, '[0, 2]']
      - [uint32x2_t, '[0, 2]']
      - [uint64x2_t, '[0, 2]']
      - [poly64x2_t, '[0, 2]']
      - [float32x2_t, '[0, 2]']
      - [float64x2_t, '[0, 2]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]

  - name: "vuzp1{neon_type[0].no}"
    doc: Unzip vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [uzp1]]}]]
    safety: safe
    types:
      - [int8x8_t, '[0, 2, 4, 6, 8, 10, 12, 14]']
      - [int8x16_t, '[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]']
      - [int16x4_t, '[0, 2, 4, 6]']
      - [int16x8_t, '[0, 2, 4, 6, 8, 10, 12, 14]']
      - [int32x4_t, '[0, 2, 4, 6]']
      - [uint8x8_t, '[0, 2, 4, 6, 8, 10, 12, 14]']
      - [uint8x16_t, '[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]']
      - [uint16x4_t, '[0, 2, 4, 6]']
      - [uint16x8_t, '[0, 2, 4, 6, 8, 10, 12, 14]']
      - [uint32x4_t, '[0, 2, 4, 6] ']
      - [poly8x8_t, '[0, 2, 4, 6, 8, 10, 12, 14]']
      - [poly8x16_t, '[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]']
      - [poly16x4_t, '[0, 2, 4, 6]']
      - [poly16x8_t, '[0, 2, 4, 6, 8, 10, 12, 14]']
      - [float32x4_t, '[0, 2, 4, 6]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]

  - name: "vuzp1{neon_type[0].no}"
    doc: Unzip vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [uzp1]]}]]
    safety: safe
    types:
      - [float16x4_t, '[0, 2, 4, 6]']
      - [float16x8_t, '[0, 2, 4, 6, 8, 10, 12, 14]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]

  - name: "vuzp2{neon_type[0].no}"
    doc: Unzip vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [zip2]]}]]
    safety: safe
    types:
      - [int32x2_t, '[1, 3]']
      - [int64x2_t, '[1, 3]']
      - [uint32x2_t, '[1, 3]']
      - [uint64x2_t, '[1, 3]']
      - [poly64x2_t, '[1, 3]']
      - [float32x2_t, '[1, 3]']
      - [float64x2_t, '[1, 3]']
    compose:
      - FnCall: ["simd_shuffle!", [a, b, "{type[1]}"]]

  - name: "vuzp2{neon_type[0].no}"
    doc: Unzip vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [uzp2]]}]]
    safety: safe
    types:
      - [int8x8_t, '[1, 3, 5, 7, 9, 11, 13, 15]']
      - [int8x16_t, '[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31]']
      - [int16x4_t, '[1, 3, 5, 7]']
      - [int16x8_t, '[1, 3, 5, 7, 9, 11, 13, 15]']
      - [int32x4_t, '[1, 3, 5, 7]']
      - [uint8x8_t, '[1, 3, 5, 7, 9, 11, 13, 15]']
      - [uint8x16_t, '[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31]']
      - [uint16x4_t, '[1, 3, 5, 7]']
      - [uint16x8_t, '[1, 3, 5, 7, 9, 11, 13, 15]']
      - [uint32x4_t, '[1, 3, 5, 7]']
      - [poly8x8_t, '[1, 3, 5, 7, 9, 11, 13, 15]']
      - [poly8x16_t, '[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31]']
      - [poly16x4_t, '[1, 3, 5, 7]']
      - [poly16x8_t, '[1, 3, 5, 7, 9, 11, 13, 15]']
      - [float32x4_t, '[1, 3, 5, 7]']
    compose:
      - FnCall:
          - "simd_shuffle!"
          - - a
            - b
            - "{type[1]}"

  - name: "vuzp2{neon_type[0].no}"
    doc: Unzip vectors
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [uzp2]]}]]
    safety: safe
    types:
      - [float16x4_t, '[1, 3, 5, 7]']
      - [float16x8_t, '[1, 3, 5, 7, 9, 11, 13, 15]']
    compose:
      - FnCall:
          - "simd_shuffle!"
          - - a
            - b
            - "{type[1]}"

  - name: "vabal_high_{neon_type[1]}"
    doc: "Unsigned Absolute difference and Accumulate Long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [uabal]]}]]
    safety: safe
    types:
      - [uint16x8_t, uint8x16_t, uint8x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]', '[8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint32x4_t, uint16x8_t, uint16x4_t, '[4, 5, 6, 7]', '[4, 5, 6, 7]']
      - [uint64x2_t, uint32x4_t, uint32x2_t, '[2, 3]', '[2, 3]']
    compose:
      - Let:
          - d
          - "{neon_type[2]}"
          - FnCall: [simd_shuffle!, [b, b, "{type[3]}"]]
      - Let:
          - e
          - "{neon_type[2]}"
          - FnCall: [simd_shuffle!, [c, c, "{type[4]}"]]
      - Let: [f, "{neon_type[2]}", {FnCall: ["vabd_{neon_type[2]}", [d, e]]}]
      - FnCall:
          - simd_add
          - - a
            - FnCall: [simd_cast, [f]]

  - name: "vabal_high{neon_type[1].noq}"
    doc: Signed Absolute difference and Accumulate Long
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [sabal]]}]]
    safety: safe
    types:
      - [int16x8_t, int8x16_t, int8x16_t, '[8, 9, 10, 11, 12, 13, 14, 15]', int8x8_t, uint8x8_t]
      - [int32x4_t, int16x8_t, int16x8_t, '[4, 5, 6, 7]', int16x4_t, uint16x4_t]
      - [int64x2_t, int32x4_t, int32x4_t, '[2, 3]', int32x2_t, uint32x2_t]
    compose:
      - Let:
          - d
          - "{neon_type[4]}"
          - FnCall:
              - simd_shuffle!
              - - b
                - b
                - "{type[3]}"
      - Let:
          - e
          - "{neon_type[4]}"
          - FnCall:
              - simd_shuffle!
              - - c
                - c
                - "{type[3]}"
      - Let:
          - f
          - "{neon_type[4]}"
          - FnCall:
              - "vabd{neon_type[4].no}"
              - - d
                - e
      - Let:
          - f
          - "{neon_type[5]}"
          - FnCall:
              - simd_cast
              - - f
      - FnCall:
          - simd_add
          - - a
            - FnCall:
                - simd_cast
                - - f

  - name: "vqabs{neon_type.no}"
    doc: Signed saturating Absolute value
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-stable
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [sqabs]]}]]
    safety: safe
    types:
      - int64x1_t
      - int64x2_t
    compose:
      - LLVMLink:
          name: "sqabs.{neon_type}"
          links:
            - link: "llvm.aarch64.neon.sqabs.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vslid_n_{type}"
    doc: Shift left and insert
    arguments: ["a: {type}", "b: {type}"]
    return_type: "{type}"
    static_defs:
      - "const N: i32"
    attr:
      - *neon-stable
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [sli, 'N = 2']]}]]
    safety: safe
    types:
      - i64
      - u64
    compose:
      - FnCall:
          - "static_assert!"
          - - 'N >= 0 && N <= 63'
      - FnCall:
          - transmute
          - - FnCall:
                - "vsli_n_{type}::<N>"
                - - FnCall:
                      - transmute
                      - - a
                  - FnCall:
                      - transmute
                      - - b

  - name: "vsrid_n_{type}"
    doc: Shift right and insert
    arguments: ["a: {type}", "b: {type}"]
    return_type: "{type}"
    static_defs:
      - "const N: i32"
    attr:
      - *neon-stable
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [sri, 'N = 2']]}]]
    safety: safe
    types:
      - i64
      - u64
    compose:
      - FnCall:
          - "static_assert!"
          - - 'N >= 1 && N <= 64'
      - FnCall:
          - transmute
          - - FnCall:
                - "vsri_n_{type}::<N>"
                - - FnCall:
                      - transmute
                      - - a
                  - FnCall:
                      - transmute
                      - - b

  - name: "vpmaxnm{neon_type.no}"
    doc: "Floating-point Maximum Number Pairwise (vector)."
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmaxnmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - float32x2_t
      - float64x2_t
      - float32x4_t
    compose:
      - LLVMLink:
          name: "vpmaxnm{neon_type}"
          links:
            - link: "llvm.aarch64.neon.fmaxnmp.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vst1{neon_type[1].no}"
    doc: "Store multiple single-element structures to one, two, three, or four registers"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st1]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety:
      unsafe: [neon]
    types:
      - ['*mut f64', float64x1x2_t, float64x1_t]
      - ['*mut f64', float64x2x2_t, float64x2_t]
    compose:
      - LLVMLink:
          name: "vst1{neon_type[1].no}"
          arguments:
            - "a: {neon_type[2]}"
            - "b: {neon_type[2]}"
            - "ptr: {type[0]}"
          links:
            - link: "llvm.aarch64.neon.st1x{neon_type[1].tuple}.{neon_type[2]}.p0f64"
              arch: aarch64,arm64ec
      - FnCall: ["_vst1{neon_type[1].no}", ['b.0', 'b.1', 'a']]

  - name: "vst1{neon_type[1].no}"
    doc: "Store multiple single-element structures to one, two, three, or four registers"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st1]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety:
      unsafe: [neon]
    types:
      - ['*mut f64', float64x1x3_t, float64x1_t]
      - ['*mut f64', float64x2x3_t, float64x2_t]
    compose:
      - LLVMLink:
          name: "vst1{neon_type[1].no}"
          arguments:
            - "a: {neon_type[2]}"
            - "b: {neon_type[2]}"
            - "c: {neon_type[2]}"
            - "ptr: {type[0]}"
          links:
            - link: "llvm.aarch64.neon.st1x{neon_type[1].tuple}.{neon_type[2]}.p0f64"
              arch: aarch64,arm64ec
      - FnCall: ["_vst1{neon_type[1].no}", ['b.0', 'b.1', 'b.2', 'a']]

  - name: "vst1{neon_type[1].no}"
    doc: "Store multiple single-element structures to one, two, three, or four registers"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [st1]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety:
      unsafe: [neon]
    types:
      - ['*mut f64', float64x1x4_t, float64x1_t]
      - ['*mut f64', float64x2x4_t, float64x2_t]
    compose:
      - LLVMLink:
          name: "vst1{neon_type[1].no}"
          arguments:
            - "a: {neon_type[2]}"
            - "b: {neon_type[2]}"
            - "c: {neon_type[2]}"
            - "d: {neon_type[2]}"
            - "ptr: {type[0]}"
          links:
            - link: "llvm.aarch64.neon.st1x{neon_type[1].tuple}.{neon_type[2]}.p0f64"
              arch: aarch64,arm64ec
      - FnCall: ["_vst1{neon_type[1].no}", ['b.0', 'b.1', 'b.2', 'b.3', 'a']]

  - name: "vfma{type[3]}"
    doc: "Floating-point fused multiply-add to accumulator"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float32x2_t, float32x2_t, '1', '_lane_f32']
      - [float32x2_t, float32x4_t, '2', '_laneq_f32']
      - [float32x4_t, float32x2_t, '1', 'q_lane_f32']
      - [float32x4_t, float32x4_t, '2', 'q_laneq_f32']
      - [float64x2_t, float64x2_t, '1', 'q_laneq_f64']
    compose:
      - FnCall: ["static_assert_uimm_bits!", [LANE, "{type[2]}"]]
      - FnCall:
          - "vfma{neon_type[0].no}"
          - - a
            - b
            - FnCall: ["vdup{neon_type[0].N}", [{FnCall: [simd_extract!, [c, 'LANE as u32']]}]]


  - name: "vfma{type[3]}"
    doc: "Floating-point fused multiply-add to accumulator"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float16x4_t, float16x4_t, '2', '_lane_f16']
      - [float16x4_t, float16x8_t, '3', '_laneq_f16']
      - [float16x8_t, float16x4_t, '2', 'q_lane_f16']
      - [float16x8_t, float16x8_t, '3', 'q_laneq_f16']
    compose:
      - FnCall: ["static_assert_uimm_bits!", [LANE, "{type[2]}"]]
      - FnCall:
          - "vfma{neon_type[0].no}"
          - - a
            - b
            - FnCall: ["vdup{neon_type[0].N}", [{FnCall: [simd_extract!, [c, 'LANE as u32']]}]]


  # vfms lane f16
  - name: "vfms{type[3]}"
    doc: "Floating-point fused multiply-subtract from accumulator"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmls, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float16x4_t, float16x4_t, '2', '_lane_f16']
      - [float16x4_t, float16x8_t, '3', '_laneq_f16']
      - [float16x8_t, float16x4_t, '2', 'q_lane_f16']
      - [float16x8_t, float16x8_t, '3', 'q_laneq_f16']
    compose:
      - FnCall: ["static_assert_uimm_bits!", [LANE, "{type[2]}"]]
      - FnCall:
          - "vfms{neon_type[0].no}"
          - - a
            - b
            - FnCall: ["vdup{neon_type[0].N}", [{FnCall: [simd_extract!, [c, 'LANE as u32']]}]]


  - name: "vfms{type[1]}"
    doc: "Floating-point fused multiply-subtract from accumulator"
    arguments: ["a: {type[0]}", "b: {type[0]}", "c: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmsub]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "h_f16"]
    compose:
      - FnCall: ["vfma{type[1]}", [a, -b, c]]


  - name: "vfma_lane_f64"
    doc: "Floating-point fused multiply-add to accumulator"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmadd, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - float64x1_t
    compose:
      - FnCall: ["static_assert!", ["LANE == 0"]]
      - FnCall:
          - "vfma{neon_type.no}"
          - - a
            - b
            - FnCall: ["vdup{neon_type.N}", [{FnCall: [simd_extract!, [c, 'LANE as u32']]}]]

  - name: "vfma_laneq_f64"
    doc: "Floating-point fused multiply-add to accumulator"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmadd, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float64x1_t, float64x2_t]
    compose:
      - FnCall: ["static_assert_uimm_bits!", ["LANE", "1"]]
      - FnCall:
          - "vfma{neon_type[0].no}"
          - - a
            - b
            - FnCall: ["vdup{neon_type[0].N}", [{FnCall: [simd_extract!, [c, 'LANE as u32']]}]]

  - name: "vfmaq_lane_f64"
    doc: "Floating-point fused multiply-add to accumulator"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmla, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float64x2_t, float64x1_t]
    compose:
      - FnCall: ["static_assert!", ["LANE == 0"]]
      - FnCall:
          - "vfma{neon_type[0].no}"
          - - a
            - b
            - FnCall: ["vdup{neon_type[0].N}", [{FnCall: [simd_extract!, [c, 'LANE as u32']]}]]

  - name: "vfma{type[2]}"
    doc: "Floating-point fused multiply-add to accumulator"
    arguments: ["a: {type[0]}", "b: {type[0]}", "c: {neon_type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmadd, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["f32", float32x2_t, "s_lane_f32", '1']
      - ["f32", float32x4_t, "s_laneq_f32", '2']
      - ["f64", float64x2_t, "d_laneq_f64", '1']
    compose:
      - LLVMLink:
          name: "_vfma{type[2]}"
          arguments: ["a: {type[0]}", "b: {type[0]}", "c: {type[0]}"]
          links:
            - link: "llvm.fma.{type[0]}"
              arch: aarch64,arm64ec
      - FnCall: [static_assert_uimm_bits!, ['LANE', "{type[3]}"]]
      - Let: [c, "{type[0]}", {FnCall: [simd_extract!, [c, 'LANE as u32']]}]
      - FnCall: ["_vfma{type[2]}", [b, c, a], [], true]

  - name: "vfmad_lane_f64"
    doc: "Floating-point fused multiply-add to accumulator"
    arguments: ["a: {type[0]}", "b: {type[0]}", "c: {neon_type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmadd, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["f64", float64x1_t]
    compose:
      - LLVMLink:
          name: "_vfmad_lane_f64"
          arguments: ["a: f64", "b: f64", "c: f64"]
          links:
            - link: "llvm.fma.{type[0]}"
              arch: aarch64,arm64ec
      - FnCall: [static_assert!, ['LANE == 0']]
      - Let: [c, "{type[0]}", {FnCall: [simd_extract!, [c, 'LANE as u32']]}]
      - FnCall: ["_vfmad_lane_f64", [b, c, a]]


  - name: "vfma{type[1]}"
    doc: "Floating-point fused multiply-add to accumulator"
    arguments: ["a: {type[0]}", "b: {type[0]}", "c: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmadd]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "h_f16"]
    compose:
      - LLVMLink:
          name: "_vfma_{type[1]}"
          links:
            - link: "llvm.fma.{type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vfma{type[1]}", [b, c, a], [], true]


  - name: "vfmah_lane{type[2]}"
    doc: "Floating-point fused multiply-add to accumulator"
    arguments: ["a: {type[0]}", "b: {type[0]}", "v: {neon_type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmadd, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["f16", float16x4_t, '_f16', '2']
      - ["f16", float16x8_t, 'q_f16', '3']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[3]}']]
      - Let: [c, "{type[0]}", {FnCall: [simd_extract!, [v, 'LANE as u32']]}]
      - FnCall: ["vfmah_{type[0]}", [a, b, c]]

  - name: "vfmsh_lane{type[2]}"
    doc: "Floating-point fused multiply-subtract from accumulator"
    arguments: ["a: {type[0]}", "b: {type[0]}", "v: {neon_type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmsub, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["f16", float16x4_t, '_f16', '2']
      - ["f16", float16x8_t, 'q_f16', '3']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[3]}']]
      - Let: [c, "{type[0]}", {FnCall: [simd_extract!, [v, 'LANE as u32']]}]
      - FnCall: ["vfmsh_{type[0]}", [a, b, c]]

  - name: "vfms_f64"
    doc: "Floating-point fused multiply-subtract from accumulator"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmsub]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - float64x1_t
    compose:
      - Let: [b, "{neon_type}", {FnCall: [simd_neg, [b]]}]
      - FnCall: [vfma_f64, [a, b, c]]

  - name: "vfms{neon_type.no}"
    doc: "Floating-point fused multiply-subtract from accumulator"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmls]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - float64x2_t
    compose:
      - Let: [b, "{neon_type}", {FnCall: [simd_neg, [b]]}]
      - FnCall: [vfmaq_f64, [a, b, c]]

  - name: "vmls{neon_type.no}"
    doc: "Floating-point multiply-subtract from accumulator"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmul]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - float64x1_t
      - float64x2_t
    compose:
      - FnCall: [simd_sub, [a, {FnCall: [simd_mul, [b, c]]}]]

  - name: "vfms{type[3]}"
    doc: "Floating-point fused multiply-subtract to accumulator"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmls, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float32x2_t, float32x2_t, '1', _lane_f32]
      - [float32x2_t, float32x4_t, '2', _laneq_f32]
      - [float32x4_t, float32x2_t, '1', q_lane_f32]
      - [float32x4_t, float32x4_t, '2', q_laneq_f32]
      - [float64x2_t, float64x2_t, '1', q_laneq_f64]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[2]}']]
      - FnCall: ["vfms{neon_type[0].no}", [a, b, {FnCall: ["vdup{neon_type[0].N}", [{FnCall: [simd_extract!, [c, 'LANE as u32']]}]]}]]

  - name: "vfms_lane_f64"
    doc: "Floating-point fused multiply-subtract to accumulator"
    arguments: ["a: {neon_type}", "b: {neon_type}", "c: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmsub, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - float64x1_t
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall: ["vfms{neon_type.no}", [a, b, {FnCall: ["vdup{neon_type.N}", [{FnCall: [simd_extract!, [c, 'LANE as u32']]}]]}]]

  - name: "vfms_laneq_f64"
    doc: "Floating-point fused multiply-subtract to accumulator"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmsub, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float64x1_t, float64x2_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '1']]
      - FnCall: ["vfms{neon_type[0].no}", [a, b, {FnCall: ["vdup{neon_type[0].N}", [{FnCall: [simd_extract!, [c, 'LANE as u32']]}]]}]]

  - name: "vfmsq_lane_f64"
    doc: "Floating-point fused multiply-subtract to accumulator"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmls, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float64x2_t, float64x1_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall: ["vfms{neon_type[0].no}", [a, b, {FnCall: ["vdup{neon_type[0].N}", [{FnCall: [simd_extract!, [c, 'LANE as u32']]}]]}]]

  - name: "vfms{type[2]}"
    doc: "Floating-point fused multiply-subtract to accumulator"
    arguments: ["a: {type[0]}", "b: {type[0]}", "c: {neon_type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmsub, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["f32", float32x2_t, "s_lane_f32"]
      - ["f32", float32x4_t, "s_laneq_f32"]
      - ["f64", float64x1_t, "d_lane_f64"]
      - ["f64", float64x2_t, "d_laneq_f64"]
    compose:
      - FnCall: ["vfma{type[2]}::<LANE>", ['a', '-b', 'c']]


  - name: "vceqz{neon_type[0].no}"
    doc: "Floating-point compare bitwise equal to zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmeq]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, uint32x2_t, 'f32x2', 'f32x2::new(0.0, 0.0)']
      - [float32x4_t, uint32x4_t, 'f32x4', 'f32x4::new(0.0, 0.0, 0.0, 0.0)']
      - [float64x1_t, uint64x1_t, 'f64', '0.0']
      - [float64x2_t, uint64x2_t, 'f64x2', 'f64x2::new(0.0, 0.0)']
    compose:
      - Let: [b, '{type[2]}', '{type[3]}']
      - FnCall: [simd_eq, [a, {FnCall: [transmute, [b]]}]]

  - name: "vceqz{neon_type[0].no}"
    doc: "Floating-point compare bitwise equal to zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmeq]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [float16x4_t, uint16x4_t, 'f16x4', 'f16x4::new(0.0, 0.0, 0.0, 0.0)']
      - [float16x8_t, uint16x8_t, 'f16x8', 'f16x8::new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)']
    compose:
      - Let: [b, '{type[2]}', '{type[3]}']
      - FnCall: [simd_eq, [a, {FnCall: [transmute, [b]]}]]

  - name: "vceqz{type[2]}"
    doc: "Floating-point compare bitwise equal to zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["f32", "u32", "s_f32"]
      - ["f64", "u64", "d_f64"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vceqz_{type[0]}"
                - - FnCall: ["vdup_n_{type[0]}", [a]]
            - '0'

  - name: "vceqz{type[2]}"
    doc: "Floating-point compare bitwise equal to zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "u16", "h_f16"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vceqz_{type[0]}"
                - - FnCall: ["vdup_n_{type[0]}", [a]]
            - '0'

  - name: "vceqzd_{type[2]}"
    doc: "Compare bitwise equal to zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i64", "u64", "s64"]
      - ["u64", "u64", "u64"]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vceqz_{type[2]}"
                - - FnCall: [transmute, [a]]

  - name: "vceqz{neon_type[0].no}"
    doc: "Signed compare bitwise equal to zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmeq]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, uint8x8_t, i8x8, 'i8x8::new(0, 0, 0, 0, 0, 0, 0, 0)']
      - [int8x16_t, uint8x16_t, i8x16, 'i8x16::new(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)']
      - [int16x4_t, uint16x4_t, i16x4, 'i16x4::new(0, 0, 0, 0)']
      - [int16x8_t, uint16x8_t, i16x8, 'i16x8::new(0, 0, 0, 0, 0, 0, 0, 0)']
      - [int32x2_t, uint32x2_t, i32x2, 'i32x2::new(0, 0)']
      - [int32x4_t, uint32x4_t, i32x4, 'i32x4::new(0, 0, 0, 0)']
      - [int64x1_t, uint64x1_t, i64x1, 'i64x1::new(0)']
      - [int64x2_t, uint64x2_t, i64x2, 'i64x2::new(0, 0)']
      - [poly8x8_t, uint8x8_t, i8x8, 'i8x8::new(0, 0, 0, 0, 0, 0, 0, 0)']
      - [poly8x16_t, uint8x16_t, i8x16, 'i8x16::new(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)']
      - [poly64x1_t, uint64x1_t, i64x1, 'i64x1::new(0)']
      - [poly64x2_t, uint64x2_t, i64x2, 'i64x2::new(0, 0)']
    compose:
      - Let: [b, "{type[2]}", "{type[3]}"]
      - FnCall:
          - simd_eq
          - - a
            - FnCall: [transmute, [b]]

  - name: "vceqz{neon_type[0].no}"
    doc: "Unsigned compare bitwise equal to zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmeq]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x8_t, uint8x8_t, u8x8, 'u8x8::new(0, 0, 0, 0, 0, 0, 0, 0)']
      - [uint8x16_t, uint8x16_t, u8x16, 'u8x16::new(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)']
      - [uint16x4_t, uint16x4_t, u16x4, 'u16x4::new(0, 0, 0, 0)']
      - [uint16x8_t, uint16x8_t, u16x8, 'u16x8::new(0, 0, 0, 0, 0, 0, 0, 0)']
      - [uint32x2_t, uint32x2_t, u32x2, 'u32x2::new(0, 0)']
      - [uint32x4_t, uint32x4_t, u32x4, 'u32x4::new(0, 0, 0, 0)']
      - [uint64x1_t, uint64x1_t, u64x1, 'u64x1::new(0)']
      - [uint64x2_t, uint64x2_t, u64x2, 'u64x2::new(0, 0)']
    compose:
      - Let: [b, "{type[2]}", "{type[3]}"]
      - FnCall:
          - simd_eq
          - - a
            - FnCall: [transmute, [b]]

  - name: "vcge{neon_type.no}"
    doc: "Compare unsigned greater than or equal"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmhs]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - uint64x1_t
      - uint64x2_t
    compose:
      - FnCall: [simd_ge, [a, b]]

  - name: "vcge{type[0]}"
    doc: "Floating-point compare greater than or equal"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "f32", "u32"]
      - ["d_f64", "f64", "u64"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vcge_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
                  - FnCall: ["vdup_n_{type[1]}", [b]]
            - '0'


  - name: "vcge{type[0]}"
    doc: "Floating-point compare greater than or equal"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["h_f16", "f16", "u16"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vcge_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
                  - FnCall: ["vdup_n_{type[1]}", [b]]
            - '0'

  - name: "vcge{neon_type[0].no}"
    doc: "Floating-point compare greater than or equal"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmge]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - FnCall: [simd_ge, [a, b]]

  - name: "vcge{type[0]}"
    doc: "Compare greater than or equal"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["d_s64", "i64", "u64", s64]
      - ["d_u64", "u64", "u64", u64]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vcge_{type[3]}"
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vclt{neon_type.no}"
    doc: "Compare unsigned less than"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmhi]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - uint64x1_t
      - uint64x2_t
    compose:
      - FnCall: [simd_lt, [a, b]]

  - name: "vcltd_{type[0]}"
    doc: "Compare less than"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s64", "i64", "u64"]
      - ["u64", "u64", "u64"]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vclt_{type[0]}"
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vtst{neon_type[0].no}"
    doc: "Unsigned compare bitwise Test bits nonzero"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmtst]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint64x1_t, u64x1, 'u64x1::new(0)']
      - [uint64x2_t, u64x2, 'u64x2::new(0, 0)']
    compose:
      - Let: [c, "{neon_type[0]}", {FnCall: [simd_and, [a, b]]}]
      - Let: [d, "{type[1]}", "{type[2]}"]
      - FnCall: [simd_ne, [c, {FnCall: [transmute, [d]]}]]

  - name: "vcgez{neon_type[0].no}"
    doc: "Floating-point compare greater than or equal to zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmge]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, uint32x2_t, f32x2, 'f32x2::new(0.0, 0.0)']
      - [float32x4_t, uint32x4_t, f32x4, 'f32x4::new(0.0, 0.0, 0.0, 0.0)']
      - [float64x1_t, uint64x1_t, f64, '0.0']
      - [float64x2_t, uint64x2_t, f64x2, 'f64x2::new(0.0, 0.0)']
    compose:
      - Let: [b, "{type[2]}", "{type[3]}"]
      - FnCall:
          - simd_ge
          - - a
            - FnCall: [transmute, [b]]

  - name: "vcgez{type[0]}"
    doc: "Floating-point compare greater than or equal to zero"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "f32", "u32"]
      - ["d_f64", "f64", "u64"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vcgez_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
            - '0'


  - name: "vcgez{type[0]}"
    doc: "Floating-point compare greater than or equal to zero"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["h_f16", "f16", "u16"]
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vcgez_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
            - '0'

  - name: "vclezd_s64"
    doc: "Compare less than or equal to zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i64", "u64"]
    compose:
      - FnCall:
          - transmute
          - - FnCall: [vclez_s64, [{FnCall: [transmute, [a]]}]]

  - name: "vcgtd_{type[2]}"
    doc: "Compare greater than"
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i64", "u64", 's64']
      - ["u64", "u64", 'u64']
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vcgt_{type[2]}"
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vcgtz{neon_type[0].no}"
    doc: "Compare signed greater than zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmgt]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, uint8x8_t, i8x8, 'i8x8::new(0, 0, 0, 0, 0, 0, 0, 0)']
      - [int8x16_t, uint8x16_t, i8x16, 'i8x16::new(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)']
      - [int16x4_t, uint16x4_t, i16x4, 'i16x4::new(0, 0, 0, 0)']
      - [int16x8_t, uint16x8_t, i16x8, 'i16x8::new(0, 0, 0, 0, 0, 0, 0, 0)']
      - [int32x2_t, uint32x2_t, i32x2, 'i32x2::new(0, 0)']
      - [int32x4_t, uint32x4_t, i32x4, 'i32x4::new(0, 0, 0, 0)']
      - [int64x1_t, uint64x1_t, i64x1, 'i64x1::new(0)']
      - [int64x2_t, uint64x2_t, i64x2, 'i64x2::new(0, 0)']
    compose:
      - Let: [b, "{type[2]}", "{type[3]}"]
      - FnCall:
          - simd_gt
          - - a
            - FnCall: [transmute, [b]]

  - name: "vcgtzd_s64"
    doc: "Compare signed greater than zero"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["i64", "u64"]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - vcgtz_s64
                - - FnCall: [transmute, [a]]

  - name: "vcgtz{neon_type[0].no}"
    doc: "Floating-point compare greater than zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmgt]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, uint32x2_t, f32x2, 'f32x2::new(0.0, 0.0)']
      - [float32x4_t, uint32x4_t, f32x4, 'f32x4::new(0.0, 0.0, 0.0, 0.0)']
      - [float64x1_t, uint64x1_t, f64, '0.0']
      - [float64x2_t, uint64x2_t, f64x2, 'f64x2::new(0.0, 0.0)']
    compose:
      - Let: [b, "{type[2]}", "{type[3]}"]
      - FnCall: [simd_gt, [a, {FnCall: [transmute, [b]]}]]

  - name: "vcgtz{type[0]}"
    doc: "Floating-point compare greater than zero"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "f32", "u32"]
      - ["d_f64", "f64", "u64"]
    compose:
      - FnCall:
          - "simd_extract!"
          - - FnCall:
                - "vcgtz_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
            - '0'

  - name: "vcgtz{type[0]}"
    doc: "Floating-point compare greater than zero"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["h_f16", "f16", "u16"]
    compose:
      - FnCall:
          - "simd_extract!"
          - - FnCall:
                - "vcgtz_{type[1]}"
                - - FnCall: ["vdup_n_{type[1]}", [a]]
            - '0'

  - name: "vcvt{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to unsigned fixed-point, rounding toward zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzu]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - LLVMLink:
          name: "vcvt{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.fptoui.sat.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vmul{neon_type[0].N}"
    doc: "Vector multiply by scalar"
    arguments: ["a: {neon_type[0]}", "b: {type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmul]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x1_t, "f64"]
      - [float64x2_t, "f64"]
    compose:
      - FnCall:
          - simd_mul
          - - a
            - FnCall: ["vdup{neon_type[0].N}", [b]]

  - name: "vmul_lane_f64"
    doc: "Floating-point multiply"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmul, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - float64x1_t
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - simd_mul
          - - a
            - FnCall:
                - "transmute::<f64, _>"
                - - FnCall: [simd_extract!, [b, 'LANE as u32']]

  - name: "vmulq_lane_f64"
    doc: "Floating-point multiply"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmul, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float64x2_t, float64x1_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - FnCall:
          - simd_mul
          - - a
            - FnCall: ["simd_shuffle!", [b, b, '[LANE as u32, LANE as u32]']]

  - name: "vmuld_lane_f64"
    doc: "Floating-point multiply"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmul, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["f64", float64x1_t]
    compose:
      - FnCall: [static_assert!, ['LANE == 0']]
      - Let: [b, '{type[0]}', {FnCall: [simd_extract!, [b, 'LANE as u32']]}]
      - Identifier: ['a * b', Symbol]

  - name: "vmul_laneq_f64"
    doc: "Floating-point multiply"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmul, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float64x1_t, float64x2_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '1']]
      - FnCall:
          - simd_mul
          - - a
            - FnCall:
                - "transmute::<f64, _>"
                - - FnCall: [simd_extract!, [b, 'LANE as u32']]

  - name: "vmulq_laneq_f64"
    doc: "Floating-point multiply"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmul, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float64x2_t, float64x2_t, float64x2_t]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '1']]
      - FnCall:
          - simd_mul
          - - a
            - FnCall: [simd_shuffle!, [b, b, '[LANE as u32, LANE as u32]']]


  # vmulq_laneq_f16
  - name: "vmul{type[2]}{neon_type[1].no}"
    doc: "Floating-point multiply"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmul, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float16x4_t, float16x8_t, '_lane', "[LANE as u32, LANE as u32, LANE as u32, LANE as u32]"]
      - [float16x8_t, float16x8_t, 'q_lane', "[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]"]
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '3']]
      - FnCall:
          - simd_mul
          - - a
            - FnCall: [simd_shuffle!, [b, b, "{type[3]}"]]


  - name: "vmul{type[1]}_{type[0]}"
    doc: Add
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [nop]
    safety: safe
    types:
      - [f16, 'h']
    compose:
      - 'a * b'


  - name: "vmul{type[2]}"
    doc: "Floating-point multiply"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmul, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["f32", float32x2_t, "s_lane_f32", '1']
      - ["f32", float32x4_t, "s_laneq_f32", '2']
      - ["f64", float64x2_t, "d_laneq_f64", '1']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[3]}']]
      - Let: [b, '{type[0]}', {FnCall: [simd_extract!, [b, 'LANE as u32']]}]
      - Identifier: ['a * b', Symbol]


  - name: "vmul{type[2]}"
    doc: "Floating-point multiply"
    arguments: ["a: {type[0]}", "b: {neon_type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmul, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-fp16
      - *neon-unstable-f16
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - ["f16", float16x4_t, "h_lane_f16", '2']
      - ["f16", float16x8_t, "h_laneq_f16", '3']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[3]}']]
      - Let: [b, '{type[0]}', {FnCall: [simd_extract!, [b, 'LANE as u32']]}]
      - Identifier: ['a * b', Symbol]


  - name: "vrsrad_n_s64"
    doc: "Signed rounding shift right and accumulate."
    arguments: ["a: {type}", "b: {type}"]
    return_type: "{type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [srshr, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - "i64"
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 64']]
      - Let: [b, "{type}", {FnCall: ["vrshrd_n_s64::<N>", [b]]}]
      - Identifier: ['a.wrapping_add(b)', Symbol]

  - name: "vmlsl_high_n_{neon_type[1]}"
    doc: "Multiply-subtract long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [smlsl2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int32x4_t, int16x8_t, "i16"]
      - [int64x2_t, int32x4_t, "i32"]
    compose:
      - FnCall: ["vmlsl_high_{neon_type[1]}", [a, b, {FnCall: ["vdupq_n_{neon_type[1]}", [c]]}]]

  - name: "vmlsl_high_n_{neon_type[1]}"
    doc: "Multiply-subtract long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [umlsl2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint32x4_t, uint16x8_t, "u16"]
      - [uint64x2_t, uint32x4_t, "u32"]
    compose:
      - FnCall: ["vmlsl_high_{neon_type[1]}", [a, b, {FnCall: ["vdupq_n_{neon_type[1]}", [c]]}]]

  - name: "vmlsl_high_lane{neon_type[2].no}"
    doc: "Multiply-subtract long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [smlsl2, 'LANE = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [int32x4_t, int16x8_t, int16x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [int32x4_t, int16x8_t, int16x8_t, '3', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [int64x2_t, int32x4_t, int32x2_t, '1', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [int64x2_t, int32x4_t, int32x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[3]}']]
      - FnCall:
          - "vmlsl_high_{neon_type[1]}"
          - - a
            - b
            - FnCall: [simd_shuffle!, [c, c, "{type[4]}"]]

  - name: "vmlsl_high_lane{neon_type[2].no}"
    doc: "Multiply-subtract long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [umlsl2, 'LANE = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [uint32x4_t, uint16x8_t, uint16x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [uint32x4_t, uint16x8_t, uint16x8_t, '3', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [uint64x2_t, uint32x4_t, uint32x2_t, '1', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [uint64x2_t, uint32x4_t, uint32x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[3]}']]
      - FnCall:
          - "vmlsl_high_{neon_type[1]}"
          - - a
            - b
            - FnCall: [simd_shuffle!, [c, c, "{type[4]}"]]

  - name: "vclt{neon_type[0].no}"
    doc: "Floating-point compare less than"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmgt]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - FnCall: [simd_lt, [a, b]]

  - name: "vclt{type[2]}"
    doc: "Floating-point compare less than"
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["f32", "u32", 's_f32']
      - ["f64", "u64", 'd_f64']
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vclt_{type[0]}"
                - - FnCall: ["vdup_n_{type[0]}", [a]]
                  - FnCall: ["vdup_n_{type[0]}", [b]]
            - '0'


  - name: "vclt{type[2]}"
    doc: "Floating-point compare less than"
    arguments: ["a: {type[0]}", "b: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcmp]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "u16", 'h_f16']
    compose:
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vclt_{type[0]}"
                - - FnCall: ["vdup_n_{type[0]}", [a]]
                  - FnCall: ["vdup_n_{type[0]}", [b]]
            - '0'

  - name: "vabdl_high_{neon_type[0]}"
    doc: "Unsigned Absolute difference Long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [uabdl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x16_t, uint16x8_t, uint8x8_t, '[8, 9, 10, 11, 12, 13, 14, 15]']
      - [uint16x8_t, uint32x4_t, uint16x4_t, '[4, 5, 6, 7]']
      - [uint32x4_t, uint64x2_t, uint32x2_t, '[2, 3]']
    compose:
      - Let: [c, "{neon_type[2]}", {FnCall: [simd_shuffle!, [a, a, "{type[3]}"]]}]
      - Let: [d, "{neon_type[2]}", {FnCall: [simd_shuffle!, [b, b, "{type[3]}"]]}]
      - FnCall: [simd_cast, [{FnCall: ["vabd_{neon_type[0]}", [c, d]]}]]

  - name: "vfms_n_f64"
    doc: "Floating-point fused Multiply-subtract to accumulator(vector)"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmsub]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x1_t, "f64"]
    compose:
      - FnCall:
          - "vfms{neon_type[0].no}"
          - - a
            - b
            - FnCall: ["vdup{neon_type[0].N}", [c]]

  - name: "vfmsq_n_f64"
    doc: "Floating-point fused Multiply-subtract to accumulator(vector)"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmls]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x2_t, "f64"]
    compose:
      - FnCall:
          - "vfms{neon_type[1].no}"
          - - a
            - b
            - FnCall: ["vdup{neon_type[1].N}", [c]]


  - name: "vfms{neon_type[0].N}"
    doc: Floating-point fused Multiply-Subtract from accumulator.
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-fp16
      - *neon-unstable-f16
    assert_instr: [fmls]
    safety: safe
    types:
      - [float16x4_t, f16]
      - [float16x8_t, f16]
    compose:
      - FnCall:
          - "vfms{neon_type[0].no}"
          - - a
            - b
            - FnCall:
                - "vdup{neon_type[0].N}"
                - - c


  - name: "vpminnm{type[0]}"
    doc: "Floating-point minimum number pairwise"
    arguments: ["a: {neon_type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fminnmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ['s_f32', float32x2_t, "f32"]
      - ['qd_f64', float64x2_t, "f64"]
    compose:
      - LLVMLink:
          name: "vpminnm{type[0]}"
          links:
            - link: "llvm.aarch64.neon.fminnmv.{type[2]}.{neon_type[1]}"
              arch: aarch64,arm64ec

  - name: "vpmaxnm{type[0]}"
    doc: "Floating-point maximum number pairwise"
    arguments: ["a: {neon_type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmaxnmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ['s_f32', float32x2_t, "f32"]
      - ['qd_f64', float64x2_t, "f64"]
    compose:
      - LLVMLink:
          name: "vpmaxnm{type[0]}"
          links:
            - link: "llvm.aarch64.neon.fmaxnmv.{type[2]}.{neon_type[1]}"
              arch: aarch64,arm64ec

  - name: "vcled_{type[0]}"
    doc: "Compare less than or equal"
    arguments: ["a: {type[1]}", "b: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s64", "i64", "u64"]
      - ["u64", "u64", "u64"]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vcle_{type[0]}"
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vqdmulh{neon_type[0].lane_nox}"
    doc: "Vector saturating doubling multiply high by scalar"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqdmulh, 'LANE = 0']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [int16x4_t, int16x4_t, '2']
      - [int16x8_t, int16x4_t, '2']
      - [int32x2_t, int32x2_t, '1']
      - [int32x4_t, int32x2_t, '1']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[2]}"]]
      - FnCall:
          - "vqdmulh{neon_type[0].no}"
          - - a
            - FnCall:
                - "vdup{neon_type[0].N}"
                - - FnCall: [simd_extract!, [b, 'LANE as u32']]

  - name: "vqabs{type[2]}"
    doc: "Signed saturating absolute value"
    arguments: ["a: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [sqabs]]}]]
    safety: safe
    types:
      - ["i8", "s8", 'b_s8']
      - ["i16", "s16", 'h_s16']
    compose:
      - FnCall:
          - "simd_extract!"
          - - FnCall: ["vqabs_{type[1]}", [{FnCall: ["vdup_n_{type[1]}", [a]]}]]
            - '0'

  - name: "vqabs{type[1]}"
    doc: "Signed saturating absolute value"
    arguments: ["a: {type[0]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
      - FnCall: [cfg_attr, [{FnCall: [all, [test, {FnCall: [not, ['target_env = "msvc"']]}]]}, {FnCall: [assert_instr, [sqabs]]}]]
    safety: safe
    types:
      - ["i32", "s_s32"]
      - ["i64", "d_s64"]
    compose:
      - LLVMLink:
          name: "vqabs{type[1]}"
          links:
            - link: "llvm.aarch64.neon.sqabs.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vmull_high_n_{neon_type[0]}"
    doc: "Multiply long"
    arguments: ["a: {neon_type[0]}", "b: {type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [smull2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int16x8_t, "i16", int32x4_t]
      - [int32x4_t, "i32", int64x2_t]
    compose:
      - FnCall:
          - "vmull_high_{neon_type[0]}"
          - - a
            - FnCall: ["vdupq_n_{neon_type[0]}", [b]]

  - name: "vmull_high_n_{neon_type[0]}"
    doc: "Multiply long"
    arguments: ["a: {neon_type[0]}", "b: {type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [umull2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint16x8_t, "u16", uint32x4_t]
      - [uint32x4_t, "u32", uint64x2_t]
    compose:
      - FnCall:
          - "vmull_high_{neon_type[0]}"
          - - a
            - FnCall: ["vdupq_n_{neon_type[0]}", [b]]

  - name: "vmull_high_lane{neon_type[1].no}"
    doc: "Multiply long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [smull2, 'LANE = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [int16x8_t, int16x4_t, int32x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [int16x8_t, int16x8_t, int32x4_t, '3', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [int32x4_t, int32x2_t, int64x2_t, '1', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [int32x4_t, int32x4_t, int64x2_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[3]}"]]
      - FnCall:
          - "vmull_high_{neon_type[0]}"
          - - a
            - FnCall: [simd_shuffle!, [b, b, '{type[4]}']]

  - name: "vmull_high_lane{neon_type[1].no}"
    doc: "Multiply long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [umull2, 'LANE = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [uint16x8_t, uint16x4_t, uint32x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [uint16x8_t, uint16x8_t, uint32x4_t, '3', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [uint32x4_t, uint32x2_t, uint64x2_t, '1', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [uint32x4_t, uint32x4_t, uint64x2_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[3]}"]]
      - FnCall:
          - "vmull_high_{neon_type[0]}"
          - - a
            - FnCall: [simd_shuffle!, [b, b, '{type[4]}']]

  - name: "vrsqrte{neon_type.no}"
    doc: "Reciprocal square-root estimate."
    arguments: ["a: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frsqrte]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - float64x1_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "vrsqrte{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.frsqrte.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vrsqrte{type[0]}"
    doc: "Reciprocal square-root estimate."
    arguments: ["a: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frsqrte]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["s_f32", "f32"]
      - ["d_f64", "f64"]
    compose:
      - LLVMLink:
          name: "vrsqrte{neon_type[1].no}"
          links:
            - link: "llvm.aarch64.neon.frsqrte.{type[1]}"
              arch: aarch64,arm64ec


  - name: "vrsqrte{type[0]}"
    doc: "Reciprocal square-root estimate."
    arguments: ["a: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-fp16
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [frsqrte]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["h_f16", "f16"]
    compose:
      - LLVMLink:
          name: "vrsqrte{neon_type[1].no}"
          links:
            - link: "llvm.aarch64.neon.frsqrte.{type[1]}"
              arch: aarch64,arm64ec


  - name: "vpminnm{neon_type.no}"
    doc: "Floating-point Minimum Number Pairwise (vector)."
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fminnmp]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - float32x2_t
      - float64x2_t
      - float32x4_t
    compose:
      - LLVMLink:
          name: "vpminnm{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.fminnmp.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vqshlu{type[0]}"
    doc: "Signed saturating shift left unsigned"
    arguments: ["a: {type[1]}"]
    return_type: "{type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sqshlu, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['1']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [b_n_s8, i8, u8, '3', s8]
      - [h_n_s16, i16, u16, '4', s16]
      - [s_n_s32, i32, u32, '5', s32]
      - [d_n_s64, i64, u64, '6', s64]
    compose:
      - FnCall: [static_assert_uimm_bits!, [N, "{type[3]}"]]
      - FnCall:
          - simd_extract!
          - - FnCall:
                - "vqshlu_n_{type[4]}::<N>"
                - - FnCall: ["vdup_n_{type[4]}", [a]]
            - '0'

  - name: "vcvta{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to unsigned integer, rounding to nearest with ties to away"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtau]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float32x2_t, uint32x2_t]
      - [float32x4_t, uint32x4_t]
      - [float64x1_t, uint64x1_t]
      - [float64x2_t, uint64x2_t]
    compose:
      - LLVMLink:
          name: "vcvta{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtau.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvta{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to unsigned integer, rounding to nearest with ties to away"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtau]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - [float16x4_t, uint16x4_t]
      - [float16x8_t, uint16x8_t]
    compose:
      - LLVMLink:
          name: "vcvta{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.aarch64.neon.fcvtau.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec


  - name: "vcvt{neon_type[1].no}_{neon_type[0]}"
    doc: "Floating-point convert to signed fixed-point, rounding toward zero"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtzs]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [float64x1_t, int64x1_t]
      - [float64x2_t, int64x2_t]
    compose:
      - LLVMLink:
          name: "vcvt{neon_type[1].no}_{neon_type[0]}"
          links:
            - link: "llvm.fptosi.sat.{neon_type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtm{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to integer, rounding towards minus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtms]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "i32", 'h']
      - ["f16", "i64", 'h']
    compose:
      - LLVMLink:
          name: "vcvtm{type[2]}_{type[1]}_{type[0]}"
          return_type: "{type[1]}"
          links:
            - link: "llvm.aarch64.neon.fcvtms.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtm{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to integer, rounding towards minus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtms]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "i16", 'h', 'i32']
    compose:
      - 'vcvtmh_{type[3]}_f16(a) as i16'


  - name: "vcvtm{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to unsigned integer, rounding towards minus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtmu]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "u32", 'h']
      - ["f16", "u64", 'h']
    compose:
      - LLVMLink:
          name: "vcvtm{type[2]}_{type[1]}_{type[0]}"
          return_type: "{type[1]}"
          links:
            - link: "llvm.aarch64.neon.fcvtmu.{type[1]}.{type[0]}"
              arch: aarch64,arm64ec

  - name: "vcvtm{type[2]}_{type[1]}_{type[0]}"
    doc: "Floating-point convert to integer, rounding towards minus infinity"
    arguments: ["a: {type[0]}"]
    return_type: "{type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fcvtmu]]}]]
      - *neon-fp16
      - *neon-unstable-f16
    safety: safe
    types:
      - ["f16", "u16", 'h', 'u32']
    compose:
      - 'vcvtmh_{type[3]}_f16(a) as u16'

  - name: "vmlal_high_n_{neon_type[1]}"
    doc: "Multiply-add long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [smlal2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int32x4_t, int16x8_t, "i16"]
      - [int64x2_t, int32x4_t, "i32"]
    compose:
      - FnCall:
          - "vmlal_high_{neon_type[1]}"
          - - a
            - b
            - FnCall: ["vdupq_n_{neon_type[1]}", [c]]

  - name: "vmlal_high_n_{neon_type[1]}"
    doc: "Multiply-add long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [umlal2]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint32x4_t, uint16x8_t, "u16"]
      - [uint64x2_t, uint32x4_t, "u32"]
    compose:
      - FnCall:
          - "vmlal_high_{neon_type[1]}"
          - - a
            - b
            - FnCall: ["vdupq_n_{neon_type[1]}", [c]]

  - name: "vmlal_high_lane{neon_type[2].no}"
    doc: "Multiply-add long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [smlal2, 'LANE = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [int32x4_t, int16x8_t, int16x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [int32x4_t, int16x8_t, int16x8_t, '3', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [int64x2_t, int32x4_t, int32x2_t, '1', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [int64x2_t, int32x4_t, int32x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[3]}']]
      - FnCall: ['vmlal_high_{neon_type[2]}', [a, b, {FnCall: [simd_shuffle!, [c, c, '{type[4]}']]}]]

  - name: "vmlal_high_lane{neon_type[2].no}"
    doc: "Multiply-add long"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [umlal2, 'LANE = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [uint32x4_t, uint16x8_t, uint16x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [uint32x4_t, uint16x8_t, uint16x8_t, '3', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [uint64x2_t, uint32x4_t, uint32x2_t, '1', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
      - [uint64x2_t, uint32x4_t, uint32x4_t, '2', '[LANE as u32, LANE as u32, LANE as u32, LANE as u32]']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, '{type[3]}']]
      - FnCall: ['vmlal_high_{neon_type[2]}', [a, b, {FnCall: [simd_shuffle!, [c, c, '{type[4]}']]}]]

  - name: "vrsrad_n_u64"
    doc: "Unsigned rounding shift right and accumulate."
    arguments: ["a: {type}", "b: {type}"]
    return_type: "{type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [urshr, 'N = 2']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    static_defs: ['const N: i32']
    safety: safe
    types:
      - "u64"
    compose:
      - FnCall: [static_assert!, ['N >= 1 && N <= 64']]
      - Let: [b, u64, {FnCall: ["vrshrd_n_u64::<N>", [b]]}]
      - Identifier: ['a.wrapping_add(b)', Symbol]

  - name: "vcle{neon_type.no}"
    doc: "Compare unsigned less than or equal"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [cmhs]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - uint64x1_t
      - uint64x2_t
    compose:
      - FnCall: [simd_le, [a, b]]

  - name: "vld4{neon_type[1].dup_nox}"
    doc: "Load single 4-element structure and replicate to all lanes of four registers"
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld4r]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety:
      unsafe: [neon]
    types:
      - ["*const i64", int64x2x4_t, "v2i64", "p0i64"]
      - ["*const f64", float64x1x4_t, "v1f64", "p0f64"]
      - ["*const f64", float64x2x4_t, "v2f64", "p0f64"]
    compose:
      - LLVMLink:
          name: "vld4{neon_type[1].dup_nox}"
          arguments:
            - "ptr: {type[0]}"
          links:
            - link: "llvm.aarch64.neon.ld4r.{type[2]}.{type[3]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vld4{neon_type[1].dup_nox}", ['a as _']]

  - name: "vld4{neon_type[1].dup_nox}"
    doc: "Load single 4-element structure and replicate to all lanes of four registers"
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld4r]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety:
      unsafe: [neon]
    types:
      - ["*const u64", uint64x2x4_t, "q_dup_s64"]
    compose:
      - FnCall:
          - transmute
          - - FnCall: ["vld4{type[2]}", [{FnCall: [transmute, [a]]}]]

  - name: "vld4{neon_type[1].dup_nox}"
    doc: "Load single 4-element structure and replicate to all lanes of four registers"
    arguments: ["a: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,aes"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ld4r]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety:
      unsafe: [neon]
    types:
      - ["*const p64", poly64x2x4_t, "q_dup_s64"]
    compose:
      - FnCall:
          - transmute
          - - FnCall: ["vld4{type[2]}", [{FnCall: [transmute, [a]]}]]

  - name: "vtbx4{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, int8x8x4_t]
    compose:
      - FnCall:
          - "vqtbx2"
          - - FnCall: [transmute, [a]]
            - FnCall:
                - transmute
                - - FnCall: ["vcombine{neon_type[0].noq}", ["b.0", "b.1"]]
            - FnCall:
                - transmute
                - - FnCall: ["vcombine{neon_type[0].noq}", ["b.2", "b.3"]]
            - FnCall: [transmute, [c]]

  - name: "vtbx4{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x8_t, uint8x8x4_t, uint8x8_t]
      - [poly8x8_t, poly8x8x4_t, uint8x8_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vqtbx2"
                - - FnCall: [transmute, [a]]
                  - FnCall:
                      - transmute
                      - - FnCall: ["vcombine{neon_type[0].noq}", ["b.0", "b.1"]]
                  - FnCall:
                      - transmute
                      - - FnCall: ["vcombine{neon_type[0].noq}", ["b.2", "b.3"]]
                  - c

  - name: "vtbl1{neon_type[0].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, 'int8x8_t', 'unsafe {{ transmute(b) }}']
      - [uint8x8_t, 'uint8x8_t', 'b']
      - [poly8x8_t, 'uint8x8_t', 'b']
    compose:
      - FnCall: 
          - 'vqtbl1{neon_type[0].no}'
          - - FnCall:
                - 'vcombine{neon_type[0].no}'
                - - a
                  - 'unsafe {{ crate::mem::zeroed() }}'
            - Identifier: ['{type[2]}', Symbol]

  - name: "vtbl2{neon_type[1].noq}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8x2_t, 'int8x8_t']
    compose:
      - FnCall:
          - vqtbl1
          - - FnCall:
                - transmute
                - - FnCall:
                      - 'vcombine{neon_type[1].noq}'
                      - - 'a.0'
                        - 'a.1'
            - FnCall: [transmute, [b]]

  - name: "vtbl2{neon_type[2].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x8x2_t, 'uint8x8_t', 'uint8x8_t']
      - [poly8x8x2_t, 'uint8x8_t', 'poly8x8_t']
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - vqtbl1
                - - FnCall:
                      - transmute
                      - - FnCall:
                            - 'vcombine{neon_type[2].noq}'
                            - - 'a.0'
                              - 'a.1'
                  - b

  - name: "vtbl3{neon_type[1].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8x3_t, 'int8x8_t', 'int8x16x2']
    compose:
      - Let:
          - x
          - FnCall:
              - '{type[2]}_t'
              - - FnCall: ['vcombine{neon_type[1].no}', ['a.0', 'a.1']]
                - FnCall: ['vcombine{neon_type[1].no}', ['a.2', 'unsafe {{ crate::mem::zeroed() }}']]
      - FnCall: 
          - transmute
          - - FnCall:
                - vqtbl2
                - - FnCall: [transmute, ['x.0']]
                  - FnCall: [transmute, ['x.1']]
                  - FnCall: [transmute, [b]]

  - name: "vtbl3{neon_type[3].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x8x3_t, 'uint8x8_t', 'uint8x16x2', 'uint8x8_t']
      - [poly8x8x3_t, 'uint8x8_t', 'poly8x16x2', 'poly8x8_t']
    big_endian_inverse: true 
    compose:
      - Let:
          - x
          - FnCall:
              - '{type[2]}_t'
              - - FnCall: ['vcombine{neon_type[3].no}', ['a.0', 'a.1']]
                - FnCall: ['vcombine{neon_type[3].no}', ['a.2', 'unsafe {{ crate::mem::zeroed() }}']]
      - FnCall: 
          - transmute
          - - FnCall:
                - vqtbl2
                - - FnCall: [transmute, ['x.0']]
                  - FnCall: [transmute, ['x.1']]
                  - b

  - name: "vtbl4{neon_type[1].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8x4_t, 'int8x8_t', 'int8x16x2']
    compose:
      - Let:
          - x
          - FnCall:
              - '{type[2]}_t'
              - - FnCall: ['vcombine{neon_type[1].no}', ['a.0', 'a.1']]
                - FnCall: ['vcombine{neon_type[1].no}', ['a.2', 'a.3']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vqtbl2'
                - - FnCall: [transmute, ['x.0']]
                  - FnCall: [transmute, ['x.1']]
                  - FnCall: [transmute, [b]]

  - name: "vtbl4{neon_type[3].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x8x4_t, 'uint8x8_t', 'uint8x16x2', 'uint8x8_t']
      - [poly8x8x4_t, 'uint8x8_t', 'poly8x16x2', 'poly8x8_t']
    big_endian_inverse: true
    compose:
      - Let:
          - x
          - FnCall:
              - '{type[2]}_t'
              - - FnCall: ['vcombine{neon_type[3].no}', ['a.0', 'a.1']]
                - FnCall: ['vcombine{neon_type[3].no}', ['a.2', 'a.3']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vqtbl2'
                - - FnCall: [transmute, ['x.0']]
                  - FnCall: [transmute, ['x.1']]
                  - b

  - name: "vqtbx1{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, int8x16_t, uint8x8_t, vqtbx1]
      - [int8x16_t, int8x16_t, uint8x16_t, vqtbx1q]
    compose:
      - FnCall: ['{type[3]}', [a, b, c]]

  - name: "vqtbx1{type[4]}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x8_t, "uint8x16_t", uint8x8_t, "vqtbx1", "_u8"]
      - [poly8x8_t, "poly8x16_t", uint8x8_t, "vqtbx1", "_p8"]
      - [uint8x16_t, "uint8x16_t", uint8x16_t, "vqtbx1q", "q_u8"]
      - [poly8x16_t, "poly8x16_t", uint8x16_t, "vqtbx1q", "q_p8"]
    compose:
      - Let:
        - x
        - FnCall:
            - transmute
            - - FnCall:
                  - "{type[3]}"
                  - - FnCall: [transmute, [a]]
                    - FnCall: [transmute, [b]]
                    - c
      - Identifier: [x, Symbol]
  
  - name: "vtbx1{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}", "c: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, "int8x8_t", "transmute(c)", "i8x8::splat(8)", "int8x8"]
      - [uint8x8_t, "uint8x8_t", "c", "u8x8::splat(8)", "uint8x8"]
      - [poly8x8_t, "uint8x8_t", "c", "u8x8::splat(8)", "uint8x8"]
    compose:
      - FnCall:
          - simd_select
          - - FnCall: 
                - "simd_lt::<{type[4]}_t, int8x8_t>"
                - - c
                  - FnCall: [transmute, ["{type[3]}"]]
            - FnCall:
                - transmute
                - - FnCall: 
                      - "vqtbx1"
                      - - "transmute(a)"
                        - FnCall:
                            - transmute
                            - - FnCall: ["vcombine{neon_type[0].no}", [b, "crate::mem::zeroed()"]]
                        - "{type[2]}"
            - a

  - name: "vtbx2{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, 'int8x8x2_t']
    compose:
      - FnCall:
          - vqtbx1
          - - FnCall: [transmute, [a]]
            - FnCall:
                - transmute
                - - FnCall: ["vcombine{neon_type[0].no}", ['b.0', 'b.1']]
            - FnCall: [transmute, [c]]

  - name: "vtbx2{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x8_t, 'uint8x8x2_t', uint8x8_t]
      - [poly8x8_t, 'poly8x8x2_t', uint8x8_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - vqtbx1
                - - FnCall: [transmute, [a]]
                  - FnCall:
                      - transmute
                      - - FnCall: ["vcombine{neon_type[0].no}", ['b.0', 'b.1']]
                  - c

  - name: "vtbx3{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, 'int8x8x3_t', 'int8x16x2', 'i8x8::splat(24)', 'int8x8']
    compose:
      - Let:
         - x
         - FnCall:
             - '{type[2]}_t'
             - - FnCall: ['vcombine{neon_type[0].no}', ['b.0', 'b.1']]
               - FnCall: ['vcombine{neon_type[0].no}', ['b.2', 'unsafe {{ crate::mem::zeroed() }}']]
      - FnCall:
          - transmute
          - - FnCall:
                - simd_select
                - - FnCall:
                      - 'simd_lt::<{type[4]}_t, int8x8_t>'
                      - - FnCall: [transmute, [c]]
                        - FnCall: [transmute, ['{type[3]}']]
                  - FnCall:
                      - transmute
                      - - FnCall:
                            - 'vqtbx2'
                            - - FnCall: [transmute, [a]]
                              - FnCall: [transmute, ['x.0']]
                              - FnCall: [transmute, ['x.1']]
                              - FnCall: [transmute, [c]]
                  - a

  - name: "vtbx3{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: uint8x8_t"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x8_t, 'uint8x8x3_t', 'uint8x16x2', 'u8x8::splat(24)', 'uint8x8']
      - [poly8x8_t, 'poly8x8x3_t', 'poly8x16x2', 'u8x8::splat(24)', 'poly8x8']
    big_endian_inverse: true
    compose:
      - Let:
         - x
         - FnCall:
             - '{type[2]}_t'
             - - FnCall: ['vcombine{neon_type[0].no}', ['b.0', 'b.1']]
               - FnCall: ['vcombine{neon_type[0].no}', ['b.2', 'unsafe {{ crate::mem::zeroed() }}']]
      - FnCall:
          - transmute
          - - FnCall:
                - simd_select
                - - FnCall:
                      - 'simd_lt::<{type[4]}_t, int8x8_t>'
                      - - FnCall: [transmute, [c]]
                        - FnCall: [transmute, ['{type[3]}']]
                  - FnCall:
                      - transmute
                      - - FnCall:
                            - 'vqtbx2'
                            - - FnCall: [transmute, [a]]
                              - FnCall: [transmute, ['x.0']]
                              - FnCall: [transmute, ['x.1']]
                              - c
                  - a

  - name: "vqtbl1{neon_type[3].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ['int8x16_t', uint8x8_t, 'vqtbl1', 'int8x8_t']
      - ['int8x16_t', uint8x16_t, 'vqtbl1q', 'int8x16_t']
    compose:
      - FnCall: ['{type[2]}', ['a', b]]

  - name: "vqtbl1{neon_type[3].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ['uint8x16_t', uint8x8_t, 'vqtbl1', 'uint8x8_t']
      - ['poly8x16_t', uint8x8_t, 'vqtbl1', 'poly8x8_t']
      - ['uint8x16_t', uint8x16_t, 'vqtbl1q', 'uint8x16_t']
      - ['poly8x16_t', uint8x16_t, 'vqtbl1q', 'poly8x16_t']
    compose:
      - Let:
          - x
          - FnCall:
              - transmute
              - - FnCall: 
                    - '{type[2]}'
                    - - FnCall: [transmute, ['a']]
                      - b
      - Identifier: [x, Symbol]

  - name: "vqtbl2{neon_type[3].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ['int8x16x2_t', uint8x8_t, 'vqtbl2', 'int8x8_t']
      - ['int8x16x2_t', uint8x16_t, 'vqtbl2q', 'int8x16_t']
    compose:
      - FnCall: ['{type[2]}', ['a.0', 'a.1', b]]

  - name: "vqtbl2{neon_type[3].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ['uint8x16x2_t', uint8x8_t, 'vqtbl2', 'uint8x8_t']
      - ['uint8x16x2_t', uint8x16_t, 'vqtbl2q', 'uint8x16_t']
      - ['poly8x16x2_t', uint8x8_t, 'vqtbl2', 'poly8x8_t']
      - ['poly8x16x2_t', uint8x16_t, 'vqtbl2q', 'poly8x16_t']
    compose:
      - FnCall:
          - transmute
          - - FnCall: 
                - '{type[2]}'
                - - FnCall: [transmute, ['a.0']]
                  - FnCall: [transmute, ['a.1']]
                  - b

  - name: "vqtbx2{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, 'int8x16x2_t', uint8x8_t, 'vqtbx2']
      - [int8x16_t, 'int8x16x2_t', uint8x16_t, 'vqtbx2q']
    compose:
      - FnCall: ['{type[3]}', [a, 'b.0', 'b.1', c]]

  - name: "vqtbx2{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x8_t, 'uint8x16x2_t', uint8x8_t, 'vqtbx2']
      - [uint8x16_t, 'uint8x16x2_t', uint8x16_t, 'vqtbx2q']
      - [poly8x8_t, 'poly8x16x2_t', uint8x8_t, 'vqtbx2']
      - [poly8x16_t, 'poly8x16x2_t', uint8x16_t, 'vqtbx2q']
    compose:
      - FnCall:
          - transmute
          - - FnCall: 
                - '{type[3]}'
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, ['b.0']]
                  - FnCall: [transmute, ['b.1']]
                  - c

  - name: "vqtbl3{neon_type[0].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ['int8x8_t', 'int8x16x3_t', uint8x8_t, 'vqtbl3']
      - ['int8x16_t', 'int8x16x3_t', uint8x16_t, 'vqtbl3q']
    compose:
      - FnCall: ['{type[3]}', ['a.0', 'a.1', 'a.2', b]]

  - name: "vqtbl3{neon_type[0].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ['uint8x8_t', 'uint8x16x3_t', uint8x8_t, 'vqtbl3']
      - ['uint8x16_t','uint8x16x3_t', uint8x16_t, 'vqtbl3q']
      - ['poly8x8_t', 'poly8x16x3_t', uint8x8_t, 'vqtbl3']
      - ['poly8x16_t','poly8x16x3_t', uint8x16_t, 'vqtbl3q']
    compose:
      - FnCall:
          - transmute
          - - FnCall: 
                - '{type[3]}'
                - - FnCall: [transmute, ['a.0']]
                  - FnCall: [transmute, ['a.1']]
                  - FnCall: [transmute, ['a.2']]
                  - b

  - name: "vqtbx3{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, 'int8x16x3_t', uint8x8_t, 'vqtbx3']
      - [int8x16_t, 'int8x16x3_t', uint8x16_t, 'vqtbx3q']
    compose:
      - FnCall: ['{type[3]}', [a, 'b.0', 'b.1', 'b.2', c]]

  - name: "vqtbx3{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x8_t, 'uint8x16x3_t', uint8x8_t, 'vqtbx3']
      - [uint8x16_t, 'uint8x16x3_t', uint8x16_t, 'vqtbx3q']
      - [poly8x8_t, 'poly8x16x3_t', uint8x8_t, 'vqtbx3']
      - [poly8x16_t, 'poly8x16x3_t', uint8x16_t, 'vqtbx3q']
    compose:
      - FnCall:
          - transmute
          - - FnCall: 
                - '{type[3]}'
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, ['b.0']]
                  - FnCall: [transmute, ['b.1']]
                  - FnCall: [transmute, ['b.2']]
                  - c

  - name: "vqtbl4{neon_type[3].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ['int8x16x4_t', uint8x8_t, 'vqtbl4', 'int8x8_t']
      - ['int8x16x4_t', uint8x16_t, 'vqtbl4q', 'int8x16_t']
    compose:
      - FnCall: ['{type[2]}', ['a.0', 'a.1', 'a.2', 'a.3', b]]

  - name: "vqtbl4{neon_type[3].no}"
    doc: "Table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ['uint8x16x4_t', uint8x8_t, 'vqtbl4', 'uint8x8_t']
      - ['uint8x16x4_t', uint8x16_t, 'vqtbl4q', 'uint8x16_t']
      - ['poly8x16x4_t', uint8x8_t, 'vqtbl4', 'poly8x8_t']
      - ['poly8x16x4_t', uint8x16_t, 'vqtbl4q', 'poly8x16_t']
    compose:
      - FnCall:
          - transmute
          - - FnCall: 
                - '{type[2]}'
                - - FnCall: [transmute, ['a.0']]
                  - FnCall: [transmute, ['a.1']]
                  - FnCall: [transmute, ['a.2']]
                  - FnCall: [transmute, ['a.3']]
                  - b

  - name: "vqtbx4{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [int8x8_t, 'int8x16x4_t', uint8x8_t, 'vqtbx4']
      - [int8x16_t, 'int8x16x4_t', uint8x16_t, 'vqtbx4q']
    compose:
      - FnCall: ['{type[3]}', [a, 'b.0', 'b.1', 'b.2', 'b.3', c]]

  - name: "vqtbx4{neon_type[0].no}"
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [uint8x8_t, 'uint8x16x4_t', uint8x8_t, 'vqtbx4']
      - [uint8x16_t, 'uint8x16x4_t', uint8x16_t, 'vqtbx4q']
      - [poly8x8_t, 'poly8x16x4_t', uint8x8_t, 'vqtbx4']
      - [poly8x16_t, 'poly8x16x4_t', uint8x16_t, 'vqtbx4q']
    compose:
      - FnCall:
          - transmute
          - - FnCall: 
                - '{type[3]}'
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, ['b.0']]
                  - FnCall: [transmute, ['b.1']]
                  - FnCall: [transmute, ['b.2']]
                  - FnCall: [transmute, ['b.3']]
                  - c

  - name: "{type[0]}"
    visibility: private
    doc: "Table look-up"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[2]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["vqtbl1", "int8x16_t", "uint8x8_t", "int8x8_t"]
      - ["vqtbl1q", "int8x16_t", "uint8x16_t", "int8x16_t"]
    compose:
      - LLVMLink:
          name: "_{type[0]}"
          links:
            - link: "llvm.aarch64.neon.tbl1.{neon_type[3]}"
              arch: aarch64,arm64ec

  - name: "{type[0]}"
    visibility: private
    doc: "Table look-up"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[1]}", "c: {neon_type[2]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["vqtbl2", "int8x16_t", "uint8x8_t", "int8x8_t"]
      - ["vqtbl2q", "int8x16_t", "uint8x16_t", "int8x16_t"]
    compose:
      - LLVMLink:
          name: "_{type[0]}"
          links:
            - link: "llvm.aarch64.neon.tbl2.{neon_type[3]}"
              arch: aarch64,arm64ec

  - name: "{type[0]}"
    visibility: private
    doc: "Table look-up"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[1]}", "c: {neon_type[1]}", "d: {neon_type[2]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["vqtbl3", int8x16_t, uint8x8_t, int8x8_t]
      - ["vqtbl3q", int8x16_t, uint8x16_t, int8x16_t]
    compose:
      - LLVMLink:
          name: "_{type[0]}"
          links:
            - link: "llvm.aarch64.neon.tbl3.{neon_type[3]}"
              arch: aarch64,arm64ec

  - name: "{type[0]}"
    visibility: private
    doc: "Table look-up"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[1]}", "c: {neon_type[1]}", "d: {neon_type[1]}", "e: {neon_type[2]}"]
    return_type: "{neon_type[3]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbl]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - ["vqtbl4", int8x16_t, uint8x8_t, int8x8_t]
      - ["vqtbl4q", int8x16_t, uint8x16_t, int8x16_t]
    compose:
      - LLVMLink:
          name: "_{type[0]}"
          links:
            - link: "llvm.aarch64.neon.tbl4.{neon_type[3]}"
              arch: aarch64,arm64ec

  - name: "{type[0]}"
    visibility: private
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[2]}", "c: {neon_type[3]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [vqtbx1, "int8x8_t", "int8x16_t", "uint8x8_t"]
      - [vqtbx1q, "int8x16_t", "int8x16_t", "uint8x16_t"]
    compose:
      - LLVMLink:
          name: "_{type[0]}"
          links:
            - link: "llvm.aarch64.neon.tbx1.{neon_type[1]}"
              arch: aarch64,arm64ec

  - name: "{type[0]}"
    visibility: private
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[2]}",  "c: {neon_type[2]}", "d: {neon_type[3]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [vqtbx2, "int8x8_t", "int8x16_t", "uint8x8_t"]
      - [vqtbx2q, "int8x16_t", "int8x16_t", "uint8x16_t"]
    compose:
      - LLVMLink:
          name: "_{type[0]}"
          links:
            - link: "llvm.aarch64.neon.tbx2.{neon_type[1]}"
              arch: aarch64,arm64ec

  - name: "{type[0]}"
    visibility: private
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[2]}",  "c: {neon_type[2]}", "d: {neon_type[2]}", "e: {neon_type[3]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [vqtbx3, "int8x8_t", "int8x16_t", "uint8x8_t"]
      - [vqtbx3q, "int8x16_t", "int8x16_t", "uint8x16_t"]
    compose:
      - LLVMLink:
          name: "_{type[0]}"
          links:
            - link: "llvm.aarch64.neon.tbx3.{neon_type[1]}"
              arch: aarch64,arm64ec

  - name: "{type[0]}"
    visibility: private
    doc: "Extended table look-up"
    arguments: ["a: {neon_type[1]}", "b: {neon_type[2]}", "c: {neon_type[2]}", "d: {neon_type[2]}", "e: {neon_type[2]}", "f: {neon_type[3]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [tbx]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety: safe
    types:
      - [vqtbx4, "int8x8_t", "int8x16_t", "uint8x8_t"]
      - [vqtbx4q, "int8x16_t", "int8x16_t", "uint8x16_t"]
    compose:
      - LLVMLink:
          name: "_{type[0]}"
          links:
            - link: "llvm.aarch64.neon.tbx4.{neon_type[1]}"
              arch: aarch64,arm64ec

  - name: "vld1{neon_type[1].no}"
    doc: "Load multiple single-element structures to one, two, three, or four registers"
    arguments: ["ptr: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [target_feature, ['enable = "{type[2]}"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ldr]]}]]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety:
      unsafe: [neon]
    types:
      - ['*const i8', int8x8_t, "neon"]
      - ['*const i8', int8x16_t, "neon"]
      - ['*const i16', int16x4_t, "neon"]
      - ['*const i16', int16x8_t, "neon"]
      - ['*const i32', int32x2_t, "neon"]
      - ['*const i32', int32x4_t, "neon"]
      - ['*const i64', int64x1_t, "neon"]
      - ['*const i64', int64x2_t, "neon"]
      - ['*const u8', uint8x8_t, "neon"]
      - ['*const u8', uint8x16_t, "neon"]
      - ['*const u16', uint16x4_t, "neon"]
      - ['*const u16', uint16x8_t, "neon"]
      - ['*const u32', uint32x2_t, "neon"]
      - ['*const u32', uint32x4_t, "neon"]
      - ['*const u64', uint64x1_t, "neon"]
      - ['*const u64', uint64x2_t, "neon"]
      - ['*const p8', poly8x8_t, "neon"]
      - ['*const p8', poly8x16_t, "neon"]
      - ['*const p16', poly16x4_t, "neon"]
      - ['*const p16', poly16x8_t, "neon"]
      - ['*const p64', poly64x1_t, "neon,aes"]
      - ['*const p64', poly64x2_t, "neon,aes"]
      - ['*const f32', float32x2_t, "neon"]
      - ['*const f32', float32x4_t, "neon"]
      - ['*const f64', float64x1_t, "neon"]
      - ['*const f64', float64x2_t, "neon"]
    compose:
      - FnCall:
          - 'crate::ptr::read_unaligned'
          - - MethodCall:
                - ptr
                - cast
                - []

  - name: "vld1{neon_type[1].no}"
    doc: "Load multiple single-element structures to one, two, three, or four registers"
    arguments: ["ptr: {type[0]}"]
    return_type: "{neon_type[1]}"
    attr:
      - FnCall: [target_feature, ['enable = "{type[2]}"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [ldr]]}]]
      - *neon-unstable-f16
    safety:
      unsafe: [neon]
    types:
      - ['*const f16', float16x4_t, "neon,fp16"]
      - ['*const f16', float16x8_t, "neon,fp16"]
    compose:
      - FnCall:
          - 'crate::ptr::read_unaligned'
          - - MethodCall:
                - ptr
                - cast
                - []

  - name: "vst1{neon_type[1].no}"
    doc: "Store multiple single-element structures from one, two, three, or four registers."
    arguments: ["ptr: {type[0]}", "a: {neon_type[1]}"]
    attr:
      - FnCall: [target_feature, ['enable = "{type[2]}"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [str]]}]]
      - FnCall: [allow, ['clippy::cast_ptr_alignment']]
      - FnCall: [stable, ['feature = "neon_intrinsics"', 'since = "1.59.0"']]
    safety:
      unsafe: [neon]
    types:
      - ['*mut i8', int8x8_t, "neon"]
      - ['*mut i8', int8x16_t, "neon"]
      - ['*mut i16', int16x4_t, "neon"]
      - ['*mut i16', int16x8_t, "neon"]
      - ['*mut i32', int32x2_t, "neon"]
      - ['*mut i32', int32x4_t, "neon"]
      - ['*mut i64', int64x1_t, "neon"]
      - ['*mut i64', int64x2_t, "neon"]
      - ['*mut u8', uint8x8_t, "neon"]
      - ['*mut u8', uint8x16_t, "neon"]
      - ['*mut u16', uint16x4_t, "neon"]
      - ['*mut u16', uint16x8_t, "neon"]
      - ['*mut u32', uint32x2_t, "neon"]
      - ['*mut u32', uint32x4_t, "neon"]
      - ['*mut u64', uint64x1_t, "neon"]
      - ['*mut u64', uint64x2_t, "neon"]
      - ['*mut p8', poly8x8_t, "neon"]
      - ['*mut p8', poly8x16_t, "neon"]
      - ['*mut p16', poly16x4_t, "neon"]
      - ['*mut p16', poly16x8_t, "neon"]
      - ['*mut p64', poly64x1_t, "neon,aes"]
      - ['*mut p64', poly64x2_t, "neon,aes"]
      - ['*mut f32', float32x2_t, "neon"]
      - ['*mut f32', float32x4_t, "neon"]
      - ['*mut f64', float64x1_t, "neon"]
      - ['*mut f64', float64x2_t, "neon"]
    compose:
      - FnCall:
          - 'crate::ptr::write_unaligned'
          - - MethodCall:
                - ptr
                - cast
                - []
            - a

  - name: "vst1{neon_type[1].no}"
    doc: "Store multiple single-element structures from one, two, three, or four registers."
    arguments: ["ptr: {type[0]}", "a: {neon_type[1]}"]
    attr:
      - FnCall: [target_feature, ['enable = "{type[2]}"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [str]]}]]
      - FnCall: [allow, ['clippy::cast_ptr_alignment']]
      - *neon-unstable-f16
    safety:
      unsafe: [neon]
    types:
      - ['*mut f16', float16x4_t, "neon,fp16"]
      - ['*mut f16', float16x8_t, "neon,fp16"]
    compose:
      - FnCall:
          - 'crate::ptr::write_unaligned'
          - - MethodCall:
                - ptr
                - cast
                - []
            - a

  - name: "__crc32d"
    doc: "CRC32 single round checksum for quad words (64 bits)."
    arguments: ["crc: {type[0]}", "data: {type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "crc"']]
      - *target-not-arm
      - FnCall: [cfg_attr, [test, { FnCall: [assert_instr, ["crc32x"]] }]]
      - *aarch64-crc-stable
    safety: safe
    types:
      - [u32, u64]
    compose:
      - LLVMLink:
          name: "crc32x"
          arguments:
            - "crc: u32"
            - "data: u64"
          links:
            - link: "llvm.aarch64.crc32x"
              arch: aarch64,arm64ec

  - name: "__crc32cd"
    doc: "CRC32-C single round checksum for quad words (64 bits)."
    arguments: ["crc: {type[0]}", "data: {type[1]}"]
    return_type: "{type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "crc"']]
      - *target-not-arm
      - FnCall: [cfg_attr, [test, { FnCall: [assert_instr, ["crc32cx"]] }]]
      - *aarch64-crc-stable
    safety: safe
    types:
      - [u32, u64]
    compose:
      - LLVMLink:
          name: "crc32cx"
          arguments:
            - "crc: u32"
            - "data: u64"
          links:
            - link: "llvm.aarch64.crc32cx"
              arch: aarch64,arm64ec

  - name: "{type[0]}"
    doc: "Absolute Value (wrapping)."
    arguments: ["a: {type[1]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: [abs]
    safety: safe
    types:
      - ['vabsd_s64', i64, i64]
      - ['vabs_s64', int64x1_t, v1i64]
      - ['vabsq_s64', int64x2_t, v2i64]
    compose:
      - LLVMLink:
          name: "{type[0]}"
          links:
            - link: "llvm.aarch64.neon.abs.{type[2]}"
              arch: aarch64,arm64ec

  - name: "vuqadd{neon_type[0].no}"
    doc: "Signed saturating Accumulate of Unsigned value."
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
    assert_instr: [suqadd]
    safety: safe
    types:
      - [int8x8_t, uint8x8_t]
      - [int8x16_t, uint8x16_t]
      - [int16x4_t, uint16x4_t]
      - [int16x8_t, uint16x8_t]
      - [int32x2_t, uint32x2_t]
      - [int32x4_t, uint32x4_t]
      - [int64x1_t, uint64x1_t]
      - [int64x2_t, uint64x2_t]
    compose:
      - LLVMLink:
          name: "vuqadd{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.suqadd.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vsqadd{neon_type[0].no}"
    doc: "Unsigned saturating Accumulate of Signed value."
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
    assert_instr: [usqadd]
    safety: safe
    types:
      - [uint8x8_t, int8x8_t]
      - [uint8x16_t, int8x16_t]
      - [uint16x4_t, int16x4_t]
      - [uint16x8_t, int16x8_t]
      - [uint32x2_t, int32x2_t]
      - [uint32x4_t, int32x4_t]
      - [uint64x1_t, int64x1_t]
      - [uint64x2_t, int64x2_t]
    compose:
      - LLVMLink:
          name: "vsqadd{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.usqadd.{neon_type[1]}"
              arch: aarch64,arm64ec

  - name: "vpadd{neon_type.no}"
    doc: "Add Pairwise"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-stable
    assert_instr: [addp]
    safety: safe
    types:
      - int8x16_t
      - int16x8_t
      - int32x4_t
      - int64x2_t
    compose:
      - LLVMLink:
          name: "vpadd{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.addp.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vpadd{neon_type[0].no}"
    doc: "Add Pairwise"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-stable
    assert_instr: [addp]
    safety: safe
    types:
      - [uint8x16_t, int8x16_t]
      - [uint16x8_t, int16x8_t]
      - [uint32x4_t, int32x4_t]
      - [uint64x2_t, int64x2_t]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - 'vpadd{neon_type[1].no}'
                - - FnCall: [transmute, [a]]
                  - FnCall: [transmute, [b]]

  - name: "vpaddd_s64"
    doc: "Add pairwise"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: [addp]
    safety: safe
    types:
      - [int64x2_t, i64]
    compose:
      - FnCall:
          - transmute
          - - FnCall:
                - "vaddvq_u64"
                - - FnCall: [transmute, [a]]

  - name: "vpaddd_u64"
    doc: "Add pairwise"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: [addp]
    safety: safe
    types:
      - [uint64x2_t, u64]
    compose:
      - FnCall: [vaddvq_u64, [a]]

  - name: "vaddv{neon_type[0].no}"
    doc: "Add across vector"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: [addv]
    safety: safe
    types:
      - [int8x8_t, i8, i32]
      - [int16x4_t, i16, i32]
      - [int8x16_t, i8, i32]
      - [int16x8_t, i16, i32]
      - [int32x4_t, i32, i32]
    compose:
      - LLVMLink:
          name: "vaddv{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.saddv.{type[2]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vaddv{neon_type[0].no}"
    doc: "Add across vector"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: [addp]
    safety: safe
    types:
      - [int32x2_t, i32] 
    compose:
      - LLVMLink:
          name: "vaddv{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.saddv.i32.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vaddv{neon_type[0].no}"
    doc: "Add across vector"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: [addp]
    safety: safe
    types:
      - [int64x2_t, i64]
    compose:
      - LLVMLink:
          name: "vaddv{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.saddv.i64.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vaddv{neon_type[0].no}"
    doc: "Add across vector"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: [addv]
    safety: safe
    types:
      - [uint8x8_t,  u8, i32]
      - [uint16x4_t, u16, i32]
      - [uint8x16_t, u8, i32]
      - [uint16x8_t, u16, i32]
      - [uint32x4_t, u32, i32]
    compose:
      - LLVMLink:
          name: "vaddv{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.uaddv.{type[2]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vaddv{neon_type[0].no}"
    doc: "Add across vector"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: [addp]
    safety: safe
    types:
      - [uint32x2_t, u32, i32] 
    compose:
      - LLVMLink:
          name: "vaddv{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.uaddv.{type[2]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vaddv{neon_type[0].no}"
    doc: "Add across vector"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: [addp]
    safety: safe
    types:
      - [uint64x2_t, u64, i64]
    compose:
      - LLVMLink:
          name: "vaddv{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.uaddv.{type[2]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vaddlv{neon_type[0].no}"
    doc: "Signed Add Long across Vector"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: [saddlv]
    safety: safe
    types:
      - [int8x8_t, i16]
      - [int8x16_t, i16]
    compose:
      - LLVMLink:
          name: "vaddlv{neon_type[0].no}"
          return_type: "i32"
          links:
            - link: "llvm.aarch64.neon.saddlv.i32.{neon_type[0]}"
              arch: aarch64,arm64ec
      - Identifier: ["unsafe {{ _vaddlv{neon_type[0].no}(a) as i16 }}", Symbol]

  - name: "vaddlv{neon_type[0].no}"
    doc: "Unsigned Add Long across Vector"
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: [uaddlv]
    safety: safe
    types:
      - [uint8x8_t, u16]
      - [uint8x16_t, u16]
    compose:
      - LLVMLink:
          name: "vaddlv{neon_type[0].no}"
          return_type: "i32"
          links:
            - link: "llvm.aarch64.neon.uaddlv.i32.{neon_type[0]}"
              arch: aarch64,arm64ec
      - Identifier: ["unsafe {{ _vaddlv{neon_type[0].no}(a) as u16 }}", Symbol]

  - name: "vmaxv{neon_type[0].no}"
    doc: "Horizontal vector max."
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: ['{type[2]}']
    safety: safe
    types:
      - [int8x8_t, i8, 'smaxv']
      - [int16x4_t, i16, 'smaxv']
      - [int32x2_t, i32, 'smaxp'] 
      - [int8x16_t, i8, 'smaxv']
      - [int16x8_t, i16, 'smaxv']
      - [int32x4_t, i32, 'smaxv']
    compose:
      - LLVMLink:
          name: "vmaxv{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.smaxv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vmaxv{neon_type[0].no}"
    doc: "Horizontal vector max."
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: ['{type[2]}']
    safety: safe
    types:
      - [uint8x8_t, u8, 'umaxv']
      - [uint16x4_t, u16, 'umaxv']
      - [uint32x2_t, u32, 'umaxp'] 
      - [uint8x16_t, u8, 'umaxv']
      - [uint16x8_t, u16, 'umaxv']
      - [uint32x4_t, u32, 'umaxv']
    compose:
      - LLVMLink:
          name: "vmaxv{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.umaxv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vmaxv{neon_type[0].no}"
    doc: "Horizontal vector max."
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: ['{type[2]}']
    safety: safe
    types:
      - [float32x2_t, f32, 'fmaxp']
      - [float32x4_t, f32, 'fmaxv']
      - [float64x2_t, f64, 'fmaxp'] 
    compose:
      - LLVMLink:
          name: "vmaxv{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.fmaxv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vminv{neon_type[0].no}"
    doc: "Horizontal vector min."
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: ['{type[2]}']
    safety: safe
    types:
      - [int8x8_t, i8, 'sminv']
      - [int16x4_t, i16, 'sminv']
      - [int32x2_t, i32, 'sminp'] 
      - [int8x16_t, i8, 'sminv']
      - [int16x8_t, i16, 'sminv']
      - [int32x4_t, i32, 'sminv']
    compose:
      - LLVMLink:
          name: "vminv{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.sminv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vminv{neon_type[0].no}"
    doc: "Horizontal vector min."
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: ['{type[2]}']
    safety: safe
    types:
      - [uint8x8_t, u8, 'uminv']
      - [uint16x4_t, u16, 'uminv']
      - [uint32x2_t, u32, 'uminp'] 
      - [uint8x16_t, u8, 'uminv']
      - [uint16x8_t, u16, 'uminv']
      - [uint32x4_t, u32, 'uminv']
    compose:
      - LLVMLink:
          name: "vminv{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.uminv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vminv{neon_type[0].no}"
    doc: "Horizontal vector min."
    arguments: ["a: {neon_type[0]}"]
    return_type: "{type[1]}"
    attr:
      - *neon-stable
    assert_instr: ['{type[2]}']
    safety: safe
    types:
      - [float32x2_t, f32, 'fminp']
      - [float32x4_t, f32, 'fminv']
      - [float64x2_t, f64, 'fminp'] 
    compose:
      - LLVMLink:
          name: "vminv{neon_type[0].no}"
          links:
            - link: "llvm.aarch64.neon.fminv.{type[1]}.{neon_type[0]}"
              arch: aarch64,arm64ec

  - name: "vpmin{neon_type.no}"
    doc: "Folding minimum of adjacent pairs"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-stable
    assert_instr: ['sminp']
    safety: safe
    types:
      - int8x16_t
      - int16x8_t
      - int32x4_t
    compose:
      - LLVMLink:
          name: "vpmin{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.sminp.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vpmin{neon_type.no}"
    doc: "Folding minimum of adjacent pairs"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-stable
    assert_instr: ['uminp']
    safety: safe
    types:
      - uint8x16_t
      - uint16x8_t
      - uint32x4_t
    compose:
      - LLVMLink:
          name: "vpmin{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.uminp.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vpmin{neon_type.no}"
    doc: "Folding minimum of adjacent pairs"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-stable
    assert_instr: ['fminp']
    safety: safe
    types:
      - float32x4_t
      - float64x2_t 
    compose:
      - LLVMLink:
          name: "vpmin{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.fminp.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vpmax{neon_type.no}"
    doc: "Folding maximum of adjacent pairs"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-stable
    assert_instr: ['smaxp']
    safety: safe
    types:
      - int8x16_t
      - int16x8_t
      - int32x4_t
    compose:
      - LLVMLink:
          name: "vpmax{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.smaxp.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vpmax{neon_type.no}"
    doc: "Folding maximum of adjacent pairs"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-stable
    assert_instr: ['umaxp']
    safety: safe
    types:
      - uint8x16_t
      - uint16x8_t
      - uint32x4_t
    compose:
      - LLVMLink:
          name: "vpmax{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.umaxp.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vpmax{neon_type.no}"
    doc: "Folding maximum of adjacent pairs"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - *neon-stable
    assert_instr: ['fmaxp']
    safety: safe
    types:
      - float32x4_t
      - float64x2_t 
    compose:
      - LLVMLink:
          name: "vpmax{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.fmaxp.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vsli{neon_type[0].N}"
    doc: "Shift Left and Insert (immediate)"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sli, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int8x8_t,  'static_assert_uimm_bits!', 'N, 3']
      - [int8x16_t, 'static_assert_uimm_bits!', 'N, 3']
      - [int16x4_t, 'static_assert_uimm_bits!', 'N, 4']
      - [int16x8_t, 'static_assert_uimm_bits!', 'N, 4']
      - [int32x2_t, 'static_assert!', 'N >= 0 && N <= 31']
      - [int32x4_t, 'static_assert!', 'N >= 0 && N <= 31']
      - [int64x1_t, 'static_assert!', 'N >= 0 && N <= 63']
      - [int64x2_t, 'static_assert!', 'N >= 0 && N <= 63']
    compose:
      - FnCall: ['{type[1]}', ['{type[2]}']]
      - LLVMLink:
          name: "vsli{neon_type[0].N}"
          arguments:
            - "a: {neon_type[0]}"
            - "b: {neon_type[0]}"
            - "n: i32"
          links:
            - link: "llvm.aarch64.neon.vsli.{neon_type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vsli{neon_type[0].N}", [a, b, N], [], true]

  - name: "vsli{neon_type[0].N}"
    doc: "Shift Left and Insert (immediate)"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "{type[4]}"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sli, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [uint8x8_t,  int8x8_t,  'static_assert_uimm_bits!', 'N, 3', "neon"]
      - [uint8x16_t, int8x16_t, 'static_assert_uimm_bits!', 'N, 3', "neon"]
      - [uint16x4_t, int16x4_t, 'static_assert_uimm_bits!', 'N, 4', "neon"]
      - [uint16x8_t, int16x8_t, 'static_assert_uimm_bits!', 'N, 4', "neon"]
      - [uint32x2_t, int32x2_t, 'static_assert!', 'N >= 0 && N <= 31', "neon"]
      - [uint32x4_t, int32x4_t, 'static_assert!', 'N >= 0 && N <= 31', "neon"]
      - [uint64x1_t, int64x1_t, 'static_assert!', 'N >= 0 && N <= 63', "neon"]
      - [uint64x2_t, int64x2_t, 'static_assert!', 'N >= 0 && N <= 63', "neon"]
      - [poly8x8_t,  int8x8_t,  'static_assert_uimm_bits!', 'N, 3', "neon"]
      - [poly8x16_t, int8x16_t, 'static_assert_uimm_bits!', 'N, 3', "neon"]
      - [poly16x4_t, int16x4_t, 'static_assert_uimm_bits!', 'N, 4', "neon"]
      - [poly16x8_t, int16x8_t, 'static_assert_uimm_bits!', 'N, 4', "neon"]
      - [poly64x1_t, int64x1_t, 'static_assert!', 'N >= 0 && N <= 63', "neon,aes"]
      - [poly64x2_t, int64x2_t, 'static_assert!', 'N >= 0 && N <= 63', "neon,aes"]
    compose:
      - FnCall: ['{type[2]}', ['{type[3]}']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vsli{neon_type[1].N}::<N>'
                - - FnCall:
                      - transmute
                      - - a
                  - FnCall:
                      - transmute
                      - - b

  - name: "vsri{neon_type[0].N}"
    doc: "Shift Right and Insert (immediate)"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sri, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [int8x8_t,  'N >= 1 && N <= 8']
      - [int8x16_t, 'N >= 1 && N <= 8']
      - [int16x4_t, 'N >= 1 && N <= 16']
      - [int16x8_t, 'N >= 1 && N <= 16']
      - [int32x2_t, 'N >= 1 && N <= 32']
      - [int32x4_t, 'N >= 1 && N <= 32']
      - [int64x1_t, 'N >= 1 && N <= 64']
      - [int64x2_t, 'N >= 1 && N <= 64']
    compose:
      - FnCall: ['static_assert!', ['{type[1]}']]
      - LLVMLink:
          name: "vsri{neon_type[0].N}"
          arguments:
            - "a: {neon_type[0]}"
            - "b: {neon_type[0]}"
            - "n: i32"
          links:
            - link: "llvm.aarch64.neon.vsri.{neon_type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ["_vsri{neon_type[0].N}", [a, b, N], [], true]

  - name: "vsri{neon_type[0].N}"
    doc: "Shift Right and Insert (immediate)"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[0]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "{type[3]}"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [sri, 'N = 1']]}]]
      - FnCall: [rustc_legacy_const_generics, ['2']]
      - *neon-stable
    static_defs: ['const N: i32']
    safety: safe
    types:
      - [uint8x8_t,  int8x8_t,  'N >= 1 && N <= 8', "neon"]
      - [uint8x16_t, int8x16_t, 'N >= 1 && N <= 8', "neon"]
      - [uint16x4_t, int16x4_t, 'N >= 1 && N <= 16', "neon"]
      - [uint16x8_t, int16x8_t, 'N >= 1 && N <= 16', "neon"]
      - [uint32x2_t, int32x2_t, 'N >= 1 && N <= 32', "neon"]
      - [uint32x4_t, int32x4_t, 'N >= 1 && N <= 32', "neon"]
      - [uint64x1_t, int64x1_t, 'N >= 1 && N <= 64', "neon"]
      - [uint64x2_t, int64x2_t, 'N >= 1 && N <= 64', "neon"]
      - [poly8x8_t,  int8x8_t,  'N >= 1 && N <= 8', "neon"]
      - [poly8x16_t, int8x16_t, 'N >= 1 && N <= 8', "neon"]
      - [poly16x4_t, int16x4_t, 'N >= 1 && N <= 16', "neon"]
      - [poly16x8_t, int16x8_t, 'N >= 1 && N <= 16', "neon"]
      - [poly64x1_t, int64x1_t, 'N >= 1 && N <= 64', "neon,aes"]
      - [poly64x2_t, int64x2_t, 'N >= 1 && N <= 64', "neon,aes"]
    compose:
      - FnCall: ['static_assert!', ['{type[2]}']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vsri{neon_type[1].N}::<N>'
                - - FnCall:
                      - transmute
                      - - a
                  - FnCall:
                      - transmute
                      - - b

  - name: "vfmlal{type[2]}{neon_type[1]}"
    doc: "Floating-point fused Multiply-Add Long to accumulator (vector)."
    arguments: ["r: {neon_type[0]}", "a: {neon_type[1]}",  "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-fp16
      - *enable-fhm
      - *neon-unstable-f16
    assert_instr: [fmlal2]
    safety: safe
    types:
      - [float32x2_t, float16x4_t, '_high_']
      - [float32x4_t, float16x8_t, 'q_high_']
    compose:
      - LLVMLink:
          name: "vfmlal{type[2]}.{neon_type[0]}.{neon_type[1]}"
          links:
            - link: "llvm.aarch64.neon.fmlal2.{neon_type[0]}.{neon_type[1]}"
              arch: aarch64,arm64ec


  - name: "vfmlal{type[3]}{neon_type[1]}"
    doc: "Floating-point fused Multiply-Add Long to accumulator (by element)."
    arguments: ["r: {neon_type[0]}", "a: {neon_type[1]}",  "b: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmlal2, 'LANE = 0']]}]]
      - *neon-fp16
      - *enable-fhm
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-unstable-f16
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float32x2_t, float16x4_t, float16x4_t, '_lane_high_', '_high_', '2']
      - [float32x2_t, float16x4_t, float16x8_t, '_laneq_high_', '_high_', '3']
      - [float32x4_t, float16x8_t, float16x4_t, 'q_lane_high_', 'q_high_', '2']
      - [float32x4_t, float16x8_t, float16x8_t, 'q_laneq_high_', 'q_high_', '3']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[5]}"]]
      - FnCall:
          - "vfmlal{type[4]}{neon_type[1]}"
          - - r
            - a
            - FnCall: ["vdup{neon_type[1].N}", [{FnCall: [simd_extract!, [b, 'LANE as u32']]}]]


  - name: "vfmlal{type[2]}{neon_type[1]}"
    doc: "Floating-point fused Multiply-Add Long to accumulator (vector)."
    arguments: ["r: {neon_type[0]}", "a: {neon_type[1]}",  "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-fp16
      - *enable-fhm
      - *neon-unstable-f16
    assert_instr: [fmlal]
    safety: safe
    types:
      - [float32x2_t, float16x4_t, '_low_']
      - [float32x4_t, float16x8_t, 'q_low_']
    compose:
      - LLVMLink:
          name: "vfmlal{type[2]}.{neon_type[0]}.{neon_type[1]}"
          links:
            - link: "llvm.aarch64.neon.fmlal.{neon_type[0]}.{neon_type[1]}"
              arch: aarch64,arm64ec


  - name: "vfmlal{type[3]}{neon_type[1]}"
    doc: "Floating-point fused Multiply-Add Long to accumulator (by element)."
    arguments: ["r: {neon_type[0]}", "a: {neon_type[1]}",  "b: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmlal, 'LANE = 0']]}]]
      - *neon-fp16
      - *enable-fhm
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-unstable-f16
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float32x2_t, float16x4_t, float16x4_t, '_lane_low_', '_low_', '2']
      - [float32x2_t, float16x4_t, float16x8_t, '_laneq_low_', '_low_', '3']
      - [float32x4_t, float16x8_t, float16x4_t, 'q_lane_low_', 'q_low_', '2']
      - [float32x4_t, float16x8_t, float16x8_t, 'q_laneq_low_', 'q_low_', '3']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[5]}"]]
      - FnCall:
          - "vfmlal{type[4]}{neon_type[1]}"
          - - r
            - a
            - FnCall: ["vdup{neon_type[1].N}", [{FnCall: [simd_extract!, [b, 'LANE as u32']]}]]


  - name: "vfmlsl{type[2]}{neon_type[1]}"
    doc: "Floating-point fused Multiply-Subtract Long from accumulator (vector)."
    arguments: ["r: {neon_type[0]}", "a: {neon_type[1]}",  "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-fp16
      - *enable-fhm
      - *neon-unstable-f16
    assert_instr: [fmlsl2]
    safety: safe
    types:
      - [float32x2_t, float16x4_t, '_high_']
      - [float32x4_t, float16x8_t, 'q_high_']
    compose:
      - LLVMLink:
          name: "vfmlsl{type[2]}.{neon_type[0]}.{neon_type[1]}"
          links:
            - link: "llvm.aarch64.neon.fmlsl2.{neon_type[0]}.{neon_type[1]}"
              arch: aarch64,arm64ec

  - name: "vfmlsl{type[3]}{neon_type[1]}"
    doc: "Floating-point fused Multiply-Subtract Long from accumulator (by element)."
    arguments: ["r: {neon_type[0]}", "a: {neon_type[1]}",  "b: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmlsl2, 'LANE = 0']]}]]
      - *neon-fp16
      - *enable-fhm
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-unstable-f16
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float32x2_t, float16x4_t, float16x4_t, '_lane_high_', '_high_', '2']
      - [float32x2_t, float16x4_t, float16x8_t, '_laneq_high_', '_high_', '3']
      - [float32x4_t, float16x8_t, float16x4_t, 'q_lane_high_', 'q_high_', '2']
      - [float32x4_t, float16x8_t, float16x8_t, 'q_laneq_high_', 'q_high_', '3']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[5]}"]]
      - FnCall:
          - "vfmlsl{type[4]}{neon_type[1]}"
          - - r
            - a
            - FnCall: ["vdup{neon_type[1].N}", [{FnCall: [simd_extract!, [b, 'LANE as u32']]}]]


  - name: "vfmlsl{type[2]}{neon_type[1]}"
    doc: "Floating-point fused Multiply-Subtract Long from accumulator (vector)."
    arguments: ["r: {neon_type[0]}", "a: {neon_type[1]}",  "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - *neon-fp16
      - *enable-fhm
      - *neon-unstable-f16
    assert_instr: [fmlsl]
    safety: safe
    types:
      - [float32x2_t, float16x4_t, '_low_']
      - [float32x4_t, float16x8_t, 'q_low_']
    compose:
      - LLVMLink:
          name: "vfmlsl{type[2]}.{neon_type[0]}.{neon_type[1]}"
          links:
            - link: "llvm.aarch64.neon.fmlsl.{neon_type[0]}.{neon_type[1]}"
              arch: aarch64,arm64ec

  - name: "vfmlsl{type[3]}{neon_type[1]}"
    doc: "Floating-point fused Multiply-Subtract Long from accumulator (by element)."
    arguments: ["r: {neon_type[0]}", "a: {neon_type[1]}",  "b: {neon_type[2]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [fmlsl, 'LANE = 0']]}]]
      - *neon-fp16
      - *enable-fhm
      - FnCall: [rustc_legacy_const_generics, ['3']]
      - *neon-unstable-f16
    static_defs: ['const LANE: i32']
    safety: safe
    types:
      - [float32x2_t, float16x4_t, float16x4_t, '_lane_low_', '_low_', '2']
      - [float32x2_t, float16x4_t, float16x8_t, '_laneq_low_', '_low_', '3']
      - [float32x4_t, float16x8_t, float16x4_t, 'q_lane_low_', 'q_low_', '2']
      - [float32x4_t, float16x8_t, float16x8_t, 'q_laneq_low_', 'q_low_', '3']
    compose:
      - FnCall: [static_assert_uimm_bits!, [LANE, "{type[5]}"]]
      - FnCall:
          - "vfmlsl{type[4]}{neon_type[1]}"
          - - r
            - a
            - FnCall: ["vdup{neon_type[1].N}", [{FnCall: [simd_extract!, [b, 'LANE as u32']]}]]

  - name: "vamax{neon_type.no}"
    doc: "Multi-vector floating-point absolute maximum"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,faminmax"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop]]}]]
      - FnCall: [unstable, ['feature = "faminmax"', 'issue = "137933"']]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "_vamax{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.famax.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vamin{neon_type.no}"
    doc: "Multi-vector floating-point absolute minimum"
    arguments: ["a: {neon_type}", "b: {neon_type}"]
    return_type: "{neon_type}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,faminmax"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop]]}]]
      - FnCall: [unstable, ['feature = "faminmax"', 'issue = "137933"']]
    safety: safe
    types:
      - float32x2_t
      - float32x4_t
      - float64x2_t
    compose:
      - LLVMLink:
          name: "_vamin{neon_type.no}"
          links:
            - link: "llvm.aarch64.neon.famin.{neon_type}"
              arch: aarch64,arm64ec

  - name: "vluti2{neon_type[0].lane_nox}"
    doc: "Lookup table read with 2-bit indices"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [target_feature, ['enable = {type[4]}']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 1']]}]]
      - *neon-unstable-feat-lut
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [int8x8_t,   uint8x8_t, int8x16_t, 'LANE >= 0 && LANE <= 1', '"neon,lut"']
      - [int8x16_t,  uint8x8_t, int8x16_t, 'LANE >= 0 && LANE <= 1', '"neon,lut"']
      - [int16x4_t,  uint8x8_t, int16x8_t, 'LANE >= 0 && LANE <= 3', '"neon,lut"']
      - [int16x8_t,  uint8x8_t, int16x8_t, 'LANE >= 0 && LANE <= 3', '"neon,lut"']
    compose:
      - FnCall: ['static_assert!', ['{type[3]}']]
      - LLVMLink:
          name: "vluti2{neon_type[0].lane_nox}"
          arguments:
            - 'a: {neon_type[0]}'
            - 'b: {neon_type[1]}'
            - 'n: i32'
          links:
            - link: "llvm.aarch64.neon.vluti2.lane.{neon_type[2]}.{neon_type[0]}"
              arch: aarch64,arm64ec
      - FnCall: ['_vluti2{neon_type[0].lane_nox}', [a, b, LANE]]

  - name: "vluti2{neon_type[0].lane_nox}"
    doc: "Lookup table read with 2-bit indices"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,lut"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 1']]}]]
      - *neon-unstable-feat-lut
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [uint8x8_t,  uint8x8_t, uint8x16_t, 'LANE >= 0 && LANE <= 1', 'int8x8_t']
      - [uint8x16_t, uint8x8_t, uint8x16_t, 'LANE >= 0 && LANE <= 1', 'int8x16_t']
      - [poly8x8_t,  uint8x8_t, poly8x16_t, 'LANE >= 0 && LANE <= 1', 'int8x8_t']
      - [poly8x16_t, uint8x8_t, poly8x16_t, 'LANE >= 0 && LANE <= 1', 'int8x16_t']
      - [uint16x4_t, uint8x8_t, uint16x8_t, 'LANE >= 0 && LANE <= 3', 'int16x4_t']
      - [uint16x8_t, uint8x8_t, uint16x8_t, 'LANE >= 0 && LANE <= 3', 'int16x8_t']
      - [poly16x4_t, uint8x8_t, poly16x8_t, 'LANE >= 0 && LANE <= 3', 'int16x4_t']
      - [poly16x8_t, uint8x8_t, poly16x8_t, 'LANE >= 0 && LANE <= 3', 'int16x8_t']
    compose:
      - FnCall: ['static_assert!', ['{type[3]}']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vluti2{neon_type[4].lane_nox}::<LANE>'
                - - FnCall: [transmute, [a]]
                  - b

  - name: "vluti4{neon_type[0].lane_nox}"
    doc: "Lookup table read with 4-bit indices"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = {type[3]}']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 0']]}]]
      - *neon-unstable-feat-lut
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [int8x16_t,  uint8x8_t, 'LANE == 0', '"neon,lut"']
    compose:
      - FnCall: ['static_assert!', ['{type[2]}']]
      - LLVMLink:
          name: "vluti4{neon_type[0].lane_nox}"
          arguments:
            - 'a: {neon_type[0]}'
            - 'b: {neon_type[1]}'
            - 'n: i32'
          links:
            - link: "llvm.aarch64.neon.vluti4q.lane.{neon_type[1]}"
              arch: aarch64,arm64ec
      - FnCall: ['_vluti4{neon_type[0].lane_nox}', [a, b, LANE]]

  - name: "vluti4{neon_type[0].lane_nox}"
    doc: "Lookup table read with 4-bit indices"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,lut"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 0']]}]]
      - *neon-unstable-feat-lut
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [uint8x16_t, uint8x8_t, 'LANE == 0', int8x16_t]
      - [poly8x16_t, uint8x8_t, 'LANE == 0', int8x16_t]
    compose:
      - FnCall: ['static_assert!', ['{type[2]}']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vluti4{neon_type[3].lane_nox}::<LANE>'
                - - FnCall: [transmute, [a]]
                  - b

  - name: "vluti4{neon_type[0].laneq_nox}"
    doc: "Lookup table read with 4-bit indices"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,lut"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 0']]}]]
      - *neon-unstable-feat-lut
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [int8x16_t,  uint8x16_t, 'LANE >= 0 && LANE <= 1']
    compose:
      - FnCall: ['static_assert!', ['{type[2]}']]
      - LLVMLink:
          name: "vluti4{neon_type[0].laneq_nox}"
          arguments:
            - 'a: {neon_type[0]}'
            - 'b: {neon_type[1]}'
            - 'n: i32'
          links:
            - link: "llvm.aarch64.neon.vluti4q.laneq.{neon_type[1]}"
              arch: aarch64,arm64ec
      - FnCall: ['_vluti4{neon_type[0].laneq_nox}', [a, b, LANE]]

  - name: "vluti4{neon_type[0].laneq_nox}"
    doc: "Lookup table read with 4-bit indices"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[0]}"
    attr:
      - FnCall: [target_feature, ['enable = "neon,lut"']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 0']]}]]
      - *neon-unstable-feat-lut
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [uint8x16_t, uint8x16_t, 'LANE >= 0 && LANE <= 1', int8x16_t]
      - [poly8x16_t, uint8x16_t, 'LANE >= 0 && LANE <= 1', int8x16_t]
    compose:
      - FnCall: ['static_assert!', ['{type[2]}']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vluti4{neon_type[3].laneq_nox}::<LANE>'
                - - FnCall: [transmute, [a]]
                  - b

  - name: "vluti4q_lane_{neon_type[0]}_x2"
    doc: "Lookup table read with 4-bit indices"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [target_feature, ['enable = {type[4]}']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 0']]}]]
      - *neon-unstable-feat-lut
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [int16x8x2_t, uint8x8_t, int16x8_t, 'LANE >= 0 && LANE <= 1', '"neon,lut"']
    compose:
      - FnCall: ['static_assert!', ['{type[3]}']]
      - LLVMLink:
          name: "vluti4q_lane_{neon_type[0]}_x2"
          arguments:
            - 'a: {neon_type[2]}'
            - 'a: {neon_type[2]}'
            - 'b: {neon_type[1]}'
            - 'n: i32'
          links:
            - link: "llvm.aarch64.neon.vluti4q.lane.x2.{neon_type[2]}"
              arch: aarch64,arm64ec
      - FnCall: ['_vluti4q_lane_{neon_type[0]}_x2', ['a.0', 'a.1', b, LANE]]

  - name: "vluti4q_lane_{neon_type[0]}_x2"
    doc: "Lookup table read with 4-bit indices"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [target_feature, ['enable = {type[4]}']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 0']]}]]
      - *neon-unstable-feat-lut
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [uint16x8x2_t, uint8x8_t, uint16x8_t, 'LANE >= 0 && LANE <= 1', '"neon,lut"', int16x8x2_t]
      - [poly16x8x2_t, uint8x8_t, poly16x8_t, 'LANE >= 0 && LANE <= 1', '"neon,lut"', int16x8x2_t]
      - [float16x8x2_t, uint8x8_t, float16x8_t, 'LANE >= 0 && LANE <= 1', '"neon,lut,fp16"', int16x8x2_t]
    compose:
      - FnCall: ['static_assert!', ['{type[3]}']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vluti4q_lane_{neon_type[5]}_x2::<LANE>'
                - - FnCall: [transmute, [a]]
                  - b

  - name: "vluti4q_laneq_{neon_type[0]}_x2"
    doc: "Lookup table read with 4-bit indices"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [target_feature, ['enable = {type[4]}']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 3']]}]]
      - *neon-unstable-feat-lut
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [int16x8x2_t, uint8x16_t, int16x8_t, 'LANE >= 0 && LANE <= 3', '"neon,lut"']
    compose:
      - FnCall: ['static_assert!', ['{type[3]}']]
      - LLVMLink:
          name: "vluti4{neon_type[0].lane_nox}"
          arguments:
            - 'a: {neon_type[2]}'
            - 'b: {neon_type[2]}'
            - 'c: {neon_type[1]}'
            - 'n: i32'
          links:
            - link: "llvm.aarch64.neon.vluti4q.laneq.x2.{neon_type[2]}"
              arch: aarch64,arm64ec
      - FnCall: ['_vluti4q_laneq_{neon_type[0]}_x2', ['a.0', 'a.1', b, LANE]]

  - name: "vluti4q_laneq_{neon_type[0]}_x2"
    doc: "Lookup table read with 4-bit indices"
    arguments: ["a: {neon_type[0]}", "b: {neon_type[1]}"]
    return_type: "{neon_type[2]}"
    attr:
      - FnCall: [target_feature, ['enable = {type[4]}']]
      - FnCall: [cfg_attr, [test, {FnCall: [assert_instr, [nop, 'LANE = 3']]}]]
      - *neon-unstable-feat-lut
      - FnCall: [rustc_legacy_const_generics, ['2']]
    static_defs: ["const LANE: i32"]
    safety:
      unsafe: [neon]
    types:
      - [uint16x8x2_t,  uint8x16_t, uint16x8_t, 'LANE >= 0 && LANE <= 3', '"neon,lut"', int16x8x2_t]
      - [poly16x8x2_t,  uint8x16_t, poly16x8_t, 'LANE >= 0 && LANE <= 3', '"neon,lut"', int16x8x2_t]
      - [float16x8x2_t, uint8x16_t, float16x8_t, 'LANE >= 0 && LANE <= 3', '"neon,lut,fp16"', int16x8x2_t]
    compose:
      - FnCall: ['static_assert!', ['{type[3]}']]
      - FnCall:
          - transmute
          - - FnCall:
                - 'vluti4q_laneq_{neon_type[5]}_x2::<LANE>'
                - - FnCall: [transmute, [a]]
                  - b
