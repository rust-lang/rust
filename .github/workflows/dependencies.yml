# Automatically run `cargo update` periodically

---
name: Bump dependencies in Cargo.lock
on:
  schedule:
    # Run weekly
    - cron: '0 0 * * Sun'
  workflow_dispatch:
    # Needed so we can run it manually
permissions:
  contents: read
defaults:
  run:
    shell: bash
env:
  # So cargo doesn't complain about unstable features
  RUSTC_BOOTSTRAP: 1

jobs:
  update:
    if: github.repository_owner == 'rust-lang'
    name: update dependencies
    runs-on: ubuntu-latest
    outputs:
      all_lockfiles: ${{ steps.update_script.outputs.all_lockfiles }}
      enqueued_lockfiles: ${{ steps.update_script.outputs.enqueued_lockfiles }}
    steps:
      - name: checkout the source code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: install the bootstrap toolchain
        run: |
          # Extract the stage0 version
          toolchain=$(awk -F= '{a[$1]=$2} END {print(a["compiler_version"] "-" a["compiler_date"])}' src/stage0)
          # Install and set as default
          rustup toolchain install --no-self-update --profile minimal "$toolchain"
          rustup default "$toolchain"

      - name: run update script
        id: update_script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Update all lockfiles
          ./src/ci/scripts/update-all-lockfiles.py run-update

          # Make a list of all lockfiles that we manage, as well as a list of
          # those that already have PRs in the queue. Save this for use in
          # later jobs.
          all_lockfiles="$(./src/ci/scripts/update-all-lockfiles.py list-all)"
          enqueued_lockfiles="$(./src/ci/scripts/update-all-lockfiles.py list-enqueued)"
          echo "all_lockfiles=$all_lockfiles" >> "$GITHUB_OUTPUT"
          echo "enqueued_lockfiles=$enqueued_lockfiles" >> "$GITHUB_OUTPUT"

      - name: upload output file
        uses: actions/upload-artifact@v4
        with:
          name: update-output
          path: update_output.json
          retention-days: 1

  pr:
    name: create or update PR
    needs: [update]
    strategy:
      fail-fast: false
      matrix:
        name: ${{ fromJson(needs.update.outputs.all_lockfiles) }}
    # Don't run the job for a branch if a merge is already in progress.
    if: >
      github.repository_owner == 'rust-lang' && 
      !contains(fromJSON(needs.update.outputs.enqueued_lockfiles), matrix.name)
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: checkout the source code
        uses: actions/checkout@v4

      - name: download output file from update job
        uses: actions/download-artifact@v4
        with:
          name: update-output

      - name: craft PR body and commit message
        run: |
          # Create `commit.txt` and `pr_body.md`
          ./src/ci/scripts/update-all-lockfiles.py prepare-pr-files "${{ matrix.name }}"

          # Set some environment variables from the JSON file
          echo "BRANCH=$(jq -r '.${{ matrix.name }}.branch' update_output.json)" >> "$GITHUB_ENV"
          echo "PR_TITLE=$(jq -r '.${{ matrix.name }}.pr_title' update_output.json)" >> "$GITHUB_ENV"

      - name: commit
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git switch --force-create "$BRANCH"

          # Update and add only the relevant lockfile
          ./src/ci/scripts/update-all-lockfiles.py restore-lockfile "${{ matrix.name }}"
          git add "$(jq -r '.${{ matrix.name }}.lockfile_path' update_output.json)"

          git commit --no-verify --file=commit.txt

      - name: push
        run: git push --no-verify --force --set-upstream origin "$BRANCH"

      - name: edit existing open pull request
        id: edit
        # Don't fail job if we need to open new PR
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Exit with error if PR is closed
          state=$(gh pr view "$BRANCH" --repo "$GITHUB_REPOSITORY" --json state --jq '.state')
          [ "$state" != "OPEN" ] && exit 1

          # Replace the title and body with what we generated
          gh pr edit "$BRANCH" --title "$PR_TITLE" --body-file pr_body.md --repo "$GITHUB_REPOSITORY"

      - name: open new pull request
        # Only run if there wasn't an existing PR
        if: steps.edit.outcome != 'success'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: gh pr create --title "$PR_TITLE" --body-file pr_body.md --repo "$GITHUB_REPOSITORY"
