- // MIR for `outer` before Inline
+ // MIR for `outer` after Inline
  
  fn outer() -> usize {
      let mut _0: usize;
+     scope 1 (inlined inner) {
+         let mut _1: &[bool; 1];
+         let mut _2: bool;
+         let mut _3: bool;
+         scope 2 {
+             debug buffer => _1;
+             scope 3 {
+                 debug index => _0;
+             }
+         }
+     }
  
      bb0: {
-         _0 = inner() -> [return: bb1, unwind continue];
+         StorageLive(_1);
+         StorageLive(_2);
+         _1 = const inner::promoted[0];
+         _0 = index() -> [return: bb2, unwind continue];
      }
  
      bb1: {
+         StorageDead(_2);
+         StorageDead(_1);
          return;
+     }
+ 
+     bb2: {
+         StorageLive(_3);
+         _2 = Lt(copy _0, const 1_usize);
+         assert(move _2, "index out of bounds: the length is {} but the index is {}", const 1_usize, copy _0) -> [success: bb3, unwind continue];
+     }
+ 
+     bb3: {
+         _3 = copy (*_1)[_0];
+         switchInt(move _3) -> [0: bb4, otherwise: bb5];
+     }
+ 
+     bb4: {
+         _0 = const 0_usize;
+         StorageDead(_3);
+         goto -> bb1;
+     }
+ 
+     bb5: {
+         StorageDead(_3);
+         goto -> bb1;
      }
  }
  
