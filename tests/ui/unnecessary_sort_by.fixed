#![allow(clippy::stable_sort_primitive, clippy::useless_vec)]

use std::cell::Ref;

fn unnecessary_sort_by() {
    fn id(x: isize) -> isize {
        x
    }

    let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];
    // Forward examples
    vec.sort();
    //~^ unnecessary_sort_by
    vec.sort_unstable();
    //~^ unnecessary_sort_by
    vec.sort_by_key(|a| (a + 5).abs());
    //~^ unnecessary_sort_by
    vec.sort_unstable_by_key(|a| id(-a));
    //~^ unnecessary_sort_by
    // Reverse examples
    vec.sort_by(|a, b| b.cmp(a)); // not linted to avoid suggesting `Reverse(b)` which would borrow
    vec.sort_by_key(|b| std::cmp::Reverse((b + 5).abs()));
    //~^ unnecessary_sort_by
    vec.sort_unstable_by_key(|b| std::cmp::Reverse(id(-b)));
    //~^ unnecessary_sort_by
    // Negative examples (shouldn't be changed)
    let c = &7;
    vec.sort_by(|a, b| (b - a).cmp(&(a - b)));
    vec.sort_by(|_, b| b.cmp(&5));
    vec.sort_by(|_, b| b.cmp(c));
    vec.sort_unstable_by(|a, _| a.cmp(c));

    // Vectors of references are fine as long as the resulting key does not borrow
    let mut vec: Vec<&&&isize> = vec![&&&3, &&&6, &&&1, &&&2, &&&5];
    vec.sort_by_key(|a| (***a).abs());
    //~^ unnecessary_sort_by
    vec.sort_unstable_by_key(|a| (***a).abs());
    //~^ unnecessary_sort_by
    // `Reverse(b)` would borrow in the following cases, don't lint
    vec.sort_by(|a, b| b.cmp(a));
    vec.sort_unstable_by(|a, b| b.cmp(a));

    // No warning if element does not implement `Ord`
    let mut vec: Vec<Ref<usize>> = Vec::new();
    vec.sort_unstable_by(|a, b| a.cmp(b));
}

// Do not suggest returning a reference to the closure parameter of `Vec::sort_by_key`
mod issue_5754 {
    #[derive(Clone, Copy)]
    struct Test(usize);

    #[derive(PartialOrd, Ord, PartialEq, Eq)]
    struct Wrapper<'a>(&'a usize);

    impl Test {
        fn name(&self) -> &usize {
            &self.0
        }

        fn wrapped(&self) -> Wrapper<'_> {
            Wrapper(&self.0)
        }
    }

    pub fn test() {
        let mut args: Vec<Test> = vec![];

        // Forward
        args.sort_by(|a, b| a.name().cmp(b.name()));
        args.sort_by(|a, b| a.wrapped().cmp(&b.wrapped()));
        args.sort_unstable_by(|a, b| a.name().cmp(b.name()));
        args.sort_unstable_by(|a, b| a.wrapped().cmp(&b.wrapped()));
        // Reverse
        args.sort_by(|a, b| b.name().cmp(a.name()));
        args.sort_by(|a, b| b.wrapped().cmp(&a.wrapped()));
        args.sort_unstable_by(|a, b| b.name().cmp(a.name()));
        args.sort_unstable_by(|a, b| b.wrapped().cmp(&a.wrapped()));
    }
}

// The closure parameter is not dereferenced anymore, so non-Copy types can be linted
mod issue_6001 {
    struct Test(String);

    impl Test {
        // Return an owned type so that we don't hit the fix for 5754
        fn name(&self) -> String {
            self.0.clone()
        }
    }

    pub fn test() {
        let mut args: Vec<Test> = vec![];

        // Forward
        args.sort_by_key(|a| a.name());
        //~^ unnecessary_sort_by
        args.sort_unstable_by_key(|a| a.name());
        //~^ unnecessary_sort_by
        // Reverse
        args.sort_by_key(|b| std::cmp::Reverse(b.name()));
        //~^ unnecessary_sort_by
        args.sort_unstable_by_key(|b| std::cmp::Reverse(b.name()));
        //~^ unnecessary_sort_by
    }
}

fn main() {
    unnecessary_sort_by();
    issue_5754::test();
    issue_6001::test();
}

fn issue16405() {
    let mut v: Vec<(i32, &str)> = vec![(1, "foo"), (2, "bar")];

    v.sort_by_key(|a| a.0);
    //~^ unnecessary_sort_by

    struct Item {
        key: i32,
        value: String,
    }

    let mut items = vec![
        Item {
            key: 2,
            value: "b".to_string(),
        },
        Item {
            key: 1,
            value: "a".to_string(),
        },
    ];
    items.sort_by_key(|item1| item1.key);
    //~^ unnecessary_sort_by

    items.sort_by(|item1, item2| item1.value.cmp(&item2.value));

    items.sort_by_key(|item1| item1.value.clone());
    //~^ unnecessary_sort_by
}

fn issue16348() {
    let mut v: Vec<(i32, &str)> = vec![(1, "foo"), (2, "bar")];
    v.sort_by_key(|(_, s1)| *s1);
    //~^ unnecessary_sort_by

    struct Foo {
        bar: i32,
    }
    let mut v: Vec<Foo> = vec![Foo { bar: 1 }, Foo { bar: 2 }];
    v.sort_by_key(|Foo { bar: b1 }| *b1);
    //~^ unnecessary_sort_by

    struct Baz(i32);
    let mut v: Vec<Baz> = vec![Baz(1), Baz(2)];
    v.sort_by_key(|Baz(b1)| *b1);
    //~^ unnecessary_sort_by

    v.sort_by_key(|&Baz(b1)| b1);
    //~^ unnecessary_sort_by

    let mut v: Vec<&i32> = vec![&1, &2];
    v.sort_by_key(|&&b1| b1);
    //~^ unnecessary_sort_by

    let mut v: Vec<[i32; 2]> = vec![[1, 2], [3, 4]];
    v.sort_by_key(|[a1, b1]| *a1);
    //~^ unnecessary_sort_by

    v.sort_by_key(|[a1, b1]| a1 - b1);
    //~^ unnecessary_sort_by
}
