error[E0382]: use of moved value: `offset`
  --> $DIR/derive-clone-implicit-bound.rs:26:26
   |
LL |     fn update_value<T, F>(&self, offset: TypedAddress<T>, update: F)
   |                                  ------ move occurs because `offset` has type `TypedAddress<T>`, which does not implement the `Copy` trait
...
LL |         let old = self.return_value(offset);
   |                                     ------ value moved here
...
LL |         self.write_value(offset, &new);
   |                          ^^^^^^ value used here after move
   |
note: consider changing this parameter type in method `return_value` to borrow instead if owning the value isn't necessary
  --> $DIR/derive-clone-implicit-bound.rs:15:39
   |
LL |     fn return_value<T>(&self, offset: TypedAddress<T>) -> T;
   |        ------------ in this method    ^^^^^^^^^^^^^^^ this parameter takes ownership of the value
note: if all bounds were met, you could clone the value
  --> $DIR/derive-clone-implicit-bound.rs:6:1
   |
LL | #[derive(Clone, Copy)]
   |          ----- derived `Clone` adds implicit bounds on type parameters
LL | pub struct TypedAddress<T>{
   | ^^^^^^^^^^^^^^^^^^^^^^^^-^
   |                         |
   |                         introduces an implicit `T: Clone` bound
...
LL |         let old = self.return_value(offset);
   |                                     ------ you could clone this value
   = help: consider manually implementing `Clone` to avoid undesired bounds
help: consider further restricting type parameter `T` with trait `Copy`
   |
LL |         where F: FnOnce(T) -> T, T: Copy
   |                                +++++++++

error: aborting due to 1 previous error

For more information about this error, try `rustc --explain E0382`.
