warning: transmuting an integer to a pointer creates a pointer without provenance
  --> $DIR/int_to_ptr.rs:10:36
   |
LL |     let _ptr: *const u8 = unsafe { std::mem::transmute::<usize, *const u8>(a) };
   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
   = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
   = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
   = help: for more information about transmute, see <https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers>
   = help: for more information about exposed provenance, see <https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance>
   = note: `#[warn(integer_to_ptr_transmutes)]` on by default
help: use `std::ptr::with_exposed_provenance` instead to use a previously exposed provenance
   |
LL -     let _ptr: *const u8 = unsafe { std::mem::transmute::<usize, *const u8>(a) };
LL +     let _ptr: *const u8 = unsafe { std::ptr::with_exposed_provenance::<u8>(a) };
   |

warning: transmuting an integer to a pointer creates a pointer without provenance
  --> $DIR/int_to_ptr.rs:12:34
   |
LL |     let _ptr: *mut u8 = unsafe { std::mem::transmute::<usize, *mut u8>(a) };
   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
   = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
   = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
   = help: for more information about transmute, see <https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers>
   = help: for more information about exposed provenance, see <https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance>
help: use `std::ptr::with_exposed_provenance_mut` instead to use a previously exposed provenance
   |
LL -     let _ptr: *mut u8 = unsafe { std::mem::transmute::<usize, *mut u8>(a) };
LL +     let _ptr: *mut u8 = unsafe { std::ptr::with_exposed_provenance_mut::<u8>(a) };
   |

warning: transmuting an integer to a pointer creates a pointer without provenance
  --> $DIR/int_to_ptr.rs:14:38
   |
LL |     let _ref: &'static u8 = unsafe { std::mem::transmute::<usize, &'static u8>(a) };
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
   = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
   = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
   = help: for more information about transmute, see <https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers>
   = help: for more information about exposed provenance, see <https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance>
help: use `std::ptr::with_exposed_provenance` instead to use a previously exposed provenance
   |
LL -     let _ref: &'static u8 = unsafe { std::mem::transmute::<usize, &'static u8>(a) };
LL +     let _ref: &'static u8 = unsafe { &*std::ptr::with_exposed_provenance::<u8>(a) };
   |

warning: transmuting an integer to a pointer creates a pointer without provenance
  --> $DIR/int_to_ptr.rs:16:42
   |
LL |     let _ref: &'static mut u8 = unsafe { std::mem::transmute::<usize, &'static mut u8>(a) };
   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
   = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
   = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
   = help: for more information about transmute, see <https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers>
   = help: for more information about exposed provenance, see <https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance>
help: use `std::ptr::with_exposed_provenance_mut` instead to use a previously exposed provenance
   |
LL -     let _ref: &'static mut u8 = unsafe { std::mem::transmute::<usize, &'static mut u8>(a) };
LL +     let _ref: &'static mut u8 = unsafe { &mut *std::ptr::with_exposed_provenance_mut::<u8>(a) };
   |

warning: transmuting an integer to a pointer creates a pointer without provenance
  --> $DIR/int_to_ptr.rs:19:25
   |
LL |     let _ptr = unsafe { std::mem::transmute::<usize, *const u8>(42usize) };
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
   = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
   = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
   = help: for more information about transmute, see <https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers>
   = help: for more information about exposed provenance, see <https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance>
help: use `std::ptr::with_exposed_provenance` instead to use a previously exposed provenance
   |
LL -     let _ptr = unsafe { std::mem::transmute::<usize, *const u8>(42usize) };
LL +     let _ptr = unsafe { std::ptr::with_exposed_provenance::<u8>(42usize) };
   |

warning: transmuting an integer to a pointer creates a pointer without provenance
  --> $DIR/int_to_ptr.rs:21:25
   |
LL |     let _ptr = unsafe { std::mem::transmute::<usize, *const u8>(a + a) };
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
   = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
   = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
   = help: for more information about transmute, see <https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers>
   = help: for more information about exposed provenance, see <https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance>
help: use `std::ptr::with_exposed_provenance` instead to use a previously exposed provenance
   |
LL -     let _ptr = unsafe { std::mem::transmute::<usize, *const u8>(a + a) };
LL +     let _ptr = unsafe { std::ptr::with_exposed_provenance::<u8>(a + a) };
   |

warning: transmuting an integer to a pointer creates a pointer without provenance
  --> $DIR/int_to_ptr.rs:26:36
   |
LL |     let _ptr: *const u8 = unsafe { std::mem::transmute::<usize, *const u8>(a) };
   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
   = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
   = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
   = help: for more information about transmute, see <https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers>
   = help: for more information about exposed provenance, see <https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance>
help: use `std::ptr::with_exposed_provenance` instead to use a previously exposed provenance
   |
LL -     let _ptr: *const u8 = unsafe { std::mem::transmute::<usize, *const u8>(a) };
LL +     let _ptr: *const u8 = unsafe { std::ptr::with_exposed_provenance::<u8>(a) };
   |

warning: transmuting an integer to a pointer creates a pointer without provenance
  --> $DIR/int_to_ptr.rs:28:34
   |
LL |     let _ptr: *mut u8 = unsafe { std::mem::transmute::<usize, *mut u8>(a) };
   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
   = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
   = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
   = help: for more information about transmute, see <https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers>
   = help: for more information about exposed provenance, see <https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance>
help: use `std::ptr::with_exposed_provenance_mut` instead to use a previously exposed provenance
   |
LL -     let _ptr: *mut u8 = unsafe { std::mem::transmute::<usize, *mut u8>(a) };
LL +     let _ptr: *mut u8 = unsafe { std::ptr::with_exposed_provenance_mut::<u8>(a) };
   |

warning: transmuting an integer to a pointer creates a pointer without provenance
  --> $DIR/int_to_ptr.rs:30:38
   |
LL |     let _ref: &'static u8 = unsafe { std::mem::transmute::<usize, &'static u8>(a) };
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
   = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
   = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
   = help: for more information about transmute, see <https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers>
   = help: for more information about exposed provenance, see <https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance>
help: use `std::ptr::with_exposed_provenance` instead to use a previously exposed provenance
   |
LL -     let _ref: &'static u8 = unsafe { std::mem::transmute::<usize, &'static u8>(a) };
LL +     let _ref: &'static u8 = unsafe { &*std::ptr::with_exposed_provenance::<u8>(a) };
   |

warning: transmuting an integer to a pointer creates a pointer without provenance
  --> $DIR/int_to_ptr.rs:32:42
   |
LL |     let _ref: &'static mut u8 = unsafe { std::mem::transmute::<usize, &'static mut u8>(a) };
   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
   = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
   = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
   = help: for more information about transmute, see <https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers>
   = help: for more information about exposed provenance, see <https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance>
help: use `std::ptr::with_exposed_provenance_mut` instead to use a previously exposed provenance
   |
LL -     let _ref: &'static mut u8 = unsafe { std::mem::transmute::<usize, &'static mut u8>(a) };
LL +     let _ref: &'static mut u8 = unsafe { &mut *std::ptr::with_exposed_provenance_mut::<u8>(a) };
   |

warning: transmuting an integer to a pointer creates a pointer without provenance
  --> $DIR/int_to_ptr.rs:35:25
   |
LL |     let _ptr = unsafe { std::mem::transmute::<usize, *const u8>(42usize) };
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
   = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
   = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
   = help: for more information about transmute, see <https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers>
   = help: for more information about exposed provenance, see <https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance>
help: use `std::ptr::with_exposed_provenance` instead to use a previously exposed provenance
   |
LL -     let _ptr = unsafe { std::mem::transmute::<usize, *const u8>(42usize) };
LL +     let _ptr = unsafe { std::ptr::with_exposed_provenance::<u8>(42usize) };
   |

warning: transmuting an integer to a pointer creates a pointer without provenance
  --> $DIR/int_to_ptr.rs:37:25
   |
LL |     let _ptr = unsafe { std::mem::transmute::<usize, *const u8>(a + a) };
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this is dangerous because dereferencing the resulting pointer is undefined behavior
   = note: exposed provenance semantics can be used to create a pointer based on some previously exposed provenance
   = help: if you truly mean to create a pointer without provenance, use `std::ptr::without_provenance_mut`
   = help: for more information about transmute, see <https://doc.rust-lang.org/std/mem/fn.transmute.html#transmutation-between-pointers-and-integers>
   = help: for more information about exposed provenance, see <https://doc.rust-lang.org/std/ptr/index.html#exposed-provenance>
help: use `std::ptr::with_exposed_provenance` instead to use a previously exposed provenance
   |
LL -     let _ptr = unsafe { std::mem::transmute::<usize, *const u8>(a + a) };
LL +     let _ptr = unsafe { std::ptr::with_exposed_provenance::<u8>(a + a) };
   |

warning: 12 warnings emitted

