#![warn(clippy::strlen_on_c_strings)]
#![allow(clippy::manual_c_str_literals)]

use libc::strlen;
use std::ffi::{CStr, CString};

fn main() {
    // CString
    let cstring = CString::new("foo").expect("CString::new failed");
    let _ = cstring.as_bytes().len();
    //~^ ERROR: using `libc::strlen` on a `CString` value

    // CStr
    let cstr = CStr::from_bytes_with_nul(b"foo\0").expect("CStr::from_bytes_with_nul failed");
    let _ = cstr.to_bytes().len();
    //~^ ERROR: using `libc::strlen` on a `CStr` value

    let _ = cstr.to_bytes().len();
    //~^ ERROR: using `libc::strlen` on a `CStr` value

    let pcstr: *const &CStr = &cstr;
    let _ = unsafe { (*pcstr).to_bytes().len() };
    //~^ ERROR: using `libc::strlen` on a `CStr` value

    unsafe fn unsafe_identity<T>(x: T) -> T {
        x
    }
    let _ = unsafe { unsafe_identity(cstr).to_bytes().len() };
    //~^ ERROR: using `libc::strlen` on a `CStr` value
    let _ = unsafe { unsafe_identity(cstr) }.to_bytes().len();
    //~^ ERROR: using `libc::strlen` on a `CStr` value

    let f: unsafe fn(_) -> _ = unsafe_identity;
    let _ = unsafe { f(cstr).to_bytes().len() };
    //~^ ERROR: using `libc::strlen` on a `CStr` value
}
