// Test for issue #25860: the cve-rs lifetime expansion exploit
// This demonstrates casting an arbitrary lifetime to 'static using
// HRTB and variance, which should NOT be allowed.
//
// Once fixed, this test should fail to compile with an appropriate error.

static STATIC_UNIT: &'static &'static () = &&();

/// This function has an implied bound: 'b: 'a
/// (because &'a &'b () requires 'b to outlive 'a)
fn lifetime_translator<'a, 'b, T: ?Sized>(
    _val_a: &'a &'b (),
    val_b: &'b T
) -> &'a T {
    val_b
}

/// The exploit: expand any lifetime 'a to any other lifetime 'b
/// This is UNSOUND because 'a may not outlive 'b
fn expand<'a, 'b, T: ?Sized>(x: &'a T) -> &'b T {
    // This coercion should fail because:
    // 1. lifetime_translator requires 'b: 'a (implied by &'a &'b ())
    // 2. When we call f(STATIC_UNIT, x), 'a gets unified with the lifetime of x
    // 3. But there's no guarantee that 'a: 'b!
    let f: for<'x> fn(_, &'x T) -> &'b T = lifetime_translator;
    //~^ ERROR mismatched types
    f(STATIC_UNIT, x)
}

/// Concrete example: extend a local reference to 'static
fn extend_to_static<'a, T: ?Sized>(x: &'a T) -> &'static T {
    expand(x)
}

fn main() {
    // Use-after-free: this should not compile!
    let dangling: &'static str;
    {
        let local = String::from("This should not escape!");
        dangling = extend_to_static(&local);
    }
    println!("{}", dangling); // UB: use after free!
}
