// run-rustfix

#![allow(clippy::print_literal, clippy::redundant_clone)]
#![warn(clippy::useless_format)]

struct Foo(pub String);

macro_rules! foo {
    ($($t:tt)*) => (Foo(format!($($t)*)))
}

fn main() {
    "foo".to_string();
    "{}".to_string();
    "{} abc {}".to_string();
    r##"foo {}
" bar"##.to_string();

    "foo".to_string();
    format!("{:?}", "foo"); // Don't warn about `Debug`.
    format!("{:8}", "foo");
    format!("{:width$}", "foo", width = 8);
    "foo".to_string(); // Warn when the format makes no difference.
    "foo".to_string(); // Warn when the format makes no difference.
    format!("foo {}", "bar");
    format!("{} bar", "foo");

    let arg: String = "".to_owned();
    arg.to_string();
    format!("{:?}", arg); // Don't warn about debug.
    format!("{:8}", arg);
    format!("{:width$}", arg, width = 8);
    arg.to_string(); // Warn when the format makes no difference.
    arg.to_string(); // Warn when the format makes no difference.
    format!("foo {}", arg);
    format!("{} bar", arg);

    // We donâ€™t want to warn for non-string args; see issue #697.
    format!("{}", 42);
    format!("{:?}", 42);
    format!("{:+}", 42);
    format!("foo {}", 42);
    format!("{} bar", 42);

    // We only want to warn about `format!` itself.
    println!("foo");
    println!("{}", "foo");
    println!("foo {}", "foo");
    println!("{}", 42);
    println!("foo {}", 42);

    // A `format!` inside a macro should not trigger a warning.
    foo!("should not warn");

    // Precision on string means slicing without panicking on size.
    format!("{:.1}", "foo"); // Could be `"foo"[..1]`
    format!("{:.10}", "foo"); // Could not be `"foo"[..10]`
    format!("{:.prec$}", "foo", prec = 1);
    format!("{:.prec$}", "foo", prec = 10);

    42.to_string();
    let x = std::path::PathBuf::from("/bar/foo/qux");
    x.display().to_string();

    // False positive
    let a = "foo".to_string();
    let _ = Some(a + "bar");
}
